<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>HTTP - 标签 - Sam&#39;s Garage</title>
        <link>http://samrks.github.io/tags/http/</link>
        <description>HTTP - 标签 - Sam&#39;s Garage</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ryuukousen@gmail.com (Sam)</managingEditor>
            <webMaster>ryuukousen@gmail.com (Sam)</webMaster><lastBuildDate>Mon, 10 Aug 2020 18:49:11 &#43;0800</lastBuildDate><atom:link href="http://samrks.github.io/tags/http/" rel="self" type="application/rss+xml" /><item>
    <title>前端也得懂点儿 HTTP (下) </title>
    <link>http://samrks.github.io/13-http-2/</link>
    <pubDate>Mon, 10 Aug 2020 18:49:11 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://samrks.github.io/13-http-2/</guid>
    <description><![CDATA[<p>🤞🏻 “Nobody knows HTTP better than me !! ” 🤥</p>
<p>​</p>
<h2 id="先导">先导</h2>
<ul>
<li>安装 Node.js 8+</li>
<li>理解 IP 和 端口</li>
<li>理解 URL 路径和查询参数</li>
</ul>
<p>​</p>
<h2 id="演示-nodejs-server-">演示 Node.js Server ⭐</h2>
<h3 id="请求与响应模型">请求与响应模型</h3>
<p></p>
<ul>
<li>服务器，就是没有显示器的电脑</li>
</ul>
<p>​</p>
<h3 id="如何发请求">如何发请求</h3>
<p>方法</p>
<ul>
<li>用 Chrome 地址栏</li>
<li>用 curl 命令</li>
</ul>
<p>概念</p>
<ul>
<li>帮你发请求的工具叫做「用户代理」
<ul>
<li>如果使用 Chrome 地址栏发送请求，那么 Chrome 就是我们的「用户代理」</li>
<li>如果使用 curl 命令发送请求，那么 curl 就是我们的「用户代理」</li>
</ul>
</li>
<li>「用户代理」 英文名 User Agent</li>
</ul>
<p>​</p>
<h3 id="如何做出一个响应-">如何做出一个响应 ⭐</h3>
<blockquote>
<p>用 Chrome 地址栏 或 用 curl 命令 ，可以发出一个请求</p>
<ul>
<li>那么如何做出一个响应呢？（演示自己发请求-自己响应的过程）</li>
</ul>
</blockquote>
<p>需要用到编程</p>
<ul>
<li>
<p>Node.js 有一个 http 模块可以做到</p>
</li>
<li>
<p>新建项目目录 node-demo / server.js，将下面代码粘入  ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐</p>
<blockquote>
<p>代码细节先不管，直接复制使用。（注意这块目的不是学 nodejs，而是搞清楚 http 的请求和响应）</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;url&#39;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">port</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">port</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&#39;</span><span class="p">)</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">parsedUrl</span> <span class="o">=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">url</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">pathWithQuery</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">url</span>
  <span class="kd">var</span> <span class="nx">queryString</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">pathWithQuery</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">queryString</span> <span class="o">=</span> <span class="nx">pathWithQuery</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">pathWithQuery</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">))</span> <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">parsedUrl</span><span class="p">.</span><span class="nx">pathname</span>
  <span class="kd">var</span> <span class="nx">query</span> <span class="o">=</span> <span class="nx">parsedUrl</span><span class="p">.</span><span class="nx">query</span>
  <span class="kd">var</span> <span class="nx">method</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">method</span>
    
  <span class="cm">/******** 从这里开始看，上面不要看 ************/</span>
    
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;有个傻子发请求过来啦！路径（带查询参数）为：&#39;</span> <span class="o">+</span> <span class="nx">pathWithQuery</span><span class="p">)</span>
    
  <span class="k">if</span> <span class="p">(</span><span class="nx">path</span> <span class="o">===</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/html;charset=utf-8&#39;</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="sb">`二哈`</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">path</span> <span class="o">===</span> <span class="s1">&#39;/x&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/css;charset=utf-8&#39;</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="sb">`body{color: red;}`</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">404</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/html;charset=utf-8&#39;</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="sb">`你输入的路径不存在对应的内容`</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
  <span class="p">}</span>
    
  <span class="cm">/******** 代码结束，下面不要看 ************/</span>
<span class="p">})</span>
    
<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">port</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;监听 &#39;</span> <span class="o">+</span> <span class="nx">port</span> <span class="o">+</span> <span class="s1">&#39; 成功\n请在空中转体720度然后用电饭煲打开 http://localhost:&#39;</span> <span class="o">+</span> <span class="nx">port</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>注意事项</p>
<ul>
<li>这些代码就是服务器代码，一般放在服务器上</li>
<li>path 是不带查询参数的路径 /x</li>
<li>query 是查询参数的对象形式 {a:1}</li>
<li>queryString 是查询参数的字符串形式 ?a=1</li>
<li>pathWithQuery 是带查询参数的路径，一般不用</li>
<li>request 是请求对象</li>
<li>response 是响应对象</li>
<li>\n 表示回车</li>
</ul>
<p>​</p>
<h4 id="运行机制">运行机制⭐</h4>
<ol>
<li>
<p>在终端中启动应用：</p>
<ol>
<li>运行 <code>node server.js</code>  未指定<strong>端口号</strong>，会有提示</li>
<li>按照提示执行即可  <code>node server.js 8888</code>  或者  <code>node server 8888</code>  这句话就意味着我们的电脑会开一个端口 8888，这个端口被 server.js 监听着</li>
<li>这时候只要有人请求了8888 端口，就会走入 server.js 的代码中，我们注释的那段代码就会运行一遍。每接收到一次请求，就运行一遍</li>
</ol>
</li>
<li>
<p>用 curl 发出请求 <code>curl http://127.0.0.1:8080/xxxx</code>。server.js 接收到请求，会做出响应。</p>
<p></p>
<p></p>
<ul>
<li>如果响应内容乱码，可能是 windows 系统的关系</li>
</ul>
</li>
<li>
<p>添加路由</p>
<ol>
<li>
<p>编辑 server.js 文件，添加 if else（限定条件，访问某个路径，响应对应内容）</p>
</li>
<li>
<p>重新运行 node server.js 8888（修改服务代码，需要重启）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="nx">path</span> <span class="o">===</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;有人访问/了&#39;</span><span class="p">)</span>
  <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s1">&#39;这就是访问/，响应的内容\n&#39;</span><span class="p">)</span>   <span class="c1">// 回车\n
</span><span class="c1"></span><span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>下面是，server.js 监听到 curl 命令 请求根路径时 执行的 console.log(…)</p>
<p></p>
</li>
</ol>
</li>
<li>
<p>后台启动应用：</p>
<ol>
<li>
<p><code>touch log </code>  创建一个 log 文件</p>
</li>
<li>
<p><code>node server.js 8888 &gt;log log 2&gt;&amp;1 &amp;</code></p>
<p>返回的数字1144就是这个<strong>进程的 ID</strong>（目前这个进程已经在后台运行了）</p>
</li>
</ol>
<p></p>
<ul>
<li>运行后，服务器在后台启动，不占用当前终端</li>
<li>怎么关闭这个后台进程呢？
<ul>
<li>执行 <code>kill -9 xxxx</code>   xxxx为后台进程的 id数字</li>
<li>kill -9 是最厉害的杀进程的方法</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>​</p>
<h4 id="代码逻辑">代码逻辑</h4>
<p>语法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="sb">`这种字符串`</span> <span class="nx">里面可以回车</span>
<span class="s1">&#39;这种字符串&#39;</span> <span class="nx">里面要回车</span><span class="err">，</span><span class="nx">只能用</span> <span class="err">\</span><span class="nx">n</span> <span class="nx">表示</span>
</code></pre></td></tr></table>
</div>
</div><p>逻辑</p>
<ol>
<li>
<p>每次收到请求都会把中间的代码执行一遍</p>
</li>
<li>
<p>用 if else 判断路径，并返回响应</p>
</li>
<li>
<p>如果是已知路径，一律返回 200</p>
</li>
<li>
<p>如果是未知路径，一律返回 404</p>
</li>
<li>
<p>Content-Type 表示内容的「类型/语法」（省略后缀，程序员从来不看后缀😎，后缀只是用来告诉计算机要用什么软件打开文件）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="sb">`text/html`</span><span class="err">、</span><span class="sb">`text/css`</span>
<span class="nx">path</span> <span class="nx">不写</span> <span class="o">/</span><span class="nx">x</span><span class="p">.</span><span class="nx">css</span> <span class="nx">而写</span> <span class="o">/</span><span class="nx">x</span><span class="err">，</span><span class="nx">因为</span> <span class="nx">content</span><span class="o">-</span><span class="nx">type</span> <span class="nx">中已经声明了类型</span><span class="o">/</span><span class="nx">语法</span><span class="err">，</span><span class="nx">所以可省略后缀</span> <span class="p">.</span><span class="nx">css</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>response.write() 可以填写返回的内容（写入响应内容）</p>
</li>
<li>
<p>调用 response.end() 表示响应可以发给用户了（调用 response.end() ，就会将响应发送给浏览器）</p>
<p>（ 以前不写 end 就会一直等待，现在可能优化了可以不写 end，严谨起见还是都写完整，明确告知可以响应给用户了 ）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"> <span class="k">if</span> <span class="p">(</span><span class="nx">path</span> <span class="o">===</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="sb">`
</span><span class="sb">        &lt;!DOCTYPE html&gt;
</span><span class="sb">        &lt;head&gt;
</span><span class="sb">                &lt;meta charset=&#34;UTF-8&#34;&gt;
</span><span class="sb">            &lt;link rel=&#34;stylesheet&#34; href=&#34;http://samrks.github.io/x&#34;&gt;  // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 将 html 和 css 结合起来
</span><span class="sb">        &lt;/head&gt;
</span><span class="sb">        &lt;body&gt;
</span><span class="sb">                &lt;h1&gt;标题&lt;/h1&gt;
</span><span class="sb">            &lt;/body&gt;
</span><span class="sb">    `</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">path</span> <span class="o">===</span> <span class="s1">&#39;/x&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/css;charset=utf-8&#39;</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="sb">`body{color: red;}`</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<ul>
<li>
<p>如上图就是，通过 link 把 html 和 css 联系起来，成为一个网页，把这个网页通过 http 传送到浏览器上的整个过程：一个路径返回 html 字符串，一个路径响应 css  字符串。</p>
</li>
<li>
<p>这就是李爵士发明的 URL + HTTP + HTML</p>
</li>
</ul>
</li>
</ol>
<p>​</p>
<h4 id="注意符号-">注意符号 ``</h4>
<blockquote>
<p>反引号 ``  可以识别回车、语法</p>
<p>单引号 ‘’   不能识别回车语法，仅作为字符串</p>
</blockquote>
<p></p>
<p>​</p>
<p>​</p>
<h3 id="遥想当年李爵士">遥想当年李爵士</h3>
<p><strong>世界上第一个服务器程序</strong></p>
<ul>
<li>我们也写一个服务器程序</li>
</ul>
<p><strong>世界上第一个网页</strong></p>
<ul>
<li>
<p>我们在 / 路径返回一个 HTML 内容</p>
</li>
<li>
<p>然后在 /x 路径返回一个 CSS 内容</p>
</li>
<li>
<p>然后再 /y 路径返回一个 JS 内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"> <span class="k">if</span> <span class="p">(</span><span class="nx">path</span> <span class="o">===</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="sb">`
</span><span class="sb">        &lt;!DOCTYPE html&gt;
</span><span class="sb">        &lt;head&gt;
</span><span class="sb">                &lt;meta charset=&#34;UTF-8&#34;&gt;
</span><span class="sb">            &lt;link rel=&#34;stylesheet&#34; href=&#34;http://samrks.github.io/x&#34;&gt;   ←←←←←←←←←←←←←← 引入 css
</span><span class="sb">        &lt;/head&gt;
</span><span class="sb">        &lt;body&gt;
</span><span class="sb">                &lt;h1&gt;标题&lt;/h1&gt;
</span><span class="sb">                &lt;script src=&#34;http://samrks.github.io/y&#34;&gt;&lt;script&gt;   ←←←←←←←←←←←←←←← 引入 js
</span><span class="sb">            &lt;/body&gt;
</span><span class="sb">    `</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">path</span> <span class="o">===</span> <span class="s1">&#39;/x&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/css;charset=utf-8&#39;</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="sb">`body{color: red;}`</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">path</span> <span class="o">===</span> <span class="s2">&#34;/y&#34;</span><span class="p">){</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s2">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s2">&#34;text/javascript;charset=utf-8&#34;</span><span class="p">);</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="sb">`console.log(&#39;这是JS内容&#39;)`</span><span class="p">;</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">404</span><span class="p">;</span>
        <span class="nx">response</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/html;charset=utf-8&#39;</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="sb">`你输入的路径不存在对应的内容`</span><span class="p">)</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>关于后缀
<ul>
<li>即使写成 <code>path === &quot;/y.css&quot;</code> ，但如果在 Content-Type 中规定是 js 类型，就会按照 js 解析。所以，URL里的css 后缀卵用没有</li>
<li><strong>Content-Type 才是决定文件类型的关键</strong></li>
</ul>
</li>
</ul>
<p>​</p>
<h2 id="体系化学习-http">体系化学习 HTTP</h2>
<p>必须学会什么</p>
<ul>
<li>基础概念（有哪些是必会的）
<ul>
<li>请求、响应</li>
</ul>
</li>
<li>如何调试（用的是 Node.js，可以用 log / debugger )
<ul>
<li>本质是学习 HTTP，所以不要在 Nodejs 花费太多时间，只需要搞懂 nodejs 怎么调试即可</li>
</ul>
</li>
<li>在哪查资料（用的是 Node.js，所以看 Node.js 文档）</li>
<li>标准制定者是谁（ HTTP 规格文档：<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener noreffer">RFC2616</a>（<a href="https://cloud.tencent.com/developer/chapter/13544" target="_blank" rel="noopener noreffer">中文</a>）等）</li>
</ul>
<p>如何学</p>
<ul>
<li>Copy-抄文档、抄老师</li>
<li>Run-放在自己的机器上运行成功</li>
<li>Modify-加入一点自己的想法，然后重新运行</li>
</ul>
<p>​</p>
<h2 id="http-基础概念">HTTP 基础概念</h2>
<blockquote>
<ul>
<li>
<p>必须点击 view source ，才能看到完整的请求、响应</p>
<p></p>
</li>
</ul>
</blockquote>
<h3 id="请求">请求</h3>
<p></p>
<ul>
<li><font color="redorage"><strong>请求动词 路径加查询参数 协议名/版本</strong></font>（所有请求都按照这个格式，简化版）例：<code>GET   /x?wd=hi   HTTP/1.1</code></li>
</ul>
<ul>
<li>
<p><font color="darkorange">Host: 就是域名或  IP</font>（包括端口号）</p>
</li>
<li>
<p><font color="darkorange">Accept: text/html</font>（表示浏览器想接收什么内容）</p>
<ul>
<li>
<p>测：根据 accept 返回不同内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">accept</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">headers</span><span class="p">[</span><span class="s1">&#39;accept&#39;</span><span class="p">];</span>  <span class="c1">// 获取请求头中的 accept 的值，赋给变量
</span><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="nx">accept</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;xml&#39;</span><span class="p">)){</span>
  <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s1">&#39;我知道你想访问 XML 内容&#39;</span><span class="p">)</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
  <span class="nx">response</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="sb">`&lt;!DOCTYPE html&gt;&lt;html&gt;...&lt;/html&gt;`</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>浏览器可接收的内容：accept。（大多来说浏览器就是接收 html）</p>
<p>默认先找 html，如果没有 html，可以接收 xhtml、xml、webp、png、igned-exchange（如下）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p><font color="darkorange">Content-Type: 表示请求体的格式</font>（例：text/javascript;charset=utf-8）</p>
</li>
<li>
<p><font color="grey">回车</font>（划分请求头、请求体的界线）</p>
</li>
<li>
<p><font color="redr">请求体（也就是上传内容）</font></p>
</li>
</ul>
<h4 id="细节">细节</h4>
<ul>
<li>
<p>请求有三部分，用回车隔开，分别是：（与 ↑↑ 对应颜色）</p>
<ul>
<li><font color="redorage">请求行</font>（因为只有一行，所以叫请求行）<code>GET   /x?wd=hi   HTTP/1.1</code></li>
<li><font color="darkorange">请求头</font></li>
<li><font color="redr">请求体</font>（请求体的格式，是在 content-type 中指定的）</li>
</ul>
</li>
<li>
<p>请求动词有 GET / POST / PUT / PATCH / DELETE 等</p>
<ul>
<li>
<p>GET 用于获取内容</p>
</li>
<li>
<p>POST 用于上传内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">发送post请求：curl -v -X POST --data &#39;上传内容&#39; http://localhost:8888/
</code></pre></td></tr></table>
</div>
</div><p></p>
</li>
</ul>
</li>
<li>
<p>请求体在 GET 请求中一般为空</p>
<ul>
<li>因为get请求通常用于获取内容，而请求体表示要上传的内容，所以GET请求一般没有请求体</li>
</ul>
</li>
<li>
<p>文档位于 <a href="https://tools.ietf.org/html/rfc2616#page-35" target="_blank" rel="noopener noreffer">RFC2616 第五章</a></p>
</li>
<li>
<p>大小写不敏感（随意），最好照着我的写</p>
</li>
</ul>
<p>​</p>
<h3 id="响应">响应</h3>
<p></p>
<ul>
<li><strong><font color="redorage">协议名/版本 状态码 状态字符串</font></strong></li>
<li><font color="darkorange">Content-Type: 响应体的格式</font></li>
<li><font color="gray">回车</font></li>
<li><font color="redr">响应体</font>（也就是下载内容）</li>
</ul>
<h4 id="细节-1">细节</h4>
<ul>
<li>响应有三部分，用回车隔开，分别是：
<ul>
<li><font color="redorage">状态行</font>（Status LIne）</li>
<li><font color="darkorange">响应头</font></li>
<li><font color="redr">响应体</font>（响应体的格式，在Content-Type中指定）</li>
</ul>
</li>
<li>常见的状态码是<strong>考点</strong>
<ul>
<li>200 成功</li>
<li>404 找不到</li>
</ul>
</li>
<li>文档位于 <a href="https://tools.ietf.org/html/rfc2616#page-39" target="_blank" rel="noopener noreffer">RFC2616 第六章</a></li>
</ul>
<p>​</p>
<h2 id="用-curl-构造请求">用 curl 构造请求</h2>
<h3 id="curl-用法">curl 用法</h3>
<blockquote>
<p>curl 可以用来改请求动词、查询参数，还可以改第二部分的请求头、第三部分的请求内容…</p>
<ul>
<li>什么都可以改，请求的东西都可以由自己觉得</li>
<li>只不过需要按照 http 的标准来写</li>
</ul>
</blockquote>
<blockquote>
<p>前提条件：server 要处于开启的状态：node server.js 8888</p>
</blockquote>
<p>例：<strong><code>curl -v http://localhost:8888</code></strong></p>
<blockquote>
<p>设置请求动词</p>
</blockquote>
<ul>
<li><code>-X POST</code></li>
<li>例：<strong><code>curl -v -X POST http://localhost:8888</code></strong>  设置为post请求</li>
<li>注意大小写</li>
</ul>
<blockquote>
<p>设置路径和查询参数</p>
</blockquote>
<ul>
<li>直接在 url 后面加</li>
<li>例：<strong><code>curl -v -X POST http://localhost:8888/xxx?id=xxx</code></strong></li>
<li>注：在 url 后添加 # 锚点是不会发送到服务器的</li>
</ul>
<blockquote>
<p>设置请求头</p>
</blockquote>
<ul>
<li><code>-H 'Name: Value' </code> 或者  <code>--header 'Name: Value'</code></li>
<li>例：<strong><code>curl -v -X POST -H 'Accept: text/html' http://localhost:8888</code></strong></li>
</ul>
<blockquote>
<p>设置请求体</p>
</blockquote>
<ul>
<li><code>-d '内容'</code>  或者  <code>--data '内容'</code></li>
</ul>
<ul>
<li>
<p><strong><code>curl -v -X POST -H 'ABC: abc' -H 'Content-Type: text/plain;charset=utf-8' -d '请求体内容' http://localhost:8888</code></strong></p>
<p>在请求体中设置一个 ABC: abc，没有实际意义但是成立的。</p>
<p>text/plain 表示上传的内容是纯文本，编码是 utf-8（中文），内容是&rsquo;请求体内容&rsquo;这5个字（每个字占2bytes）</p>
<p></p>
</li>
</ul>
<blockquote>
<p>总结：可以使用 curl 随心所欲的构造一个请求</p>
</blockquote>
<p>​</p>
<h3 id="用-nodejs-读取请求">用 Node.js 读取请求</h3>
<p>读取请求动词</p>
<ul>
<li>
<p><strong><code>request.method</code></strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;method:&#39;</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">method</span><span class="p">)</span>   <span class="c1">// method: GET ...
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>读取路径</p>
<ul>
<li>
<p><strong><code>request.url</code></strong> 路径，带查询参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;路径：&#39;</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">url</span><span class="p">)</span> <span class="c1">// 路径：/xxxx?wd=hihihi
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong><code>path</code></strong> 纯路径，不带查询参数</p>
</li>
<li>
<p><strong><code>query</code></strong> 只有查询参数</p>
</li>
</ul>
<p>读取请求头</p>
<ul>
<li>
<p>**<code>request.headers['Accept']</code> **    读取请求头中的 Accept 值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;请求头：&#34;</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">headers</span><span class="p">)</span>  <span class="c1">// 请求头：{ host:xxx, ???:???, ... }
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>读取请求体</p>
<ul>
<li>比较复杂，先不讲</li>
</ul>
<p>​</p>
<h3 id="用-nodejs-设置响应">用 Node.js 设置响应</h3>
<p>设置响应状态码</p>
<ul>
<li><strong><code>response.statusCode = 200 </code></strong></li>
<li>状态码可以任意设置，状态字符串会根据设置的状态码自动改变</li>
<li>但是状态码是有统一的使用规则的，如 200 规定就是表示请求成功时返回的状态码，所以不要随意改变</li>
<li>404 表示请求的网页不存在 。404 页面就是一个普通页面，是 Chrome 提供的，当访问页面不存在时提醒用户</li>
</ul>
<p>设置响应头</p>
<ul>
<li><strong><code>response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;); </code></strong></li>
</ul>
<p>设置响应体</p>
<ul>
<li>
<p><strong><code>response.write(&quot;内容&quot;） </code></strong></p>
</li>
<li>
<p>可追加内容</p>
</li>
</ul>
<p>​</p>
<h3 id="curl-的作用是什么">curl 的作用是什么</h3>
<blockquote>
<p>不单单是用来测试 http 的请求和响应。</p>
<p>curl 可以完成 Chrome 的大多基本功能，但 curl 通过命令行执行，所以不具有可视化能力</p>
</blockquote>
<ol>
<li>
<p>下载图片</p>
<p><code>curl 图片路径.jpg &gt; xxx.jpg</code>  （ 在命令行开启的目录中，下载图片并重命名为 xxx ）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">curl https://i.loli.net/2020/07/15/Q2dnHSgxCcbfhZW.jpg &gt; 3.jpg
</code></pre></td></tr></table>
</div>
</div><p></p>
</li>
<li>
<p>测试 请求和响应</p>
</li>
<li>
<p>…</p>
<p>curl 功能很强大，Chrome 的基本功能都可以实现，但不具有可视化</p>
</li>
</ol>
<p>​</p>
<h2 id="html--css--js-的本质都是字符串">HTML / CSS / JS 的本质都是字符串</h2>
<blockquote>
<p>HTML / CSS / JS 的<strong>本质都是字符串，不是文件</strong></p>
<ul>
<li>本质上我们看到的网页，都是通过 html字符串 渲染的，html字符串 里面请求了 css字符串、js字符串</li>
<li>从演示的 server.js 中就能体现这一点</li>
</ul>
</blockquote>
<p>​</p>
<p>​</p>
<h2 id="consolelog-调试大法">console.log 调试大法</h2>
<blockquote>
<p>console.log（打印）这种调试方法，是在所有编程语言中都适用的</p>
<p>JS（console.log）、Java（print）、Python（print）、PHP（echo）…  语言/写法不一样，但原理相同</p>
</blockquote>
<ul>
<li>把可能有问题的代码，打印看看</li>
<li>debug 就是在不断质疑自己的过程</li>
<li>不要过分相信自己，而要相信 console.log() 可以告诉你对错</li>
<li>程序员每天都在问自己错在哪里</li>
</ul>]]></description>
</item><item>
    <title>前端也得懂点儿 HTTP (上) ——浅析 URL</title>
    <link>http://samrks.github.io/12-http-1/</link>
    <pubDate>Tue, 04 Aug 2020 23:58:43 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://samrks.github.io/12-http-1/</guid>
    <description><![CDATA[<p>本文主要围绕 URL ，为学 HTTP 做个铺垫。</p>
<p>​</p>
<h2 id="先导">先导</h2>
<h3 id="英语protocol">英语：protocol</h3>
<blockquote>
<p>protocol       /ˈproʊtəkɑːl/     协议、礼节、约定</p>
</blockquote>
<h3 id="李爵士发明的三样东西">李爵士发明的三样东西</h3>
<blockquote>
<p>WWW = URL + HTTP + HTML</p>
</blockquote>
<p>HTML 前面已经学了，html + css 本质就是网页</p>
<p>再认识了 URL 和 HTTP ，那么 WWW 我们就基本了解了（ URL 是为 HTTP 做铺垫）</p>
<p>​</p>
<h2 id="什么是-ip">什么是 IP</h2>
<blockquote>
<p>要学习 URL 、HTTP，得先从 IP 讲起（⭐剧透：HTTP 的 P  和  IP 的 P 之间有重要联系）</p>
</blockquote>
<p>IP：</p>
<ul>
<li>
<p>Internet（因特网==互联网，整个人类组成的网络就叫互联网，比WWW更加底层）protocol（协议）</p>
</li>
<li>
<p>由此可见 IP 也是非常底层的，没有 IP 就不能上网</p>
</li>
</ul>
<p>Internet Protocal 主要约定了两件事：</p>
<ul>
<li>一、<strong>如何定位一台设备</strong></li>
<li>二、如何封装数据报文，以跟其他设备交流
<ul>
<li>具体内容我们不关心</li>
</ul>
</li>
</ul>
<blockquote>
<p>只要你在互联网中，你就有至少一个独特的IP</p>
</blockquote>
<p>​</p>
<h3 id="ip-分为内网和外网">IP 分为内网和外网</h3>
<blockquote>
<p>内网和外网是不能直接相通的，只能通过路由器作为网关，来连通</p>
</blockquote>
<p></p>
<p>路由器：是一个非常重要的设备，连通了内网和外网</p>
<p>例：比如你在玩 LOL，按了一下Q键（第一个技能），怎么让网线那头的对手被Q到？</p>
<ul>
<li>Q 通过键盘传到路由器，路由器通过电信服务器传到 QQ 的游戏服务器， QQ 的游戏服务器接收到 Q 键后，就将 Q 键发送到对手那里，对手就被 Q 到了</li>
<li>整个过程是非常复杂的，但非常快，按下Q键立马响应，因为这个复杂的过程是以光速的形式来运行的，所以用户感受不到</li>
</ul>
<p>​</p>
<h3 id="如何获取外网-ip">如何获取外网 IP</h3>
<blockquote>
<p>必须有 外网IP 才能和小伙伴打 LOL、王者荣耀…</p>
</blockquote>
<ol>
<li>
<p>首先，你得从电信租用带宽，一年一千多。</p>
<p>（然后需要有个猫（调制解调器），猫是用来把信号转换成路由器能理解的信号。现在普遍是光猫，把光信号变成电信号，变成路由器能理解的网络信号）</p>
</li>
<li>
<p>你买了一个路由器，然后用电脑和手机分别连接路由器广播出来的无线 WIFl。</p>
<ul>
<li>有线连接和无线WiFi在本质上没有不同，但在实际使用中，无线可能慢于有线连接</li>
<li>有线连接的下载速度可能超过 10M/s，但无线WIFI连接的设备的下载速度可能无法超过 10M/s</li>
</ul>
</li>
<li>
<p>只要路由器连上电信的服务器，那么路由器就会有一个「外网 IP」 ，比如 [ 14.17.32.211 ] 就是一个外网 IP。这就是你在互联网中的地址。</p>
<ul>
<li>访问 <a href="https://ip138.com/">https://ip138.com/</a> 查看当前外网 IP（通常外网IP不要告诉别人，可以准确定位你的位置）</li>
<li>那么你的所有设备，就全都是这一个 外网 IP</li>
<li>那么如何区分是手机设备…还是笔记本呢？这就依靠「内网 IP」来区分了</li>
</ul>
</li>
<li>
<p>但是如果你重启路由器，那么你很有「可能」被重新分配一个「外网 IP」，也就是说你的路由器没有「固定的外网 IP」</p>
<ul>
<li>如果想固定外网IP ，需要花钱每个月五六千，可以得到一个固定的外网IP（在国内购买这些网络资源通常贵于国外）</li>
</ul>
</li>
<li>
<p>但是有个问题，你的路由器的外网 IP 如果是 14.17.32.211，那么你的手机和电脑的 IP 又是什么呢？答案是「内网IP」</p>
</li>
</ol>
<p>​</p>
<h3 id="内网-ip">内网 IP</h3>
<ol>
<li>
<p>路由器会在你家里创建一个内网，内网中的设备使用内网IP，一般来说这个IP的格式都是192.168.xxx.xxx。</p>
<ul>
<li>
<p>命令行：ipconfig ，查看当前设备的内网 IP  ：192.168.101.10</p>
<p></p>
<p>默认网关中的 IP：192.168.101.1  是路由器的 IP</p>
</li>
<li>
<p>如果你家足够大，路由器可能功率不够，覆盖不了整个家，用户可能需要买电力猫或再买一个小路由器做中介器之类的手段，来扩大覆盖范围到整个家。</p>
</li>
<li>
<p>如果家里五六十平米，那路由器基本可以全覆盖。</p>
</li>
</ul>
</li>
<li>
<p>一般路由会给自己分配一个好记的内网IP，如 192.168.1.1</p>
<ul>
<li>小米路由器的 IP ，一般都是 192.168.31.1，为了让出一个位置给光猫的 IP</li>
</ul>
</li>
<li>
<p>然后路由会给每一个内网中的设备分配一个不同的内网 IP，如电脑是 192.168.1.2，手机是 192.168.1.3，以此类推。</p>
</li>
</ol>
<p>​</p>
<h3 id="路由器的功能">路由器的功能</h3>
<blockquote>
<p>把内网的请求，路由到外部，把外部的响应，路由到内部。具有双向路由的功能，所以也被称为网关</p>
</blockquote>
<ol>
<li>现在路由器有两个 IP，一个外网 IP（电信分配的）和一个内网 IP（自己分配给自己的）</li>
<li>内网中的设备可以互相访问，但是不能直接访问外网</li>
<li>内网设备想要访问外网，就必须经过路由器中转</li>
<li>外网中的设备可以互相访问，但是无法访问你的内网</li>
<li>外网设备想要把内容送到内网，也必须通过路由器
<ul>
<li>想从网上（外网）下载内容，会先把内容下载到路由器，路由器再把内容下载到用户的设备上</li>
</ul>
</li>
<li>也就是说内网和外网就像两个隔绝的空间，无法互通，唯一的联通点就是路由器</li>
<li>所以路由器有时候也被叫做「网关]
<ul>
<li>一夫当关，万夫莫开。一旦把路由器拔了，那就与网络世界断联了</li>
</ul>
</li>
</ol>
<p>​</p>
<blockquote>
<p>用 http-server 可以创建一个服务</p>
<ul>
<li>
<p>命令行：http-server . -c-1</p>
<p></p>
</li>
<li>
<p>第一个地址 192.168.xxx.xxx:8080 ，是给手机访问的（需要手机端调试内容时，就可以使用）</p>
</li>
<li>
<p>第二个地址 127.0.0.1:8080 ，是给电脑访问的</p>
</li>
</ul>
</blockquote>
<p>​</p>
<h3 id="几个特殊的-ip">几个特殊的 IP</h3>
<p>分别是</p>
<ol>
<li>127.0.0.1 表示自己（规定死的）</li>
<li>localhost 通过 <a href="C:%5cWindows%5cSystem32%5cdrivers%5cetc" rel="">hosts</a> 指定为自己</li>
<li>0.0.0.0 不表示任何设备</li>
</ol>
<p>​</p>
<h4 id="问hosts-文件在哪">问：hosts 文件在哪？</h4>
<blockquote>
<p>答： 在 Windows 系统中，hosts 位于 C:\Windows\System32\drivers\etc\hosts 。在 macOS / Linux系统中，hosts 位于 /etc/hosts</p>
</blockquote>
<p>hosts 文件，用于指定本机 IP （表示自己）</p>
<ul>
<li>127.0.0.1 / localhost  是 hosts 中默认的 （表示自己）</li>
<li>也可以在 hosts 文件中添加自定义 <strong>任何字符串</strong> 来表示自己（文件中的#内容均为注释，可删）
<ul>
<li>写法如下，定义后，就可以使用这些字符串来访问本地服务</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">+ 127.0.0.1 sam
+ 127.0.0.1 ryuuks
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意：需要通过 http-server 开启本地服务后，下述地址才可以使用</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">http://localhost:8080/index.html
http://127.0.0.1:8080/index.html
http://sam:8080/index.html
http://ryuuks:8080/index.html
</code></pre></td></tr></table>
</div>
</div><p>上述地址，均可以访问到 index.html</p>
<p>​</p>
<p>​</p>
<h2 id="端口">端口</h2>
<blockquote>
<p>IP 有了，还需要什么？ 端口</p>
</blockquote>
<p>WWW（万维网）= URL + HTTP + HTML</p>
<ul>
<li>URL 就是用来定位服务器的，例如，定位百度的服务器 baidu.com</li>
</ul>
<blockquote>
<p>一台机器可以提供很多服务</p>
<p>每个服务一个号码，这个号码就叫端口号port</p>
</blockquote>
<h3 id="端口-port">端口 port</h3>
<h4 id="一个比喻">一个比喻</h4>
<ul>
<li>麦当劳提供两个窗口，一号快餐，二号咖啡</li>
<li>你去快餐窗口点咖啡会被拒绝，让你去另一个窗口</li>
<li>你去咖啡窗口点快餐结果一样</li>
</ul>
<blockquote>
<p>在计算机世界也是这样，你要提供不同的服务，就需要有不同的窗口。这个窗口，就是端口 port</p>
</blockquote>
<h4 id="一台机器可以提供不同服务">一台机器可以提供不同服务</h4>
<ul>
<li>要提供 HTTP 服务最好使用 80 端口</li>
<li>要提供 HTTPS 服务最好使用 443 端口</li>
<li>要提供 FTP 服务最好使用 21 端口</li>
<li>一共有 65535 个端口（基本够用）</li>
</ul>
<p>​</p>
<h3 id="我怎么知道应该用什么端口">我怎么知道应该用什么端口</h3>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8#0%E5%88%B01023%E5%8F%B7%E7%AB%AF%E5%8F%A3" target="_blank" rel="noopener noreffer">维基百科</a>一个一个列出来了，需要的时候就对应查找：每个端口用来做什么</p>
</blockquote>
<table>
<thead>
<tr>
<th>端口</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>80/TCP,UDP</td>
<td><a href="https://zh.wikipedia.org/wiki/%e8%b6%85%e6%96%87%e6%9c%ac%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae" target="_blank" rel="noopener noreffer">超文本传输协议</a>（HTTP）或 <a href="https://zh.wikipedia.org/wiki/%e5%bf%ab%e9%80%9fUDP%e7%bd%91%e7%bb%9c%e8%bf%9e%e6%8e%a5" target="_blank" rel="noopener noreffer">快速UDP网络连接</a>- 用于传输网页</td>
</tr>
<tr>
<td></td>
<td>例如：百度服务器要给用户传输一个网页，那就必须用80端口，用其他端口会有问题</td>
</tr>
<tr>
<td>443/TCP</td>
<td><a href="https://zh.wikipedia.org/wiki/%e8%b6%85%e6%96%87%e6%9c%ac%e4%bc%a0%e8%be%93%e5%ae%89%e5%85%a8%e5%8d%8f%e8%ae%ae" target="_blank" rel="noopener noreffer">超文本传输安全协议</a>（HTTPS）或<a href="https://zh.wikipedia.org/wiki/QUIC" target="_blank" rel="noopener noreffer">QUIC</a></td>
</tr>
<tr>
<td></td>
<td>HTTPS 协议传输就必须用 443 端口，用其他端口也会有问题</td>
</tr>
<tr>
<td>21/TCP,UDP</td>
<td><a href="https://zh.wikipedia.org/wiki/%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae" target="_blank" rel="noopener noreffer">文件传输协议</a>（FTP） - 控制端口</td>
</tr>
<tr>
<td></td>
<td>80后和早期的90后应该在学校见过FTP协议，传文件都是通过 FTP。95后00后可能没见过FTP了</td>
</tr>
</tbody>
</table>
<p>​</p>
<h3 id="端口使用还有什么规则">端口使用还有什么规则</h3>
<ol>
<li>0 到 1023（2的10次方减1）号端口是留给系统使用的
<ul>
<li>普通用户绝对不能使用</li>
<li>即使是管理员有使用权限，但也需要输入额外的密码才能使用这些端口，所以也不推荐管理员使用</li>
<li>通常使用 8080 端口做开发，真正部署服务器时，拥有服务器权限才能用 80 端口…</li>
</ul>
</li>
<li>你只有拥有了管理员权限后，才能使用这 1024 个端口</li>
<li>其他端口可以给普通用户使用</li>
<li>比如 http-server 默认使用 8080 端口</li>
<li>一个端口如果被占用，你就只能换一个端口</li>
</ol>
<h4 id="在其他端口开启服务">在其他端口开启服务</h4>
<ol>
<li>
<p>在 1234 端口开启服务</p>
<p>命令行：<code>hs -c-1 -p 1234</code>（hs：http-server 简写）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">http</span><span class="o">:</span><span class="c1">//192.168.101.10:1234
</span><span class="c1"></span><span class="nx">http</span><span class="o">:</span><span class="c1">//127.0.0.1:1234
</span></code></pre></td></tr></table>
</div>
</div><p>通过访问 http://localhost:1234/index.html 就可以浏览本地页面</p>
</li>
<li>
<p>可否强行使用 80 端口，开启服务呢？🉑</p>
<blockquote>
<p>仅在 windows 上能直接使用这个端口号，在 Linus 和 Mac 中都必须输入密码才能使用，不推荐</p>
</blockquote>
<p>命令行：<code>hs -c-1 -p 80</code>  （在 80 端口开启服务）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">http</span><span class="o">:</span><span class="c1">//192.168.101.10:80
</span><span class="c1"></span><span class="nx">http</span><span class="o">:</span><span class="c1">//127.0.0.1:80
</span></code></pre></td></tr></table>
</div>
</div><p>通过访问 http://localhost/index.html 就可以浏览本地页面（80 是默认端口，可省略）</p>
</li>
<li>
<p>端口被占用的情况，会有如下报错，换个其他的端口号即可（六万多个端口）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">hs</span> <span class="o">-</span><span class="nx">c</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="nx">p</span> <span class="mi">80</span>
<span class="p">=&gt;</span>  <span class="nb">Error</span><span class="o">:</span> <span class="nx">listen</span> <span class="nx">EADDRINUSE</span> <span class="mf">0.0.0.0</span><span class="o">:</span><span class="mi">80</span> <span class="c1">// EADDRINUSE: error address in use 错误地址正在使用中
</span><span class="c1"></span>    
<span class="nx">hs</span> <span class="o">-</span><span class="nx">c</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="nx">p</span> <span class="mi">1234</span>
<span class="p">=&gt;</span>  <span class="nb">Error</span><span class="o">:</span> <span class="nx">listen</span> <span class="nx">EADDRINUSE</span> <span class="mf">0.0.0.0</span><span class="o">:</span><span class="mi">1234</span> <span class="c1">// error address in use
</span><span class="c1"></span>    
<span class="nx">hs</span> <span class="o">-</span><span class="nx">c</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="nx">p</span> <span class="mi">2233</span>
<span class="p">=&gt;</span>  <span class="nx">http</span><span class="o">:</span><span class="c1">//192.168.101.10:2233
</span><span class="c1"></span><span class="p">=&gt;</span>  <span class="nx">http</span><span class="o">:</span><span class="c1">//127.0.0.1:2233
</span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>​</p>
<p>​</p>
<h2 id="ip-和端口缺一不可">IP 和端口缺一不可</h2>
<blockquote>
<p>总而言之：<strong>IP 和 端口 缺一不可</strong> （记住这句话）</p>
</blockquote>
<ul>
<li>IP 是用来定位一个<strong>设备</strong>。</li>
<li>端口是用来定位一个设备的<strong>服务。</strong></li>
<li>有了 IP 和端口，就可以定位一个设备提供的服务了。</li>
<li>例如：百度设备提供的网页服务。腾讯设备提供的聊天服务。淘宝设备提供的支付服务</li>
<li>这些服务都可以通过 IP + 端口 ，实现唯一确定</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="域名是什么">域名是什么</h2>
<blockquote>
<p>域名就是对 IP 起一个友好的名字。</p>
<p>域名是以 .com  .net  .org  …  结尾的字符串，仅此而已。需要花钱购买</p>
<p>如：qq.com</p>
</blockquote>
<ul>
<li>
<p>在前面搭建个人博客时，已经注册过域名。</p>
</li>
<li>
<p>我没有自己的服务器，而是将这个域名映射到（指向） github 的服务器上</p>
</li>
<li>
<p>github 给我 4 个 IP。用户访问时，会访问到这4台中的任何一台服务器。访问的内容都是一样的</p>
</li>
</ul>
<p>​</p>
<p>补充：</p>
<ul>
<li>.com 域名，比较便宜，一年50-80</li>
<li>t.tt，曾经是锤子手机的域名，转手价50W。访问 t.tt 跳转至锤子手机官网：smartisan.com</li>
<li>蔡文胜，2000年抢注十多万个域名，倒手生意。 qiyi.com 是百度旗下爱奇艺的域名</li>
<li>为什么我们需要向国外的人购买域名？发域名的机构也很赚钱。这就是美国人欧洲人赚钱的思维，我发明一套东西，用户都需要使用的，那使用一次就要交一次钱。
<ul>
<li>比如苹果有很多手机专利。谷歌买了摩托罗拉，摩托罗拉也有很多手机专利。谷歌发明了安卓系统，手机厂商用到安卓系统里面的谷歌服务，也需要给谷歌钱。</li>
<li>中国的 5G 出来了，如果以后世界的 5G 应用是由中国主导，关键技术是中国的，那么中国就可以躺着赚钱。如果中国的 5G 搞起来了，那就不单是 5G，周边的所有产业都会全面超过其他国家（所以川普联合各国抵制）</li>
</ul>
</li>
</ul>
<blockquote>
<p>在互联网，每一个新东西出来，都蕴藏着巨大的商机。  如5G</p>
</blockquote>
<p>​</p>
<h3 id="域名就是对-ip-的别称">域名就是对 IP 的别称</h3>
<p>baidu.com 对应什么 IP</p>
<ul>
<li>
<p>命令行：ping baidu.com</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="mf">220.181.38.148</span>  <span class="c1">// 也有 39.156.69.79
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>qq.com 对应什么 IP</p>
<ul>
<li>
<p>命令行：ping qq.com</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">125.39.52.26
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>知识点</p>
<blockquote>
<p>先总结：IP 和 域名 之间，没有什么必然的一对一关系</p>
</blockquote>
<ol>
<li>
<p>一个域名可以对应不同 IP（这个叫 <strong>负载均衡</strong>）</p>
<ul>
<li>这个叫做均衡负载，防止一台机器扛不住</li>
</ul>
</li>
<li>
<p>一个 IP 可以对应不同域名（这个叫 <strong>共享主机</strong>）</p>
<ul>
<li>比如6个人合买一台主机，这台主机服务6个域名</li>
</ul>
<ul>
<li>就叫做共享主机，穷开发者会这么做</li>
<li>或者一个公司提供不同的网站，但不想买两台服务器，就把两个网站（两个域名）放在同一台主机上</li>
</ul>
</li>
</ol>
<p>​</p>
<blockquote>
<p>通常 ping 同一个域名，不一定会得到同一个 IP。这里涉及 <strong>负载均衡</strong> 的问题。</p>
<ul>
<li>假如，一万人同时访问百度，如果只有一个服务器，就要同时接纳一万人。</li>
<li>如果有100万人同时访问，，即使每人只分配1k内存，也需要 100万 k，那么这台服务器肯定容纳不了</li>
<li>解决方法，把这个域名绑定到4个不同的 IP 上，4个 IP 分别位于 华中、华南、华东、华北。</li>
<li>电信有全国服务器，告诉电信，如果用户来自华中，就访问华中服务器…（1/4分流）</li>
<li>如此实现负载均衡。分散负担，不至于让某个服务器因承受不了而宕机。（网站优化策略）</li>
</ul>
</blockquote>
<p>​</p>
<p>补充：</p>
<ul>
<li>
<p>ping 的作者写的一篇文章：<a href="https://ftp.arl.army.mil/~mike/ping.html" target="_blank" rel="noopener noreffer">The Story of the PING Program</a></p>
</li>
<li>
<p>皮卡丘站起来，是皮卡兵。皮卡丘跑起来是什么？<a href="%e7%9a%ae%e5%8d%a1%e4%b9%92%e3%80%81%e7%9a%ae%e5%8d%a1%e4%b9%93" rel="">答案</a> 😂</p>
</li>
</ul>
<p>​</p>
<h3 id="域名和-ip-是怎么对应起来的">域名和 IP 是怎么对应起来的</h3>
<blockquote>
<p>通过 DNS</p>
<ul>
<li>Domain Name System （域名系统、域名服务）</li>
</ul>
</blockquote>
<h4 id="当你输入-baiducom">当你输入 baidu.com</h4>
<p><strong>过程</strong></p>
<ol>
<li>
<p>你的 Chrome 浏览器会向电信/联通提供的 DNS 服务器询问 baidu.com 对应什么IP</p>
</li>
<li>
<p>电信/联通会回答一个 IP（具体过程很复杂，不研究）</p>
<ul>
<li>
<p>这个过程可以用 nslookup 模拟（ns域名，lookup寻找）命令行：nslookup baidu.com</p>
<p></p>
</li>
</ul>
</li>
<li>
<p>然后 Chrome 才会向对应 IP 的 80 / 443 端口发送请求</p>
</li>
<li>
<p>请求内容是查看 baidu.com 的首页</p>
<ul>
<li>baidu 收到请求，就会把你请求的页面的 index.html 发送给你，index.html 中又会请求 css 、js，加载完css、js，就可以看到 baidu.com 的完整页面</li>
</ul>
</li>
</ol>
<p>​</p>
<p><strong>在 network 中可以查看全部请求</strong></p>
<ul>
<li>
<p>Request URL:    <a href="https://www.baidu.com/">https://www.baidu.com/</a>（末尾的 / 表示请求的是baidu的根目录）</p>
<p></p>
</li>
<li>
<p>Response：[得到一个<code>&lt;html&gt;…&lt;/html&gt;</code>]，浏览器就会把这一串 html 渲染出来（中间遇到 link 会请求对应的图片、css、js等文件）</p>
</li>
</ul>
<p>​</p>
<p><strong>为什么是 80 或 443 端口？</strong></p>
<blockquote>
<p>因为这是规定。</p>
</blockquote>
<p>我们在地址栏输入 baidu.com 时，为什么不用写端口号？如 <code>baidu.com:443</code> （ IP 和端口不是缺一不可吗！）</p>
<ul>
<li>
<p>服务器默认用 80 提供 http 服务</p>
</li>
<li>
<p>服务器默认用 443 提供 https 服务</p>
</li>
<li>
<p>你可以在开发者工具里看到具体的端口</p>
<p>61.135.168.125:443  （ 前面就是服务器 IP ，后面就是网页服务的端口）</p>
<p></p>
<p>访问 http 就是 80，访问 https 就是 443</p>
</li>
</ul>
<p>​</p>
<h3 id="题外话">题外话</h3>
<blockquote>
<p>前端需要懂点域名知识</p>
</blockquote>
<h4 id="www">www</h4>
<ul>
<li><a href="http://www.baidu.com">www.baidu.com</a> 和 baidu.com</li>
<li>是同一个域名吗？不是</li>
</ul>
<h4 id="他们是什么关系">他们是什么关系</h4>
<blockquote>
<p><a href="http://www.baidu.com">www.baidu.com</a> 和 baidu.com</p>
</blockquote>
<ul>
<li>com 是顶级域名（com 全写 company 公司，org 非营利性组织）</li>
<li>baidu.com 是二级域名（俗称一级域名）父域名</li>
<li><a href="http://www.baidu.com">www.baidu.com</a> 是三级域名（俗称二级）子域名</li>
<li>他们是父子关系</li>
<li>github.io 把子域名 xxx.github.io 免费给你使用
<ul>
<li>所以 github.io（github公司）和 xxx.github.io（个人网站） 可能不是同一家公司，之间没什么关系</li>
</ul>
</li>
<li>所以你应该知道 <a href="http://www.baidu.com">www.baidu.com</a> 和 baidu.com 可以不是同一家公司，也可以是</li>
<li>www 是多余的吗？是的，非常多余。
<ul>
<li>早期人们为了表明自己是 www 而加的，实际上没有必要加，因为所有域名本身就存在与 万维网www中，写上www前缀反倒多此一举</li>
</ul>
</li>
</ul>
<p>​</p>
<h2 id="如何请求不同的页面">如何请求不同的页面</h2>
<p>访问不同的<strong>路径</strong>，就请求到不同的页面，如下（注意：路径后面不加后缀）</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">https://developer.mozilla.org/zh-CN/docs/Web/HTML</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">https://developer.mozilla.org/zh-CN/docs/Web/CSS</a></li>
</ul>
<p>工具</p>
<ul>
<li>使用 Chrome 开发者工具 Network 面板看看区别
<ul>
<li>只有 Request URL 不同</li>
</ul>
</li>
</ul>
<p>​</p>
<h2 id="同一个页面不同内容">同一个页面，不同内容</h2>
<p>不同的<strong>查询参数</strong>，返回不同的内容</p>
<ul>
<li><a href="http://www.baidu.com/s?wd=hi">www.baidu.com/s?wd=hi</a></li>
<li><a href="http://www.baidu.com/s?wd=hello">www.baidu.com/s?wd=hello</a></li>
</ul>
<p>​</p>
<h2 id="同一个内容不同位置">同一个内容，不同位置</h2>
<p><strong>锚点</strong>可以做到</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS#">https://developer.mozilla.org/zh-CN/docs/Web/CSS#</a>参考书</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS#">https://developer.mozilla.org/zh-CN/docs/Web/CSS#</a>教程</li>
</ul>
<p>注意</p>
<ul>
<li>锚点看起来有中文，实际不支持中文</li>
<li><code>#参考书</code> 会变成 <code>#%E5%8F%82%E8%80%83%E4%B9%A6</code>  重新编码</li>
<li>锚点是无法在 Network 面板看到的，因为锚点不会传给服务器。
<ul>
<li># 井号后面的内容会被浏览器直接吃掉，并不会传到服务器中</li>
<li>锚点仍在当前页面中，只是位置不同而已，并不需要重新请求数据</li>
<li><strong>注意</strong>：一定不要把用户传参拼接到 # 后面，会被浏览器当做锚点内容直接吃掉，服务器就无法获取到参数</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="一个-url-的完整内容">一个 URL 的完整内容</h2>
<blockquote>
<p><strong>协议  +  域名 或 IP  +  端口号  +  路径  +  查询字符串  +  锚点</strong></p>
</blockquote>
<ul>
<li>协议：分 HTTP 和 HTTPS</li>
<li>域名：用来表示IP对应的名称的字符串</li>
<li>IP ：用来定位一个设备的字符串（分为4段，最大值255）</li>
<li>端口号：提供一个服务，就要有对用端口号（有六万多个）</li>
<li>路径：就是一个字符串，用来判断用户访问什么网页</li>
<li>查询参数：就是这个网页中，用户要具体看什么内容，可能有分页</li>
<li>锚点：内容已经获取到了，通过锚点定位到用户想要具体查看的内容的位置（实现文档内部的定位）</li>
</ul>
<p>把上述全部加起来，就是 李爵士发明的 URL （统一资源定位符）</p>
<blockquote>
<p>URL</p>
<ul>
<li>
<p>U：Uniform 统一。国际化标准的</p>
</li>
<li>
<p>R：Resouce 资源。图片、网页…都是资源</p>
</li>
<li>
<p>L：Locator 定位符。</p>
</li>
</ul>
</blockquote>
<p>例：</p>
<ul>
<li>就算没写，你也应该知道端口
<ul>
<li>HTTPS 默认端口 443、HTTP 默认端口 80</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="http协议">HTTP（协议）</h2>
<blockquote>
<p>前面讲了 IP 协议：是用于表示每个设备的地址</p>
<p>而 HTTP 协议：是用来表示如何传输网页的</p>
<ul>
<li>HTTP协议，是基于 TCP 和 IP 两个协议</li>
<li>先有 TCP、IP，李爵士基于前人发明的这两个协议，发明了新的 HTTP 协议</li>
</ul>
</blockquote>
<p>​</p>
<h2 id="curl-命令">curl 命令</h2>
<ul>
<li>curl    /kɜːrl/     使…卷曲</li>
</ul>
<blockquote>
<p>如何用 curl 命令，发出 HTTP 的请求？</p>
</blockquote>
<h3 id="用-curl-可以发-http-请求">用 curl 可以发 HTTP 请求</h3>
<p><strong>示例1：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">curl https://www.baidu.com
</code></pre></td></tr></table>
</div>
</div><p></p>
<ul>
<li>执行命令，获取到整个文档。（中文默认 utf-8 编码，而控制台默认 GBK  所以中文会乱码）</li>
<li>我们在 Chrome 的地址栏中输入上述网址，Chrome 也是做了同样的事情，获取到这个html文档并解析</li>
</ul>
<p>​</p>
<p><strong>示例2：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">curl -v http://baidu.com    只有域名没有路径
</code></pre></td></tr></table>
</div>
</div><ul>
<li>-v ： verbose   /vɜːrˈboʊs/   啰嗦（效果：会显示更多内容）</li>
</ul>
<p></p>
<blockquote>
<p>请求的内容</p>
</blockquote>
<ol>
<li>
<p>我们发出的 HTTP 请求中，只有域名没有路径，则默认请求根路径，会自动补全根路径的斜杠 /</p>
</li>
<li>
<p>开启代理，使用了一些代理的功能（非必须）</p>
</li>
<li>
<p>问了DNS：获取到 baidu.com 的 IP</p>
</li>
<li>
<p>获取到 IP 后，就开始启动 TCP</p>
</li>
<li>
<p>开始连接到 baidu.com（ 220.181.38.148 这个 IP） 的 80 端口</p>
</li>
<li>
<p>连接成功，往 baidu.com 发送了这5行内容</p>
<ol>
<li>GET请求，请求/根路径，使用 HTTP 协议 1.1 版本</li>
<li>因为一个IP（220.181.38.148）可能对应多个域名，说明需要访问的是这个IP上的 baidu.com 这个域名</li>
<li>说明我是用什么来访问的：用 curl 的 7.61.1 版本来访问的</li>
<li>期待返回什么内容：*/*    表示所有内容我都接收</li>
<li>空行（发送一个回车）   表示请求头部分结束</li>
</ol>
</li>
</ol>
<blockquote>
<p>返回的内容</p>
</blockquote>
<ul>
<li>
<p>响应头：先忽略 😂</p>
</li>
<li>
<p><code>&lt;html&gt; &lt;meta …&gt;  &lt;/html&gt;</code> meta 中内容，意为请重新访问 <a href="http://www.baidu.com">http://www.baidu.com</a></p>
<ul>
<li>说明 <a href="http://baidu.com">http://baidu.com</a> 这个 URL 被弃用了，只使用这个最早就有的 URL <a href="http://www.baidu.com">www.baidu.com</a></li>
<li>通常直接使用 baidu.com 访问百度的人，基本都是程序员，将程序员的流量导到 www 上</li>
</ul>
</li>
</ul>
<blockquote>
<p>上面请求失败，发起第二次请求   <code>curl -v http://www.baidu.com</code></p>
</blockquote>
<p></p>
<p>​</p>
<p><strong>示例3：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">curl -s -v -- https://www.baidu.com
</code></pre></td></tr></table>
</div>
</div><ul>
<li>会比上面显示的内容更详细</li>
</ul>
<p>​</p>
<h3 id="需要理解以下流程">需要理解以下流程</h3>
<ul>
<li>url 会被 curl 工具重写，先请求 DNS 获得 IP</li>
<li>先进行 TCP 连接，TCP 连接成功后，开始发送 HTTP 请求</li>
<li>请求内容看一眼</li>
<li>响应内容看一眼</li>
<li>响应结束后，关闭TCP连接（curl 中没有直接写出来）</li>
<li>真正结束（只有TCP结束才是真正的结束）</li>
</ul>
<p>​</p>
<h3 id="http">HTTP</h3>
<blockquote>
<p>HTTP 到底做了什么</p>
<ul>
<li>规定请求的格式是什么，响应的格式是什么</li>
</ul>
</blockquote>
<p>HTTP 规定了请求怎么写： 如何写第6步中的5行请求</p>
<p>HTTP 规定了响应怎么写： 如何写下面响应的内容</p>
<p>​</p>
<blockquote>
<p>那么 HTTP 到底是怎么规定请求格式和响应格式的？  下回分解 ✋</p>
</blockquote>
<p>​</p>
<p>​</p>
<h2 id="习题">习题</h2>
<blockquote>
<p>关于 <a href="http://www.baidu.com">www.baidu.com</a> 和 baidu.com，正确的有（多选）<a href="2,3" rel="">答案</a></p>
</blockquote>
<ol>
<li>是同一个域名</li>
<li>是不同的域名</li>
<li>它们还有相同的一级域名 baidu.com</li>
</ol>
<blockquote>
<p>关于 hosts 文件，正确的有（多选） <a href="1,2,4" rel="">答案</a></p>
</blockquote>
<ol>
<li>hosts 文件中以 # 开头的表示注释</li>
<li>hosts 中可以添加一行 127.0.0.1 sam，让 sam 成为 127.0.0.1 的别称</li>
<li>hosts 中可以添加一行 sam 127.0.0.1，让 sam 成为 127.0.0.1 的别称</li>
<li>hosts 一般需要用管理员权限才能编辑</li>
</ol>
<blockquote>
<p>HTTP 的英文全称是 <strong>____</strong>（注意大小写不要错了）</p>
</blockquote>
<ul>
<li>HyperText Transfer Protocol</li>
</ul>
<blockquote>
<p>DNS 的英文全称是 <strong>____</strong>（注意大小写不要错了）</p>
</blockquote>
<ul>
<li>Domain Name System</li>
</ul>
<blockquote>
<p>URL 包含哪些部分？（多选）<a href="1,2,3,4,5,6" rel="">答案</a></p>
</blockquote>
<ol>
<li>协议</li>
<li>域名或IP</li>
<li>端口</li>
<li>路径</li>
<li>查询参数</li>
<li>锚点</li>
<li>get 或 post</li>
</ol>]]></description>
</item></channel>
</rss>
