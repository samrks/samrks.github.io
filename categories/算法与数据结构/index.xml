<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>算法与数据结构 - 分类 - Sam&#39;s Garage</title>
        <link>http://samrks.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
        <description>算法与数据结构 - 分类 - Sam&#39;s Garage</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ryuukousen@gmail.com (Sam)</managingEditor>
            <webMaster>ryuukousen@gmail.com (Sam)</webMaster><lastBuildDate>Mon, 19 Oct 2020 00:25:48 &#43;0800</lastBuildDate><atom:link href="http://samrks.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="self" type="application/rss+xml" /><item>
    <title>数据结构（上）</title>
    <link>http://samrks.github.io/algorithm-data-structures-part.1/</link>
    <pubDate>Mon, 19 Oct 2020 00:25:48 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://samrks.github.io/algorithm-data-structures-part.1/</guid>
    <description><![CDATA[<p>​</p>
<h2 id="目前用过的数据结构">目前用过的数据结构</h2>
<ul>
<li>数组
<ul>
<li>数组可以分为队列、栈等</li>
</ul>
</li>
<li>哈希表
<ul>
<li>用来存储 key - value 对</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="队列-queue">队列 Queue</h2>
<blockquote>
<p>队列，是一种特殊的数组 ——**「先进先出 FIFO」的数组 **</p>
<p>FIFO :  first in ,  first out</p>
</blockquote>
<h3 id="题目">题目</h3>
<ul>
<li>请实现一个「餐厅叫号」网页</li>
<li>点击「取号」按钮，生成一个号码</li>
<li>点击「叫号」按钮，显示「请 X 号就餐]</li>
</ul>
<h3 id="分析">分析</h3>
<ul>
<li>
<p>首先，应该选择「队列 queue」作为数据结构</p>
<ul>
<li>因为「叫号」遵循的应该是「先到先得」的原则，这点与「队列」的「先进先出」是一致的</li>
</ul>
</li>
<li>
<p>队列的两个重要的 API ：入队、出队</p>
<ul>
<li>在 JS 中，「入队」相当于 queue.push （在叫号数组的最后，添加一个人）</li>
<li>在 JS 中，「出队」相当于 queue.shift （把叫号数组中第一个人踢走，结束排队、可以去吃饭了）</li>
</ul>
</li>
<li>
<p>记得练习一下 call 的用法</p>
</li>
<li>
<p>其他的事情就顺其自然了，见<a href="https://codesandbox.io/s/naughty-frost-qkmhd" target="_blank" rel="noopener noreffer">完整代码</a> （<a href="https://codesandbox.io/" target="_blank" rel="noopener noreffer">codesandbox</a>在线编译器）</p>
</li>
<li>
<p>本地编译器中，开启项目，运行 <code>parcel  +（文件路径，如 src/index.html ）</code>  就可以开启本地服务，实时监听</p>
<p><code>yarn global add parcel</code></p>
</li>
</ul>
<p>​</p>
<h3 id="代码">代码</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;screen&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;actions&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">button</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;createNumber&#34;</span><span class="p">&gt;</span>取号<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">button</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;callNumber&#34;</span><span class="p">&gt;</span>叫号<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
    当前号码： <span class="p">&lt;</span><span class="nt">span</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;newNumber&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
    当前队列： <span class="p">&lt;</span><span class="nt">span</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;queue&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;./main.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 获取到所有页面元素
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">divScreen</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&#34;#screen&#34;</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">btnCreateNumber</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&#34;.createNumber&#34;</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">btnCallNumber</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&#34;.callNumber&#34;</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">spanNewNumber</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&#34;#newNumber&#34;</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">spanQueue</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&#34;#queue&#34;</span><span class="p">)</span>

<span class="c1">// 取号
</span><span class="c1">// 取号号码n默认从0开始，每次点击后自增1
</span><span class="c1">// 需要把所有取过的号都记下来，才能实现叫号
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kd">let</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[]</span>
<span class="nx">btnCreateNumber</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>  <span class="c1">// 入队
</span><span class="c1"></span>  <span class="nx">spanNewNumber</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="nx">n</span>
  <span class="nx">spanQueue</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span>
  <span class="cm">/* innerText 只能显示字符串，
</span><span class="cm">  * 可以用 queue.toString() 显示效果：1,2,3,4
</span><span class="cm">  * 用 JSON.stringify(..) 会把JS对象转换成外观完全一样的字符串, [1,2,3,4]
</span><span class="cm">  * */</span>
<span class="p">}</span>

<span class="c1">// 叫号
</span><span class="c1"></span><span class="nx">btnCallNumber</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 当队列为空，就不再执行叫号操作
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">spanQueue</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="sb">`无需排队`</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>  <span class="c1">// 出队
</span><span class="c1"></span>  <span class="nx">divScreen</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="sb">`请 </span><span class="si">${</span><span class="nx">m</span><span class="si">}</span><span class="sb"> 号就餐`</span>
  <span class="nx">spanQueue</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<h3 id="问">问</h3>
<blockquote>
<p>如果不知道「队列」这个知识点，你会怎么做？</p>
</blockquote>
<ul>
<li>
<p>懂得「队列」，看到这种实现逻辑（先到先得），能立马知道这符合「队列：入队/出队」（先进先出）
科班生只需要了解：「入队、出队」在 JS 中对应的 API 形式即可</p>
</li>
<li>
<p>没有「数据结构」相关知识的辅助，只能一步一步推导这种逻辑的实现方法（相对薄弱）</p>
</li>
</ul>
<ul>
<li>所以「数据结构」很重要</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="栈-stack">栈 Stack</h2>
<blockquote>
<p>「后进先出 LIFO」的数组</p>
<p>LIFO  :  last in ,  first out</p>
</blockquote>
<h3 id="举例">举例</h3>
<blockquote>
<p>可以以一个不严谨的「坐电梯」的情景来理解 ：
1层直达88层的电梯，先进电梯的人，会站到电梯最后。而后进电梯的人站在电梯最前，会先出电梯</p>
</blockquote>
<blockquote>
<p>现实生活的运行机制中，这种<strong>不公平</strong>的例子很少
所以下面就是以一个**「JS 函数调用」**的例子来展开。JS 的「调用栈」就是「栈」的数据结构</p>
</blockquote>
<ul>
<li>
<p>JS 函数的调用栈 call stack 就是一个栈</p>
</li>
<li>
<p>假设 f1 调用了 f2，f2 有调用了 f3</p>
</li>
<li>
<p>那么 f3 结束后应该回到 f2，f2 结束后应该回到 f1</p>
</li>
</ul>
<h3 id="代码-1">代码</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">f1</span><span class="p">(){</span> <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">returb</span> <span class="nx">a</span><span class="o">+</span><span class="nx">f2</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">function</span> <span class="nx">f2</span><span class="p">(){</span> <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">return</span> <span class="nx">b</span><span class="o">+</span><span class="nx">f3</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">function</span> <span class="nx">f3</span><span class="p">(){</span> <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">return</span> <span class="nx">c</span> <span class="p">}</span>
<span class="nx">f1</span><span class="p">()</span>
<span class="c1">// 问：上述代码是 如何压栈和弹栈的 ？
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>画一下压栈、出栈过程，便知这是「后入先出」的栈</p>
</blockquote>
<p>首先，栈就是数组</p>
<p></p>
<ul>
<li>压栈就是 push（添加到最后）</li>
<li>弹栈就是 pop（把最前面先弹出来）</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="留一个悬念">留一个悬念</h3>
<h4 id="内存图里的栈内存和这个调用栈">内存图里的栈内存和这个调用栈</h4>
<ul>
<li>它们是什么关系？—— 关系很大</li>
<li>是同一块内存吗？—— （可以说是同一块内存，因为）有很大的地方是重叠的</li>
</ul>
<blockquote>
<p>这块和 JS 关系不大。【内存图 2.0】</p>
</blockquote>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="链表-linked-list">链表 Linked List</h2>
<blockquote>
<p>只要满足「一个链一个」这样的数据结构，就是「链表」</p>
</blockquote>
<p></p>
<h3 id="实际使用">实际使用</h3>
<blockquote>
<p>举例：**「JS 的原型链」**中的「链」，实际上就是指「链表」</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>  
<span class="nx">array</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span> 
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span>
</code></pre></td></tr></table>
</div>
</div><p>从这个角度看，JS 中任何一个普通对象，都是一个链表（因为有原型的概念）</p>
<p></p>
<blockquote>
<p>链表，是一种对数据结构的抽象。这种抽象，是一种很松散的链接关系</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">push</span> <span class="c1">// array本身没有push，就去数组原型上找
</span><span class="c1"></span><span class="nx">array</span><span class="p">.</span><span class="nx">hasOwnProperty</span>  <span class="c1">// array本身没有，数组原型上没有，只能从对象原型上找到
</span></code></pre></td></tr></table>
</div>
</div><p>这是非常简洁的、实现继承的一种机制</p>
<p>​</p>
<h3 id="链表的好处">链表的好处</h3>
<blockquote>
<p>可以随时把中间的链条给断掉</p>
</blockquote>
<p>例</p>
<ul>
<li>
<p>任意一个数组 array，要去掉链条中的数组原型</p>
</li>
<li>
<p>实现方式：让 array 的 _<em>proto</em>_ 直接指向对象原型（那么这个 array 就不再具备 push 这些方法了）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">__proto__</span>  <span class="c1">// 得到数组原型
</span><span class="c1"></span><span class="nx">array</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span>  <span class="c1">// 得到对象原型
</span><span class="c1"></span><span class="nx">array</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span>  <span class="c1">// null
</span><span class="c1"></span>    
<span class="c1">// 让 array 的 __proto__ 直接指向对象原型 
</span><span class="c1"></span><span class="nx">array</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">push</span> <span class="c1">// undefined
</span></code></pre></td></tr></table>
</div>
</div><p></p>
</li>
</ul>
<h3 id="链表的简单操作-">链表的简单操作 ✅</h3>
<blockquote>
<p>怎么创建链表、怎么在链表上进行增删改查  ——  代码见本地【<a href="D:%5cJirengu%5c%e7%ac%ac1%e9%98%b6%e6%ae%b5%5c6-%e7%ae%97%e6%b3%95%e4%b8%8e%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%5c04-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%88%e4%b8%8a%ef%bc%89%5clinked_list" rel="">linked_list</a>】项目</p>
</blockquote>
<blockquote>
<p>要在大脑中，能构建出这样的模型</p>
</blockquote>
<h4 id="添加节点">添加节点</h4>
<h5 id="第一次尝试失败-">第一次尝试：失败 ❌</h5>
<h5 id="bug分析">BUG分析</h5>
<ul>
<li>运行下面代码的【appendList 方法】只能实现一种情况：就是在第1个节点后面，添加第2个节点。</li>
<li>当你想添加多个节点，多次运行【appendList 方法】会发现链表中始终只有两个节点</li>
<li>多次运行的结果，就是第二个节点在不断的被替换，而不会将每次运行时用户写的节点添加到已有节点的后面</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">* 如何创建一个链表 ↓
</span><span class="cm">* 最简单的链表，就是只有一个节点的链表
</span><span class="cm">* 一个节点，用对象表示。需要包含两个属性：数据、下一个节点(默认是空)
</span><span class="cm">* */</span>
<span class="kr">const</span> <span class="nx">createList</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">data</span><span class="o">:</span> <span class="nx">value</span><span class="p">,</span>
    <span class="nx">next</span><span class="o">:</span> <span class="kc">null</span>   <span class="c1">// 默认下一个节点是空
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/* 添加其他节点 */</span>
<span class="kr">const</span> <span class="nx">appendList</span> <span class="o">=</span> <span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="p">{</span> 
    <span class="nx">data</span><span class="o">:</span> <span class="nx">value</span><span class="p">,</span>
    <span class="nx">next</span><span class="o">:</span> <span class="kc">null</span> 
  <span class="p">}</span>
  <span class="nx">list</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span>
  <span class="k">return</span> <span class="nx">node</span>  <span class="c1">// 往list上添加node节点，并把这个node节点作为函数返回值
</span><span class="c1"></span><span class="p">}</span>
<span class="kr">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">createList</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>        <span class="c1">// 创建list链条(只有一个节点)
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">appendList</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>  <span class="c1">// 往list链条上，添加node节点。
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`node`</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`list`</span><span class="p">,</span> <span class="nx">list</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="代码简化">代码简化</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="p">{</span>
  <span class="nx">data</span><span class="o">:</span> <span class="nx">value</span><span class="p">,</span>   <span class="c1">// 形参value
</span><span class="c1"></span>  <span class="nx">next</span><span class="o">:</span> <span class="kc">null</span>     <span class="c1">// 默认是单节点链表，下一个节点为空
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>上述部分被多次引用。可以提取出来，单独成一个函数 createNode ，来多次调用</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 提取公共部分，独立成一个函数 createNode
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">createNode</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">data</span><span class="o">:</span> <span class="nx">value</span><span class="p">,</span>
    <span class="nx">next</span><span class="o">:</span> <span class="kc">null</span>  
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">--------------------------------------------------------------------------</span>
<span class="kr">const</span> <span class="nx">createList</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">createNode</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>  <span class="c1">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;   多次调用
</span><span class="c1"></span><span class="p">}</span>
<span class="kr">const</span> <span class="nx">appendList</span> <span class="o">=</span> <span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">createNode</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>  <span class="c1">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;   多次调用
</span><span class="c1"></span>  <span class="nx">list</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span>
  <span class="k">return</span> <span class="nx">node</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="第二次尝试成功-">第二次尝试：成功 ✔️</h5>
<blockquote>
<p>我们说「添加节点」实际上是要在当前链条的**最后一个节点的后面，再添加新的节点 **。**而不是在第一个节点的后面，添加新的节点 **</p>
</blockquote>
<blockquote>
<p>👆 上述这点逻辑，必须清晰认识到，这样代码才有可能写对</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">appendList</span> <span class="o">=</span> <span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">createNode</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="c1">// 先生成我们要新添加的节点的内容
</span><span class="c1"></span>  
  <span class="c1">// 添加节点：我们需要在当前链条的最后一个节点的后面，添加新的节点。
</span><span class="c1"></span>  <span class="c1">// 所以必须找到 list 的最后一个节点
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">list</span> 
  <span class="c1">// 重新赋值给变量x，更保险。直接用list原值，可能会导致问题
</span><span class="c1"></span>  <span class="c1">// 开局假设：链表只有一个节点，声明变量 x，作为链表的这一个节点（也是最后一个节点）
</span><span class="c1"></span>  
  <span class="c1">// 循环遍历
</span><span class="c1"></span>  <span class="c1">// 如果 x 后面还有节点存在，说明 x 不是最后一个节点，需要给 x 重新赋值为下一个节点
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>  
    <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span>
  <span class="p">}</span>
  <span class="c1">// x.next === null 
</span><span class="c1"></span>  <span class="c1">// 遍历结束，x.next如果是null了，说明 x 是最后一个节点
</span><span class="c1"></span>  <span class="c1">// 此时只需要，把需要添加的节点，赋值给 x.next 即可
</span><span class="c1"></span>  <span class="nx">x</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span>
  <span class="k">return</span> <span class="nx">node</span>  <span class="c1">// 把需要添加的节点 node 作为函数返回值
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<p>​</p>
<h4 id="删除节点">删除节点</h4>
<blockquote>
<p>现 list 链条上有 3 个节点，每个节点的 data 分别是 10/20/30。需求：从链条中删除 20 的节点</p>
</blockquote>
<h5 id="示例分析">示例分析</h5>
<ol>
<li>
<p>这个实现的思路和[前面的例子](# 链表的好处)类似。</p>
<p>「从链条中删除 20 节点」，实际上就是让 10 节点的 next 不再指向 20，而是直接指向 30</p>
</li>
<li>
<p>删掉 10 和 20 之间的联系后，10 和 20 的 next 仍然分别指向 30。
但是并没有任何对象指向 20 ，20 就相当于没人用的内存垃圾，浏览器会自动把它回收掉</p>
</li>
<li>
<p>所以最终 10 - 20 - 30，就变成了 10 - 30</p>
</li>
</ol>
<p>（图解 ↘）</p>
<p></p>
<p>问题：怎么找到 20 节点的上一个节点（我们只能通过 next 找到当前节点的下一个节点，并没有属性保存当前节点的上一个节点？？）</p>
<p>​</p>
<h5 id="思路">思路</h5>
<ul>
<li>通过上图可知，**「删除 X 节点」**可以转嫁成另一个需求 👇</li>
<li>**「让 X 的上一个节点的 next，直接指向 X 的下一个节点」 **</li>
<li>跳过了 X 节点，相当于从链条中删除了 X 节点（浏览器还会自动回收）</li>
</ul>
<p>​</p>
<h5 id="第一次尝试找规律-">第一次尝试：找规律 ⚠️</h5>
<blockquote>
<p>常规逻辑书写</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">* 删除节点
</span><span class="cm">* 参数1：从哪个链条删除
</span><span class="cm">* 参数2：删除哪个节点
</span><span class="cm">* */</span>
<span class="kr">const</span> <span class="nx">removeFromList_Demo</span> <span class="o">=</span> <span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>   <span class="c1">// 注意：链条的名称 === 第一个节点的名称
</span><span class="c1"></span>  <span class="c1">// 如果要删除的(node传入的)是第1个节点（那node.next就表示第2个节点）
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">list</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span>  <span class="c1">// 就将第1个节点list重新赋值为第2个节点（相当于第1节点就不存在了）
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 如果要删除的(node传入的)是第2个节点（那node.next就表示第3个节点）
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">list</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span> <span class="c1">// 就将第1个节点的next，直接指向第3个节点（跳过第2节点，相当于删除）
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 如果要删除的(node传入的)是第3个节点（那node.next就表示第4个节点）
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span>  <span class="c1">// 就将第2个节点的next，直接指向第四个节点（跳过第3节点，相当于删除）
</span><span class="c1"></span>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 如果要删除的是第4个节点 =&gt; 让第3个节点.next，直点接指向第5个节（跳过4）
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
          <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span><span class="p">).</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// 找到规律了吗？
</span><span class="c1"></span>          <span class="c1">// 这是一个循环（递归）呀
</span><span class="c1"></span>        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>根据需求，写出上述常规代码：非常冗余，全是近似代码、不断重复。【是否说明这其实是有规律可循的】</p>
</blockquote>
<blockquote>
<p>猜想：是否可以用「循环」来解决代码的重复调用、实现规律</p>
</blockquote>
<p>​</p>
<h5 id="第二次尝试有-bug-">第二次尝试：有 bug ⭕️</h5>
<blockquote>
<p>利用循环，实现规律</p>
</blockquote>
<ul>
<li>删除X节点：就是让【 X 的上一个节点】的 next，直接指向【 X 的下一个节点】（X.next）
<ul>
<li>所以**关键在于： X 的上一个节点怎么找到 **</li>
<li>要知道 X 的上一个节点，这就与 X 节点联系紧密</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">* 删除节点
</span><span class="cm">* 参数1：从哪个链条删除
</span><span class="cm">* 参数2：删除哪个节点
</span><span class="cm">* （链条名===第一个节点）
</span><span class="cm">* */</span>
<span class="kr">const</span> <span class="nx">removeFromList</span> <span class="o">=</span> <span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">list</span>   <span class="c1">// x 默认为第一个节点
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="kc">null</span>   <span class="c1">// p 始终表示 x 的上一个节点，默认为空
</span><span class="c1"></span>
  <span class="c1">// 传入的 node 表示是要删除的节点。
</span><span class="c1"></span>  <span class="c1">// 要遍历链条中的每一个节点，用 x 表示当前遍历的节点
</span><span class="c1"></span>  <span class="c1">// 将 x 与 node 比对，如果当前节点 x 不等于 node 节点，就给 x 重新赋值下一个节点，再次判断是否相等
</span><span class="c1"></span>  <span class="c1">// 不断循环查找下一个，最终 x 就会找到要删除的那个节点
</span><span class="c1"></span>  <span class="c1">// 因为【x的上一个节点】是关键，所以循环每轮都要把【当前x的上一个节点】记录下来
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="nx">node</span> <span class="o">!==</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">=</span> <span class="nx">x</span>      <span class="c1">// 每轮先用 p 把当前 x 记下来 
</span><span class="c1"></span>    <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span> <span class="c1">// 然后再把 x 重新赋值为下一个节点
</span><span class="c1"></span>    <span class="c1">//（此时x成为x的下一个节点，p就成为x的上一个节点）
</span><span class="c1"></span>  <span class="p">}</span> 
  <span class="c1">// while 遍历完，得出当前要删除的节点。如果找不到，说明用户传入的 node 不存在 (╯□╰)
</span><span class="c1"></span>  <span class="c1">// 综上，遍历完后，x 和 p 的取值各有两种情况 👇 
</span><span class="c1"></span>  <span class="c1">// console.log(x === node || x === null)  // x 要么找到传入的要删除的节点；要么就是null
</span><span class="c1"></span>  <span class="c1">// console.log(p === x的上一个节点 || p === null)  // p 要么是 x 的上一个节点；要么就是null（说明要删除的就是第1个节点，所以 p 是 null）
</span><span class="c1"></span>  <span class="cm">/*
</span><span class="cm">  * 最后，删除节点，相当于跳过这个节点。
</span><span class="cm">  * x是要删除的节点，那么跳过x这个节点，就应该是x的上一个节点的next ，直接指向 x 的下一个节点 （跳过x）
</span><span class="cm">  * x的上一个节点的next ===&gt; p.next
</span><span class="cm">  * x的下一个节点 ===&gt; x.next
</span><span class="cm">  * */</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span>   <span class="c1">// ← ←  综上得出
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>通过循环，实现了规律，但有 bug。</p>
<ul>
<li>无法删除第一个节点</li>
<li>缺少很多边界情况的处理</li>
</ul>
</blockquote>
<p>示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">createList</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">list</span> <span class="c1">// node 就是 list 的第一个节点了现在
</span><span class="c1"></span><span class="nx">removeFromList</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="c1">// 你会发现 list 没有任何变化
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">newList</span> <span class="o">=</span> <span class="nx">removeFromList</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="c1">// 就算获取返回值也没有用，因为根本就没返回新 list
</span></code></pre></td></tr></table>
</div>
</div><h5 id="第三次尝试成功-">第三次尝试：成功 ✅</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">* 删除节点
</span><span class="cm">* 参数1：从哪个链条删除
</span><span class="cm">* 参数2：删除哪个节点
</span><span class="cm">* removeFromList_Demo1： 原始代码，用于发现规律
</span><span class="cm">* removeFromList_Demo2： 最终代码，用于实现规律（循环），未处理边界情况
</span><span class="cm">* removeFromList：非常抽象，且不是最优方案
</span><span class="cm">* 关键思路：就是让【 X 的上一个节点】的 next，直接指向【 X 的下一个节点】，跳过x节点
</span><span class="cm">* */</span>
<span class="kr">const</span> <span class="nx">removeFromList</span> <span class="o">=</span> <span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">list</span>
  <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">node</span> <span class="c1">// p 仍然表示x的上一个节点，Demo2中将 p 初始化为 null，这里改为 node
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="nx">node</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Demo2中忘了对null进行处理，如果node不 list中，x就可能为 null
</span><span class="c1"></span>    <span class="nx">p</span> <span class="o">=</span> <span class="nx">x</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span>
    <span class="c1">//（此时x被重新赋值为【x的下一个节点】，那么p就成为【x的上一个节点】，稍稍有点抽象，注意理解）
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 若 x 为 null，则不需要删除，直接 return， false 表示无法删除不在list里的节点
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span> 
    <span class="c1">// x初值为list，p初值为node。
</span><span class="c1"></span>    <span class="c1">// 如果node接收传参list，则循环过后x===p，也就是两个参数都是list，说明要删除的节点是第一个节点
</span><span class="c1"></span>    <span class="nx">p</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span> <span class="c1">// p是list，list重新赋值为list.next，那list原值就不存在，相当于删除原本的list第一个节点
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">p</span> 
    <span class="c1">// 如果删除的是第一个节点，那么就要把新 list 的头节点 p 返回给外面
</span><span class="c1"></span>    <span class="c1">// 即 newList = removeFromList(list, list)
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span>  <span class="c1">// 赋值跳过x节点
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">list</span> <span class="c1">// 如果删除的不是第一个节点，返回原来的 list 即可
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">createList</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">list</span> <span class="c1">// node 就是 list 的第一个节点了现在
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">newList</span> <span class="o">=</span> <span class="nx">removeFromList</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="c1">// 必须用 newList 获取返回值才能拿到删除了第一个节点的新 list
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>P.S. 当然还有其他更优雅的实现方法，比如将头指针改为头结点，不过有点超纲，就不说了。。。</p>
</blockquote>
<blockquote>
<p>这个删除节点的代码，华中科技大学里第一次听完链表课的同学也只有 10 % 能写出来。</p>
<p>逻辑很绕，比较难。所以放轻松，不理解也别太着急</p>
</blockquote>
<p>​</p>
<p>​</p>
<h4 id="遍历节点">遍历节点</h4>
<blockquote>
<p>对 list 中的每一个节点，进行一些操作</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">* 获取节点
</span><span class="cm">* 参数：要获取第几个节点
</span><span class="cm">* 返回这个节点 node
</span><span class="cm">* 思路：遍历一次记1，遍历两次记2，遍历到第index次把这个节点返回出来
</span><span class="cm">* */</span>
<span class="kr">const</span> <span class="nx">getNode</span> <span class="o">=</span> <span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">list</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">!==</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">x</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="总结">总结</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">list</span> <span class="o">=</span> <span class="nx">create</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>  <span class="c1">// 创建
</span><span class="c1"></span><span class="nx">node</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> 
<span class="nx">append</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>   <span class="c1">// 添加
</span><span class="c1"></span><span class="nx">remove</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>          <span class="c1">// 删除
</span><span class="c1"></span><span class="nx">travel</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span><span class="nx">fn</span><span class="p">)</span>       <span class="c1">// 遍历
</span></code></pre></td></tr></table>
</div>
</div><h3 id="链表的变形">链表的变形</h3>
<blockquote>
<p>这块比较超纲，就只提出个概念，感兴趣可以自己了解一下</p>
</blockquote>
<h4 id="双向链表">双向链表</h4>
<p>每个节点有一个 previous ，指向上一个节点</p>
<h4 id="循环链表">循环链表</h4>
<p>最后一个节点的 next ，指向头节点</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="哈希表-key-value-pairs">哈希表 key-value pairs</h2>
<blockquote>
<p>链表比较复杂，哈希表没有链表复杂</p>
</blockquote>
<p>有人说：哈希表看起来就是 JS 对象的简化版，有什么难点吗？</p>
<ul>
<li>
<p>哈希表的难点，不在于「表」这个字</p>
</li>
<li>
<p>难点在于**「哈希」**二字</p>
</li>
<li>
<p>这里有<a href="https://www.zhihu.com/question/330112288/answer/744362539" target="_blank" rel="noopener noreffer">一篇文章</a>（停车场案例），帮助你理解什么是 hash</p>
</li>
</ul>
<p>​</p>
<h3 id="哈希表">哈希表</h3>
<blockquote>
<p>key-value 的组合</p>
</blockquote>
<ul>
<li>就是存 key-value 这种形式的数据</li>
<li>并没有限制存储容量的上限。但是存的越多，读取就越难</li>
<li>难点就是如何读取hash表更快</li>
</ul>
<p>​</p>
<h3 id="哈希表的难点">哈希表的难点</h3>
<h4 id="场景">场景</h4>
<ul>
<li>假设哈希表 hashTable 里有10000对 key-value （N=10000）</li>
<li>如何使得读取任意一个  hashTable[&lsquo;yyy&rsquo;]  速度都很快呢 ？
<ul>
<li>可以看<a href="https://www.zhihu.com/question/330112288/answer/744362539" target="_blank" rel="noopener noreffer">一篇文章</a>（与停车场案例，同理）</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">hashTable</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">aaa</span><span class="o">:</span> <span class="nx">value1</span>
  <span class="nx">aab</span><span class="o">:</span> <span class="nx">value2</span>
  <span class="nx">aba</span><span class="o">:</span> <span class="nx">value3</span>
  <span class="nx">abb</span><span class="o">:</span> <span class="nx">value4</span>
  <span class="p">...</span>  
  <span class="nx">zzz</span><span class="o">:</span> <span class="nx">value10000</span>  <span class="c1">// 假设共有 10000 对 key-value
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// 找到 hashTable[`yyy`] 的最快方式
</span></code></pre></td></tr></table>
</div>
</div><h4 id="解决办法">解决办法</h4>
<blockquote>
<p>四种读取  hashTable[&lsquo;yyy&rsquo;]  的方式，如下</p>
</blockquote>
<ol>
<li>
<p>不作任何优化，hash[&lsquo;xxx&rsquo;] 需要遍历所有 key，复杂度为 O(N)    （N表示key的总个数10000）【速度慢】</p>
<ul>
<li>一万个需要1秒，十万个10秒 …</li>
</ul>
</li>
<li>
<p>对 key 排序，使用<strong>二分法</strong>查找，复杂度就是 O(log(2)N)    =&gt;   可简写成（ln N）【速度较快】</p>
</li>
<li>
<p>用字符串对应的 ASCII 数字做索引，复杂度 O(1)  【速度最快，占空间巨大】</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">aaa</span> <span class="p">=&gt;</span> <span class="mi">979797</span>     <span class="p">(</span><span class="nx">a</span><span class="o">:</span> <span class="mi">97</span><span class="p">)</span>
<span class="nx">yyy</span> <span class="p">=&gt;</span> <span class="mi">121121121</span>  <span class="p">(</span><span class="nx">y</span><span class="o">:</span> <span class="mi">121</span><span class="p">)</span>
<span class="c1">// 虽然一次就可以直接找到 yyy, 但是就像停车场的案例，这样导致占用的空间太大了（每一个指都对应一个空间）
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>对索引做除法，取余数，O(1)     【速度最快，节省大部分空间】</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">假设要获取的key的ASCII为</span> <span class="mi">979797</span><span class="err">，</span><span class="nx">准备一个长度为</span> <span class="mi">1000</span> <span class="nx">的容器</span>
<span class="nx">那就用</span> <span class="mi">979797</span> <span class="o">/</span> <span class="mi">1000</span> <span class="nx">余数肯定在</span> <span class="mi">0</span><span class="o">~</span><span class="mi">999</span> <span class="nx">之间</span>
<span class="nx">这个数组只需要</span> <span class="mi">0</span><span class="o">~</span><span class="mi">999</span> <span class="nx">项</span>
<span class="p">{</span>
  <span class="mi">0</span><span class="err">：</span><span class="nx">aaa</span><span class="p">,</span><span class="nx">aab</span><span class="p">,</span><span class="nx">aba</span><span class="p">,</span><span class="nx">abb</span><span class="p">,...</span>
  <span class="mi">1</span><span class="o">:</span> <span class="nx">bbb</span><span class="p">,</span><span class="nx">bba</span><span class="p">,</span><span class="nx">bab</span><span class="p">,</span><span class="nx">baa</span><span class="p">,...</span>
  <span class="mi">2</span><span class="o">:</span> <span class="nx">ccc</span><span class="p">,...</span>
  <span class="p">...</span>
  <span class="mi">998</span><span class="o">:</span> <span class="nx">yyy</span><span class="p">,...</span>
  <span class="mi">999</span><span class="o">:</span> <span class="nx">zzz</span><span class="p">,...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>（同一个号码有两个）冲突了怎么办，冲突了就顺延</p>
<ul>
<li>998 满了就存 999，999 满了就存到 0，0 满了就存到 1 …</li>
<li>反正只有 1000 个位置</li>
</ul>
</li>
</ol>
<blockquote>
<p>通过哈希表实现更快的读取到数据</p>
<ul>
<li>哈希表解决的就是这个问题（存的很容易，读也得快）</li>
</ul>
</blockquote>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="树-tree">树 Tree</h2>
<blockquote>
<p>一个链多个</p>
<p>是对链表的升级</p>
</blockquote>
<p></p>
<ul>
<li>children 是个**数组 **</li>
<li>data1 节点有两个子节点（数组元素） data2 / data3  ，共同组成一个「树」结构（可以有无限长）</li>
<li>两个子节点 data2 / data3 可以再向下链接其他的子节点 data4 / 5 / 6 … ，也可不再有其他子节点</li>
<li>如果子节点不再（分枝杈）有 children，就称这个子节点为「叶子」
<ul>
<li>链到头了，最后一个节点</li>
</ul>
</li>
<li>所以 data1 有两个叶子</li>
</ul>
<blockquote>
<p>看起来不像树，像金字塔，倒过来就像树了</p>
</blockquote>
<p></p>
<p>​</p>
<p>​</p>
<h3 id="实际使用-1">实际使用</h3>
<blockquote>
<p>实际生活中，到处都是「树」结构</p>
</blockquote>
<ul>
<li>中国的省市区，可以看成一棵树</li>
<li>公司的层级结构，可以看成一棵树</li>
<li>网页中的节点，可以看成一棵树 
html &gt; head、body，body &gt; div、span、a、p …，head &gt; link、title、meta</li>
</ul>
<p>​</p>
<h3 id="对树进行增删改查">对「树」进行增删改查</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">tree</span> <span class="o">=</span> <span class="nx">createTree</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="c1">// 创建树
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">createNode</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="c1">// 创建节点
</span><span class="c1"></span><span class="nx">addChild</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span><span class="nx">node</span><span class="p">)</span>          <span class="c1">// 添加节点
</span><span class="c1"></span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">node1</span><span class="p">,</span><span class="nx">node2</span><span class="p">)</span>     <span class="c1">// 删除节点
</span><span class="c1"></span><span class="nx">travel</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span>                 <span class="c1">// 遍历树
</span></code></pre></td></tr></table>
</div>
</div><p>​</p>
<h4 id="创建树根节点">创建树（根节点）</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">createTree</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">data</span><span class="o">:</span> <span class="nx">value</span><span class="p">,</span>
    <span class="nx">children</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>   <span class="c1">// 子节点
</span><span class="c1"></span>    <span class="nx">parent</span><span class="o">:</span> <span class="kc">null</span>      <span class="c1">// 父节点
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h4 id="添加子节点">添加子节点</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">* 添加子节点
</span><span class="cm">* 参数1：往哪个节点下添加子节点
</span><span class="cm">* 参数2：要添加的子节点数据是什么
</span><span class="cm">* */</span>
<span class="kr">const</span> <span class="nx">addChild</span> <span class="o">=</span> <span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">data</span><span class="o">:</span> <span class="nx">value</span><span class="p">,</span>
    <span class="nx">children</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">parent</span><span class="o">:</span> <span class="nx">node</span>
  <span class="p">}</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span> <span class="o">||</span> <span class="p">[]</span> <span class="c1">// 必须保证node.children是数组，才能用push方法
</span><span class="c1"></span>  <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">newNode</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">newNode</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h4 id="遍历节点-1">遍历节点</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">* 遍历节点
</span><span class="cm">* 先fn操作根节点，然后遍历根节点上的所有子节点，分别用fn操作子节点（不断循环）
</span><span class="cm">* 这种先打印根节点，后处理子节点的遍历方法，称为「先根遍历」法，是比较简单的遍历方法
</span><span class="cm">* 当然还有其他遍历方法
</span><span class="cm">* */</span>
<span class="kr">const</span> <span class="nx">travel</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">travel</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">fn</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h4 id="删除节点-1">删除节点</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">* 删除节点
</span><span class="cm">* 数组只能通过下标删除元素（splice）
</span><span class="cm">* 所以必须先找到node的兄弟姐妹，遍历兄弟姐妹，看node排行第几（获取下标）
</span><span class="cm">* */</span>
<span class="kr">const</span> <span class="nx">removeNode</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">node</span><span class="cm">/*要删除的节点*/</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">siblings</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">children</span>
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">siblings</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">siblings</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">index</span> <span class="o">=</span> <span class="nx">i</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">siblings</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="查找节点">查找节点</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">* 查找节点
</span><span class="cm">* */</span>
<span class="kr">const</span> <span class="nx">findNode</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">tree</span> <span class="o">===</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 要查找的就是根节点
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">tree</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">tree</span> <span class="o">!==</span> <span class="nx">node</span> <span class="o">&amp;&amp;</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 非根节点、且存在子节点的情况
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 遍历所有子节点，找到目标node
</span><span class="c1"></span>      <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">findNode</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">node</span><span class="p">)</span>  <span class="c1">// 递归
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">result</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">undefined</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">undefined</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h2 id="数据结构就这么简单-">数据结构就这么简单 ？</h2>
<blockquote>
<p>对，数据结构就是这些代码</p>
<ul>
<li>难在，看着代码简单，但是写起来非常难（逻辑绕）</li>
<li>甚至大脑里面想都想不清楚，必须写出来、log、再慢慢推导</li>
</ul>
</blockquote>
<blockquote>
<p>其实，数据结构必须是**简单的 **</p>
<ul>
<li>所有数据结构都可以通过一句话就概况出来
<ul>
<li>队列是什么：先进先出</li>
<li>栈是什么：先进后出</li>
<li>哈希表是什么： key-value的组合</li>
<li>链表是什么：一个对象链着另一个对象</li>
<li>树是什么：一个对象链着多个对象</li>
</ul>
</li>
<li>它不可以复杂，即使复杂了，也会被程序员重新划分成几个简单问题</li>
</ul>
<p>因为👇程序员崇尚简洁优雅</p>
</blockquote>
<ul>
<li>程序员崇尚简洁优雅</li>
<li>如果你觉得某个编程概念真的很难</li>
<li>那么请相信一定是你哪里理解错了</li>
<li>请试着重新理解一下</li>
<li>把细节<strong>自己动手敲一敲</strong>，才找到错误点。
<ul>
<li>这个过程中可能会突然意识到「噢！！原来是这样，我之前大脑想的是错的」</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<blockquote>
<p>「二叉树」</p>
<ul>
<li>可能是前端中最难的</li>
</ul>
</blockquote>]]></description>
</item><item>
    <title>排序算法</title>
    <link>http://samrks.github.io/algorithm-sort/</link>
    <pubDate>Fri, 16 Oct 2020 15:18:26 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://samrks.github.io/algorithm-sort/</guid>
    <description><![CDATA[<p>​</p>
<h2 id="前言">前言</h2>
<blockquote>
<p>算法中最简单的就是排序算法</p>
</blockquote>
<p>​</p>
<h2 id="复习代码">复习代码</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>一句话总结：
每次找到最小的数放前面，然后对后面的数做同样的事情</p>
</blockquote>
<p>​</p>
<h2 id="minindex">minIndex</h2>
<blockquote>
<p>用于找出数组中最小数字的下标</p>
</blockquote>
<h3 id="你永远都有两种写法">你永远都有两种写法</h3>
<ul>
<li>「递归」和「循环」</li>
</ul>
<h3 id="目前的-minindex-递归算法">目前的 minIndex （递归算法）</h3>
<blockquote>
<p>通过 min 函数的「递归」算法，来获取到最小值，从而找到下标</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">minIndex</span><span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">min</span><span class="p">(</span><span class="nx">numbers</span><span class="p">))</span> 
<span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">min</span><span class="p">(</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">min</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span>    <span class="c1">// 递归
</span><span class="c1"></span>  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="缺点">缺点</h4>
<ul>
<li>看着就繁琐（递归中用了很多括号、还引用了额外的帮助函数min ）</li>
<li>重写吧</li>
</ul>
<h3 id="重写-minindex--循环算法">重写 minIndex 🔔 （循环算法）</h3>
<blockquote>
<p>用循环</p>
</blockquote>
<p>思路：【 index 】作为一个标志，始终代表着「数组 numbers」中的「最小值」的【下标】</p>
<ul>
<li>
<p>第一步，假设下标为 0 的元素，是 numbers 中的最小值，也就是 index = 0</p>
</li>
<li>
<p>把下标 1 的元素与下标 0 的元素进行比较，如果下标 1 的元素，比下标 0 的元素还小，也就是下标 1 是最小值。而 index 始终表示最小值的下标，所以 index 需重新赋值为 1</p>
</li>
<li>
<p>👆这种方法叫【贪婪法】：只要判断是比自己小的值，就认为是最小的值
（俗称「渣男法」：只要看到一个女生比现在的女朋友漂亮，就要换女朋友）</p>
</li>
<li>
<p>逐步分析 👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">minIndex</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="p">=&gt;</span> <span class="p">(</span><span class="nx">假设9</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nx">最小</span><span class="p">)</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">=&gt;</span> <span class="p">(</span><span class="mi">9</span><span class="nx">遇到6</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">-</span>  <span class="mi">9</span><span class="o">&gt;</span><span class="mi">6</span><span class="p">)</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">=&gt;</span> <span class="p">(</span><span class="mi">6</span><span class="nx">遇到8</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="o">-</span>  <span class="mi">8</span><span class="o">&gt;</span><span class="mi">6</span><span class="p">)</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">=&gt;</span> <span class="p">(</span><span class="mi">6</span><span class="nx">遇到13</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">13</span><span class="o">&gt;</span><span class="mi">6</span><span class="p">)</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">=&gt;</span> <span class="p">(</span><span class="mi">6</span><span class="nx">遇到5</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="o">-</span>  <span class="mi">5</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">)</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">=&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="nx">遇到4</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="o">-</span>  <span class="mi">4</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">)</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">5</span>
<span class="p">=&gt;</span> <span class="nx">index</span> <span class="nx">变化过程</span> <span class="mi">0</span><span class="err">→</span><span class="mi">1</span><span class="err">→</span><span class="mi">4</span><span class="err">→</span><span class="mi">5</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="源代码循环实现minindex-">源代码（循环实现minIndex） 👇</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="mi">1</span><span class="nx">et</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span> 
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span> 
    <span class="k">if</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">){</span>  
      <span class="nx">index</span> <span class="o">=</span> <span class="nx">i</span> 
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">index</span>
<span class="p">}</span>
<span class="nx">minIndex</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>index 表示当前最小值下标，已经为 0，所以循环体中，应该是从下标为 1 的元素开始，和下标为 0 的元素进行比较大小</li>
<li>全部遍历完，返回最小值下标</li>
</ul>
<p>​</p>
<h4 id="分析">分析</h4>
<ul>
<li>一目了然，一听就会，一写就错</li>
<li>写错，就记得多测试几次</li>
</ul>
<p>​</p>
<h2 id="启发-">启发 💡</h2>
<blockquote>
<p>是不是所有的「递归」都可以写成「循环」 ？？</p>
</blockquote>
<blockquote>
<p>答：是的</p>
</blockquote>
<ul>
<li><strong>所有的递归，都可以改写成循环</strong></li>
<li>这是已经被证明的事情</li>
<li>如果觉得递归不好理解，都可以改写成循环，一般来说循环会更好理解，但循环写起来会更麻烦、代码量更大</li>
</ul>
<h2 id="选择排序-select-sort--">选择排序 select sort  ⭕️</h2>
<blockquote>
<p>选择排序两种思路</p>
<ol>
<li>递归</li>
<li>循环</li>
</ol>
</blockquote>
<blockquote>
<p>改写 sort</p>
</blockquote>
<p></p>
<h3 id="递归写法">递归写法</h3>
<blockquote>
<p>复习一下  |  递归思路：</p>
<ul>
<li>长度大于2，就找最小值放到前面 + 并对后面所有值再次 sort</li>
<li>长度等于2，就直接判断大小 / 交换两个元素位置，然后返回数组（中止条件）</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">minIndex</span><span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">min</span><span class="p">(</span><span class="nx">numbers</span><span class="p">))</span> 
<span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`numbers: </span><span class="si">${</span><span class="nx">numbers</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">min</span><span class="p">(</span> <span class="p">[</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">min</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span>   <span class="c1">// 递归
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span> 
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> 
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> 
    <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>    <span class="c1">// 递归
</span><span class="c1"></span>  <span class="p">}</span><span class="k">else</span><span class="p">{</span> 
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>  
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="循环实现分析">循环实现分析</h3>
<blockquote>
<p>思路不变：</p>
<ul>
<li>每次找到最小的数放前面，<del>然后对后面的数做同样的事情</del></li>
<li>然后 i++</li>
</ul>
</blockquote>
<blockquote>
<p>「循环的每次找到最小的数，放前面 —— 选择排序」这个思路比较容易想到，但是代码写起来却比较困难</p>
</blockquote>
<p>尝试写循环代码 👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="mi">1</span><span class="nx">et</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span> 
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span> 
    <span class="k">if</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">){</span>  
      <span class="nx">index</span> <span class="o">=</span> <span class="nx">i</span> 
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">index</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;???</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>  
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="c1">// index 是当前最小数的下标，i 表示当前下标
</span><span class="c1"></span>    <span class="c1">// index 对应的数应该放到 i 处（交换 index 和 i 的元素，这就是👇swap需要实现的）
</span><span class="c1"></span>    <span class="nx">swap</span><span class="p">(</span><span class="nx">numbers</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">// swap 还没实现
</span><span class="c1"></span>    
    <span class="c1">// index、i 都是 index 的意思，建议 i 改名
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="分析-1">分析</h4>
<ul>
<li>怎么知道 <code>i &lt; ???</code> 处应该写什么（结束条件是什么）</li>
<li>提前写好 minIndex 能有效简化问题</li>
<li>用 swap 占位能有效简化问题（虽然还不知道swap应该实现的代码，但是先写个占位符，有助于分析思路）</li>
</ul>
<p>​</p>
<h4 id="一实现-swap">一、实现 swap</h4>
<blockquote>
<p>实现交换 index 和 i 的元素</p>
</blockquote>
<p>1、常规方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">swap</span> <span class="o">=</span> <span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
  <span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span>
<span class="p">}</span>
<span class="nx">swap</span><span class="p">(</span><span class="nx">numbers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>2、JS 解构赋值（析构赋值）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">b</span><span class="p">,</span><span class="nx">a</span><span class="p">]</span>
<span class="c1">// a =&gt; 2
</span><span class="c1">// b =&gt; 1
</span></code></pre></td></tr></table>
</div>
</div><p>​</p>
<h5 id="错误的实现-swap">错误的实现 swap</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">swap</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">a</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span>
  <span class="nx">b</span> <span class="o">=</span> <span class="nx">temp</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">300</span><span class="p">]</span>  <span class="c1">// 能否实现交换元素位置呢 ？？
</span><span class="c1"></span><span class="nx">swap</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="c1">// [100,200,300]  未实现交换位置
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>你会发现，上述 numbers[1] 和 numbers[2] 的值原封不动</p>
</blockquote>
<p>分析：</p>
<ul>
<li>如果 a / b 是简单类型，传参的时候就会<strong>复制值</strong>
<ul>
<li>numbers[1] 传给 a，相当于 a 复制了 200 这个值，a 与 numbers 并没有连带关系。 b 同理</li>
<li>相当于只是把 a(200) 和 b(300) 交换了值，但这一切与 numbers  并没有关系</li>
</ul>
</li>
<li>而前面常规方法中 numbers 是(数组)对象，传参时是<strong>复制地址</strong>
<ul>
<li><code>let swap = (array, i, j) =&gt; {...}</code>  这里的 array 形参是接收一个数组实参，也就是接收一个对象，对象传递时只是复制了地址，所以 array 形参始终代表了传递进来的实参数组 numbers</li>
<li>所以 array[i] 和 array[j] 交换位置，也就等同于控制 numbers 中对应元素交换了位置</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>这就是【传值 V.S. 传址】的区别</p>
<p>内存图相关知识：所有放在 stack 中的都是直接复制值，放在 heap 里面只能复制地址</p>
</li>
</ul>
<p>​</p>
<h4 id="二分析-i---应该写什么">二、分析 i &lt; ??? 应该写什么</h4>
<blockquote>
<p>怎么知道 i &lt; ??? 处应该写什么</p>
</blockquote>
<p>暴力分析（逐步拆解）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;???</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span> 
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> 
    <span class="nx">swap</span><span class="p">(</span><span class="nx">number</span><span class="err">，</span><span class="nx">index</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>假设 numbers 的长度为 n = 4 👇</p>
<p></p>
<ul>
<li>第一次循环 i = 0，当前遍历的元素下标为 0 ，需要进行比较的元素、其下标 index 的取值范围只能是 1\2\3</li>
<li>第二次循环 i = 1，当前遍历的元素下标为 1 ，需要进行比较的元素、其下标 index 的取值范围只能是 2\3</li>
<li>第三次循环 i = 2，当前遍历的元素下标为 2 ，需要进行比较的元素、其下标 index 的取值范围只能是 3</li>
<li>第四次循环 i = 3，当前遍历的元素下标为 3 ，需要进行比较的元素、其下标 index 无法取值，所以 i 不能等于 3，一定要 i = 3 和 一个空数组进行比较也可以，但多此一举</li>
</ul>
<blockquote>
<p>结论：i 的取值为 0\1\2  【 i 能取到的最大值小于 3 ，也就是  i &lt; numbers 的长度减 1 】</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">){...}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<p>​</p>
<h4 id="发现-2-个问题">发现 2 个问题</h4>
<h5 id="1minindex-查找范围有问题">1、minIndex 查找范围有问题</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这句话有问题，如果上次循环已经找到了第一个最小的数字，那么之后找最小数字的时候，就可以忽略第一个</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">)</span>  <span class="o">+</span> <span class="nx">i</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="分析-2">👆分析</h5>
<blockquote>
<p>下标 i 、下标 index 对应元素的交换经过</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js">  <span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="p">=&gt;</span> <span class="nx">当前i</span><span class="o">=</span><span class="mi">0</span> <span class="p">,</span> <span class="nx">minIndex</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">10</span><span class="p">])=&gt;</span><span class="nx">最小值下标index</span><span class="o">=</span><span class="mi">3</span> <span class="p">,</span> <span class="mi">0</span><span class="nx">与3交换位置</span><span class="p">=&gt;[</span><span class="mi">10</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span> <span class="p">,</span> <span class="mi">10</span><span class="nx">位置钉住</span>
<span class="p">=&gt;</span> <span class="nx">当前i</span><span class="o">=</span><span class="mi">1</span> <span class="p">,</span> <span class="nx">minIndex</span><span class="p">([</span><span class="nx">xx</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">])=&gt;</span><span class="nx">最小值下标index</span><span class="o">=</span><span class="mi">3</span> <span class="p">,</span> <span class="mi">1</span><span class="nx">与3交换位置</span><span class="p">=&gt;[</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">]</span> <span class="p">,</span> <span class="mi">10</span><span class="o">/</span><span class="mi">20</span><span class="nx">位置钉住</span>
<span class="p">=&gt;</span> <span class="nx">当前i</span><span class="o">=</span><span class="mi">2</span> <span class="p">,</span> <span class="nx">minIndex</span><span class="p">([</span><span class="nx">xx</span><span class="p">,</span><span class="nx">xx</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">])=&gt;</span><span class="nx">最小值下标index</span><span class="o">=</span><span class="mi">2</span> <span class="nx">就是当前元素</span> <span class="nx">i</span><span class="err">，</span><span class="nx">无需交换位置</span>
<span class="p">=&gt;</span> <span class="err">（</span><span class="nx">结束</span><span class="err">）</span><span class="nx">i不需要再取3</span><span class="err">，</span><span class="nx">因为上一步已经将最后两个元素进行比较</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>所以说，每一轮 minIndex 的元素，都需要忽略前一个元素，也就是👇</p>
</blockquote>
<ul>
<li>
<p>当 i = 0，需要从 [20, 40, 30, 10] 中找出最小值，忽略 0 个 👉 [10, 40, 30, 20]</p>
</li>
<li>
<p>当 i = 1，需要从 [xx, 40, 30, 20] 中找出最小值，忽略 1 个 👉 [10, 20, 30, 40]</p>
</li>
<li>
<p>当 i = 2，需要从 [xx, xx, 30, 40] 中找出最小值，忽略 2 个 👉 [10, 20, 30, 40]</p>
<p></p>
</li>
</ul>
<blockquote>
<p>综上，发现规律：<strong>i 等于 N，就需要忽略前面 N 个元素</strong></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">所以</span> <span class="p">=&gt;</span>  <span class="nx">minIndex</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">)</span> 
</code></pre></td></tr></table>
</div>
</div><h5 id="2为什么要-i">2、为什么要 +i</h5>
<blockquote>
<ul>
<li>
<p>如果不加 i ， 那么 index 的取值计算，每次都是从 0 开始</p>
</li>
<li>
<p>因为每轮都切掉前面一个元素，导致下标数值发生变化</p>
</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">当</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="err">，</span><span class="nx">忽略0个</span><span class="err">，</span><span class="nx">从</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="nx">中找出最小值10</span><span class="o">/</span><span class="nx">下标为</span><span class="err">【</span><span class="mi">3</span><span class="err">】，</span><span class="nx">实际在</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="nx">对应下标仍为</span><span class="err">【</span><span class="mi">3</span><span class="err">】</span>
<span class="err">👉</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>

<span class="nx">当</span> <span class="nx">i</span><span class="o">=</span><span class="mi">1</span><span class="err">，</span><span class="nx">忽略1个</span><span class="p">(</span><span class="nx">下标为0的元素</span><span class="p">)</span><span class="err">，</span><span class="nx">从</span><span class="p">[</span><span class="mi">40</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span><span class="nx">中找出最小值20</span><span class="o">/</span><span class="nx">下标为</span><span class="err">【</span><span class="mi">2</span><span class="err">】</span><span class="nx">实际在</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span><span class="nx">对应下标应为</span><span class="err">【</span><span class="mi">3</span><span class="err">】</span>
<span class="err">👉</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>

<span class="nx">当</span> <span class="nx">i</span><span class="o">=</span><span class="mi">2</span><span class="err">，</span><span class="nx">忽略2个</span><span class="p">(</span><span class="nx">下标为0</span><span class="o">/</span><span class="mi">1</span><span class="nx">的元素</span><span class="p">)</span><span class="err">，</span><span class="nx">从</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">]</span><span class="nx">中找出最小值30</span><span class="o">/</span><span class="nx">下标为</span><span class="err">【</span><span class="mi">0</span><span class="err">】</span><span class="nx">实际在</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">]</span><span class="nx">对应下标应为</span><span class="err">【</span><span class="mi">2</span><span class="err">】</span>
<span class="err">👉</span><span class="nx">不交换</span>
</code></pre></td></tr></table>
</div>
</div><p>得出规律</p>
<ul>
<li>i=0时，minIndex =&gt; 3，index =&gt; 3  👉 相当于 minIndex(3) + i(0) = index(3)</li>
<li>i=1时，minIndex =&gt; 2，index =&gt; 3  👉 相当于 minIndex(2) + i(1) = index(3)</li>
<li>i=2时，minIndex =&gt; 0，index =&gt; 2  👉 相当于 minIndex(0) + i(2) = index(2)</li>
</ul>
<blockquote>
<p>index = minIndex(…) + i</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 最终得出
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">)</span>  <span class="o">+</span> <span class="nx">i</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h4 id="再次分析-i-">再次分析 i&lt; ???</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;???</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span> 
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">)</span>  <span class="o">+</span> <span class="nx">i</span> 
    <span class="nx">swap</span><span class="p">(</span><span class="nx">number</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>假设 numbers 的长度 n = 4</p>
<p></p>
<ul>
<li>i 等于 3 时，在 <code>minIndex(numbers.slice(3))</code>中， numbers 只剩 numbers[3]  也就是 numbers[i] 本身，只剩一个元素，无法再和其他元素进行比较大小了，也就不需要 minIndex 操作了，<strong>所以 i = 3 是无意义的</strong></li>
<li>所以 i 的取值从 0 开始，最大就到 2 为止</li>
<li><strong>结论</strong>：i 的取值范围是 i &lt; 3 ，也就是 i &lt; n-1</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="循环代码注释版">循环代码（注释版）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`----`</span><span class="p">)</span> <span class="c1">// 这个log很精髓
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`i: </span><span class="si">${</span><span class="nx">i</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span> <span class="c1">// 打印i，知道这是第几次比较
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="o">+</span> <span class="nx">i</span> <span class="c1">// 找到最小值下标
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`index: </span><span class="si">${</span><span class="nx">index</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`min: </span><span class="si">${</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">index</span> <span class="o">!==</span> <span class="nx">i</span><span class="p">){</span>  <span class="c1">// 如果最小值下标index 与 i 不等，就交换二者位置，相等就什么也不做
</span><span class="c1"></span>      <span class="nx">swap</span><span class="p">(</span><span class="nx">numbers</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> 
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`swap </span><span class="si">${</span><span class="nx">index</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">i</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span> <span class="c1">// 打印出调换的 index 和 i
</span><span class="c1"></span>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`numbers: </span><span class="si">${</span><span class="nx">numbers</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">numbers</span>
<span class="p">}</span>

<span class="c1">// 下面是sort中引用的两个帮助函数： swap / minIndex
</span><span class="c1"></span>
<span class="kd">let</span> <span class="nx">swap</span> <span class="o">=</span> <span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>   <span class="c1">// 用于交换位置
</span><span class="c1"></span>  <span class="c1">// let temp = array[i]
</span><span class="c1"></span>  <span class="c1">// array[i] = array[j]
</span><span class="c1"></span>  <span class="c1">// array[j] = temp
</span><span class="c1"></span>  <span class="p">[</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>  <span class="c1">// 也可以用解构赋值法，交换元素位置
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>  <span class="c1">// 用于找出最小值下标
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]){</span>
      <span class="nx">index</span> <span class="o">=</span> <span class="nx">i</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">index</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<p>​</p>
<h3 id="汇总-">汇总 ✅</h3>
<h4 id="循环代码纯净版">循环代码（纯净版）</h4>
<blockquote>
<p>思路：循环的每轮，找到未排序数组中的最小值的下标，用于交换位置，把最小值放到最前面</p>
<ul>
<li>循环的每轮，都假设 i 为当前轮次的最小值下标，并且 i 还可以表示当前未排序数组的第一位元素。</li>
<li>通过 minIndex 找到未排序数组中的最小值下标</li>
<li>如果最小值下标与假设不符，就通过 swap 交换位置</li>
</ul>
</blockquote>
<p>三部分组成：sort（循环排序）、swap（实现交换位置）、minIndex（找最小值下标）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>   <span class="c1">// 👈 重点理解！！（边界：为什么-1）
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="o">+</span> <span class="nx">i</span>   <span class="c1">// 👈 重点理解！！（最小值下标：为什么+i）
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nx">index</span> <span class="o">!==</span> <span class="nx">i</span><span class="p">){</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">numbers</span><span class="p">,</span><span class="nx">index</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">numbers</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">swap</span> <span class="o">=</span> <span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">i</span> <span class="p">,</span><span class="nx">j</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]){</span>
      <span class="nx">index</span> <span class="o">=</span> <span class="nx">i</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">index</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="补充双层-for-循环写法">补充：双层 for 循环写法</h4>
<blockquote>
<p>特点：代码量少，只需一个函数。但思路、算法过程不易理解</p>
</blockquote>
<blockquote>
<p>思路同上：每轮找未排序数组中的最小值的下标，用于交换位置，把最小值放到最前面</p>
<ul>
<li>外层循环：每轮开局，都假设当前遍历元素 j（同时也是未排序数组的第一个元素）为最小值 minIndex</li>
<li>内层循环：当前未排序数组中的第一个元素 j 和 后面元素依次比较大小，确定当前最小值下标</li>
<li>如果当前最小值下标与假设不符，就交换二者位置</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">selectSort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// j表示每轮遍历的元素的下标；i表示下一位元素的下标
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="nx">j</span>  <span class="c1">// 每轮都假设当前元素是最小值，当前元素下标 j 是最小值下标
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> 
      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">])</span> <span class="p">{</span> <span class="c1">//  当前元素与下一个元素，进行两两比较，找出最小值下标
</span><span class="c1"></span>        <span class="nx">minIndex</span> <span class="o">=</span> <span class="nx">i</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">minIndex</span> <span class="o">!==</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 若最小值不是当前元素 j ，那就把最小元素与当前元素交换位置
</span><span class="c1"></span>      <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">]]</span>
    <span class="p">}</span> 
    <span class="c1">// 每一轮都从未排序数组中找出最小值，并放到未排序数组的最前面(第一位)
</span><span class="c1"></span>    <span class="c1">// 注：每一轮遍历的当前元素 j 所在位置，就是当前未排序数组的第一位
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="对比递归写法">对比：递归写法</h4>
<blockquote>
<p>特点：思路更简明、但需要帮助函数   【边界处理 ( 中止条件 ) 是关键！！】</p>
</blockquote>
<blockquote>
<p>递归思路：</p>
<ul>
<li>长度大于2，就找最小值放到前面 + 并对后面所有值再次 sort</li>
<li>长度等于2，就直接判断大小 / 交换两个元素位置，然后返回数组。【👈中止条件（边界处理）】</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">min</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span>
<span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">min</span><span class="p">(</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">min</span><span class="p">(</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span>  <span class="c1">// 递归
</span><span class="c1"></span>  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1">// 👈 边界处理很关键！！
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">minNum</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">minNum</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">sort</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span>   <span class="c1">// 递归
</span><span class="c1"></span>  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">arr</span> <span class="o">:</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>   <span class="c1">// 👈 边界处理很关键！！
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="总结">总结</h3>
<blockquote>
<p>选择排序的两种实现方式：递归、循环</p>
</blockquote>
<ul>
<li>思路：每次选择最小 / 大的，放在最前面 / 最后面。选到最后没得选了，就排完了</li>
<li>假设有 10 个元素，就需要选择 8 次、对比 8 次。
<ul>
<li>第 1 个元素不用选，默认第 1 个直接和第 2 个对比</li>
<li>第 10 个也不用选，选第 9 个时，就已经和第 10 个对比了</li>
<li>所以只需要对比 8 次</li>
</ul>
</li>
<li>每次对比，需要进行一次搜索（找到最小值）</li>
<li>所以时间复杂度、大概是「 n 的平方 」</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="总结-">总结 👆</h2>
<h3 id="1-所有递归都能改成循环">1. 所有递归都能改成循环</h3>
<h3 id="2-循环的时候有很多细节">2. 循环的时候有很多细节</h3>
<ul>
<li>循环时特别容易被细节干扰，这些细节很难想清楚</li>
<li>要动手列出表格，找规律</li>
<li>尤其是<strong>边界条件</strong>很难确定</li>
<li>我们没有处理长度为 0 和 1 的数组（if length === 0 | 1 直接 return 即可）</li>
</ul>
<h3 id="3-如果-debug">3. 如果 debug</h3>
<ul>
<li>学会看控制台</li>
<li>学会打 log</li>
<li>打 log 的时候，注意加标记</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="快速排序-quick-sort-">快速排序 quick sort ⭕️</h2>
<blockquote>
<p>特点就是「快」</p>
</blockquote>
<blockquote>
<p>只讲递归思路，不讲循环思路。通过上面的学习，已经知道递归更简单、循环非常复杂（细节很多）</p>
</blockquote>
<h3 id="递归思路">递归思路</h3>
<blockquote>
<p>以某某为基准</p>
</blockquote>
<ul>
<li>想象你是一个体育委员</li>
<li>你面对的同学为 [12，3，7，21，5，9，4，6]</li>
<li>**「以某某为基准，小的去前面，大的去后面」  **  （不会规定「你」需要站在哪里）</li>
<li>你只需要重复说上面这句话，就能让他们完成排序</li>
<li>神奇不神奇？</li>
<li>用图说明一下</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">12</span><span class="err">，</span><span class="mi">3</span><span class="err">，</span><span class="mi">7</span><span class="err">，</span><span class="mi">21</span><span class="err">，</span><span class="mi">5</span><span class="err">，</span><span class="mi">9</span><span class="err">，</span><span class="mi">4</span><span class="err">，</span><span class="mi">6</span><span class="p">]</span>
			   		 <span class="err">👆</span>
<span class="p">=&gt;</span> <span class="nx">假设站在靠中间的</span> <span class="mi">21</span> <span class="nx">上</span>
<span class="p">=&gt;</span> <span class="nx">喊话</span><span class="err">「</span><span class="nx">以21为基准</span><span class="err">，</span><span class="nx">比21小的</span><span class="err">，</span><span class="nx">站到21前面</span><span class="err">，</span><span class="nx">大的站到后面</span><span class="err">」</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">12</span><span class="err">，</span><span class="mi">3</span><span class="err">，</span><span class="mi">7</span><span class="err">，</span><span class="mi">5</span><span class="err">，</span><span class="mi">9</span><span class="err">，</span><span class="mi">4</span><span class="err">，</span><span class="mi">6</span><span class="err">，</span><span class="mi">21</span><span class="p">]</span>   <span class="nx">经过这一次排序</span><span class="err">，</span><span class="mi">21</span> <span class="nx">的位置就钉住了</span>
						    			 <span class="err">👆</span>
<span class="p">=&gt;</span> <span class="nx">再次随机找一个数</span><span class="err">（</span><span class="nx">从中间找</span><span class="err">），</span><span class="nx">喊话</span><span class="err">「</span><span class="nx">以5为基准</span><span class="err">，</span><span class="nx">比它小的站到前面</span><span class="err">，</span><span class="nx">比它大的站到后面</span><span class="err">」</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">12</span><span class="err">，</span><span class="mi">3</span><span class="err">，</span><span class="mi">7</span><span class="err">，</span><span class="mi">5</span><span class="err">，</span><span class="mi">9</span><span class="err">，</span><span class="mi">4</span><span class="err">，</span><span class="mi">6</span><span class="err">，</span><span class="mi">21</span><span class="p">]</span>
             <span class="err">👆</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="err">，</span><span class="mi">4</span><span class="err">，</span>   <span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="err">，</span><span class="mi">12</span><span class="err">，</span><span class="mi">7</span><span class="err">，</span><span class="mi">9</span><span class="err">，</span><span class="mi">6</span><span class="err">，</span><span class="p">(</span><span class="mi">21</span><span class="p">)]</span>  <span class="c1">// [3,4]是比5小的，[12,7,9,6]是比5大的，5的位置就钉住了
</span><span class="c1"></span>
<span class="p">=&gt;</span> <span class="nx">接下来在</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="nx">中间任选一个</span><span class="err">（</span><span class="nx">假设选4吧</span><span class="err">），</span><span class="nx">喊话</span><span class="err">「</span><span class="nx">比4大的去前面</span><span class="err">，</span><span class="nx">比4小的去后面</span><span class="err">」</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="err">、</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="err">、</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="err">、</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>  <span class="c1">// 此时 4 的位置就钉住了。3固定了吗？不行，每次指向谁，谁才能固定
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="nx">此时指向3</span><span class="err">，</span><span class="nx">发现3就一个元素自身</span><span class="err">，</span><span class="nx">那无需比较</span><span class="err">，</span><span class="mi">3</span><span class="nx">可以固定了</span>
<span class="p">=&gt;</span> <span class="nx">下面跑到右边一组去</span><span class="err">，</span><span class="nx">指向</span> <span class="mi">7</span> <span class="nx">吧</span><span class="err">，</span><span class="nx">喊话</span><span class="err">「</span><span class="nx">比7大的去前面</span><span class="err">，</span><span class="nx">比7小的去后面</span><span class="err">」</span>
<span class="p">=&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="err">、</span><span class="p">[</span><span class="mi">6</span><span class="p">,(</span><span class="mi">7</span><span class="p">),</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span><span class="err">、</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>   <span class="c1">// 假设下面指向6，就一个可以直接固定了
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">6</span><span class="p">),(</span><span class="mi">7</span><span class="p">),[</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span><span class="err">、</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>   <span class="c1">// 下面指向 9 吧，所以9就钉住了，喊话「比9大的往后面去...」
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="err">、</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="err">、</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>   <span class="c1">// 就剩12一个元素了，此时指向 12，就一个所以直接固定位置
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="err">、</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">21</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>思路</p>
<ul>
<li>一共 8 个元素，每指向一个元素，就会固定一个元素的位置</li>
<li>所以只需要指 8 次，就完成排序了</li>
<li>【这就是快速排序的思路】</li>
</ul>
</blockquote>
<p>​</p>
<h3 id="快排源码递归">快排源码（递归）</h3>
<blockquote>
<p>下面是在<a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="noopener noreffer">阮一峰写的版本</a>基础上、加工成 ES6</p>
</blockquote>
<blockquote>
<p>因为使用递归思想，所以必须考虑中止条件、对各种情况进行相应处理</p>
</blockquote>
<p>逐步分析 👇</p>
<ul>
<li>
<p>如果发现数组<strong>只有一个元素</strong>，就无需排序，直接放行（中止条件）</p>
<p>注意：这里条件必须写 <code>arr.length &lt;= 1</code>  ，不能只有<code>arr.lenght === 1</code> 这会导致递归无法结束</p>
</li>
<li>
<p><a href="https://zh.forvo.com/search/pivot/en/" target="_blank" rel="noopener noreffer">pivot</a>  /ˈpɪvət/ —— 基准、中心点、轴</p>
</li>
<li>
<p>取地板（舍去小数部分）：Math.floor(3.5)  →  3</p>
</li>
<li>
<p>pivot ，这里的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener noreffer">splice</a> 用于删除数组中的某个元素，并把它。（splice 会修改原数组）
因为 JS 中 splice 提取后返回的是一个数组，必须通过 [0] 的方式才能拿到数字本身。并赋值给变量 pivot
拿到基准数，并将基准数从 arr 中删除</p>
</li>
<li>
<p>既然已经拿到基准数的下标，为什么不直接通过 <code>let pivot = arr[pivotIndex]</code> 来获取到基准数，而是还要通过 splice 的返回值来获取基准数、这么麻烦的方式？？
因为这里实际上是完成两个操作：第一目的是获取基准数、第二目的是还需要将基准数从 arr 中删除，所以使用 splice 正好可以同时完成这两个操作</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">quickSort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">arr</span> <span class="p">}</span>   <span class="c1">// 最基本的情况：发现指向的数组只剩下一个元素
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">pivotIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1">// 获取基准的索引、找到靠中间的数字（取地板）
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">pivot</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">pivotIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">// 拿到基准数，并将基准数从 arr 中删除
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>   <span class="c1">// 遍历被删掉基准数后的数组 （执行喊话操作）
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">pivot</span><span class="p">){</span> 
      <span class="nx">left</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>  <span class="c1">// 如果当前遍历元素小于基准数，就放到left数组中
</span><span class="c1"></span>    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
      <span class="nx">right</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="c1">// 由此得到了三部分：左边数组、基准数、右边数组
</span><span class="c1"></span>    <span class="p">}</span> 
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">quickSort</span><span class="p">(</span><span class="nx">left</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span> <span class="p">[</span><span class="nx">pivot</span><span class="p">],</span> <span class="nx">quickSort</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span> <span class="p">)</span>  <span class="c1">// 👈 代码的核心就是这句
</span><span class="c1"></span>  <span class="c1">// 不断对左边数组快排、右边数组快排、连接两边数组和基准数
</span><span class="c1"></span>  <span class="c1">// 停止条件是 数组只剩下一个元素，直接返回数组
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>思路：</p>
<ul>
<li>对数组「找基准数、然后左右分半」 … 不断递归（循环）这个操作</li>
<li>直到数组只剩一个元素，就不再执行直接返回</li>
</ul>
</blockquote>
<blockquote>
<p>所有算法的思路都很简单，难再代码实现</p>
</blockquote>
<h4 id="代码纯净版">代码（纯净版）</h4>
<blockquote>
<p>思路：</p>
<ul>
<li>每次找一个中间基准数。将数组对半，大于基准数，放到左边数组，小于基准数放到右边数组。</li>
<li>然后再次分别对左边/右边数组排序（层层递归、压栈）</li>
<li>中止（边界）条件：数组&lt;=1个元素，就可以直接返回这个具体值（开始弹栈）</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">quickSort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">){</span> <span class="k">return</span> <span class="nx">arr</span> <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">pivotIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">pivot</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">pivotIndex</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">pivot</span><span class="p">){</span> <span class="nx">left</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span> <span class="nx">right</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">quickSort</span><span class="p">(</span><span class="nx">left</span><span class="p">).</span><span class="nx">concat</span><span class="p">([</span><span class="nx">pivot</span><span class="p">],</span> <span class="nx">quickSort</span><span class="p">(</span><span class="nx">right</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="补充说明">补充说明</h3>
<blockquote>
<p>例：<code>let pivot = arr.splice(pivotIndex, 1)[0]</code>  因为 splice 的特性，导致必须用 [0] 来拿到基准数本身</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">45</span><span class="p">]</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="nx">a</span>  <span class="c1">// [32]
</span><span class="c1"></span><span class="o">------------------------------</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">45</span><span class="p">]</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="nx">a</span>  <span class="c1">// 32
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>算法如果涉及到某个语言的细节，这是非常不好的。
最好的算法写法是用「伪代码」来写。自己发明语法，就不用纠结 API 的问题了。</p>
</blockquote>
<blockquote>
<p>面试时，可以尝试鸡贼的写法，询问面试官可否使用「伪代码」来写</p>
</blockquote>
<p>​</p>
<h3 id="思路一句话">思路一句话</h3>
<blockquote>
<p>以某个元素为基准，小的往前放，大的往后放</p>
</blockquote>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="归并排序-merge-sort-">归并排序 merge sort ⭕️</h2>
<blockquote>
<p>是当前三种排序算法中最难理解的一个</p>
</blockquote>
<h3 id="不以某某为基准">「不」以某某为基准</h3>
<ul>
<li>想象你是一个体育委员</li>
<li>你面对的同学为 [12，3，7，21，5，9，4，6]</li>
<li><strong>左边一半排好序，右边一半排好序</strong></li>
<li>**然后把左右两边合并（merge）起来 **</li>
<li>神奇不神奇？</li>
<li>用图说明一下</li>
</ul>
<p>​</p>
<h3 id="思路分析">思路分析</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js">   <span class="p">[</span><span class="mi">12</span><span class="err">，</span><span class="mi">3</span><span class="err">，</span><span class="mi">7</span><span class="err">，</span><span class="mi">21</span><span class="err">，</span><span class="mi">5</span><span class="err">，</span><span class="mi">9</span><span class="err">，</span><span class="mi">4</span><span class="err">，</span><span class="mi">6</span><span class="p">]</span>

<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">21</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>  <span class="c1">// 【每次都把数组看作左边和右边，并让左右边自己排序】
</span><span class="c1"></span>    <span class="err">↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span>        
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">21</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>  <span class="c1">// 左右排序完成（先忽略排序细节）
</span><span class="c1"></span>
<span class="p">=&gt;</span> <span class="nx">现在只需要把左右两部分</span><span class="err">【</span><span class="nx">结合</span><span class="err">】</span><span class="nx">起来</span><span class="err">，</span><span class="nx">怎么结合</span><span class="err">？</span> <span class="c1">// 【合并】
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>   
	  <span class="err">👆</span>              <span class="err">👆</span>
    <span class="c1">// 左手指向左边第一个，右手指向右边第一个。比较两个值大小，把较小的放到容器中。 ✅✅
</span><span class="c1"></span>    <span class="c1">// 此时左边的 3 更小，所以先把 3 放到下面容器中。然后左手指向下一个元素 7 
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span>                        <span class="p">]</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>    
	     <span class="err">👆</span>           <span class="err">👆</span>
   <span class="c1">// 此时比较 7 和 4。把较小值 右边的 4 放到容器中。右手指向下一元素
</span><span class="c1"></span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>                      <span class="p">]</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> 
	     <span class="err">👆</span>              <span class="err">👆</span>
   <span class="c1">// 此时比较 7 和 5。把较小值 右边的 5 放到容器中。右手指向下一元素
</span><span class="c1"></span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span>                   <span class="p">]</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> 
	     <span class="err">👆</span>                 <span class="err">👆</span>
   <span class="c1">// 此时比较 7 和 6。把较小值 右边的 6 放到容器中。右手指向下一元素
</span><span class="c1"></span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>                <span class="p">]</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> 
	     <span class="err">👆</span>                    <span class="err">👆</span>
   <span class="c1">// 此时比较 7 和 9。把较小值 左边的 7 放到容器中。左手指向下一元素
</span><span class="c1"></span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span>             <span class="p">]</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> 
	        <span class="err">👆</span>                 <span class="err">👆</span>
   <span class="c1">// 此时比较 12 和 9。把较小值 右边的 9 放到容器中。右边元素排完了.
</span><span class="c1"></span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span>           <span class="p">]</span>

<span class="nx">当某一边元素全部排完</span><span class="err">，</span><span class="nx">另一边元素就可以全部照抄了</span> <span class="err">（</span><span class="nx">左边还剩12</span><span class="p">,</span><span class="mi">21</span><span class="nx">直接放进容器中</span><span class="err">）✅✅</span>
<span class="nx">大功告成</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span>

</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>综上可知：<strong>【合并】的算法</strong>其实很简单：左右两边 index 同时遍历，把较小值 push 到容器中</p>
</blockquote>
<blockquote>
<p>问题是：怎么让左右两边自己先完成排序？ （递归思想 👇）</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">数组</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="nx">分成左右两边</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">21</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="nx">之后</span>
<span class="nx">将左边</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">21</span><span class="p">]</span> <span class="nx">再次划分为两部分</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="err">、</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">21</span><span class="p">]</span>
<span class="nx">将左边</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="nx">再次划分为两部分</span> <span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="err">、</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>  
<span class="nx">当拆分到只有两个元素时</span><span class="err">，</span><span class="nx">就可以直接比较大小排序了</span><span class="err">（</span><span class="nx">如果不会</span><span class="err">，</span><span class="nx">还可以再进行前面的</span><span class="err">【</span><span class="nx">合并</span><span class="err">】</span><span class="nx">操作</span><span class="err">）</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="err">、</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> 
<span class="p">=&gt;</span>  <span class="err">👆</span>     <span class="err">👆</span>    <span class="c1">// 左手指向左边第一个，右手指向右边第一个。将较小值放到容器中
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span>   <span class="p">]</span>  
   <span class="c1">// 此时右边全部排完。那么左边直接照抄落到容器后面即可
</span><span class="c1"></span>   <span class="c1">// 大功告成
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span><span class="err">，</span><span class="nx">同理得到</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>上面 从 [12]、 [3] 得到 [3, 12]  这一步是最关键的一步。</li>
<li>将数组 [12,3]，[7,21]  拆分为 [12]  [3]，[7] [21] … **「使得所有数组，变成了排好序的数组」**怎么理解这句？
<ul>
<li>被拆分后，数组中只有一个元素，一个元素也就无需排序。</li>
<li>变相的理解成 **「此时所有的数组，都是无需排序的数组（排好序的数组）」 **</li>
</ul>
</li>
</ul>
<blockquote>
<p>归并排序的算法：默认只能，对两个排好序的数组，进行排序</p>
<ul>
<li>这个算法可能乍一看，很不可思议，好像什么都没做，就排好序了。</li>
<li>一定要拆解步骤，才能发现这里面的神奇之处。</li>
</ul>
</blockquote>
<p></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 再合并（左手指左一、右手指右一，较小值放到容器中）✅✅
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span>
    <span class="err">👆</span>       <span class="err">👆</span>
   <span class="c1">// 比较 3 和 7。把较小值 左边的 3 放到容器中。左手指向下一元素 12
</span><span class="c1"></span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span>        <span class="p">]</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span>
       <span class="err">👆</span>    <span class="err">👆</span>
   <span class="c1">// 比较 12 和 7。把较小值 右边的 7 放到容器中。右手指向下一元素 21
</span><span class="c1"></span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span>     <span class="p">]</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span><span class="err">，</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span>
       <span class="err">👆</span>       <span class="err">👆</span>
   <span class="c1">// 比较 12 和 21。把较小值 左边的 12 放到容器中。左边全部排完。右边剩下[21]直接落到后面
</span><span class="c1"></span>   <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span>    <span class="p">]</span>

  <span class="c1">// 大功告成
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="源码分析">源码分析</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">mergeSort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">arr</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> 
  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
  <span class="k">return</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">left</span><span class="p">),</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">right</span><span class="p">))</span>  <span class="c1">// 👈关键
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">merge</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="c1">// 👈 核心
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">b</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">a</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="p">[</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span> <span class="o">:</span> <span class="p">[</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">b</span><span class="p">))</span>
  <span class="c1">// 关键 👆
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<h4 id="详细注释-">详细注释 👇</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">mergeSort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 长度为1的数组，无需排序，所以默认它是已经排好序的数组【这点非常关键】
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">arr</span>
  <span class="p">}</span>
  <span class="c1">// arr.slice(begin,end) 截取数组下标从begin到end的部分，返回新数组（包括begin，不包括end）
</span><span class="c1"></span>  <span class="c1">// 原数组 arr 不改变
</span><span class="c1"></span>  <span class="c1">// 省略 end，则 slice 会一直提取到原数组末尾
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// left是从下标0截取到一半的位置（不包括end）
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// right是从一半的位置，截取到末尾（包括begin）
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">left</span><span class="p">),</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">right</span><span class="p">))</span> 
  <span class="c1">// 左右再次进行拆分操作。拆到数组只有1个元素，认为所有数组已经排好序。
</span><span class="c1"></span>  <span class="c1">// 对排好序的数组进行 merge 合并（这才是归并算法的核心👇见下）
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">merge</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>  <span class="c1">// 【前提条件：merge 接收的a、b两个数组，必须是已经排好序的两个数组】！！！
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">b</span>  <span class="c1">// 一个空数组a和一个已经排好序的数组b，那就直接返回排好序的数组b
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">a</span>  <span class="c1">// 同理
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="p">[</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span> <span class="o">:</span> <span class="p">[</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">b</span><span class="p">))</span>
  <span class="c1">// 👆这里就是递归的难理解之处，需要拆解步骤 ⚠️⚠️见下
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="拆解-merge">拆解 merge⚠️⚠️</h4>
<blockquote>
<p>【前提条件：merge 接收的 a、b 两个数组，必须是已经排好序的两个数组】！！！</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js">	 <span class="nx">merge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
<span class="p">=&gt;</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="p">[</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span> <span class="o">:</span> <span class="p">[</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">b</span><span class="p">))</span>

<span class="o">---------------------------------------------</span><span class="nx">拆解</span> <span class="err">👇</span><span class="o">-----------------------------------------</span>
<span class="c1">// 第一步：指向两个数组的第一位，比较大小
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>  
    <span class="err">↑</span>         <span class="err">↑</span>       
   <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="nx">否</span><span class="err">，</span><span class="nx">执行</span> <span class="p">[</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">merge</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">b</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">// 相当于把较小值摘出，再次merge剩余部分
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nx">merge</span><span class="p">(</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="p">)]</span>
               <span class="err">↑</span>       <span class="err">↑</span>
   <span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="nx">是</span><span class="err">，</span><span class="nx">执行</span> <span class="p">[</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">merge</span><span class="p">(</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">// 把较小值摘出，再次merge剩余部分
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">merge</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span> <span class="p">]</span>
                 <span class="err">↑</span>       <span class="err">↑</span>
   <span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="nx">是</span><span class="err">，</span><span class="nx">执行</span> <span class="p">[</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">merge</span><span class="p">(</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">// 把较小值摘出，再次merge剩余部分
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">merge</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">])</span> <span class="p">]</span>
	                  <span class="err">↑</span>       <span class="err">↑</span>
   <span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">9</span> <span class="nx">否</span><span class="err">，</span><span class="nx">执行</span> <span class="p">[</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">merge</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">b</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">// 把较小值摘出，再次merge剩余部分
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">merge</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">])</span> <span class="p">]</span>
		                   <span class="err">↑</span>     <span class="err">↑</span>
   <span class="mi">10</span> <span class="o">&gt;</span> <span class="mi">9</span> <span class="nx">是</span><span class="err">，</span><span class="nx">执行</span> <span class="p">[</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">merge</span><span class="p">(</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">// 把较小值摘出，再次merge剩余部分    
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nx">merge</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="p">[])</span> <span class="p">]</span>   
   											 <span class="err">↑</span>    <span class="err">↑</span>
   <span class="c1">// 满足中止条件：一个空数组、一个已经排好序的数组 ，那就直接返回排好序的数组b
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="补充slice-用法httpsdevelopermozillaorgzh-cndocswebjavascriptreferenceglobal_objectsarrayslice">补充：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noopener noreffer">slice 用法</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">begin</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong>截取数组下标从 begin 到 end 的部分，返回一个新数组（包括begin，不包括end）</strong></p>
</li>
<li>
<p>**原始数组不改变 **</p>
</li>
<li>
<p>begin （可省略）</p>
<p>提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。
如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。
**如果省略 begin，则 slice 从索引 0 开始。 **
如果 begin 大于原数组的长度，则会返回空数组。</p>
</li>
<li>
<p>end（可省略）</p>
<p>提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。
slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。
如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。
**如果 end 被省略，则 slice 会一直提取到原数组末尾。 **
如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 省略两个参数，可以实现深拷贝效果 ？！
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kd">let</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`newArr: </span><span class="si">${</span><span class="nx">newArr</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>  <span class="c1">// 6,2,3,4,5
</span><span class="c1"></span><span class="nx">newArr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`修改后，newArr: </span><span class="si">${</span><span class="nx">newArr</span><span class="si">}</span><span class="sb">，arr: </span><span class="si">${</span><span class="nx">arr</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>  <span class="c1">// 6,2,3,4,5   1,2,3,4,5 原数组不改变
</span></code></pre></td></tr></table>
</div>
</div><p>​</p>
<p></p>
<h3 id="代码纯净版-1">代码（纯净版）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">mergeSort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">arr</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> 
  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
  <span class="k">return</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">left</span><span class="p">),</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">right</span><span class="p">))</span>  
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">merge</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">b</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">a</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="p">[</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span> <span class="o">:</span> <span class="p">[</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">b</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="总结-1">总结</h3>
<h4 id="归并排序的思路">归并排序的思路</h4>
<ul>
<li>
<p>mergeSort</p>
<ul>
<li>拿到一个乱序的数组，会把数组分成<strong>左右两部分</strong>。然后对左右两边继续调用 mergeSort 再拆分 …</li>
<li>拆分到所有元素独自成一个数组，达到中止条件。</li>
</ul>
</li>
<li>
<p>merge</p>
<ul>
<li>接收两个数组作为参数（只接收排好序的数组）</li>
<li>**每次都比较两个数组的首项，并提取出较小的值，放在最前面 **
因为两个数组都是顺序排列，所以首项一定代表其所在数组的最小值。
两个最小值对比得出的较小值，一定是所有元素中的最小值，所以摘出放在最前面</li>
<li>对剩余数组，继续重复上一步操作</li>
</ul>
</li>
</ul>
<p>​</p>
<h4 id="代码">代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">mergeSort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">){</span> 
    <span class="k">return</span> <span class="nx">arr</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
  <span class="k">return</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">left</span><span class="p">),</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">right</span><span class="p">))</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">merge</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">b</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">a</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="p">[</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="nx">b</span><span class="p">))</span> <span class="o">:</span> <span class="p">[</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h4 id="图示">图示</h4>
<h5 id="1">1</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">merge</span><span class="p">(</span>     <span class="nx">a</span>    <span class="p">,</span>    <span class="nx">b</span>    <span class="p">)</span>
<span class="nx">merge</span><span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<h5 id="2">2</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">mergeSort</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<h5 id="3">3</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">mergeSort</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="nx">merge</span><span class="p">(</span> <span class="nx">mergeSort</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">]),</span> <span class="nx">mergeSort</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> <span class="p">)</span>
<span class="nx">merge</span><span class="p">(</span> <span class="nx">merge</span><span class="p">(</span> <span class="nx">mergeSort</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="nx">mS</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span> <span class="p">),</span> <span class="nx">merge</span><span class="p">(</span> <span class="nx">mergeSort</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">]),</span> <span class="nx">mergeSort</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
<span class="nx">m</span><span class="p">(</span><span class="nx">m</span><span class="p">(</span><span class="nx">m</span><span class="p">(</span><span class="nx">mS</span><span class="p">([</span><span class="mi">6</span><span class="p">]),</span><span class="nx">mS</span><span class="p">([</span><span class="mi">3</span><span class="p">])),</span> <span class="nx">m</span><span class="p">(</span><span class="nx">mS</span><span class="p">([</span><span class="mi">2</span><span class="p">]),</span><span class="nx">mS</span><span class="p">([</span><span class="mi">7</span><span class="p">]))</span> <span class="p">)</span> <span class="p">,</span> <span class="nx">m</span><span class="p">(</span><span class="nx">m</span><span class="p">(</span><span class="nx">mS</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span><span class="nx">mS</span><span class="p">([</span><span class="mi">5</span><span class="p">])),</span> <span class="nx">m</span><span class="p">(</span><span class="nx">mS</span><span class="p">([</span><span class="mi">8</span><span class="p">]),</span><span class="nx">mS</span><span class="p">([</span><span class="mi">4</span><span class="p">]))))</span>
<span class="c1">// 达到 mergeSort 中止条件 👆
</span><span class="c1"></span><span class="nx">m</span><span class="p">(</span> <span class="nx">m</span><span class="p">(</span> <span class="nx">m</span><span class="p">([</span><span class="mi">6</span><span class="p">],[</span><span class="mi">3</span><span class="p">]),</span> <span class="nx">m</span><span class="p">([</span><span class="mi">2</span><span class="p">],[</span><span class="mi">7</span><span class="p">])</span> <span class="p">)</span> <span class="p">,</span> <span class="nx">m</span><span class="p">(</span> <span class="nx">m</span><span class="p">([</span><span class="mi">1</span><span class="p">],[</span><span class="mi">5</span><span class="p">]),</span> <span class="nx">m</span><span class="p">([</span><span class="mi">8</span><span class="p">],[</span><span class="mi">4</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
<span class="c1">// 开始 merge 👇
</span><span class="c1"></span><span class="nx">m</span><span class="p">(</span> <span class="nx">m</span><span class="p">(</span> <span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">m</span><span class="p">([</span><span class="mi">6</span><span class="p">],[])</span> <span class="p">)</span> <span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">m</span><span class="p">([</span><span class="mi">7</span><span class="p">],[])</span> <span class="p">)</span> <span class="p">)</span>  <span class="p">...</span>  <span class="p">)</span> <span class="p">)</span> 
<span class="nx">m</span><span class="p">(</span> <span class="nx">m</span><span class="p">(</span> <span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nx">concat</span><span class="p">([</span><span class="mi">6</span><span class="p">]),</span> <span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nx">concat</span><span class="p">([</span><span class="mi">7</span><span class="p">])</span> <span class="p">)</span> <span class="p">,</span> <span class="nx">m</span><span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">([</span><span class="mi">5</span><span class="p">]),</span> <span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="nx">concat</span><span class="p">([</span><span class="mi">8</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
<span class="nx">m</span><span class="p">(</span> <span class="nx">m</span><span class="p">(</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="p">),</span> <span class="nx">m</span><span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="nx">m</span><span class="p">(</span> <span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">m</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="p">)</span> <span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">m</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
<span class="nx">m</span><span class="p">(</span> <span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">m</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]))</span> <span class="p">)</span> <span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">m</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">]))</span> <span class="p">)</span> <span class="p">)</span>
<span class="nx">m</span><span class="p">(</span> <span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nx">concat</span><span class="p">([</span><span class="mi">6</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">m</span><span class="p">([],</span> <span class="p">[</span><span class="mi">7</span><span class="p">])))</span> <span class="p">),[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">m</span><span class="p">([],</span> <span class="p">[</span><span class="mi">8</span><span class="p">]))</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
  <span class="p">...</span>
  <span class="nx">m</span><span class="p">(</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<p></p>
<p>​</p>
<h3 id="思路一句话-1">思路一句话</h3>
<blockquote>
<p>每次都分两部分，默认是排好序的，如果没有排好序就先排序。然后对排好序的两个数组，进行合并</p>
</blockquote>
<ul>
<li>
<p>怎么把无序的数组排好序？</p>
<p>很简单，（变相理解）不断拆分数组，直到每个数组中只有一个元素，这样每个数组都是排好序的</p>
</li>
<li>
<p>然后两个一组，开始进行合并</p>
</li>
</ul>
<p>​</p>
<blockquote>
<p>归并的思路确实很抽象，是上述三种算法种最难理解的（很哲学）</p>
<p>如果实在无法理解归并排序，那就学到快速排序就不要再学了</p>
</blockquote>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="总结-2">总结</h2>
<h3 id="目前理清了三种排序">目前理清了三种排序</h3>
<ul>
<li>选择排序（递归、循环）
<ul>
<li>每次选择最小的，放在最前面。选到最后没得选了，就排完了</li>
</ul>
</li>
<li>快速排序（递归）
<ul>
<li>以某个元素为基准，小的往前放，大的往后放</li>
</ul>
</li>
<li>归并排序（递归）
<ul>
<li>每次都分两部分，默认是排好序的，如果没有排好序就先排序。然后对排好序的两个数组，进行合并</li>
<li>是上述三种算法种最难理解的（很哲学）</li>
</ul>
</li>
</ul>
<p>​</p>
<h3 id="接下来">接下来</h3>
<ul>
<li>**计数排序 **（循环）
<ul>
<li>比上面的排序算法都要**快 **</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="计数排序-counting-sort-">计数排序 counting sort ⭕️</h2>
<blockquote>
<p>特性：速度非常快</p>
</blockquote>
<blockquote>
<p>注：本节如果提到哈希，实际说的是哈希表（因为我们并没有接触过哈希函数 … ）</p>
</blockquote>
<h3 id="思路">思路</h3>
<ul>
<li>用一个新的<strong>数据结构</strong> —— <strong>哈希表</strong>，来作记录
<ul>
<li>哈希表：一种 key: value 的形式。</li>
<li>JS 的对象可以算是哈希表的一种形式，但不是纯粹的哈希表。</li>
<li>因为 JS 对象具有隐藏属性、函数，而真正的哈希表里没有隐藏属性，只有数据。
所以 JS 对象不能算是一个完全的哈希表</li>
</ul>
</li>
<li>发现数字 N 就记 N：1，如果再次发现 N 就加 1</li>
<li>最后把哈希表的 key 全部打出来，假设 N：m，那么 N 需要打印 m 次</li>
<li>画图演示</li>
</ul>
<p>​</p>
<h4 id="扑克牌">扑克牌</h4>
<ul>
<li>
<p>「一副扑克牌，（不算大小王）共 52 张，乱序 」</p>
</li>
<li>
<p>怎么对这副扑克牌排序 ，实现 【 AAAA , 2222 , 3333 , 4444 , … , JJJJ , QQQQ , KKKK 】 的排序结果 ？？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nx">K</span><span class="p">,</span><span class="nx">K</span><span class="p">,</span><span class="nx">J</span><span class="p">,</span><span class="nx">J</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="p">......</span> <span class="p">]</span>  <span class="c1">// 52张牌乱序
</span><span class="c1"></span> <span class="c1">// 👇 哈希表：每碰到一个数，就对应位置记上一笔。（类似计数器）
</span><span class="c1"></span> <span class="p">{</span>
     <span class="nx">A</span><span class="err">：</span><span class="mi">0</span>
     <span class="mi">2</span><span class="err">：</span><span class="mi">0</span>
     <span class="mi">3</span><span class="err">：</span><span class="mi">0</span>  
     <span class="nx">J</span><span class="err">：</span><span class="mi">0</span> 
     <span class="nx">Q</span><span class="err">：</span><span class="mi">0</span>	 
     <span class="nx">K</span><span class="err">：</span><span class="mi">0</span>
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>人类天生就会排序，只不过可能不会用代码表示出来</p>
</li>
</ul>
<p>​</p>
<h3 id="示例分析">示例分析</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js">	 <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">=&gt;</span> <span class="nx">发现数字</span> <span class="nx">N</span> <span class="nx">就记</span> <span class="nx">N</span><span class="err">：</span><span class="mi">1</span><span class="err">，</span><span class="nx">再次发现</span> <span class="nx">N</span> <span class="nx">就加</span> <span class="mi">1</span><span class="err">。</span> 
   <span class="nx">同时记录最大值</span> <span class="nx">max</span><span class="err">：</span><span class="nx">假设第一个元素就是最大值</span><span class="err">，</span><span class="nx">max</span> <span class="o">=</span> <span class="mi">0</span><span class="err">。</span><span class="nx">遇到3</span> <span class="o">&lt;</span><span class="mi">12</span><span class="err">，</span><span class="nx">max不变</span><span class="err">；</span><span class="mi">9</span><span class="o">&lt;</span><span class="mi">12</span><span class="err">，</span><span class="nx">max不变</span> <span class="p">...</span>
	 <span class="nx">后面的数都比</span> <span class="mi">12</span> <span class="nx">小</span><span class="err">，</span><span class="nx">所以</span> <span class="nx">max</span> <span class="nx">就是</span> <span class="mi">12</span>
<span class="p">=&gt;</span> <span class="p">{</span>
     <span class="mi">12</span><span class="o">:</span><span class="mi">1</span>  <span class="p">(</span><span class="nx">max</span><span class="p">)</span>
     <span class="mi">3</span><span class="o">:</span><span class="mi">1</span>
     <span class="mi">9</span><span class="o">:</span><span class="mi">1</span>
     <span class="mi">4</span><span class="o">:</span><span class="mi">1</span>
     <span class="mi">2</span><span class="o">:</span><span class="mi">1</span>
     <span class="mi">8</span><span class="o">:</span><span class="mi">1</span>
     <span class="mi">5</span><span class="o">:</span><span class="mi">1</span>
     <span class="mi">7</span><span class="o">:</span><span class="mi">1</span>
   <span class="p">}</span>
   <span class="nx">现在完成两件事</span><span class="err">：</span>
   <span class="mi">1</span><span class="err">、</span><span class="nx">x最大值为12</span>
   <span class="mi">2</span><span class="err">、</span><span class="nx">所有数据次数记录完毕</span><span class="err">。</span>
   <span class="nx">接下来</span><span class="err">，</span><span class="nx">开始循环</span>
   
<span class="p">=&gt;</span> <span class="nx">设定</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">~</span> <span class="mi">12</span><span class="p">(</span><span class="nx">max</span><span class="p">)</span><span class="err">，</span><span class="nx">如果发现哈希表里存在</span> <span class="nx">i</span> <span class="nx">值</span><span class="err">，</span><span class="nx">就把</span> <span class="nx">i</span> <span class="nx">值打印到一个数组里面</span>
   <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">哈希表中没有</span> <span class="mi">0</span> <span class="p">=&gt;</span> <span class="p">[]</span>
   <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">哈希表中没有</span> <span class="mi">1</span> <span class="p">=&gt;</span> <span class="p">[]</span>
   <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">哈希表中有</span> <span class="mi">2</span>  <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">]</span>
   <span class="nx">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">哈希表中有</span> <span class="mi">3</span>  <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="p">]</span>
       <span class="mi">4</span>               <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span> <span class="p">]</span>
       <span class="mi">5</span>               <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="p">]</span>
       <span class="mi">6</span>               <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="p">]</span>
       <span class="mi">7</span>               <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="p">]</span>
       <span class="mi">8</span>               <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span> <span class="p">]</span>
       <span class="mi">9</span>               <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span> <span class="p">]</span>
       <span class="mi">10</span>              <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span> <span class="p">]</span>
       <span class="mi">11</span>              <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span> <span class="p">]</span>
       <span class="mi">12</span>              <span class="p">=&gt;</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span> <span class="p">]</span>   <span class="c1">// 👈 排序完成
</span><span class="c1"></span>
  <span class="c1">// 当 i 从 0 ~ 12 走完，排好序的数组也就得出了
</span><span class="c1"></span>  <span class="c1">// 需要两个条件姐就可以实现排序：哈希表、最大值max
</span></code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="初步代码">初步代码</h3>
<blockquote>
<p>补充： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in" target="_blank" rel="noopener noreffer">in 操作符用法</a></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">countSort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">hashTable</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>  <span class="c1">// 遍历数组，得到【哈希表】和【max】
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="k">in</span> <span class="nx">hashTable</span><span class="p">)){</span> <span class="c1">// 发现数字 N 就记 N：1，再次发现 N 就加 1
</span><span class="c1"></span>      <span class="nx">hashTable</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
      <span class="nx">hashTable</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// max：谁比我大，我就等于谁
</span><span class="c1"></span>      <span class="nx">max</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> 
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">max</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>  <span class="c1">// 遍历哈希表
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nx">j</span> <span class="k">in</span> <span class="nx">hashTable</span><span class="p">){</span>
      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span>   <span class="c1">// 如果发现这个值在hash表中，就push到数组
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><blockquote>
<h4 id="上述代码有bug">上述代码有bug</h4>
<ul>
<li>遍历哈希表时，没有考虑「一个值在 hash 表中出现多个」的情况</li>
</ul>
</blockquote>
<h4 id="举例验证-bug">举例验证 bug</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="c1">// 得到 hash表 👇
</span><span class="c1"></span><span class="p">{</span>
  <span class="mi">4</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">2</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="mi">5</span><span class="o">:</span> <span class="mi">1</span>  
<span class="p">}</span>
<span class="c1">// 遍历哈希表
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">max</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>  
  <span class="k">if</span><span class="p">(</span><span class="nx">j</span> <span class="k">in</span> <span class="nx">hashTable</span><span class="p">){</span>  <span class="c1">//  如果发现 j 在 hash表 中，就 push 到数组
</span><span class="c1"></span>    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span>   
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// j 取 0~5 （如果发现 j 在hash表中，就把 j 添加到数组）
</span><span class="c1">// j=0  =&gt;  []
</span><span class="c1">// j=1  =&gt;  []
</span><span class="c1">// j=2  =&gt;  [2, ]
</span><span class="c1">// j=3  =&gt;  [2, ]
</span><span class="c1">// j=4  =&gt;  [2,4, ]
</span><span class="c1">// j=5  =&gt;  [2,4,5 ]    遍历完成，结果数组中少了两个元素 2
</span></code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="完整代码-">完整代码 ✅</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">countSort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">hashTable</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="k">in</span> <span class="nx">hashTable</span><span class="p">){</span>
      <span class="nx">hashTable</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span> 
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
      <span class="nx">hashTable</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">max</span><span class="p">){</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">max</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">j</span> <span class="k">in</span> <span class="nx">hashTable</span><span class="p">){</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">hashTable</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>  
        <span class="c1">// 假设 j 出现了 3 次，就需循环 3 次(添加 j)的操作。
</span><span class="c1"></span>        <span class="c1">// i 可以取几个值，循环就执行几次，所以 i 应该取 3 个值 （从0开始就取 i = 0，1，2）
</span><span class="c1"></span>        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span>
      <span class="p">}</span>  
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<h3 id="思路总结-">思路总结 ✅</h3>
<ul>
<li>遍历数组，得到一个 hashTable（记录出现过的元素 key，以及出现次数 value）。</li>
<li>同时，在这次遍历数组的过程中，找到数组最大值
（开局假设第一个元素就是最大值max，依次比较，大于 max 的元素，就重新赋值给 max）</li>
<li>此时，已知 hashTable 和 max。</li>
<li>已知最大值 max，所以全部元素的取值都在 0 ~ max 这个范围之间</li>
<li>遍历 0 ~ max 这个范围之间的所有元素，如果与哈希表的 key 一致，就之间把这个元素 push 到数组中
<ul>
<li>如果当前 key(元素) 的 value(出现次数) 不是 1，说明原数组中有 N 个该元素，那就需要把 N 个该元素都在此时 push 到数组中。所以 push 操作需要循环执行 N 次</li>
<li>获取这个 value 次数，作为 for 循环执行次数 i 的依据，来控制 push 的执行轮次</li>
</ul>
</li>
</ul>
<p>​</p>
<h3 id="计数排序的特点-">计数排序的特点 ✅</h3>
<h4 id="数据结构不同">数据结构不同</h4>
<ul>
<li>
<p>使用了额外的 hashTable （数据结构）</p>
<ul>
<li>计数排序中使用的数据结构升级了</li>
<li>算法也就直接升级了，非常快</li>
</ul>
</li>
<li>
<p>只遍历数组一遍（不过还要遍历一次 hashTable ）</p>
<ul>
<li>之前的排序算法，都会多次遍历数组</li>
<li>选择排序：找第一个最小值，需遍历一遍数组。找第二个最小值，需再把余下元素遍历 …（重复遍历）</li>
</ul>
</li>
<li>
<p>为什么计数排序，可以这么厉害，就遍历一遍数组呢？</p>
<p>答：就是因为有 hashTable，这叫做「用空间换时间」</p>
<ul>
<li>hashTable 就是存储在内存中的一块空间。</li>
<li>用多余的空间就可以节省多余的时间。</li>
<li>通常空间、时间只能二选一：「用空间换时间」或「用时间换空间」
（除非你智商碾压，二者都能实现）</li>
</ul>
</li>
</ul>
<p>​</p>
<h4 id="时间复杂度对比">时间复杂度对比</h4>
<ul>
<li>选择排序 O(n^2）</li>
<li>快速排序 O(n log2n)</li>
<li>归并排序 O(n log2n)</li>
<li>计数排序 O(n + max)
<ul>
<li>时间最少、速度最快，但空间占的多</li>
<li>先遍历一个长度为 n 的数组，再遍历一个长度为 max 的数组</li>
</ul>
</li>
</ul>
<blockquote>
<p>时间复杂度，到底是怎么计算出来的呢？</p>
<ul>
<li>其实有特别简单的方法，几乎不需要太复杂的数学知识  👇 [详见下](# 时间复杂度)</li>
</ul>
</blockquote>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="题外话字母出现次数">题外话：字母出现次数</h3>
<p>前面讲过案例「如何统计一段文字中字母出现的次数，并打印结果」
其实就是借鉴了【计数排序】的思维</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">str</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kd">let</span> <span class="nx">newStr</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^a-zA-Z]/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>   <span class="c1">// `HiImSam`
</span><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newStr</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">newStr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">newStr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="k">in</span> <span class="nx">result</span><span class="p">){</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">newStr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">newStr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="sb">`Hi, I&#39;m Sam`</span>
<span class="kd">let</span> <span class="nx">newStr</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/a-zA-Z/g</span><span class="p">)</span>
<span class="nx">count</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
<span class="o">--------------------------------------------------</span>
<span class="p">{</span>
  <span class="nx">H</span><span class="o">:</span> <span class="mi">1</span>
  <span class="nx">I</span><span class="o">:</span> <span class="mi">1</span>
  <span class="nx">S</span><span class="o">:</span> <span class="mi">1</span>
  <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span>
  <span class="nx">i</span><span class="o">:</span> <span class="mi">1</span>
  <span class="nx">m</span><span class="o">:</span> <span class="mi">2</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="补充正则">补充正则</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">提取数字</span><span class="p">....</span><span class="nx">value</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^\d]/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="nx">提取中文</span><span class="p">....</span><span class="nx">value</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^\u4E00-\u9FA5]/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="nx">提取英文</span><span class="p">....</span><span class="nx">value</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^a-zA-Z]/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="sb">`Hi, I&#39;m Sam`</span>
<span class="kd">let</span> <span class="nx">newStr</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/[a-zA-Z]/g</span><span class="p">)</span>  <span class="c1">//  [&#34;H&#34;, &#34;i&#34;, &#34;I&#34;, &#34;m&#34;, &#34;S&#34;, &#34;a&#34;, &#34;m&#34;]
</span><span class="c1">// match 返回数组
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">newStr</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^a-zA-Z]/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>  <span class="c1">// `HiImSam` （把字符串中所有非字母字符，替换为空）
</span><span class="c1">// replace 返回字符串 （替换思想）
</span></code></pre></td></tr></table>
</div>
</div><p>​</p>
<p>​</p>
<p>​</p>
<h2 id="时间复杂度">时间复杂度</h2>
<blockquote>
<p>其实就是举一个比较大的数组，看一下当前算法的规模</p>
</blockquote>
<h3 id="以选择排序为例">以「选择排序」为例</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 假设数组长度为 1000 （且处于最坏情况，每次都需要对比，没有任何一次是不需要对比的）
</span><span class="c1"></span><span class="nx">第1次遍历</span><span class="err">，</span><span class="nx">要从</span> <span class="p">[</span><span class="mi">0</span><span class="p">,...,</span><span class="mi">999</span><span class="p">]</span> <span class="nx">找到最小值</span> <span class="nx">min1</span><span class="err">（</span><span class="nx">放到首位</span><span class="err">），</span><span class="nx">需要对比999次</span>
<span class="nx">第2次遍历</span><span class="err">，</span><span class="nx">要从</span> <span class="p">[</span><span class="mi">1</span><span class="p">,...,</span><span class="mi">999</span><span class="p">]</span> <span class="nx">找到最小值</span> <span class="nx">min2</span><span class="err">（</span><span class="nx">放到首位</span><span class="err">），</span><span class="nx">需要对比998次</span>
<span class="nx">第3次遍历</span><span class="err">，</span><span class="nx">要从</span> <span class="p">[</span><span class="mi">2</span><span class="p">,...,</span><span class="mi">999</span><span class="p">]</span> <span class="nx">找到最小值</span> <span class="nx">min3</span><span class="err">（</span><span class="nx">放到首位</span><span class="err">），</span><span class="nx">需要对比997次</span>
<span class="p">...</span>
<span class="nx">第999次遍历</span><span class="err">，</span><span class="nx">要从</span> <span class="p">[</span><span class="mi">998</span><span class="p">,</span><span class="mi">999</span><span class="p">]</span> <span class="nx">找到最小值</span> <span class="nx">min999</span><span class="err">（</span><span class="nx">放到首位</span><span class="err">），</span><span class="nx">需要对比1次</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>长度为 1000 的数组，最坏情况下（每次都需要对比）  1+2+3+4+…+998+999</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js">   <span class="p">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="err">…</span> <span class="o">+</span> <span class="mi">998</span> <span class="o">+</span> <span class="mi">999</span>
   <span class="p">=&gt;</span> <span class="mi">1</span><span class="err">≈</span><span class="mi">1000</span> <span class="o">+</span> <span class="mi">2</span><span class="err">≈</span><span class="mi">1000</span> <span class="o">+</span> <span class="mi">3</span><span class="err">≈</span><span class="mi">1000</span> <span class="o">+</span> <span class="mi">4</span><span class="err">≈</span><span class="mi">1000</span> <span class="o">+</span> <span class="p">...</span> <span class="o">+</span> <span class="mi">555</span><span class="err">≈</span><span class="mi">1000</span> <span class="o">+</span> <span class="p">...</span> <span class="o">+</span> <span class="mi">998</span><span class="err">≈</span><span class="mi">1000</span> <span class="o">+</span> <span class="mi">999</span><span class="err">≈</span><span class="mi">1000</span>
   <span class="p">=&gt;</span> <span class="nx">大概1000个1000</span><span class="err">，</span><span class="nx">也就是</span> <span class="mi">1000</span><span class="o">^</span><span class="mi">2</span> 
   <span class="p">=&gt;</span> <span class="nx">n</span><span class="o">^</span><span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>综上：</p>
<ul>
<li>选择排序：每次找最小的</li>
<li>时间复杂度，是 n 的平方  （这是最坏情况）</li>
</ul>
</blockquote>
<p>​</p>
<h3 id="以快速排序为例">以「快速排序」为例</h3>
<blockquote>
<p>找一个基准数，然后左右分两队</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 假设数组长度为 1000
</span><span class="c1"></span>    <span class="p">[</span><span class="mi">0</span><span class="p">,...,</span><span class="mi">500</span><span class="p">,...,</span><span class="mi">999</span><span class="p">]</span>
            <span class="err">↑</span>
     <span class="err">↙</span>            <span class="err">↘</span>        <span class="c1">// 以500为基准，依次和 500 进行比较
</span><span class="c1"></span><span class="p">[</span><span class="mi">0</span><span class="p">,...,</span><span class="mi">500</span><span class="p">)</span> <span class="p">,</span> <span class="p">[</span><span class="mi">500</span><span class="p">,...,</span><span class="mi">999</span><span class="p">]</span> <span class="c1">// 左边全是比500小的，比较了 500 次。右边全是比500大的，比较了 500 次
</span><span class="c1"></span>
<span class="c1">// 然后 [0,...,500) 中再找一个基准数 250
</span><span class="c1"></span>       <span class="p">[</span><span class="mi">0</span><span class="p">,...,</span><span class="mi">250</span><span class="p">,...,</span><span class="mi">500</span><span class="p">)</span>
               <span class="err">↑</span>
            <span class="err">↙</span>   <span class="err">↘</span>
         <span class="mi">250</span>      <span class="mi">250</span>  <span class="c1">// 左边是比250小的，比较了250次。右边是比250大的，比较了250次，以此类推
</span><span class="c1"></span>
<span class="c1">// 得出图示 👇
</span><span class="c1"></span>       <span class="p">[</span><span class="mi">0</span><span class="p">,...,</span><span class="mi">250</span><span class="p">,...,</span><span class="mi">500</span><span class="p">)</span>      <span class="p">[</span><span class="mi">500</span><span class="p">,...,</span><span class="mi">999</span><span class="p">]</span>       <span class="o">|</span>    <span class="p">=&gt;</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">1000</span> <span class="nx">次</span>
               <span class="err">↑</span>                      <span class="err">↑</span>             <span class="o">|</span> 
            <span class="err">↙</span>   <span class="err">↘</span>                 <span class="err">↙</span>   <span class="err">↘</span>          <span class="o">|</span> 
         <span class="mi">250</span>      <span class="mi">250</span>            <span class="mi">250</span>     <span class="mi">250</span>        <span class="o">|</span>    <span class="p">=&gt;</span> <span class="mi">250</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">=</span> <span class="mi">1000</span> <span class="nx">次</span>
        <span class="err">↙</span> <span class="err">↘</span>     <span class="err">↙</span> <span class="err">↘</span>          <span class="err">↙</span> <span class="err">↘</span>    <span class="err">↙</span> <span class="err">↘</span>       <span class="o">|</span>
      <span class="mi">125</span>  <span class="mi">125</span>  <span class="mi">125</span>  <span class="mi">125</span>      <span class="mi">125</span>  <span class="mi">125</span>  <span class="mi">125</span>  <span class="mi">125</span>    <span class="o">|</span>    <span class="p">=&gt;</span> <span class="mi">125</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">=</span> <span class="mi">1000</span> <span class="nx">次</span>
             <span class="p">...</span>                      <span class="p">...</span>                        <span class="p">...</span>

<span class="cm">/* 
</span><span class="cm">	虽然每一排比较次数都是 1000 次，但是减少的速度特别快（每次折半） 
</span><span class="cm">	看 1000 能除以多少次 2，就知道这个树形图，能分裂出多少个 1000 次
</span><span class="cm">	1000 ≈ 1024 = 2^10，1000大概是2的10次方，所以最多除以10次。
</span><span class="cm">	如果把树形图比喻成塔，塔最高10层，每层1000次】
</span><span class="cm">*/</span>

	 <span class="nx">复杂度</span><span class="err">：</span>
<span class="p">=&gt;</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">10</span><span class="nx">层</span>   <span class="c1">// log(2)1000 ≈ 10层  (2^10=1024)
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="nx">N</span> <span class="o">*</span> <span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nx">N</span> 
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>【快速排序】的时间复杂度，是 N * log(2)N</p>
</blockquote>
<p>​</p>
<blockquote>
<p>基本上画出 4 步的图示，就能找到规律，无需花费更多精力来记忆</p>
</blockquote>
<p>​</p>
<p>​</p>
<h3 id="以归并排序为例">以「归并排序」为例</h3>
<blockquote>
<p>思路：每次对半分。对排好序的两个数组，进行合并</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 假设数组长度为 1000
</span><span class="c1"></span>            <span class="p">[</span><span class="mi">0</span><span class="p">,...,</span><span class="mi">999</span><span class="p">]</span>
              <span class="err">↙</span>    <span class="err">↘</span>    <span class="c1">// 拆分成左右两部分，各操作 1 次（共2次）
</span><span class="c1"></span><span class="nx">merge</span><span class="p">([</span><span class="mi">0</span><span class="p">,...,</span><span class="mi">500</span><span class="p">],</span> <span class="p">[</span><span class="mi">500</span><span class="p">,...,</span><span class="mi">999</span><span class="p">])</span>   <span class="c1">// merge合并：分别用左边500个数和右边500个数做对比（共1000次操作）
</span><span class="c1"></span>        <span class="err">↙</span> <span class="err">↘</span>            <span class="err">↙</span> <span class="err">↘</span>  <span class="c1">// 拆分成左右两部分，各操作 1 次（共4次）
</span><span class="c1"></span>      <span class="mi">250</span>    <span class="mi">250</span>      <span class="mi">250</span>    <span class="mi">250</span>   <span class="c1">// merge：拆分成两部分，每部分250个数，逐个对比（共1000次操作） 
</span><span class="c1"></span>     <span class="err">↙↘</span>    <span class="err">↙↘</span>      <span class="err">↙↘</span>    <span class="err">↙↘</span>
   <span class="mi">125</span> <span class="mi">125</span> <span class="mi">125</span> <span class="mi">125</span>  <span class="mi">125</span> <span class="mi">125</span> <span class="mi">125</span> <span class="mi">125</span>  <span class="c1">// merge：拆分，每部分125个数，逐个对比（共1000次操作）
</span><span class="c1"></span>                  <span class="p">...</span>
<span class="c1">// 拆分到，每个数组只有一个元素，就停止：[0]，[1]，[2]...[998]，[999]
</span><span class="c1">// 问题就转换为：1000个数对半拆分，需要多少次就能拆分成1个1个的。 2^10 = 1024
</span><span class="c1">// 所以拆分10次就会停止，得到每个数组只有一个元素
</span><span class="c1">// 所以，需要10次拆分，每次拆分需要执行1000次合并操作
</span><span class="c1"></span>                  
   <span class="nx">复杂度</span><span class="err">：</span>
<span class="p">=&gt;</span> <span class="mi">1000</span><span class="nx">次合并</span> <span class="o">*</span> <span class="mi">10</span><span class="nx">次拆分</span>   <span class="c1">// log(2)1000 ≈ 10次拆分   (2^10=1024)
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="mi">1000</span> <span class="o">*</span> <span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1000</span>
<span class="p">=&gt;</span> <span class="nx">N</span> <span class="o">*</span> <span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nx">N</span>                  
</code></pre></td></tr></table>
</div>
</div><p>例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js">   <span class="nx">merge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span> 
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>  
<span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>    <span class="c1">// 6个元素需要对比5次 / 1000个元素需要对比999次
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="nx">四舍五入就是</span> <span class="nx">n</span> <span class="nx">个元素需要对比</span> <span class="nx">n</span> <span class="nx">次</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<blockquote>
<p>「归并排序」的 时间复杂度：与快速排序一致  N * log(2)N</p>
</blockquote>
<p>​</p>
<p>​</p>
<h3 id="以计数排序为例">以「计数排序」为例</h3>
<blockquote>
<p>思路：每次对半分。对排好序的两个数组，进行合并</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 假设数组长度为 1000
</span><span class="c1"></span>   <span class="p">[</span><span class="mi">0</span><span class="p">,...,</span><span class="mi">999</span><span class="p">]</span>
<span class="p">=&gt;</span> <span class="nx">对数组进行一次遍历</span><span class="err">：</span><span class="nx">得出</span> <span class="nx">计数的</span><span class="err">【</span><span class="nx">哈希表</span><span class="err">】</span><span class="nx">hashTable</span> <span class="err">，</span><span class="nx">并找出最大值</span><span class="err">（</span><span class="nx">假设max是100</span><span class="err">）</span>  <span class="err">（</span><span class="mi">1000</span><span class="nx">次操作</span><span class="err">）</span>
<span class="p">=&gt;</span> <span class="nx">hashTable</span> <span class="nx">里就添加了1000个数据</span>
<span class="p">=&gt;</span> <span class="nx">遍历</span> <span class="nx">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">~</span> <span class="nx">max</span><span class="err">（</span><span class="mi">100</span><span class="err">），</span><span class="nx">对应哈希表</span><span class="err">，</span><span class="nx">发现相同值</span><span class="err">，</span><span class="nx">就push输出</span> <span class="err">（</span><span class="mi">100</span><span class="nx">次操作</span><span class="err">）</span>  
                  
   <span class="nx">复杂度</span><span class="err">：</span>
<span class="p">=&gt;</span> <span class="mi">1000</span> <span class="o">+</span> <span class="mi">100</span>  <span class="c1">// 元素在0~100之间
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="nx">max</span>   
<span class="c1">// 如果哈希表有最小值、最大值，如元素在50~100之间，则应该再减去min（只需比较 50 次）
</span><span class="c1"></span><span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="nx">max</span> <span class="o">-</span> <span class="nx">min</span> <span class="p">(</span><span class="nx">默认min是0</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>「计数排序」的 时间复杂度： n + max - min (默认min是0)</p>
</blockquote>
<p>​</p>
<blockquote>
<p>基本上画出 4 步的图示，就能找到规律，无需花费更多精力来记忆</p>
<p>不需要做特别精细的分析，只需要看衰减的规律即可</p>
</blockquote>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="算法学习总结">算法学习总结</h2>
<h3 id="心法">心法</h3>
<ul>
<li>战略上藐视敌人：思想上暗示自己算法是特别简单的东西</li>
<li>战术上重视敌人：在真正写代码时，要非常重视每一个细节  +1  -1    &lt;   &lt;=   … （细节难以确定时，写写画画逐步分析）</li>
</ul>
<h3 id="特点">特点</h3>
<ul>
<li>思路都很简单</li>
<li>细节都很多
<ul>
<li>不需要多强的智力，需要的是耐心、细心</li>
</ul>
</li>
<li>**多画表，多画图，多 log **</li>
<li>如果实在不想陷入 JS 的细节，可以用「伪代码」</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="还有哪些排序算法-">还有哪些排序算法 ⁉️</h2>
<p>冒泡排序 <a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a>   点击 BUB    （visualgo只提供伪代码思路参考）</p>
<p>插入排序 <a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a> 点击 INS</p>
<p>希尔排序 <a href="http://sorting.at/">http://sorting.at/</a>  自己选择 Shell Sort</p>
<p>基数排序 <a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a>  点击 RAD</p>
<p></p>
<p></p>
<h3 id="冒泡排序-bubble-sort">冒泡排序 bubble sort</h3>
<blockquote>
<p>最 low 的排序。<a href="https://zhuanlan.zhihu.com/p/45501356" target="_blank" rel="noopener noreffer">思路</a></p>
</blockquote>
<blockquote>
<p><a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a>    （查看图示 + 伪代码）</p>
</blockquote>
<p>两两对比，较大的往后接着对比。</p>
<p>每一轮找出一个最大值，冒泡到最后</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">bubbleSort</span> <span class="o">=</span> <span class="nx">arr</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>    <span class="c1">// i 代表轮次（两两比较）
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>  <span class="c1">// j 代表当前轮选中元素的下标
</span><span class="c1"></span>      <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]){</span>
        <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span>  <span class="c1">// 交换元素
</span><span class="c1"></span>      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>​</p>
<h3 id="插入排序-insertion-sort">插入排序 Insertion Sort</h3>
<blockquote>
<p>参考扑克牌思路，很好理解。  <a href="https://zhuanlan.zhihu.com/p/45638675" target="_blank" rel="noopener noreffer">思路</a></p>
</blockquote>
<blockquote>
<p>扑克牌思路：大部分人抓完牌，手上拿着的牌就已经都是排好序的。</p>
</blockquote>
<blockquote>
<p><a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a> 点击 INS   （查看图示 + 伪代码）</p>
</blockquote>
<p>拿起一张牌，依次和前面的牌对比（所以起始值从下标为 1 的元素开始，才能保证前面有值可对比）</p>
<p>比前面的小，就插入到前面去</p>
<p></p>
<h4 id="思路-1">思路</h4>
<ul>
<li>**从第一个元素开始，该元素可以认为已经被排序 **</li>
<li>取出下一个元素，**在已经排序的元素序列中从后向前扫描 **</li>
<li>把取出的元素放到已排序的元素中间的合适位置</li>
<li>重复步骤2~3</li>
</ul>
<p>就像排队一样，依次每次挑一个同学，把该同学“插入”到已经排好的部分队伍里。</p>
<p>​</p>
<h4 id="代码-1">代码</h4>
<ul>
<li>开局默认第一个元素（前面元素）是已经排好序的。</li>
<li>取出下一个待排序元素，与前面已排好序的元素进行比较</li>
<li>如果后面的元素小于前面已排好序的某个元素，就把后面元素插入到前面已排好序的元素的**相应位置 **</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 插入法JS版
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 开局默认下标0的元素已排序，所以待排序数组的下标取值从1开始
</span><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// i 表示当前待排序数组元素的下标
</span><span class="c1"></span>    <span class="c1">// j 表示当前已排序数组元素的下标（默认下标0的元素已排序,所以 j 初始值一定为0）
</span><span class="c1"></span>    <span class="c1">// 已排序元素始终在待排序元素的前面，所以 j 的取值一定小于 i
</span><span class="c1"></span>    <span class="c1">// 综上 j = [0,i)
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> 
      <span class="c1">// 当前取出的待排序元素arr[i]，依次和前面已排序元素进行比较
</span><span class="c1"></span>      <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>  
        <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>  <span class="c1">// 在 arr[j] 前面插入 arr[i]，然后把原本的 arr[i] 删除
</span><span class="c1"></span>        <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 因为上一步已经在前面插入一个元素，导致后面元素下标后移一位，原本需要被删除 i 位置上的元素，现在的下标变成了 i+1
</span><span class="c1"></span>        <span class="k">break</span>  <span class="c1">// 跳出内层循环，i++
</span><span class="c1"></span>      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">28</span><span class="p">]</span>
<span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>插入法普通版 for</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">temp</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">-----------------------------------------------------</span>
<span class="kd">function</span> <span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">temp</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">-------------------------------------------------------</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">28</span><span class="p">]</span>
<span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>插入法普通版 while</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">temp</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
      <span class="nx">j</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">28</span><span class="p">]</span>
<span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="希尔排序-shell-sort">希尔排序 Shell Sort</h3>
<blockquote>
<p>极其少见</p>
<p>算法应该是比较复杂的，是生想出来的。现实生活中没有可参考的例子、数学中也没有例子</p>
</blockquote>
<blockquote>
<p>1959年，一个叫 Shell 的人发明的</p>
</blockquote>
<p>貌似是间隔着排，先大间隔、然后中间间隔 …  可能会节省一些中间的步骤</p>
<p>​</p>
<h3 id="基数排序-radix-sort">基数排序 Radix Sort</h3>
<blockquote>
<p>特别适合用于**多位数排序 **</p>
<ul>
<li>指未排序数组中的元素，有一位数得、也有两位数、三位数、四位数、五位数的 … （形式多样的数组）</li>
</ul>
</blockquote>
<blockquote>
<p>死记硬背，顺序非常重要，记错了就完了（但是可以理解这个算法的精神 👇 ）</p>
</blockquote>
<p></p>
<ul>
<li>先根据个位数排序，个位是 0 的从下往上叠在一起，个位是 1 的从下往上叠在一起 …
<ul>
<li>然后<strong>按照个位 0-9 堆叠的从下往上的顺序</strong>（这个顺序非常重要）展开所有元素，成一个数组</li>
</ul>
</li>
<li>对这个新数组，根据十位数进行排序，十位数 0-9 从下往上堆叠。
<ul>
<li>然后再按0-9从下往上的顺序展开成数组</li>
</ul>
</li>
<li>…</li>
<li>所有位数都重复上述操作</li>
<li>最后展开的数组，就是排完序的数组</li>
</ul>
<p></p>
<p>​</p>
<p>​</p>
<h3 id="堆排序-heap-sort">堆排序 Heap Sort</h3>
<ul>
<li>堆排序应该是排序的终点了，因为没有比堆排序更复杂的排序了</li>
<li>其他复杂的排序，基本都是在堆排序的基础上进行改进而已</li>
<li>搞定了堆排序，就搞定了**「树」**这个数据结构，就搞定了排序的最难的一部分</li>
</ul>]]></description>
</item><item>
    <title>算法入门</title>
    <link>http://samrks.github.io/algorithm-introduction/</link>
    <pubDate>Sun, 11 Oct 2020 00:36:27 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://samrks.github.io/algorithm-introduction/</guid>
    <description><![CDATA[<p>​</p>
<h2 id="前言">前言</h2>
<blockquote>
<p>前面学习的伪代码和流程图，是用来帮助我们思考的</p>
</blockquote>
<blockquote>
<p>本节是特别简单的算法入门。
—— 对于没学过算法的人可能觉得算法有点难，但当你学完后再来回顾，也许就会有上述的同感了</p>
</blockquote>
<blockquote>
<p>算法比你想象中简单</p>
<p>「什么是算法」「算法需要满足什么条件」…  等理论，这里就不讲了 
直接开始写代码 —— 代码可以是 JS 也可以不是，主要是靠大脑在思考</p>
</blockquote>
<p>​</p>
<p>​</p>
<h2 id="小试牛刀找-2-个数中的较小值-minof2">⭕️小试牛刀：找 2 个数中的较小值 minOf2</h2>
<blockquote>
<p>首先应该想：如何表示两个数</p>
<ul>
<li>二元组？！ 可以的</li>
<li>但 JS 中没有二元组，退而求其次，可以使用【长度为 2 的数组】来表示这两个数
如果能想到这一点，就说明已经知道【什么是数据结构】了 👆</li>
<li>约定用 [a,b] 表示这两个数</li>
</ul>
</blockquote>
<blockquote>
<p>必备知识 👇</p>
</blockquote>
<h3 id="数据结构">数据结构</h3>
<ul>
<li>用数组 [a,b] 表示两个数字</li>
<li>你能想到这一点，就说明你在使用数据结构</li>
</ul>
<h3 id="编程知识">编程知识</h3>
<ul>
<li>问号冒号表达式 <code>?   :</code>     或  if … else …</li>
</ul>
<blockquote>
<p>怎么从 [a,b] 中找出较小的呢（逻辑）</p>
<ul>
<li>a &lt; b 成立，就返回 a。否则返回 b  （比较大小，并返回较小值）</li>
</ul>
</blockquote>
<h3 id="代码">代码</h3>
<blockquote>
<p><a href="" rel="">minOf2 的实现</a></p>
</blockquote>
<ul>
<li>numbers 是数组。
判断中直接获取 numbers[0] 、 numbers[1]  相当于约定数组长度只能为 2</li>
<li>虽然约定是长度为 2 的数组，但如果调用时传了长度为 1 的数组，怎么办 （暂时不考虑这种情况）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">minOf2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]){</span> 
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
  <span class="p">}</span><span class="k">else</span><span class="p">{</span> 
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="优化代码">优化代码</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">minOf2</span> <span class="o">=</span> <span class="nx">numbers</span> <span class="p">=&gt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="再优化代码">再优化代码</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">minOf2</span> <span class="o">=</span> <span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">&lt;</span> <span class="nx">b</span> <span class="o">?</span> <span class="nx">a</span> <span class="o">:</span> <span class="nx">b</span>     <span class="c1">// 最简洁写法
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>这种写法叫做**「析构赋值」**，之后的课程会反复使用（解构）</p>
</blockquote>
<h3 id="调用">调用</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">minOf2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>             <span class="c1">// 1   这是小白调用法
</span><span class="c1"></span><span class="nx">minOf2</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>  <span class="c1">// 1   这是高手调用法 【推荐使用】（不使用this所以赋空值null）
</span></code></pre></td></tr></table>
</div>
</div><p>​</p>
<blockquote>
<p>算法，就是把解决问题的思路，用代码表示出来，不论问题多么的简单（如两个数取最小）</p>
<p>什么是算法，就是用代码来解决问题</p>
<p>只不过编程界，有很多固定的问题，只有把这些固定问题都搞清楚，才可以说是会算法。只会一点是不够的</p>
</blockquote>
<p>​</p>
<h3 id="现成-api">现成 API</h3>
<h4 id="js内置了-mathmin">JS内置了 Math.min</h4>
<blockquote>
<p>Math.min 的核心，实际上就是上面我们写的 minOf2 的代码（比较大小，并返回较小值）</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="err">）</span> <span class="c1">// 1  小白调用法
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>    <span class="c1">// 高手调用法，不需要this，所以取null
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="c1">// 高手调用法，区别于call，apply方法的第二个参数是【数组】形式
</span></code></pre></td></tr></table>
</div>
</div><h4 id="关于-math">关于 Math</h4>
<ul>
<li>
<p>看起来 Math 像 Object 一样，都是首字母大写，难道 Math 也是构造函数 ？？</p>
</li>
<li>
<p>实际上 Math 只是一个（首字母大写的）**普通对象 **</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nb">Math</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> 
<span class="c1">// Math不是函数，不具有函数的共有属性。打开 Math 的原型，就是【根对象】
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>以前接触过的所有对象，都是首字母小写，甚至全局对象 window 都是首字母小写
<strong>JS 中只有 Math 是唯一一个首字母大写的对象  ⭕️</strong>⚡️🚩</p>
</li>
<li>
<p>这是唯一的特例：首字母大写是构造函数</p>
</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="举一反三找-3-个数中的最小值-minof3">⭕️举一反三：找 3 个数中的最小值 minOf3</h2>
<blockquote>
<p>思路：先求前两个数中的较小值，然后拿这个较小值和第三个数进行比较，再得出一个较小值，它就是三个数中的最小值</p>
</blockquote>
<h3 id="代码-1">代码</h3>
<blockquote>
<p><a href="" rel="">minOf3 的实现</a></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">minOf3</span> <span class="o">=</span> <span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">return</span> <span class="nx">minOf2</span><span class="p">([</span><span class="nx">minOf2</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">]),</span> <span class="nx">c</span><span class="p">])</span>   <span class="c1">// 先求 a、b 最小值
</span><span class="c1"></span><span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>或者</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">minOf3</span> <span class="o">=</span> <span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">return</span> <span class="nx">minOf2</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">minOf2</span><span class="p">([</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">])])</span>   <span class="c1">// 先求 b、c 的最小值  【推荐写法：形式上更好看😝】
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：</p>
<ul>
<li>minOf3  调用了两次 minOf2  ，这并不是「递归」</li>
<li>如果 minOf3 调用了 minOf3 ，这才是「递归」</li>
</ul>
<p>​</p>
<h2 id="逐步推理找-4-个数中的最小值-minof4">⭕️逐步推理：找 4 个数中的最小值 minOf4</h2>
<blockquote>
<p><a href="" rel="">minOf4 的实现</a></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">minOf4</span> <span class="o">=</span> <span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">d</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">return</span> <span class="nx">minOf2</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">minOf3</span><span class="p">([</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">,</span><span class="nx">d</span><span class="p">])])</span>  <span class="c1">// 用 minOf2 求 a 和 后面三个数中的最小值
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>得出推论：任意长度数组 求最小值，都可以基于 minOf2 并最终实现</p>
</blockquote>
<blockquote>
<p>提问：可否把「求最小值」写作一个函数 min 呢 👇</p>
</blockquote>
<p>​</p>
<h2 id="推广求任意长度数组の最小值-min">⭕️推广：求任意长度数组の最小值 min</h2>
<blockquote>
<p><a href="" rel="">min 的实现</a></p>
</blockquote>
<h3 id="细品">细品</h3>
<blockquote>
<p>把 minOf? 全部用 min 替换</p>
</blockquote>
<blockquote>
<p>思路：先依次求后面所有元素的最小值 … 最后和第一位元素进行比较，最终得出所有元素的最小值
（不断<strong>拆分</strong>第1个元素和后面所有元素）</p>
</blockquote>
<p>代码👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">return</span> <span class="nx">min</span><span class="p">(</span>
    <span class="p">[</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">min</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span>   <span class="c1">// 截取数组中下标为1及1之后的所有元素，组成新数组（也就是去掉数组中下标为0的元素）
</span><span class="c1"></span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个代码会死循环不停调用自己，直到报错为止，所有需要添加一个中止条件</p>
<p></p>
<h3 id="完整代码添加中止条件">完整代码：添加中止条件</h3>
<blockquote>
<p>跳出递归的条件：当 numbers 中只有两个元素时，不再拆分，直接判断两个元素大小，返回较小值</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>  <span class="c1">// 停止条件
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">min</span><span class="p">(</span> 
      <span class="p">[</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">min</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span>  <span class="c1">// 递归（拆分出第1个元素和后面所有元素）
</span><span class="c1"></span>    <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span> 
    <span class="c1">// return numbers[0] &lt; numbers[1] ? numbers[0] : numbers[1]  // 👈👇两种写法均可
</span><span class="c1"></span>    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">numbers</span><span class="p">)</span> <span class="c1">// 必须用 apply。
</span><span class="c1"></span>    <span class="c1">// 因为min方法接收的参数必须是一个一个的数字，不接受数组，如果用call就是把整个数组传给min。所以必须用 apply 会把数组给展开成一个一个的数字
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">min</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>   <span class="c1">// 代入法：获取这个数组[2,4,3,1]中的最小值
</span></code></pre></td></tr></table>
</div>
</div><p></p>
<p>这就是[递归](# 递归) 👆</p>
<h2 id="递归">递归</h2>
<blockquote>
<p>先递进，再回归</p>
</blockquote>
<blockquote>
<p>一定要用<strong>代入法</strong>来理解，只靠看是看不懂的，眼睛只会欺骗你、</p>
</blockquote>
<h3 id="特点">特点</h3>
<ul>
<li>函数不停调用自己，每次调用的参数略有不同</li>
<li>当满足某个简单条件时，则实现一个简单的调用（获取到一个基本值）</li>
<li>然后将基本值层层代入、回归</li>
<li>算出最终结果</li>
</ul>
<h3 id="理解">理解</h3>
<ol>
<li>
<p>可以用 <strong>代入法</strong> 快速理解递归</p>
<ul>
<li>层层剖开</li>
</ul>
<p></p>
</li>
<li>
<p>可以用 **调用栈 **快速理解递归</p>
<ul>
<li>
<p>什么时候 <strong>压栈、弹栈</strong></p>
</li>
<li>
<p>每次进入下一行代码，就是压栈；开始回归后，就是弹栈</p>
<p></p>
</li>
</ul>
</li>
</ol>
<p>​</p>
<p>​</p>
<hr>
<hr>
<p>​</p>
<p>​</p>
<h2 id="排序算法">排序算法</h2>
<blockquote>
<p>将一个正整数数组，从小到大排序</p>
</blockquote>
<blockquote>
<p>思路：递归思路、循环思路</p>
</blockquote>
<h3 id="用递归实现">用递归实现</h3>
<ul>
<li>代码简单，但不易理解。推荐使用<strong>代入法</strong>，层层剖开理解</li>
</ul>
<h3 id="用循环实现">用循环实现</h3>
<ul>
<li>代码多，但易于理解</li>
</ul>
<p>​</p>
<h2 id="选择排序">选择排序</h2>
<blockquote>
<p>思路：每次选择最小的放到前面，对后面的进行排序（递归）</p>
</blockquote>
<h2 id="长度为-2-的数组排序-sort2">🔴长度为 2 的数组排序 sort2</h2>
<h3 id="代码-2">代码</h3>
<blockquote>
<p>析构赋值</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort2</span> <span class="o">=</span> <span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">if</span><span class="p">(</span><span class="nx">a</span> <span class="o">&lt;</span> <span class="nx">b</span><span class="p">){</span> 
    <span class="k">return</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">]</span>   
    <span class="c1">// 注意：return的数组[a,b]是新数组，与原数组[a,b]是不同的内存空间。新数组只是复制了原数组ab的值
</span><span class="c1"></span>  <span class="p">}</span><span class="k">else</span><span class="p">{</span> 
    <span class="k">return</span> <span class="p">[</span><span class="nx">b</span><span class="p">,</span><span class="nx">a</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>内存图原理——复制
<ul>
<li>变量是对象，就是把对象存的地址复制</li>
<li>变量是普通值，就是把值复制</li>
</ul>
</li>
</ul>
<h3 id="优化代码-1">优化代码</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort2</span> <span class="o">=</span> <span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">&lt;</span> <span class="nx">b</span> <span class="o">?</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">]</span> <span class="o">:</span> <span class="p">[</span><span class="nx">b</span><span class="p">,</span><span class="nx">a</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h2 id="长度为-3-的数组排序-sort3">🔴长度为 3 的数组排序 sort3</h2>
<h3 id="代码-3">代码</h3>
<blockquote>
<p>思路：</p>
<ul>
<li>先求三个数的最小值，作为返回数组的第一项</li>
<li>然后后面两个数字进行 sort2 操作（长度为 2 的数组排序）</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort3</span> <span class="o">=</span> <span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">return</span> <span class="p">[</span> <span class="nx">min</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">]),</span> <span class="nx">sort2</span><span class="p">([</span><span class="o">???</span><span class="p">])</span> <span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>但，**我们发现无法将最小值从数组里删掉 ** 来单独进行sort2其余两个数字的排序</p>
</blockquote>
<h3 id="改进代码">改进代码</h3>
<blockquote>
<p>思路：如果知道最小数字的下标，就可以把它从数组里删掉</p>
</blockquote>
<h4 id="补充splice-方法易错点">补充：splice 方法易错点</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">// 直接修改原数组 numbers，从中删除下标为 index 的元素
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">// splice的返回值rest是被删除的元素组成的新数组
</span><span class="c1">// 注意：上面两点经常被混淆，注意区别
</span></code></pre></td></tr></table>
</div>
</div><h4 id="代码-">代码 👇</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort3</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">].</span><span class="nx">concat</span><span class="p">(</span> 
    <span class="nx">sort2</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>  
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>上面代码可忽略，比较复杂 :）</p>
</blockquote>
<h4 id="优化-">优化 👇</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort3</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>  <span class="c1">// 假设有👇minIndex函数，与min相似，只不过返回的是最小值的下标
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>  <span class="c1">// 根据最小值下标index，获取到最小值本身min
</span><span class="c1"></span>  <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">// 从numbers数组的index处删掉1个数字，也就是从numbers中删掉最小值
</span><span class="c1"></span>  <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort2</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>  <span class="c1">// 返回一个从小到大排序后的数组
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>因为我们需要返回的结果是一个数组</li>
<li>而这个数组是需要两个部分拼接：最小值、sort2返回排序后的数组</li>
<li>JS 中使用 concat 可以实现两个数组的拼接（ruby语法中可用+直接相加两个数组）</li>
<li>所以把最小值放在一个数组中，这样就可以和 sort2 返回的数组，通过 concat 方法进行拼接</li>
</ul>
<p>（自己写写这段代码）</p>
<p>​</p>
<h3 id="获取最小值下标-minindex">获取最小值下标 minIndex</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span> <span class="nx">min</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>   <span class="c1">// 先用min获取最小值，再用indexOf获取数组中当前元素的下标
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>有小 bug：如果最小值有两个（相同值），indexOf 只会返回第一个值得下标（）</p>
</blockquote>
<blockquote>
<p>这是一个取巧的办法，以后会教更好的</p>
</blockquote>
<h3 id="完整代码">完整代码</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// min 函数：获取任意数组中最小值
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span> <span class="c1">// 停止条件
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">min</span><span class="p">(</span> 
      <span class="p">[</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">min</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span>    <span class="c1">// 递归
</span><span class="c1"></span>    <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span> 
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">numbers</span><span class="p">)</span> <span class="c1">// 必须用apply，call会传递整个数组。Math.min仅接收单个数字
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// minIndex 函数：获取任意数组中最小值的下标
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span> <span class="nx">min</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span> 
<span class="p">}</span>

<span class="c1">// sort3 函数：对长度为3的数组从小到大排序
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">sort3</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> 
  <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> 
  <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// numbers中仅保存最小值以外的两个元素，就可以使用sort2对numbers进行排序
</span><span class="c1"></span>  <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort2</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>  <span class="c1">// 返回一个从小到大排序后的数组
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="长度为-4-的数组排序-sort4">🔴长度为 4 的数组排序 sort4</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort4</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> 
  <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> 
  <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
  <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort3</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="推广任意长度的数组排序-sort">🔴推广：任意长度的数组排序 sort</h2>
<blockquote>
<p>递归</p>
</blockquote>
<blockquote>
<p>回顾：先获取最小值，然后从数组中排除最小值 … 进行大小比较 …</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
  <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>    <span class="c1">// 死循环
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="思路一">思路一</h3>
<blockquote>
<p>中止条件</p>
<ul>
<li><strong>当 numbers 中只有 2 个值时</strong></li>
<li>直接通过 三元运算符（问好冒号表达式）比较大小</li>
<li>并返回从小到大排序后的数组</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 用代入法看看 sort[12,5,8,7,9]
</span></code></pre></td></tr></table>
</div>
</div><p>代入法 👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js">  <span class="nx">sort</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="nx">sort</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="nx">sort</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="p">)</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="nx">sort</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="p">))</span>  <span class="c1">// 👇 sort([12,9]) 进入停止条件 👇 
</span><span class="c1"></span><span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="mi">12</span> <span class="o">&lt;</span> <span class="mi">9</span> <span class="o">?</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="o">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span> <span class="p">)))</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span> <span class="p">)))</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span> <span class="p">))</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span> <span class="p">)</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="思路二">思路二</h3>
<blockquote>
<p>开始「递进」，不断提取最小值。进入「回归」，将 每轮提取的最小值 进行逐个拼接</p>
</blockquote>
<blockquote>
<p>中止条件：不断提取最小值，<strong>直到 numbers 长度为 1</strong>，也就是只有一个元素时，直接返回 numbers</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">numbers</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>代入法 👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js">  <span class="nx">sort</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="nx">sort</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="nx">sort</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="p">)</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="nx">sort</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="p">))</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="nx">sort</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="p">)))</span>  <span class="c1">// sort[12] =&gt; [12]
</span><span class="c1"></span><span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="p">)))</span>  <span class="c1">// 递进中止，开始回归
</span><span class="c1"></span><span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span> <span class="p">))</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span> <span class="p">)</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
<span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<p>​</p>
<h2 id="代码调试">代码调试</h2>
<blockquote>
<p>如果代码报错，如何调试</p>
</blockquote>
<h3 id="举例splice易错点">举例：splice易错点</h3>
<blockquote>
<p>[splice易错点](# 补充：splice 方法易错点)</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">// splice的返回值与原数组，经常被搞混淆
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">rest</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<h3 id="consolelog-调试">console.log 调试</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">min</span><span class="p">(</span> 
      <span class="p">[</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">min</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span> 
    <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span> 
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">numbers</span><span class="p">)</span> 
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span> <span class="nx">min</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span> 
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`index: </span><span class="si">${</span><span class="nx">index</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>  <span class="c1">// console调试大法
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`min: </span><span class="si">${</span><span class="nx">min</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>   <span class="c1">// console调试大法
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`rest: </span><span class="si">${</span><span class="nx">rest</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>   <span class="c1">// console调试大法
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">rest</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<ul>
<li>打印结果，发现 rest 值有问题（正确的值应该是 <code>rest =&gt; [12,8,7,9]</code> ）</li>
<li>这时候就可以 mdn 查查 splice 写法是否正确（得知 splice 返回值为被删元素的数组，而非其余元素）</li>
<li>找到问题，得出正确写法：**无需获取返回值，numbers调用splice方法就会直接删除numbers中的指定元素 **</li>
<li>修改代码，如下 👇</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`min: </span><span class="si">${</span><span class="nx">min</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>   
    <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`numbers: </span><span class="si">${</span><span class="nx">numbers</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>   
    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<blockquote>
<p>总结：新人一定要不停的  log 调试，当你把所有可能的问题都发现了，就成长了</p>
</blockquote>
<h3 id="举例调用-min-报错">举例：调用 min 报错</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">min</span><span class="p">(</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">min</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span> <span class="nx">min</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span> <span class="c1">// 报错 Cannot access &#39;min&#39; before initialization
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">sort</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>原因：</p>
<ul>
<li><code>let index = numbers.indexOf( min(numbers) )</code> 目的是获取到最小值的坐标，需要先调用 min函数 获取最小值</li>
<li>但是因为当前作用域中定义了同名的 min</li>
<li>JS 优先认为 ①<code>min(numbers)</code> 中的 min 是 ②<code>let min = numbers[index]</code>  中的 min</li>
<li>而执行 代码① 时，代码②还未执行，所以报错：不能在 min 初始化前访问</li>
</ul>
<p>解决</p>
<ul>
<li>给 min 变量改名</li>
</ul>
<p>​</p>
<h2 id="完整代码-sort">完整代码 sort</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// min 函数：获取任意数组中最小值
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> 
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span> 
    <span class="k">return</span> <span class="nx">min</span><span class="p">(</span> 
      <span class="p">[</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">min</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span>   
    <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span> 
    <span class="c1">// return Math.min.apply(null, numbers) 
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// minIndex 函数：获取任意数组中最小值的下标
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span> <span class="nx">min</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span> 
<span class="p">}</span>

<span class="c1">// sort 函数：从小到大排序 ------------------------------------------------
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">min</span><span class="p">(</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">min</span><span class="p">(</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span> <span class="nx">min</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>    <span class="c1">// （省略了 minIndex 函数）
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">minNum</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">minNum</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span> <span class="o">:</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">sort</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<p>​</p>
<p>​</p>
<h2 id="总结">总结</h2>
<h4 id="求最小值">求最小值</h4>
<ul>
<li>2个数</li>
<li>3个数</li>
<li>N个数</li>
</ul>
<h4 id="排序">排序</h4>
<ul>
<li>2个数</li>
<li>3个数</li>
<li>N个数</li>
</ul>
<h4 id="用到的东西">用到的东西</h4>
<ul>
<li>本节只用到一个数据结构 —— 【数组】，提供了三个方法 slice（截取）、concat（连接）、splice（删除）</li>
<li>递归</li>
</ul>]]></description>
</item><item>
    <title>伪代码与流程图</title>
    <link>http://samrks.github.io/algorithm-pseudocode-flowchart/</link>
    <pubDate>Fri, 25 Sep 2020 15:31:35 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://samrks.github.io/algorithm-pseudocode-flowchart/</guid>
    <description><![CDATA[<p>​</p>
<h2 id="前言">前言</h2>
<blockquote>
<ul>
<li>正式学算法之前，有一个铺垫 ——「伪代码与流程图」</li>
<li>铺垫，看似不重要，实际上可能会影响非常深远
<ul>
<li>我们作为前端，一般学习的第一门编程语言是 Javascript</li>
<li>根据之前的学习，我们可以看到 JavaScript 这门语言有很多的问题</li>
<li>这些问题，都会导致学习者的思维上的一些缺陷</li>
<li>由于你学的第一门语言是一门有问题的语言，所以导致你的编程的一些基础知识是有缺陷的。</li>
<li>通过「伪代码和流程图」可以很好的弥补这些缺陷</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="js-语法不难难的是抽象概念">JS 语法不难，难的是抽象概念</h2>
<blockquote>
<p>有没有发现 JS 语法不难，难的是抽象概念</p>
</blockquote>
<blockquote>
<p>比如，你经常发现每句都懂，加在一起就不懂（就像学英语，每个单词都懂，拼成句子就懵了）</p>
</blockquote>
<h3 id="举个栗子">举个栗子</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">t</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span><span class="nx">delay</span><span class="p">){</span> 
  <span class="kd">let</span> <span class="nx">fn2</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span> 
    <span class="k">if</span><span class="p">(</span><span class="nx">fn2</span><span class="p">.</span><span class="nx">timer</span><span class="p">){</span><span class="k">return</span><span class="p">}</span> 
    <span class="nx">fn</span><span class="p">()</span> 
    <span class="nx">fn2</span><span class="p">.</span><span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> 
      <span class="nx">fn2</span><span class="p">.</span><span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span> 
    <span class="p">},</span> <span class="nx">delay</span><span class="p">)</span> 
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fn2</span> 
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">t</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;火球术&#39;</span><span class="p">)},</span> <span class="mi">5000</span><span class="p">)</span> 
<span class="c1">// 这个函数在做什么？（防抖节流 ?!）
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>看不懂，是因为对「抽象概念」不了解</p>
</blockquote>
<p>​</p>
<p>​</p>
<h2 id="抽象能力">抽象能力</h2>
<blockquote>
<p>越高级的程序员，抽象能力越强</p>
</blockquote>
<h3 id="编程语言也能抽象">编程语言也能抽象</h3>
<blockquote>
<p>懂得抽象后，JS、Python、Java、PHP 根本就没区别。
这就是高级程序员，能掌握多种语言的原因</p>
</blockquote>
<h4 id="这些语言都有这些共同点">这些语言都有👇这些共同点</h4>
<ul>
<li>声明</li>
<li>if..else&hellip;</li>
<li>while 循环、for 循环</li>
<li>函数</li>
<li>对象</li>
</ul>
<h4 id="这意味着">这意味着</h4>
<ul>
<li>你没有必要过分关注语言的细节</li>
<li>你应该首先理解这些语言的[不变之处](# 不变之处)</li>
<li>然后以不变应万变</li>
</ul>
<blockquote>
<p>对于肤浅的程序员，所有新知识都是全新的。
而对于理解抽象的程序员，所有新东西只是原本基础知识上的抽象组合而已</p>
</blockquote>
<p>​</p>
<p>​</p>
<h2 id="不变之处">不变之处</h2>
<blockquote>
<p>从第一位程序员诞生至今，有什么东西是不变的（也就是，所有程序员都认为这是有用的东西）</p>
</blockquote>
<ol>
<li>[对编程的热爱](# 一、对编程的热爱)</li>
<li>[逻辑](# 二、逻辑 ⭐️)</li>
<li>[数据结构](# 三、数据结构)</li>
</ol>
<p>（详见👇）</p>
<h2 id="一对编程的热爱">一、对编程的热爱</h2>
<blockquote>
<p>怎么会有人爱这么枯燥的玩意</p>
</blockquote>
<p>1</p>
<p>《Just For Fun》</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program.

大多数程序员愿意写代码，不是因为他们获得高额的薪水或者他人的赞誉，而是因为写代码很有意思。

—— Linus Torvalds （Linux之父、Git之父）
</code></pre></td></tr></table>
</div>
</div><p>2</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">I&#39;m not a great programmer;
I&#39;m just a good programmer with great habits.
我不是一个牛X的程序员；
我只是一个拥有牛X的习惯的还凑活的程序员。
—— Kent Beck（极限编程创始人）
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>我想让你知道的是：</p>
<ul>
<li>不是所有人都只为工资编程，虽然一开始是为了工资</li>
<li>（但最后一直坚持下去的人，都是真正热爱编程的人）</li>
</ul>
</blockquote>
<p>​</p>
<h4 id="人们喜欢编程的原因">人们喜欢编程的原因</h4>
<blockquote>
<p>简洁之美</p>
</blockquote>
<ul>
<li>新人可能无法特别好的理解这种「简洁之美」</li>
<li>随着工作经验的积累，可能几年之后，你会发现，层次越高，代码越简洁。</li>
<li>代码越少，解决的越多，这就是编程的魅力</li>
<li>中国可能大部分公司不考虑简洁，只考虑时间、能否解决问题，不行就 996。</li>
<li>永远处在这种模式下，你会感觉不到任何美，就是单纯堆时间的体力活</li>
<li>真正的简洁美，是程序员用大脑想到一个方法，来解决一个较为复杂的问题，同时还能带来收益回报</li>
</ul>
<blockquote>
<p>要有追求</p>
<ul>
<li>追求简洁的代码</li>
<li>追求不加班的编程，而不是靠时间堆砌的体力活</li>
</ul>
</blockquote>
<p>​</p>
<p>​</p>
<h2 id="二逻辑-">二、逻辑 ⭐️</h2>
<blockquote>
<p>所有的编程，都在使用逻辑</p>
</blockquote>
<p>我们写代码，实际上就是在写逻辑</p>
<ul>
<li>JS 用 JS 的语言来表达逻辑</li>
<li>Java 用 Java 的语音来表达逻辑</li>
<li>PHP 用 PHP 的语音来表达逻辑</li>
<li>…</li>
</ul>
<p>​</p>
<h3 id="逻辑是什么">逻辑是什么</h3>
<h4 id="三段论逻辑---1">三段论逻辑 - 1</h4>
<ul>
<li>命题一：JS 有 7 种数据类型：string、number、bool、symbol、undefined、null、object</li>
<li>命题二：JS 的函数不属于前六种类型</li>
<li>如果命题一、二为真，那么我们可以得到</li>
<li>推论：JS 的函数属于 object 类型</li>
</ul>
<blockquote>
<p>给出命题一、二，能发现它们之间的逻辑关系，并得出推论  ——  这就说明你是懂逻辑的</p>
</blockquote>
<h4 id="三段论逻辑---2">三段论逻辑 - 2</h4>
<ul>
<li>命题一：JS 中所有函数都是由 Function 构造的</li>
<li>命题二：Function、Object、Array 是函数</li>
<li>推论：Function、Object、Array 是由 Function 构造的</li>
</ul>
<blockquote>
<p>逻辑是需要学习的</p>
<ul>
<li>中国人比外国人缺乏「逻辑」</li>
<li>中国人更愿意持有混沌的思维方式，比如，二元对立、辩证统一 …中国人共容易接受这些思维方式</li>
<li>「逻辑」反而是一个外来的词语</li>
<li>「逻辑」有时候是「符合直觉」的，但又有的时候「反直觉」</li>
</ul>
</blockquote>
<p>​</p>
<h3 id="逻辑-vs-直觉">逻辑 V.S. 直觉</h3>
<h4 id="直觉的好处">直觉的好处</h4>
<ul>
<li>直觉能让你快速学会一些东西</li>
<li>比如数字、字符串、数组、对象都可以靠直觉学会</li>
</ul>
<h4 id="直觉的坏处">直觉的坏处</h4>
<ul>
<li>直觉却又能阻止你学会另一些东西</li>
<li>这时你就只能依靠「逻辑」来说服自己</li>
<li>比如，虽然不知道 Function 是如何构造 Function 的，但是逻辑告诉我们，确实如此（尽管这并不符合直觉）</li>
</ul>
<p>​</p>
<h3 id="如何用代码表示逻辑">如何用代码表示逻辑</h3>
<h4 id="例1">例1</h4>
<p>输出两个数中较大的一个数</p>
<ul>
<li>如果第1个数大于第2个数，就输出第1个数</li>
<li>否则输出第2个数</li>
</ul>
<blockquote>
<p>👇 这里只是用<strong>代码</strong>来表示出上述逻辑，**不限定语言/语法  **  —— [伪代码](# 伪代码)</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">a = [12,32]
if a.get(0) &gt; a.get(1)
	print a.get(0)
else
  print a.get(1)
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>可以得出一个结论</p>
<ul>
<li>用 if … else … 可以表示某些逻辑 （发现规律）</li>
</ul>
</blockquote>
<p>​</p>
<h4 id="例2">例2</h4>
<p>输出 N 个数中最大的一个数</p>
<ul>
<li>找到第 1、2 个数字中较大的那一个，存入 max</li>
<li>找到 max 和第 3 个数字中较大的那个，存入 max</li>
<li>找到 max 和第 … 个，存入 max</li>
<li>max 就是最大的数</li>
</ul>
<p>代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">a = [12, 32, 9, 1, 23, 6]
max = a[0]
for i from 1 to a.length() - 1 
	if a.get(i) &gt; max 
	then max = a.get(i)
print max
</code></pre></td></tr></table>
</div>
</div><p>依次两两比较，找出最大</p>
<p></p>
<p>​</p>
<blockquote>
<p>可以得出一个结论</p>
<ul>
<li>用 for 循环，也可以表示某些逻辑 （又发现规律）</li>
<li>引出问题 👇</li>
</ul>
</blockquote>
<p>​</p>
<p>​</p>
<h3 id="表示逻辑需要多少种语句">表示逻辑需要多少种语句</h3>
<blockquote>
<p>如果要表达所有的逻辑，应该用哪些语句 ？（表示逻辑需要多少种语句）
掌握了这些语句就能表达所有逻辑 ？！</p>
</blockquote>
<ul>
<li>
<p>上世纪60-70年代，科学家发明了一种理论 —— 「结构化编程」理论</p>
</li>
<li>
<p>他们说，所有逻辑，只需要 [3 种语句](# 三种语句搞定所有逻辑)就可以表达</p>
</li>
<li>
<p>注：</p>
<p>结构化编程，在某些情况下，会变得麻烦</p>
<p>比如，错误处理（这时候可能需要第4种语句：go to ）</p>
</li>
</ul>
<p>​</p>
<h3 id="三种语句搞定所有逻辑-">三种语句搞定所有逻辑 ⭐️</h3>
<blockquote>
<p>所有的复杂算法，都能用这三种语句描述 —— 多么简洁啊</p>
</blockquote>
<h4 id="顺序执行语句">顺序执行语句</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">语句1
语句2
</code></pre></td></tr></table>
</div>
</div><p></p>
<h4 id="条件判断语句">条件判断语句</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">if ... then ... else ...
if ... else if ... else
</code></pre></td></tr></table>
</div>
</div><p>伪代码 👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">if x &gt; 10
	语句1
else
	语句2
</code></pre></td></tr></table>
</div>
</div><p></p>
<h4 id="循环语句">循环语句</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">while ... do ...
for i from 1 to n ...
</code></pre></td></tr></table>
</div>
</div><p>伪代码 👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">when</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span>
	<span class="nx">语句1</span>
  <span class="nx">i</span><span class="o">+=</span><span class="mi">1</span>
<span class="nx">语句2</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<blockquote>
<p>JS 的变量提升就是个 BUG  （ 所有编程语言只有 JS 支持变量提升，JS 宛如智障🤪）</p>
<p>所以[前面](# 前言)说，第一门语言学习 JS 是很不友好的、可能导致学习者思维上的缺陷</p>
<ul>
<li>现在要学习另外一种叫「伪代码」的东西，来弥补这块缺陷</li>
</ul>
</blockquote>
<p>​</p>
<h3 id="伪代码">伪代码</h3>
<blockquote>
<p>有没有发现，尽管没有讲解这种语法，我们依旧可以通过「这种代码」来理解这些[例子](# 例1)的逻辑/目的</p>
</blockquote>
<ul>
<li>这种代码就叫  「伪代码」</li>
<li>伪代码，不属于任何一种标准语言，只是为方便程序员自己理清逻辑</li>
<li>所以只要便于自己理解，**「伪代码」可以是任意写法 **</li>
<li>作用：可以锻炼我们的大脑、思维，<u>而不是总需要依靠浏览器去判断正确性</u></li>
</ul>
<p>​</p>
<h3 id="流程图">流程图</h3>
<blockquote>
<p>流程图是一种语言，一种标准语言/标准画法</p>
</blockquote>
<ul>
<li>不同的语法逻辑，需使用相对应的某种形状来表达，是具有一定标准的。</li>
<li>**形状不可乱用，「流程图」不可乱画，必须遵循标准 **</li>
</ul>
<p>​</p>
<blockquote>
<p>注：「流程图」「伪代码」，只是两种表达形式，用来<strong>阐明逻辑</strong>，看个人喜好使用一种即可</p>
<ul>
<li>流程图，可以看到整个逻辑的脉络（可能更适合较为复杂的逻辑 ?! 🤔）</li>
<li>并不绝对</li>
</ul>
</blockquote>
<p>​</p>
<p>​</p>
<h3 id="推荐使用-mindjet-画流程图">推荐使用 Mindjet 画流程图</h3>
<blockquote>
<p>也可以用 XMind、百度脑图 等工具代替</p>
</blockquote>
<p></p>
<h3 id="流程图伪代码的好处">流程图、伪代码的好处</h3>
<h4 id="锻炼你的大脑">锻炼你的大脑</h4>
<ul>
<li>你必须自己画出来</li>
<li>不能运行在计算机里</li>
</ul>
<h4 id="整理你的思路">整理你的思路</h4>
<ul>
<li>思路乱，则图乱</li>
<li>伪代码都写不好，则真代码更写不好</li>
</ul>
<blockquote>
<p>帮助提高 应对复杂情况时的分析能力</p>
</blockquote>
<p>​</p>
<p>​</p>
<h3 id="用流程图找到最大数">用流程图找到最大数</h3>
<h4 id="两个数中找最大数">两个数中找最大数</h4>
<h4 id="n个数中找最大数">N个数中找最大数</h4>
<p></p>
<h3 id="总结">总结</h3>
<ul>
<li>
<p>逻辑很重要</p>
<ul>
<li>理解三段论</li>
<li>逻辑有时符合直觉，有时违反直觉。不论怎样，一定要相信逻辑</li>
</ul>
</li>
<li>
<p>可以用<strong>三种语句</strong><u>表达所有逻辑</u></p>
<ol>
<li>顺序执行语句</li>
<li>条件判断语句</li>
<li>循环语句</li>
</ol>
</li>
<li>
<p>可以用「图 &amp; 伪代码」表示上述**三种语句 **</p>
<p>推论：用「图 &amp; 伪代码」，可以<u>表达所有逻辑</u></p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="三数据结构">三、数据结构</h2>
<blockquote>
<p>「数据结构」</p>
<ul>
<li>**表示数据与数据之间的关系和结构 **。</li>
<li>是比算法更抽象的东西，**非常抽象 **。</li>
<li>抽象到甚至无法举出很具体的示例来表示「什么是数据结构」，只能尽量阐述、举例</li>
</ul>
</blockquote>
<h3 id="如何表示两个数据">如何表示两个数据</h3>
<blockquote>
<p>两个人之间能有什么关系？基友，师生，父子 …  这就是他们之间的数据结构
他们之间的关系，就是他们的结构</p>
<p>两个整数之间能有什么关系？比如，1是2的前一个，2是1的后一个（1和2是前后关系）
虽然很抽象，但确实是种关系</p>
</blockquote>
<h4 id="如果顺序有意义">如果顺序有意义</h4>
<blockquote>
<p>可以用下面方法👇来表示</p>
</blockquote>
<ul>
<li>[x, y] 表示第一个是 x，第二个是 y</li>
<li>[y, x] 表示第一个是 y，第二个是 x
<ul>
<li>这就是最简单的数据结构 ——【有序的二元组】</li>
</ul>
</li>
<li>比如，<strong>坐标</strong> 就是这样的数据结构
<ul>
<li>前一个数据表示 x 轴位置、后一个数据表示 y 轴位置。</li>
<li>如果反过来，就是另一个坐标数据了</li>
</ul>
</li>
<li>对于这样的数据结构，**需要提供 first 和 last 操作 **
<ul>
<li>（一共两个数据）first 返回第一个数据、last 返回第二个数据</li>
</ul>
</li>
</ul>
<p>​</p>
<h4 id="如果顺序无意义">如果顺序无意义</h4>
<ul>
<li>(x, y) 和 (y, x) 一样 —— 【无序二元组】</li>
<li>比如，<strong>血压值</strong>  (120, 80) 和 (80, 120) 没区别。（书写顺序任意，默认较大值是高压、较小值是低压）</li>
<li>不需要提供 first 和 last 操作
<ul>
<li>因为顺序无意义，所以无需区别第一个还是最后一个</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：
上面提到的【xxx二元组】这种数据结构跟 JS 没有任何关系，只是随机一种写法来表示两个数据的关系而已
目前，在 JS 中只需知道【数组和对象】这两种数据结构</p>
</blockquote>
<blockquote>
<p>上述就是「两个数据能组成的数据结构」的举例</p>
</blockquote>
<p>​</p>
<p>​</p>
<h3 id="如何表示-n-个数据">如何表示 N 个数据</h3>
<blockquote>
<p>N个数据，能组成什么样的数据结构</p>
<p>比如：一串数字，组成全部同学的分数</p>
</blockquote>
<h4 id="如果顺序有意义-1">如果顺序有意义</h4>
<ul>
<li>
<p>可以用一个经典的数据结构 —— <strong>数组</strong> 来表示  [ a1, a2, … , aN ]</p>
</li>
<li>
<p>数组需要提供<strong>索引操作</strong> get(i)：给定一个数字 i，返回对应的某项数据</p>
</li>
<li>
<p>还要提供  add / indexOf / delete  操作（增删改查的接口）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// indexOf 在数组中找到一个给定元素的第一个索引，如果不存在，则返回-1
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">beasts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ant&#39;</span><span class="p">,</span> <span class="s1">&#39;bison&#39;</span><span class="p">,</span> <span class="s1">&#39;camel&#39;</span><span class="p">,</span> <span class="s1">&#39;duck&#39;</span><span class="p">,</span> <span class="s1">&#39;bison&#39;</span><span class="p">];</span>
<span class="nx">beasts</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;bison&#39;</span><span class="p">);</span>  <span class="c1">// 1
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>​</p>
<h4 id="如果顺序没有意义">如果顺序没有意义</h4>
<blockquote>
<p>实际中，很少有数据顺序是无意义的情况</p>
</blockquote>
<ul>
<li><strong>集合</strong> 表示  { a1, a2, … , aN }</li>
<li>要提供  add / delete / has  操作</li>
</ul>
<blockquote>
<p>注意：当前md中的所有代码，与 JS 无关</p>
</blockquote>
<p>​</p>
<p>​</p>
<h3 id="如何表示-n-对-n-数据">如何表示 N 对 N 数据</h3>
<p>也就是 2*N 个数据</p>
<h4 id="比如学号对应名字">比如，学号对应名字</h4>
<blockquote>
<p>用「哈希表」表示</p>
</blockquote>
<ul>
<li>哈希表，是一种抽象的数据结构，有 key 和 value</li>
<li>key 可以是字符串、数字、布尔、甚至对象 … （因为「哈希表」是一种抽象的数据结构）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">hash = { 1001 =&gt; &#39;小芳&#39;, 1002 =&gt; &#39;小红&#39;} 
</code></pre></td></tr></table>
</div>
</div><ul>
<li>学号1001的同学，名字叫小芳；学号1002的同学，名字叫小红</li>
<li>这种 key 对应 value 的结构，叫做「哈希表」</li>
</ul>
<p>​</p>
<blockquote>
<p>JS 对象，区别于「哈希表」</p>
</blockquote>
<ul>
<li>「哈希表」的 key 可以是字符串、数字、布尔、甚至对象 … 因为「哈希表」是一种抽象的数据结构</li>
<li>**JS 对象的 key 只能是字符串 **。</li>
<li>可以认为，JS 对象，只是一种对哈希的部分实现而已。</li>
<li>而且 **JS 对象永远有一个隐藏属性 <em>_proto</em>_，而「哈希表」里没有原型 **</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="数据结构--数据形式--操作">数据结构 = 数据形式 + 操作</h3>
<blockquote>
<p>不同形式的数据暴露不同的操作</p>
</blockquote>
<ul>
<li>
<p>数据形式</p>
<ul>
<li>就是逻辑形式</li>
</ul>
</li>
<li>
<p>操作</p>
<ul>
<li>数组必须提供 add / indexOf / delete 增删改查 的接口</li>
<li>如果是集合，就不需要提供 indexOF，需要 add / delete / has  操作</li>
<li>这些接口，都属于操作</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="有没有觉得很抽象">有没有觉得很抽象</h2>
<blockquote>
<p>数据结构都是抽象的
数据结构的全名，就叫做「抽象数据结构」</p>
</blockquote>
<blockquote>
<p>前面都属于非常抽象的描述
下面举一些<strong>具体的例子</strong>，讲讲为什么数据结构这么重要（什么是数据结构，懂数据结构的人有多🐮B）</p>
</blockquote>
<h2 id="面试题">面试题</h2>
<blockquote>
<pre><code>有一段英文对白，里面只会出现  a-z  A-Z、标点符号和空格，请告诉我**每个字符出现的次数 **
</code></pre>
</blockquote>
<ul>
<li>例如  Hi, I&rsquo;m Sam</li>
<li>需求：输出 a 出现 1 次，H 出现 1 次 …</li>
</ul>
<blockquote>
<p>懂「数据结构」的程序员一看完问题，就能抽象的发现，这与「哈希表」的结构形式一样
key : value</p>
</blockquote>
<p>伪代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">str = `Hi, I&#39;m Sam`
hash = {}
for i from 0 to str.length-1
	key = str.get(i)
	value = hash.get(key,0) + 1      // value是上一次key值加1，如果上一次没有值就默认是0
	hash.set(key, value)
for key,value from hash 
	print `${key} 出现了 ${value} 次`
</code></pre></td></tr></table>
</div>
</div><p>JS 代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">times</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]])</span> <span class="p">{</span>
      <span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">){</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb"> 出现了 </span><span class="si">${</span><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="si">}</span><span class="sb"> 次`</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">times</span><span class="p">(</span><span class="sb">`Hi, I&#39;m Sam`</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<p>​</p>
<h2 id="数据结构的作用">数据结构的作用</h2>
<h3 id="提前记住一些结构">提前记住一些结构</h3>
<blockquote>
<p>如果能提前就记住一些数据结构，这是最好的（如，数组、hash … ）</p>
</blockquote>
<ul>
<li>这些结构很常见</li>
<li>这些结构，能让你很快理清思路</li>
<li>这些结构，面试经常问</li>
</ul>
<h3 id="锻炼你的抽象能力">锻炼你的抽象能力</h3>
<ul>
<li>一种数据结构往往能解决很多类似的问题</li>
<li>如果选错了数据结构，那基本玩完，算法再厉害也没用。因为在错误的数据结构下，压根就得不到正确的思路</li>
<li>牛逼的程序员更重视数据结构，而不是算法
<ul>
<li>能分析出数据是怎样的结构，这是最重要的</li>
<li>再根据数据结构去想算法</li>
</ul>
</li>
</ul>
<blockquote>
<p>想快速有效的理解数据结构，快速入门算法和数据结构</p>
<ul>
<li>只推荐一种方式：**搞懂 8 种排序算法 **</li>
<li>每一种排序算法，都对应不同的数据结构。搞懂8个排序算法，基本学会了 5-6 个数据结构</li>
</ul>
</blockquote>
<p>后面会总结：</p>
<ul>
<li>「归并排序」</li>
<li>「快速排序」</li>
<li>「计数排序」</li>
<li>「选择排序 」</li>
<li>以及「对应的数据结构」</li>
</ul>
<p>搞定这 4 种排序算法，基本上也就会了 3-4 个数据结构，可以应付めんせつ了</p>
<blockquote>
<p>数据结构在工作中用的多吗？</p>
<ul>
<li>这其实是主观上的
<ul>
<li>举个例子，在武侠世界里，有内功的人打出的拳肯定比普通人打出的拳更扎实。
别人打了一拳，很难说他用没用内功。但如果你没有内功，那就只能干打拳。</li>
</ul>
</li>
<li>所以说，对于程序员来说，懂数据结构的人写的代码，质量上一定更高</li>
<li>但是如果具体问别人：写代码时，有没有回忆起10年前学的数据结构呢？当事人自己可能也不知道</li>
<li>所以要**把「数据结构」融会到自己的思想中，内化 **（ hash、二元组 … ）</li>
</ul>
</blockquote>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="补充一些走的东西">补充：一些走❤️的东西</h3>
<blockquote>
<p>写代码会有种创造世界的成就感（就像 Minecraft）
写代码的控制感会比玩游戏的控制感更强烈一些，所以有些人可能代码写多了反而不爱玩游戏了</p>
</blockquote>
<blockquote>
<p>数据结构和伪代码，就是让你通过自己的方式和逻辑来解决问题，不要依赖浏览器等工具的调试，而是依靠自己的大脑，看它能不能想出一些东西</p>
</blockquote>
<blockquote>
<p>学习编程、写代码，一定是先定一个目的</p>
<ul>
<li>「我要学好编程」这种不是目的</li>
<li>「今天我要写出一个时钟」这种才是目的</li>
</ul>
</blockquote>]]></description>
</item></channel>
</rss>
