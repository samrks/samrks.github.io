[{"categories":null,"content":"每一天都是新的开始，Stay Simple，Stay Young","date":"2020-03-06","objectID":"/celebration/","tags":["开博纪念"],"title":"【置顶】开博纪念🥰","uri":"/celebration/"},{"categories":null,"content":"每一天都是新的开始，Stay Simple，Stay Young 🎉 ","date":"2020-03-06","objectID":"/celebration/:0:0","tags":["开博纪念"],"title":"【置顶】开博纪念🥰","uri":"/celebration/"},{"categories":null,"content":"Yeah！🎉🎉 Life is simply about getting hit over and over :) ","date":"2020-03-06","objectID":"/celebration/:1:0","tags":["开博纪念"],"title":"【置顶】开博纪念🥰","uri":"/celebration/"},{"categories":["JavaScript"],"content":"JS 对象分类——原型 \u0026 类","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"「构造函数」「原型」「new 操作符」「类 class」 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:0:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"对象需要分类吗？ 这是一个值得思考的问题 我们来做一个小程序 输出各种形状的面积和周长 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:1:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"一个正方形 Square 代码 let square = { width: 5, getArea(){ return this.width * this.width // 先简单的把this理解成当前对象，在「函数篇」会重新学习this }， getLength(){ return this.width * 4 } } 分析 声明一个「正方形」对象 「正方形」拥有三个属性：边长、面积、周长 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:2:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"一打正方形 💡 let square1 = { width: 5, getArea(){ return this.width * this.width }， getLength(){ return this.width * 4 } } let square2 = { width: 5, getArea(){ return this.width * this.width }， getLength(){ return this.width * 4 } } let square3 = { ... } ... let square12 = { ... } 写12遍。这样写代码的，要么是新人，要么是傻子。 这么写非常累，如果修改，需要逐个修改，非常非常麻烦 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"用 for 循环实现（浪费内存） let squareList = [] for(let i=0; i\u003c12; i++){ // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c squareList[i] = { // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c width: 5, getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 } } } 如果 width 不全是 5，怎么实现 let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c for(let i=0; i\u003c12; i++){ squareList[i] = { width: widthList[i], // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 } } } 分析 虽然实现了需求，但上面写法仍属于「垃圾代码」，浪费了太多内存，自己画 内存图 就知道了 squareList[0].getArea === squareList[1].getArea // false \u003cimg src=\"https://i.loli.net/2020/09/03/kQiTnhXL92HNabF.jpg\" alt=\"内存图-循环过程\" /\u003e 会画内存图的人， 比其他人理解的更好 内存中，一共创建了 24 个函数，其中 22 个都是多余重复的 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"借助原型 √ 将12个正方形对象的共有属性放到原型里 代码 let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] let squarePrototype = { getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 } } for(let i=0; i\u003c12; i++){ squareList[i] = Object.create(squarePrototype) // 每一个正方形都以squarePrototype为原型，共享方法 squareList[i].width = widthList[i] } squareList[0].getArea === squareList[1].getArea // true 分析 有人指出创建一个正方形的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来 还是垃圾代码！创建square的代码太分散了！ 在上面基础上，应该再把代码抽离到一个函数里，实现调用函数 就可以创建正方形 —— 封装函数 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"抽离到函数（封装）⭐️ 将创建正方形的代码，整合到一个 function 中 直接调用 function 即可创建出对应个数的正方形对象 这种过程就叫做「封装」 把细节写到一个函数里，调用函数、传参，就搞定了 let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] function createSquare(width){ // 此函数叫做「构造函数」详见一下版块 let obj = Object.create(squarePrototype) // 以 squarePrototype 为原型创建空对象 obj.width = width return obj } let squarePrototype = { getArea(){ return this.width * this.width } getLength(){ return this.width * 4 } } for(let i=0; i\u003c12; i++){ squareList[i] = createSquare(widthList[i]) // 这下创建 square 很简单了吧！ } ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"构造函数 ⭐️ 就是可以构造出对象的函数 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:4:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"函数和原型结合（进一步封装）⭐️ 进一步封装 squarePrototype 原型 和 creatSquare 函数，还是分散的 能不能组合在一起？ let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] function createSquare(width){ // 构造函数：用于创建 square 对象 let obj = Object.create(createSquare.squarePrototype) // 先使用后定义？NO，这里并未执行，执行时已经定义完了 obj.width = width return obj } createSquare.squarePrototype = { // 把原型放到构造函数上，结合够紧密了吗？ getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 }, constructor: createSquare // 再把构造函数放到原型上，方便通过原型找到构造函数 // 原型和构造函数互相引用，非常紧密 // 可以通过createSquare函数，找到原型squarePrototype。也可以拿到原型，方便的找到createSquare函数 } for(let i=0; i\u003c12; i++){ squareList[i] = createSquare(widthList[i]) console.log(squareList[i].constructor) // ƒ createSquare(width){...} // 打印 constructor 可以知道谁构造了 squareList[0→11] 对象：你妈是谁？ } 函数上面也可以用「点 . 」？ 因为函数属于对象 此时，代码已经没有进一步优化的空间了 这段代码几乎完美 为什么不固定下来，让每个JS开发者直接用呢? 这时 JS 就有了 new 操作符 来帮我们实现 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:4:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"new 操作符 ⭐️ 让我们感受JS之父的爱 JS 之父创建了 new 关键字，可以让我们可以再少写几行代码 JS 的 new 到底是干什么的？⚡️⚡️⚡️⚡️（必读！！！） 函数和原型结合（重写）⭐️⭐️ let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] function Square(width){ // 构造函数 this.width = width } Square.prototype.getArea = function(){ return this.width * this.width } Square.prototype.getLength = function(){ return this.width * 4 } for(let i=0; i\u003c12; i++){ squareList[i] = new Square(widthList[i]) console.log(squareList[i].constructor) } // 多美，几乎没有一句多余的废话 每个函数创建时，都自带有prototype属性，这是JS之父故意的 每个prototype都自带有constructor属性，也是故意的 function f1(){} console.dir(f1) f1.prototype.constructor === f1 // true // 函数原型上的constructor等于函数本身 ​ 对比 上面的代码被简化为下面的代码 唯一的区别是要用 new 来调用 细节 creatSquare =\u003e Square 函数名变了 之前需要创建对象，让对象的原型指向拥有 getArea 和 getLength 的那个对象 。 现在这句话不用写了，new 会帮我们实现 用 this 代表新的对象（this 会指向临时对象） return obj 也不用写了，new 会帮我们实现（函数原本三行，压缩成一行，其他 new 会帮我们实现） 现在，把 getArea 和 getLength 通过「点方法」挨个添加到 prototype 上，不能直接给 prototype 赋新值，会导致丢失原本的 constructor（可以用 Object.assign 批量添加） 最后，声明新对象时，用 new Square(width) ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:4:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"总结 ⚡️⚡️⚡️ JS 的 new 到底是干什么的？⚡️⚡️⚡️⚡️（必读！！！） ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"new X() 自动做了四件事情 自动创建空对象 自动为空对象关联原型，原型地址指定为 X.prototype 自动将空对象作为 this 关键字运行构造函数 this 就是我们new构造函数创建的对象 自动 return this ——这就是 JS 之父的爱 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"构造函数 X X 函数本身负责给对象本身添加属性 X.prototype 对象负责保存对象的共用属性 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"原型与共有属性的关系 因为 JS 引擎按照「堆栈」来分配内存、存储数据 根据「堆栈」的规则，简单类型在「栈区 Stack」存储，复杂类型在「堆区 Heap」存储 X.prototype 的值是，原型的地址 因为原型是一个对象，对象是以「堆」的形式存储，所以严格来说，X.prototype的值是：原型的地址 这个地址，对应到计算机中的那一坨内存，才是原型本身 而原型中，有很多属性/方法：toString、valueOf … 它们就是「共有属性」（原创的词） 共有属性的集合就是原型 如果会画内存图，会理解的更清楚 ↓↓↓ ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"示例 function Dog(name){ this.name = name this.color = 'white' this.kind = '萨摩耶' // this 就是我们new构造函数创建的对象 } Dog.prototype.say = function(){ console.log('汪汪') } // 共用函数 Dog.prototype.run = function(){ console.log('狗在跑') } let dog1 = new Dog('小白') Dog.prototype.x = '狗' // 共用的不一定都是函数, 也可以共用属性。 let dog2 = new Dog('小黑') dog1.x // '狗' dog2.x // '狗' ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:6:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"题外话：代码规范 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:7:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"大小写 所有构造函数（专门用于创建对象的函数）首字母大写 所有被构造出来的对象，首字母小写 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:7:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"词性 new 后面的函数（构造函数），使用名词形式。 如 new Person()、new Object() 普通函数，一般使用动词开头。如 createSquare(5)、createElement('div') 其他规则以后再说 ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:7:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"总结一个非常重要的公式 💋 也是 JS 里唯一的一个公式 很多前端对于原型的理解是通过画图，实际上是可以通过公式来表示的 只有方方的课才能看到，若愚的课也没有 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"如何确定一个对象的原型 为什么 let obj = new Object()的原型是 Object.prototype let arr = new Array()的原型是 Array.prototype let square = new Square()的原型是 Square.prototype let fn = new Function()的原型是 Function.prototype 可以总结出，一个对象通过 new XXX 创建出来，那么 XXX.prototype 就是这个对象的原型 因为 new 操作故意这么做的 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"结论 你是谁构造的 你的原型就是谁的 prototype 属性 对应的对象 很多前端会说 prototype 就是原型 实际上、严格来说，prototype 只是存了个地址，不是对象。 prototype 地址对应的那块内存、内存中所有共有属性的集合，才是原型对象本身 ⚡️⚡️⚡️⚡️ 原型公式 ⚡️⚡️⚡️ 对象.__proto__ === 其构造函数.prototype ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"例 💋 function X(width){ this.width = width } X.prototype.getArea = function(){ return this.width * this.width } X.prototype.getLength = function(){ return this.width * 4 } let a = new X(5) let b = new X(6) 构造函数的原型：X.prototype 是 #309 构造出的对象 a 和 b 的原型 ： a.__proto__ 和 b.__proto__ 也是 #309 补充：#109 结构 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"参考资料 JS 中 __proto__ 和 prototype 存在的意义是什么？ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:4","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"做几个题 来理解公式：对象.__proto__ === 其构造函数.prototype 难度1 let x = {} 请问： x的原型是什么？ Object.prototype x.__proto__的值是什么？ Object.prototype 上面两个问题是等价的吗？ 请用内存图画出x的所有属性 答： Object.prototype // x的原型 Object.prototype // x.__proto__ x.__proto__ === Object.prototype // true 二者是等价的 x.__proto__ === window.Object.prototype // true 「window.」可省略 ​ 难度2 function Square(width){ this.width = width } let square = new Square(5) ⚡️⚡️⚡️ 请问： square的原型是什么？ square.__proto__的值是什么？ 请用内存图画出 square 的所有属性 答： Square.prototype // square的原型 Square.prototype // square.__proto__ // 1/2两个问题是等价的（带入公式理解） ​ 难度3 请问： Object.prototype 是哪个函数构造出来的？ Object.prototype 的原型是什么？ Object.prototype.__proto__ 值是什么? 请用内存图画出上述内容 答： 未知，Object.prototype 是默认就存在的，没有谁把它构造出来 没有原型 Object.prototype.__proto__ === null // true ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:5","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"构造函数、prototype、new 通过 Square 的例子，已经可以基本理解了 构造函数 用来创建对象的函数，就是构造函数（特点：首字母大写） ​ prototype 不论构造函数、还是普通函数，每一个函数（对象）都有一个 prototype，用来存放共有属性 每个对象都有原型，但除了「根对象 Object.prototype」比较特殊，Object.prototype 这个对象的原型为空 null function add(x,y){return x+y} add.prototype // 不仅是构造函数，普通函数也有 prototype delete add.prototype // false 而且删不掉，仍然存在 ​ new：会帮我们做四件事情（省略了很多代码） 创建一个临时对象 把这个对象指向一个原型 把这个对象作为 this 来运行这个构造函数 return this ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:9:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"Square 最终版（存疑） function Square(width){ this.width = width } Square.prototype.getArea = function(){ return this.width * this.width } Square.prototype.getLength = function(){ return this.width * 4 } let square = new Square(5) square.width // 5 square.getArea() // 25 square.getLength() // 20 为什么说存疑：因为还有一个更简化的版本，后面再讲 ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:10:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"圆形 Circle function Circle(radius){ this.radius = radius } Circle.prototype.getLength = function(){ return this.radius * Math.PI } Circle.prototype.getArea = function(){ return Math.pow(this.radius, 2) * Math.PI } let c1 = new Circle(10) c1.radius // 10 c1.getLength() // 31.41592653589793 c1.getArea() // 314.1592653589793 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:11:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"长方形 Rectangle 两个参数：宽、高 function Rect(width, height){ this.width = width this.height = height } Rect.prototype.getArea = function(){ return this.width * this.height } Rect.prototype.getLength = function(){ return (this.width + this.height) * 2 } let r1 = new Rect(4,5) r1.width r1.height r1.getLength() r1.getArea() ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:12:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"对象需要分类吗？🧐 回到最初的问题 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"答案是 需要分类 因为不同的对象有不同的功能，某些对象具有相同功能，某些对象具有不同功能 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"理由一 有很多对象拥有一样的属性和行为 需要把它们分为同一类 如 square1 和 square2 如 圆1、圆2、圆3，都是圆 如 长方形1、长方形2，都是长方形 … 这样创建类似对象的时候就很方便 直接 new 一个 Square、new Circle、new Rect … 然后传参，就能创建出相应图形的对象 就不需要【 let square1 = {…}; let square2 = {…} 然后把所有属性写一遍】，这样会很麻烦 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"理由二 但是还有很多对象拥有其他的属性和行为 所以就需要不同的分类 比如 Square / Circle / Rect 就是不同的分类 Array / Function 也是不同的分类 而 Object 创建出来的对象，是最没有特点的对象（没有什么额外更多的功能，相对比较普通） let x = {} // 等价于 let x = new Object() ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"类型 vs. 类 「 类型 \u0026 类 」有什么区别 ？ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:14:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"类型 类型是 JS 数据的分类，有 7 种 四基两空一对象 string number boolean symbol null undefined object ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:14:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"类 类是针对于对象的分类，有无数种 Object 创建出来的对象，是最没有特点的对象 只要觉得需要再创建一个分类，就再写一个 构造函数，new 出来新的分类对象 常见的有 Array、Function、Date(日期)、RegExp(正则) 等 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:14:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"有特色的类 ⭐️ 上面提到 Object 创建的的对象，是最没有特色的类 那什么是有特色的的类？举两个例子：数组对象、函数对象 （在其他语言中，数组、函数可能都不是对象，但在 JS 中，数组/函数 都属于对象） ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:15:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"数组对象 定义一个数组 let arr = [1,2,3] // 简写 let arr = new Array(1,2,3) // 元素为 1,2,3 // arr [1,2,3] let arr = new Array(3) // 长度为 3 // arr [empty×3] ​ 数组对象的自身属性 let arr = [1,2,3] // arr的自身属性有 4 个： '0'/'1'/'2'/'length' 注意，属性名没有数字，只有字符串 属性名：‘0’/‘1’/‘2’ ，都是字符串 灰色属性，是不能被遍历到的：如 length、__proto__ 数组对象的共用属性 共有属性非常多，都存储在数组对象的 __proto__ 中 'push'/'pop'/'shift'/'unshift'/'join' ...... ​ 数组对象 比 普通对象，多一层 原型 let obj = {} let arr = [1,2,3] obj.__proto__ === Object.prototype // true obj.__proto__ === arr.__proto__.__proto__ // true arr.__proto__.__proto__ === Object.prototype // true ​ 调用共有属性时，采用就近原则 在 arr 自身的原型上找到这个属性时，就不会再去 对象原型 上找 arr.toString == arr.__proto__.__proto__.toString // false arr.toString == arr.__proto__.toString // true ​ 各个【共有属性】，用法都在 MDN，基本与其英文原意相关 后面会有单独课程 教这些 API。所谓的 API 就是【数组有哪些函数、对象有哪些函数】 推 push() 方法，将一个或多个元素添加到数的末尾，并返回该数组的新长度。 弹 pop()方法，从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 提档 shift() 方法，从数组中删除第一个元素，并返回该元素的值。 降档 unshift() 方法，将一个或多个元素添加到数组的开头，并返回该数组的新长度。（修改原数组） 联结 join() 方法，将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。 联结 concat() 方法，用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 … let arr = [1,2,3] arr.push(0) // 4 返回数组的新长度 arr // [1,2,3,0] arr.pop() // 0 返回被删除的元素的值 arr // [1,2,3] arr.shift() // 1 返回被删除的元素的值 arr // [2,3] arr.unshift(0) // 3 返回数组的新长度 arr // [0,2,3] arr.join('哈') // \"0哈2哈3\" 直接返回字符串 let arr1 = [1,1], arr2 = [2,2], arr3 = [3,3] arr1.concat(arr2) // [1, 1, 2, 2] arr1.concat(arr2, arr3) // [1, 1, 2, 2, 3, 3] ... ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:15:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"函数对象 定义一个函数 function fn(x,y){return x+y} // 声明函数 fn let fn2 = function fn(x,y){return x+y} // 声明函数 fn，并赋给变量fn2 let fn3 = (x,y) =\u003e x+y let fn4 = new Function('x','y', 'return x+y') // 声明的是匿名函数，并将它赋给 fn4 function fn1(x,y){return 'fn1'} // 声明函数 fn let fn2 = function fn(x,y){return 'fn2'} // 声明函数 fn，并赋给变量fn2 let fn3 = (x,y) =\u003e 'fn3' // 声明函数 fn3 let fn4 = new Function('x','y', 'return `fn4`') // 声明的是匿名函数，并将它赋给 fn4 函数对象自身属性 'name' / 'length' ​ 函数对象共用属性 共有属性非常多，都存储在函数对象的 __proto__ 中 'call' / 'apply' / 'bind' 这三个属性是重点 后面会有单独课程介绍函数 ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:15:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"JS 终极一问：谁构造了ta ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"window 是谁构造的 Window 可以通过 constructor 属性看出构造者 window.constructor === Window // true window.__proto__ === Window.prototype // true ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"window.Object 是谁构造的 window.Function ==因为所有函数都是 window.Function 构造的== window.Object.constructor === window.Function // true window.Object.__proto__ === window.Function.prototype // true ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"window.Function 是谁构造的 window.Function 因为所有函数都是 window.Function 构造的 window.Function.constructor === window.Function // true 自己构造的自己？并不是这样，这是「上帝(浏览器)」的安排 浏览器构造了 Function，然后指定它的构造者是自己 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"ES6 ：class 语法 💋 JS 构造对象目前有两种方式，一种是用【构造函数+prototype】，一种是用【class】 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"prototype 是过时的 ？ 非常遗憾，下面代码（构造函数）被某些前端认为是过时的 function Square(width){ this.width = width } Square.prototype.getArea = function(){ return this.width * this.width } Square.prototype.getLength = function(){ return this.width * 4 } 学习资料：你可以不会 class，但是一定要学会 prototype ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"ES6 ：class 语法 class 是用来声明一个类，类是用来创建对象的，不讲究什么内存共用 class Square{ constructor(width){ // constructor中写对象里的属性 this.width = width } getArea(){ // 对象里的函数 return this.width * this.width } getLength(){ // 对象里的函数 return this.width * 4 } } 注意：方法不能写成 getLength: function(){ ... } 这种形式 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"class 语法引入了更多概念 class Square{ static x = 1 // static表示x属于Square，调用需采用 Square.x 的写法 \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c width = 0 // 初始化 width 的值 // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c constructor(width){ this.width = width } getArea(){ return this.width * this.width } getLength(){ return this.width * 4 } get area2(){ // 只读属性：调用时直接Square.area2就会执行，无需括号 \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c return this.width * this.width } } class 引入更多的语法，这些语法多来自 Java世界 或 c#世界（跟 JS 以前的世界是格格不入的） ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"用 class 重写 Circle class Circle{ constructor(radius){ this.radius = radius } getArea(){ return Math.pow(this.radius, 2) * Math.PI } getLength(){ return this.radius * 2 * Math.PI } } let circle = new Circle(10) circle.radius circle.getArea() circle.getLength() ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:4","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"用 class 重写 Rectangle class Rectangle{ constructor(width, height){ this.width = width this.height = height } getArea(){ return this.width * this.height } getLength(){ return (this.width + this.height) * 2 } } let rect = neww Rectangle(4,5) rect.width rect.height rect.getArea() rect.getLenght() ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:5","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"易混淆语法 语法1： class Person{ sayHi(name){} } // 等价于 function Person(){} Person.prototype.sayHi = function(name){} 语法2： 注意冒号变成了等于号 class Person{ sayHi = (name)=\u003e{} // 注意，一般我们不在这个语法里使用普通函数，多用箭头函数 } // 等价于 function Person(){ this.sayHi = (name)=\u003e{} } ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:6","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"不要强求完全转换成 ES5 大部分 class 语法都可以转为 ES5 语法，但并不是 100% 能转，有些 class 语法你意思理解就行，不需要强行转换为 ES5。 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:7","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"原型好，还是类好？ 都是用来给对象分类的 目前，先推荐用 class 但是 class 的语法知识比较复杂，还需要再多花点时间学习 （关于类和对象的新语法有 页面1，页面2 和 页面3） 原型的知识，上面👆已经全部讲过了 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:18:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"JS 对象的基本用法","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"「增」「删」「改」「查」「原型」 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:0:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"回顾 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:1:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"七种数据类型 number、string、booleansymbol undefined、null object 四基(本类型)两空一对象 (bigInt) ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:1:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"五个 falsy 值 null、undefined 0、NaN '' （空字符串） ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:1:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"JS 对象 是学习 JS 的三座大山之一 对象（原型） this AJAX ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:2:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"对象 object 对象的基础知识 object ，是第七种数据类型，唯一 一种「复杂类型」 其他六种（numbe、string、boolean、symbol、null、undefined），叫做「简单类型」。因为这六种不包含其他任何东西，而 object 对象包含其他内容 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"定义 无序的数据集合 键值对的集合 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"写法 let 对象名 = { key: value // 属性名/键名 : 属性值 } 对象的写法，与 block（代码块）类似，只是碰巧都有 { } 。 要注意区分 { } 是对象，还是代码块 例 let obj = { 'name': 'sam', 'age': 18 } // 不论'name'/'age'(属性名)是否有引号，它都只能是字符串 let obj = new Object({'name': 'sam'}) // 正规写法 console.log({ 'name': 'sam', 'age': 18 }) // 创建匿名对象 JS 既然可以通过字面量方式创建对象，为什么还要有第二种 new Object() 的方式创建 ? 实际上第二种 new Object() 才是正规创建对象的写法，第一种属于简化版 因为简化了代码，所以通常都是用第一种写法 ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"细节 ==键名是字符串==，不是标识符，可以包含任意字符 只要是字符串就行：空串、空格串、emoji 、数字字符串 … （任何一个 Unicode 能表达的串都 ok ） 标识符 规则：（变量）不能以数字开头 属性名的引号可省略，省略之后需按照标识符的规则命名，特例：允许纯数字的键名 就算引号省略了，键名也还是字符串（重要） 例 var obj1 = { '': 1 } var obj2 = { 2: 123, name:'fff', 'age':12 } var obj3 = { ' ': 2 } var obj4 = { '👍': 'zan' } // Object.keys(对象名) 获取对象中的 key名 组成的数组 Object.keys(obj1) // [\"\"] // 空串也是字符串，合法 Object.keys(obj2) // [\"2\", \"name\", \"age\"] Object.keys(obj3) // [\" \"] Object.keys(obj4) // [\"👍\"] // 所以不论怎么写，key 都是字符串 属性名 每个 key 都是对象的属性名（property） 属性值 每个 value 都是对象的属性值 ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:3","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"奇怪的属性名 所有属性名会自动变成字符串 let obj = { 1: 'a', // \"1\" 3.2: 'b', // \"3.2\" 1e2: true, // \"100\" 1e-2: true, // \"0.01\" .234: true, // \"0.234\" 0xFF: true // \"255\" }; Object.keys(obj) // [\"1\", \"100\", \"255\", \"3.2\", \"0.01\", \"0.234\"] JS 可能会自动换算「属性名」，所以如果不想被自动换算，给属性名加上「引号」即可解决 细节 Object.keys(obj) 可以得到 obj 的所有 key 组成的数组 这个 API 需要会使用 「变量」作属性名 如何用变量做属性名 之前都是用常量做属性名（所有不是变量的都是常量） let p1 = 'name' let obj = { p1 : 'sam'} 这样写，属性名为 'p1' let obj = { [p1] : 'sam' } 这样写，属性名为 'name' （ ES 6 ） let aa = 'xxx' // 想用变量a作为属性名 var obj = { aa: 1111 } // {aa: 1111} var obj = { 'aa': 1111 } // {aa: 1111} var obj = { [aa]: 1111 } // {xxx: 1111} // ES6之后 ES6之前，实现变量作属性名 ↓↓ ，需两行代码实现。ES6之后一行 ↑↑ 即可 let aa = 'xxx' var obj = {} obj[aa] = 1111 console.log(obj) // {xxx: 1111} 对比 不加 的属性名会自动变成字符串 加了 则会当做变量求值 值如果不是字符串，则会自动变成字符串 var obj = { [1+2+3+4]: '十' } console.log(obj) // { 10: \"十\" } Object.keys(obj) // [ \"10\" ] ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:4","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"对象的隐藏属性（原型 💡） 隐藏属性 JS 中，每一个对象 都有一个 隐藏属性 __proto__ 这个隐藏属性，储存着其 共有属性组成的对象的地址 这个共有属性组成的对象，叫做原型 也就是说，隐藏属性 储存着 原型的地址 __proto__ 存储了一个地址，这个地址所代表的内存空间中的对象，叫做原型 / 共有属性 代码示例 var obj = {} obj.toString() // 居然不报错 因为 obj 的隐藏属性对应的对象（原型 / 共有属性）上有 toString() ​ 举个栗子：什么叫共有属性 将共有的属性，提取出来单独存储成一个对象。最大的好处，就是省内存 每次声明一个 chinese 时，无需重复写入：国籍、肤色、发色 … 等 chinese 公共的属性，直接用一个特定属性（–proto–），存储共有属性所在的内存地址即可 var chinese1 = { name: '小兰' } var chinese2 = { name: '小红' } ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:5","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"超纲知识 前面提到，对象中所有的 key 都是字符串 实际上，ES 6 中稍微做了调整：除了字符串，symbol 也能做属性名 let a = Symbol() let obj = { [a]: 'Hello' } 这有什么用呢？ 目前，屁用都没用，很久很久以后可能会有用（方方从没用过） 在学习「迭代」时会用到（但前端不流行迭代，所以根本没机会用） ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:6","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"增删改查 「增删改查」对象的属性 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"删除属性 delete 操作符：用于删除对象的某个属性 delete obj.xxx delete obj['xxx'] 作用：删除 obj 的 xxx 属性 请区分「属性值为 undefined」和「不含属性名」 不含属性名 直接删除属性名 var obj = {name: 'sam', age: 18} delete obj.name // 或 delete obj['name'] console.log(obj) // {age: 18} // console.log(obj.name) // undefined 判断是否删除成功 'xxx' in obj === false // 返回 true 说明该属性名已被删除 （不能省略引号） 含有属性名，但是值为 undefined 仅删除属性值，保留属性名 'xxx' in obj \u0026\u0026 obj.xxx === undefined var obj = {name: 'sam', age: 18} obj.name = undefined console.log(obj) // {name: undefined, age: 18} // console.log(obj.name) // undefined 注意 obj.xxx === undefined obj.xxx === undefined 不能断定 ‘xxx’ 是否为 obj 的属性 let obj = {} let obj2 = {x:undefined} obj.x === undefined // true obj.x === undefined // true 所以说 这句话无法判断出 x 到底是不是 obj 的属性 用 in 和 hasOwnProperty 可以判断 let obj = {} let obj2 = {x:undefined} 'x' in obj // false 'x' in obj2 // true obj.hasOwnProperty('x') // false obj2.hasOwnProperty('x') // true 类比 你有没有卫生纸？ A: 没有 // 不含属性名 B: 有，但是没带 // 含有属性名，但是值为 undefined 程序员就是这么严谨 「没有」和「undefined」是两个概念 没有就是没有，undefined 就是 undefined 绝不含糊 需要细心，发现细微的区别 ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"查看所有属性（读属性） 例 var obj = {name: 'sam', age: 18} 查看自身所有属性 无法打印【共有属性 __proto__】 Object.keys(obj) // [\"name\", \"age\"] Object.values(obj) // [\"sam\", 18] Object.entries(obj) // [Array(2), Array(2)] =\u003e 0:[\"name\", \"sam\"] 1:[\"age\", 18] 查看自身+共有属性 dir 指以目录的形式，可以查看到【共有属性 __proto__】 console.dir(obj) // 查看 obj内容 及 共有属性 【推荐】 obj.__proto__ // 也可以直接打印共有属性（但不推荐此法，因为隐藏属性的命名是不固定的，不同浏览器可能规定不同） 或者自己依次用 Object.keys 打印出 obj.__proto__ 判断一个属性是自身的还是共有的 判断一个属性是否是某个对象的属性，可以用 in ，但是 in 无法区分是自身的还是共有的 \"name\" in obj // true \"toString\" in obj // true obj.hasOwnProperty('toString') // false obj.hasOwnProperty('name') // true obj.hasOwnProperty('age') // true ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"原型 原型，就是隐藏属性 所指向的对象 每个对象都有原型 原型里存着对象的共有属性 比如 obj 的原型就是一个对象 obj.__proto__ 存着这个原型对象的地址 这个原型对象里有 toString / constructor / valueOf 等属性 对象的原型也是对象 既然每个对象都有原型，且原型也是对象，那么可以推出：原型上也有原型 所以对象的原型上也有原型 obj = { } 空对象的原型即为所有对象的原型 这个原型包含所有对象的共有属性，是对象的根 这个原型也有原型，是 null 【/nʌl/】 原型为 null 的对象，就是对象的根 console.log(obj.__proto__) // 原型对象（根对象） console.log(obj.__proto__.__proto__) // null 原型上的原型 ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:3","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"查看属性 两种方法查看属性 **中括号语法：obj[‘key’] ** 点语法：obj.key 坑新人语法：obj[key] // 中括号里是变量，【变量 key】 值一般不等于【字符串 ‘key’】 var obj = {name: 'sam', age: 18} obj['name'] // 'sam' obj.name // 'sam' obj[name] // undefined console.log(name) // \"\" window.name = 'age' obj[name] // 18 // 等同于 obj['age'] 变态 obj['na'+'me'] // 'sam' obj[console.log('name')] // name // 先执行log命令，打印内容 // undefined // log 函数的返回值为 undefined，相当于执行 obj[undefined] =\u003e undefined ​ 请优先使用中括号语法 【点语法】会误导你，让你以为 key 不是字符串 等你确定不会弄混两种语法，再改用点语法 obj.name 等价于 obj[‘name’] obj.name 不等价于 obj[name] 简单来说，obj.name 这里的 name 是字符串，而不是变量 let name = ‘sam’ 此时 obj[name] 等价于 obj[‘sam’] ，而不是 obj[‘name’] 和 obj.name ​ 考题 区分变量 name 和 常量字符串 'name' 代码 let list = ['name', 'age', 'gender'] let person = {name:'sam', age:18, gender:'man'} for(let i = 0; i \u003c list.length; i++){ let name = list[i] console.log(person???) } // 使得 person 的所有属性被打印出来 选项 console.log(person.name) ✘ // sam sam sam console.log(person[name]) ✔ // sam 18 man 区分 name 和 ‘name’ 为什么这么重要 因为如果你现在不搞清楚，那么你在学 Vue 的时候，会更加迷惑 ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:4","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"修改或增加属性（写属性） 直接赋值 直接赋值，name 属性已存在，就相当于修改属性值；name 属性不存在，就会新增这个属性，值为 sam let obj = {name: 'sam'} // name 是字符串 obj.name = 'sam' // name 是字符串 ✔ obj['name'] = 'sam' // ✔ obj[name] = 'sam' // 错，因name为变量，值不一定等于'name' obj['na'+'me'] = 'sam' // ✔ let key = 'name'; obj[key] = 'sam' let key = 'name'; obj.key = 'sam' // 错，因为obj.key等价于obj['key']，相当于给obj增加了key属性 值为sam ​ 批量赋值 let obj = {name: 'sam'} Object.assign(obj, {name:'123', age: 18, gender: 'man'}) // name 属性已存在，就相当于修改属性值；name 属性不存在，就会新增这个属性，值为'123' console.log(obj) // {name:'123', age: 18, gender: 'man'} assign ：赋值的意思 Object.assign() ：是 ES6 新出的 API ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:5","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"修改或增加共有属性 JS 特性： 读取时，可以读取到（原型上的）共有属性。 写入时，只写在自己身上，不会影响（原型）共有属性 无法通过自身修改或增加共有属性 原型上的属性，无法通过自身直接修改 let obj = {}, obj2 = {} // 共有 toString 方法 obj.toString = 'xxx' // 只会在改 obj 自身属性，不会覆盖共用的 toString 方法 obj.toString // 'xxx' obj.toString() // 报错 obj.toString is not a function obj2.toString // ƒ toString() { [native code] } 还是在原型上的方法 obj2.toString() // \"[object Object]\" 偏要修改或增加原型上的属性 obj.__proto__.toString = 'xxx' // 不推荐用 __proto__ Object.prototype.toString = 'xxx' console.dir(obj.toString) // obj.__proto__ 存的地址，等价于 window.Object.prototype 存的地址 obj.__proto__ === window.Object.prototype // true 这是 JS 非常危险的特型，一旦修改，会使得原型上的属性非常不可信 —— JS 的脆弱性 一般来说，不要修改原型，会引起很多问题：代码崩溃/异常… ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:6","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"修改隐藏属性 不推荐使用 __proto__ 修改原型 例1 let obj = {name:'sam'} console.log(obj) // {name:\"sam\", __proto__: Object} obj.__proto__ = null console.log(obj) // {name:\"sam\"} 没有proto原型了，变成非常纯净的对象，不能调用任何功能 例2 let person = {name:'sam'} let person2 = {name: 'jack'} let common = {kind: 'human', '国籍': '中国'， hairColor: 'black'} person.__proto__ = common person2.__proto__ = common 上述，使用 __proto__ 直接修改原型，不推荐，性能非常低 ​ 推荐使用 Object.create 修改对象的原型 规范的修改对象的原型，使用 Object.create 【功能：用于指定原型】 var obj = Object.create({name:'sam'}) console.log(obj) // { __proto__:{name:'sam'} } 用法 ↓ let common = {kind: 'human', '国籍': '中国'， hairColor: 'black'} let obj = Object.create(common) // 以common为原型对象，创建obj obj.name = 'sam' // 点方法，挨个添加属性，或 批量修改/添加属性 Object.assign(obj,{ ... }) ... Object.create() 第二个参数，写法比较麻烦 let person = Object.create(common, { name: { value: 'sam' } }) console.log(person) // {name:'sam', __proto__: Object} =\u003e 规范的写法：大概是，要改就一开始就改；别后来再改，如person.__proto__ = common 影响性能 ​ ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:7","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"总结 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"删 delete obj['name'] 'name' in obj // false // in 用于判断某个对象中是否含这个属性，缺点：无法区分是自身的，还是原型上共有的 obj.hasOwnProperty('name') // false // 只有对象自身含有这个属性，才会返回 true ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"查 Object.keys(obj) console.dir(obj) // 目录形式，详细 obj['name'] obj.name // 记住这里的 name 是字符串 obj[name] // 记住这里的 name 是变量 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"改 改自身 obj['name'] = 'jack' 批量改自身 Object.assign(obj, {age:18, ...}) 改某个共有属性 obj.__proto__['toString'] = 'xxx' // 强烈不推荐 改某个共有属性 Object.prototype['toString'] = 'xxx' 换原型 obj.__proto__ = common // 强烈不推荐 换原型 let obj = Object.create(common) // 注：所有 proto 代码都是强烈不推荐写的。学习时可以用用，但是工作中不要用 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:3","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"增 基本同上，已有属性则改；没有属性则增。 查：属于读，可以读到原型链 改 和 增：属于写，只能改自身，不能改到原型 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:4","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"JS 的数据类型","date":"2020-08-27","objectID":"/javascript-something-about-data-type/","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"「如何存数字\u0026字符」「JS 的数据类型」「64位浮点数 」「变量声明 var / let / const」「类型转换」 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:0:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数据为什么需要类型 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:1:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数字与字符串 都是一，为什么要分 1 和 '1' 功能不同 数字是数字，字符串是字符串，要严谨 数字能加减乘除，字符串不行 字符串能表示电话号码，数字不行 存储形式不同 JS中，数字 number 是用64位浮点数的形式存储的 JS中，字符串是用类似 UTF8 形式存储的（UCS-2) ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:1:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"如何存数字 进制转二进制即可 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:2:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"二进制 10转2 31变成二进制： 经过一番尝试： 所以31（十进制）= 01111（二进制） 不是套公式吗？程序员从来不套公式 🙃 2转10 100011变成十进制 每一位乘以2的N次方，然后加起来即可 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:2:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"用十六进制表示二进制 为什么用十六进制，因为二进制写起来太慢了：011110001011010 记住 8 4 2 1 对应 X X X X 从右往左每四位改写成一位：011110001011010 得到 3，12，5，10； 16进制中，把大于9的数字改为ABCDEF 0123456789 A B C D E F 10 11 12 13 14 15 于是得到 3C5A，你也可以用计算器的程序员模式 HEX表示16进制，BIN表示2进制 OCT表示8进制，DEC表示10进制 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:2:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"如何存字符 转成数字即可（但字符有几万个，数字只有0-9），解决办法就是把所有字符都编号 注意，\"1\" 不能用 1 来表示 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"用 0 ~ 127 表示所有符号 （2^7^ = 128） 0 表示结束字符 10 表示换行 13 表示回车 32 表示空格 33 到 47 表示标点 48 到 57 表示数字符号（存 0 用 48 表示） 65 到 90 表示大写字母（存 A 用 65 表示） 97 到 122 表示小写字母（存 a 用 97 表示） 127 表示删除键 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"中文怎么表示？ 1990-1995年左右，中国开始有人买得起电脑了 简单，还是编号 中国国家标准局来编，名称为「国标23121」 ​ 用 0000 ~ FFFF 表示汉字 用两个字节，表示一个汉字（一个字节是8个0/1位） 一个 16 进制数是4个0/1位 FFFF 就是 4x4=16 位，也就是两个字节 最多收录 2^16=65536 个字符 但只收录了6000多常用汉字、西文字母和日文假名（没有收录生僻字、繁体字、韩文…） 「你」的 GB2312 编号为 C4E3 「牛」的 GB2312 编号为 C5A3 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"生僻字 随着计算机的普及，政府、学习开始采用计算机管理录入信息 中国人的名字里有生僻字！ 例 李瓛 =\u003e 李* 陶喆 =\u003e 陶吉吉 怎么表示生僻字、繁体字、韩文呢，之前的忘了编进去 微软出手了，推出了一个国标扩展，简称 GBK ​ GBK 国标扩 含 21886 个汉字和图形符号 收录了中日韩使用的几乎所有汉字 完全兼容 GB2312 依然使用 16 位（两字节） 后来国标局推出 GB18030 想取代 GBK 但 GB18030 不兼容 GB2312，导致没人使用 GB18030，而是一直使用国标扩 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"泰文、藏文 继续编号，这回一次性解决全世界需求 —— 推出 万国码 Unicode 字符集 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"万国码 Unicode 优点 已收录13万字符（大于16位），全世界通用 以后还会继续扩充，不会停止 最新版(2019)只添加了一个字 —— 令和的合体字 （日本的新元号） 日文有很多合体字。如，「株式会社」被合成一个字；元号也都被合成一个字 缺点 两个字节不够用，每个字符要用三个及以上字节 这样所有文件都扩大50%，不划算 那怎么办？ 虽然用Unicode，但存的时候偷懒，这样行不行 UTF-8 就被发明出来了，还真行 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"UTF-8 Unicode 是字符集，UTF-8是编码形式 鸡贼的存法 英文用 1 个字节存，中文用 3 个字节存 存储「a」 a 对应的 Unicode 编号为 97，十六进制为61 Unicode 直接存：000000000000000001100001 UTF-8 偷懒存法：01100001 UTF-8 使得所有字母，从三字节变一字节，比 GBK 还省 存储「你」 你 对应的 Unicode 编号为 4F60（16位） Unicode 直接存：000000000100111101100000 UTF-8 偷懒存法：111001001011110110100000 还是三字节，没有省，但是字母都能省一点 UTF-8 中的 8 的意思是 最少可用 8 位，存一个字符。（可能用 8/16/24 位存一个字符） UTF-8 的规则 这一块看不懂就跳过，反正不考。记住去餐馆排队的比喻即可 以「你a」为例 11100100 10111101 10100000 01100001 如何知道上述内容表示什么字符？ 读 8 位信息 11100100 发现开头有3个1，就认为这个字符有3个八位 于是再往后读两个 8 位信息 10111101 10100000 10 表示当前这8位是跟着前面一起的 前面的 10 不要，其他合起来，得 0100 111101 100000 前面补8个0，这就还原为 Unicode 的「你」了： 000000000100111101100000 再读 8 位信息 01100001 发现开头是 0，就认为这个字符只占 8 位 前面补16个0，这就还原为 Unicode 的「a」 了： 000000000000000001100001 上面 4 个字节，存了两个字符。UTF-8 平均每个字符需要 2 个字节 Unicode 每个字符至少占 3 个字节，UTF-8 的存储方法更节省空间 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:6","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"终于搞清如何存字符了 全世界的字符，都是先把字符进行编号，然后存下编号（10进制变2进制） ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:7","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数字1 和 字符1 的区别 功能不同：数字1 可以进行运算，加减乘除… （ 字符只能相加 =\u003e 拼接字符 ） 存储形式不同：数字是转为二进制直接存储，字符需要经过编码变成数字再存储 数字1 ，最终存的是 1 字符1 ，最终存的是 49 ​ 既然字符也是存的数字，那么计算机怎么知道存的是字符还是数字呢？ 答：计算机并不知道这段0/1是字符还是数字。 但计算机可以通过看文件格式判断，如果是 .txt 那就全都是字符串，如果在 Excel 中存一个1 ，就是数字1 计算机并不知道用户存的0/1到底什么意思，但可以通过其他辅助信息得知（如后缀）或者其他方式约定（比如在文件开头约定：0表示数字，1表示字符串，2表示布尔值…这种方式）。 http 只支持字符串，在 html 中写一个1，就是字符串1 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:4:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"JS 中的数据类型 💡 7 种（大小写无所谓） 数字 number 字符串 string 布尔 bool 符号 symbol（JS 从 ruby 抄的，基本没人用） 空 undefined 空 null 对象 object 总结：四基两空一对象 bigint（新增第8种） 以下不是数据类型 数组、函数、日期、正则… 它们都是特殊的对象 object，所以它们都属于object ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数字 number number 是由64位(0/1)浮点数组成的 JS 的 number 全都是以小数（浮点数）的形式存储的，没有单独的整数 写法 整数写法 1 小数写法 0.1 科学计数法 1.23e4 （1.23×10^4^ ） 八进制写法（用得少） 0 或 00 或 0o 开头，就是 8进制 0123 或 00123 或 0o123 十六进制写法 0x3F 或 0X3F （用得少） 0x 或 0X 开头 二进制写法 0b11 或 0B11（用得少） 0b 或 0B 开头 特殊值 正0和负0 0分三种：0、+0、-0 都是 0，基本没什么区别 只在一种情况有区别（要严谨） 1/0 或 1/+0 =\u003e Infinity 1/-0 =\u003e -Infinity 无穷大 Infinity、+Infinity、-Infinity 无法表示的数字 NaN (Not a Number) 0/0 =\u003e NaN 但 NaN 仍是一个数字 NaN 永远不会和另一个 NaN 相等 NaN == NaN // false 64位浮点数 网道教程 JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 1 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的“位运算”部分。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 0.1 + 0.2 === 0.3 // false 0.3 / 0.1 // 2.9999999999999996 (0.3 - 0.2) === (0.2 - 0.1) // false 根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 … 为什么说【 number 是由 64位(0/1)浮点数组成的】 ？ （看↓图）一共（1+11+52）64 位，就可以表示 js 中的所有数字，包括小数、NaN … JS数字的存储形式 浮点就是浮动的点，意思就是小数点会乱动 123.456 可以表示为 1.23456 × 10^2^ ，也可以表示为 12345.6 × 10^-2^（0.01） 如果小数点可以浮动，那就是浮点数 也有定点数，就是指 有效数位、指数数位 都是固定的（少用） ​ ​ 64位存储一个 number 符号占1位 浮点数的第一位，0表示正号，1表示负号。「+0」的第一位是 0，「-0」的第一位是 1 指数占11位 指的是 10 的 n 次方，把这个 n 存到这11位里（11位可以存2048，因为有正负所以范围是 -1023~1024） 有效数字占52位（开头的 1. 省略） 10进制的小数，第一位永远可以为 1.xxx ，如 0.123 =\u003e 1.23 × 10^-1^ ​ 例：存 0.5 先将0.5转为二进制（看0.5是多少个二分之一，凑）=\u003e 1.0 × 2^-1^ 0.5是1个二分之一，所以 0.5 的二进制是 0.1 0.1存成64位形式 =\u003e 1.0 × 2^-1^ 正：0，负：1 指数部分（有正负） 有效数字（省掉第一个1.） 0 -1 0 ​ 例：存 0.625 看0.625有多少个二分之一（转为二进制，凑一下） 0.625 = 0.5 + 0.125 = 1/2 + 1/8 = 1×2^-1^ + 1×2^-3^ 所以 0.625 表示成 二进制就是 0.101 0.101 ↑ ↑ -1 -3 0.101存成 64位形式 =\u003e 1.01 × 2^-1^ 正：0，负：1 指数部分（有正负） 有效数字（省掉第一个1.） 0 -1 01 ​ 范围和精度 范围（忽略符号位） 指数拉满、有效数字拉满，得到最大二进制数字 Number.MAX_VALUE: 1.7976931348623157e+308 指数负方向拉满、有效数字最小 1，得到最小值 Number.MIN_VALUE: 5e-324 精度（有效数字） 最多只能到 52 + 1 个二进制位表示有效数字 2^53^ 对应的十进制是 9 后面 15 个零 所以 15 位有效数字都能精确表示 16 位有效数字如果小于 90 开头，也能精确表示 9110000000000001 就存不下来 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"字符串 string 字符串 string 在 JS 中，每个字符占两个字节（定长）。是阉割版的 UTF8。 因为 1995 年发布 JS ，当时 Unicode 并未流行，甚至还没有推出第一个可用版本。 写法 - 单引号 '你好' - 双引号 \"你好\" - 反引号 `你好` (ES6) 注意 引号不属于字符串的一部分，就像书名号不属于书名的一部分一样 如果要在单引号里面包含单引号怎么办? 错误写法 'it's ok' JS 引擎会认为 'it' 就结束了，后面的看不懂，可能就会报错 Chrome 中这种写法如果不报错，那就是 Chrome 的误导💩🤬 正确写法 'it\\'s ok' // 这就是转义 \"it's ok\" `it's ok` ​ 转义 用另一种写法表示你想要的东西 \\' 表示 ' \\\" 表示 \" \\n 表示 换行 \\r 表示 回车 \\t 表示 tab制表符 \\\\ 表示 \\ \\uFFFF 表示对应的 Unicode 字符 \\xFF 表示前256个 Unicode 字符（16进制） 例 '\\u4f60' =\u003e \"你\" '\\x31' =\u003e \"1\" （10进制的49转16进制为 31） '\\x32' =\u003e \"2\" '\\x33' =\u003e \"3\" ​ 多行字符串 如果你想要在字符串里回车 let s=`这样是 可以的 用【反引号】很容易做到` 以前没有反引号的时候 写起来很麻烦，是比较古老的知识，想了解可以看阮一峰的网道教程 ​ 字符串的属性 “ 等等，对象才有属性，为什么字符串也有属性 ” 记住一点：只有对象才有属性，字符串、数字、布尔是没有属性这么一说的 那为什么这里讲「字符串的属性」？（源于对象，学完对象才能解答） 字符串的长度 string.length '123'.length // 3 '\\n\\t\\r'.length // 3 （1个换行、1个tab、1个回车） '\\\\\\\\\\\\'.length // 3 （2个反斜杠表示1个\\） ''.length // 0 （空字符串） ' '.length // 1 （1个空格字符串） ' '.length // 2 （2个空格字符串） 字符串的下标 通过下标读取字符 string[index] let s='hello' s[0] // \"h\" 注意 index 从0开始 s[0]是第一个字符 注意 index 不到 length 一个字符串的最大 index 为 length - 1 let s='hello' s[5] // undefined 居然不报错 s[4] // 'o' ​ base64 转码 window.btoa 正常字符串转为Base64编码的字符串 window.atob Base64 编码的字符串转为原来的字符串 一般用来隐藏招聘启事里的简历 邮箱：YWJjZGVmZ0BnbWFpbC5jb20= 编码 window.btoa('abcdefg@gmail.com') // YWJjZGVmZ0BnbWFpbC5jb20= 解码 window.atob('YWJjZGVmZ0BnbWFpbC5jb20=') // abcdefg@gmail.com 有时候也用来自欺欺人 所谓的「加密」，也就能骗过一部分外行 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"布尔 boolean 真或假 只有两个值：true / false （全都小写） 下列运算符会得到 bool 值 否定运算 !value 相等运算 1==2、1!=2、3===4、3!==4 比较运算 1\u003e2、1\u003e=2、3\u003c4、3\u003c=4 if 配 bool if 语句常常需要判断真假 if(value){...} else {...} 问题来了 如果 value 是 bool 值还好说 如果 value 不是 bool 值咋办，谁真谁假 1 是真还是假，0 是真还是假 '1' 是真还是假，'0' 是真还是假 五个 falsy 值 falsy 就是相当于 false，但又不是 false 的值 分别是 undefined null 0 NaN '' // ''和' '不是一个玩意再次声明，请保持严谨 整个 JavaScript 中，除了上述 5 个 falsy 值 和 false 本身（6个假值）之外 其他任何值都是【真值】，包括数组、函数、对象… ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"undefined 和 null 两种空类型，空空如也 为什么有两个空 这就是 JS 的原创（💩）之处 其他任何一种语言，都只有一个空类型 区别 没有本质区别 细节一 如果一个变量声明了，但没有赋值，那么默认值就是 undefined，而不是 null 细节二 如果一个函数，没有写 return，那么默认 return undefined，而不是 null 细节三 前端程序员习惯上，把非对象的空值写为 undefined，把对象的空值写为 null 但仅仅是习惯上而已 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"symbol 符号 不怎么常用的数据类型（大概率完全不会用到） 直接看文章吧 更详细更权威的知识参考下面的自学链接。 自学链接： MDN： Symbol - JavaScript 阮一峰：ECMAScript 6入门 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"bigint （2020.6 新增） 2020 年 6 月 JS 新增了一种类型：bigint 关于 bigint 的详细介绍，请看 MDN。 目前 bigint 用得很少。面试也基本不考，工作中也较少用到。因为太新了。 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:6","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"变量声明 var / let / const ⭐️ 强烈推荐阅读：《我用了两个月的时间才理解 let》 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"三种声明方式 var a=1 let a=1 const a=1 a=1 区别 var 是过时的、不好用的方式 let 是新的，更合理的方式 const 是声明时必须赋值，且不能再改的方式 最后这种方式是错误的，不准这样声明 var 变量提升 押题时再讲，有兴趣可以提前看网道教程 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"var 声明 直接跳过 我们写代码不用 var 面试押题前单独讲解 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"let 声明 规则（特点） 遵循块作用域，即：使用范围不能超出 { } 不能重复申明 可以赋值，也可以不赋值 必须先声明，再使用。否则报错 全局声明的 let 变量，不会变成 window 的属性 for 循环配合 let 有奇效 例 1 // 遵循块作用域，使用范围不能超出{} { let b=1 // let声明的b只能作用在声明的这个{}里面 console.log(b) // 1 } console.log(b) // Uncaught ReferenceError: b is not defined // 报错：b未被定义 例 2 let a=1 let a=2 // Uncaught SyntaxError: Identifier 'a' has already been declared // 报错：标识符a已被声明 不能重复声明：在同一个作用域，只能有一个 a let a=1 { let a=2 // 这样是可以的。因为a是在{}中的，与{}块外面的a不算重复声明 } 例 3 let a // 声明时可以赋值，也可以不赋值 console.log(a) // undefined let b = true console.log(b) // true 例 4 // 必须先声明，再使用，否则报错 { console.log(b) // Uncaught ReferenceError: Cannot access 'b' before initialization let b=1 } // 报错：不能访问 b 在初始化之前 例 5 // 全局声明的 let 变量，不会变成 window 的属性 let abc='abc' console.log(window.abc) // undefined var abc = 'abc' console.log(window.abc) // 'abc' // 这其实是 var 的 bug 。为什么声明变量会变成 window 上的属性？这是var强加的 // let就改掉这个bug了，let就是单纯声明变量，不做多余操作 例 6 for(var i=0;i\u003c5;i++){ setTimeout(()=\u003e console.log(i),0) // 5 5 5 5 5 } for(let i=0;i\u003c5;i++){ setTimeout(()=\u003e console.log(i),0) // 0 1 2 3 4 } ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"const 声明 规则 跟 let 相同的点 遵循 { } 块作用域 不能重复声明 先声明后使用 不会变成 window 属性 跟 let 只有一条不同：声明时就要赋值，赋值后不能改 const 声明的是一个 只读变量，也叫做「常量」 例 // const声明变量，声明时不赋值，就会报错 const i // Uncaught SyntaxError: Missing initializer in const declaration // 报错：const声明中缺少初始化 // 声明后，又重新赋值，会报错 const i=100 i=101 // Uncaught TypeError: Assignment to constant variable // 报错：赋值给常量 // for循环中，修改变量值，会报错 for(const i=2;i\u003c5;i++){ // Uncaught TypeError: Assignment to constant variable // 报错：赋值给常量 setTimeout(()=\u003e console.log(i),0) // 2 } ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"指定值，同时也指定了类型 变量声明 指定了值，同时也指定了类型 但是值和类型都可以随意变化 var a=1 // number类型 a=2 a='字符串' ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"name 和 ‘name’ 的区别 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:7:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"name 是变量 变量，意味着「值」「类型」可变，可能是 ‘name’，也可能是 ‘hello’ 变量，存在内存的「不知道什么区」 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:7:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"‘name’ 是字符串、常量 「常量」就是不变量 ‘name’ 只能是 ‘name’ ，不能是其他值 字符串，存在「Stack 区」 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:7:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"类型转换 ⚡️ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"number =\u003e string String(n) // 前端通常不会用这种写法，太麻烦了 n + '' // 前端都是用这种 例 var n=1 console.log(String(n)) // 1 [黑色字符串] console.log(n+'') // 1 [黑色字符串] console.log(''+n) // 1 [黑色字符串] console.log(n) // 1 [蓝色数字] JS bug String(1000000) // \"1000000\" String(1000000000000) // \"1000000000000\" String(1000000000000000000000000) // \"1e+24\" （0变多，就变成科学计数法的字符串了） // 后来JS补救了：即使0变多，也不会转成科学计数法 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"string =\u003e number Number(s) parseInt(s) / parseFloat(s) s-0 / +s // 前端都是用这种最省事的写法 例 var s='123' console.log(Number(s)) // 123 [蓝色数字] console.log(parseInt(s)) // 123 [蓝色数字] 虽然显示的是整数，实际上是小数，number只有一种64位浮点数 console.log(parseFloat(s)) // 123 [蓝色数字] console.log(s-0) // 123 [蓝色数字] console.log(+s) // 123 [蓝色数字] console.log(s) // 123 [黑色字符串] JS bug // ES6之前，parseInt()自动识别：看到0开头就认为是8进制 parseInt('0123') // 83 (8进制的0123转为10进制 =\u003e 83) // 1*8^2+2*8^1+3*8^0=83 // ES6之后，parseInt()默认就是10进制 parseInt('0123') // 123 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"x =\u003e bool Boolean(x) !!x 例 // 把1/0变成布尔类型 Boolean(1) // true Boolean(0) // false // 上述方法，前端从来不用，太麻烦 // 前端直接用 !! （两次取反） 这种方法因为比较装B，所以在前端界比较流行 !!1 // true !!'aaa' // true （ !!aaa 不加引号就是变量，这里变量需要先声明才能使用） var obj={}; !!obj // true function foo(){}; !!foo // true !!0 // false !!NaN // false !!'' // false !!null // false !!undefined // false !!abc // abc is not defined var abc !!abc // false var abc=123 !!abc // true ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"x =\u003e string String(x) x.toString() 例 true.toString() // \"true\" false.toString() // \"false\" JS bug 1.toString() // 报错，js读到「1.」认为这是个小数，后面应该跟着数字，结果读到「t」，就直接报错 // 解决办法 (1).toString() // \"1\" 1 .toString() // \"1\" 1..toString() // \"1\" // 合法。js读到「1.」认为是 1.0 1.0.toString() // \"1\" ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"补充：JS 秘密花园 Google 搜索 「JS 秘密花园」，里面就讲了 JS 的各种奇葩事情 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"JS 的基本语法","date":"2020-08-24","objectID":"/javascript-basic-syntax/","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"内容包括「什么是表达式和语句」「标识符的规则」「 if else 语句」「 while for 语句」「 label 」 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:0:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"推荐书籍 适合入门《网道 JavaScript 教程》 适合进阶《你不知道的 JavaScript（上卷）》 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:1:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"JS 语法 ⭐️ 开始学习 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"表达式与语句 表达式 1+2 表达式的值为 3 add(1,2) 表达式的值为函数的返回值 console.log 表达式的值为函数本身（因为没加括号） console.log(3) 表达式的值为多少？（面试) 表达式的值就是函数的返回值 ，log函数的返回值为 undefined 所以 console.log(3) 表达式的值为 undefined 语句 var a=1 是一个语句 二者的区别 表达式一般都有值，语句可能有也可能没有 语句一般会改变环境（声明、赋值） 上面两句话并不是绝对的 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:1","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"大小写敏感 不要写错 var a 和 var A 是不同的 object 和 Object 是不同的 function 和 Function 是不同的 具体含义后面说 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:2","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"空格 大部分空格没有实际意义 var a = 1 和 var a=1 没有区别 加回车，大部分时候也不影响 只有一个地方不能加回车，那就是 return 后面 return 后面不加东西，js 会自动补充成 return undefined function fn(){ return 3 } function fn(){ return [undefined] // return 和 3 之间加了一个回车，js会自动补充为 return undefined 3 } 唯独 return 后面不能加回车，其他多离谱的回车都没问题 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:3","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"标识符 规则 第一个字符，可以是 Unicode 字母 / $ / _ / 中文 后面的字符，除了上面所说，还可以有数字 注意，首位不能是数字 var 9$ Uncaught SyntaxError: Invalid or unexpected token // SyntaxError意为语法错误，token理解成字符串 变量名是标识符 以下都是合法的标识符用法 var _ = 1 var $ = 2 var ______= 6 var 你好 = 'hi' 其他标识符用到再说 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:4","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"注释 谣言：“ 写代码要多写注释。” 注释，分为：好的注释、不好的注释 不好的注释 不好的注释：告诉别人我写了什么 把代码翻译成中文 可能埋没了重要的注释。有用的信息和噪音的比例（信噪比）要低 过时的注释 发泄不满的注释 好的注释 好的注释：告诉别人为什么我要这么写 踩坑注解 为什么代码会写得这么奇怪，遇到什么 bug 遇到某个 bug，代码非得这么奇怪的写，才能避开这个 bug（这种也需要注释出来） ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:5","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"区块 block 把代码包在一起 { let a=1 let b=2 } 常常与 if / for / while 合用 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:6","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"if 语句 如果 … 那么 … ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 if(表达式){语句1}else{语句2} { } 在语句只有一句的时候可以省略，不建议这样做 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:1","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"变态情况 (表达式) 里可以非常变态，如 a=1 const a=2 if(a=1){ console.log('a是1') // 最终打印这句，因为 = 是赋值，=== 才是判断是否相等 }else{ console.1og('a不是1') } 语句1 里可以非常变态，如嵌套的 if else 语句2 里可以非常变态，如嵌套的 if else 缩进也可以很变态，如面试题常常下套 const a=1 if(a===2) console.log('a') console.log('a等于2') 上述代码执行结果为：因为不写 { } 时，只默认第一个语句是跟随 if 条件的，有一个**无形的 { } **括住了第一句，相当于下面效果 const a=1 if(a===2) { console.log('a') } console.log('a等于2') 注：js 中是没有【行】的概念，即使两句写在一行，结果不变，仍是只括住第一个语句 const a=1 if(a===2) { console.log('a'); } console.log('a等于2') 如果用 逗号分隔呢？ const a=1 if(a===2) { console.log('a'), console.log('a等于2') } console.log('a???') 逗号，表示这句话没结束。所以默认两个 console 就变成一个语句了（效果如上） 分号；表示这句话结束了。 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:2","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"使用最没有歧义的写法 最推荐使用的写法 永远不要省略花括号 { }，即使只有一个语句。这是最不会产生歧义的写法 if(表达式){ 语句 }else if(表达式){ 语句 }else{ 语句 } 次推荐使用的写法 该写法，只在函数里有用 基于函数 return 的特点：执行 return ，函数就结束了，不再往下执行 function fn(){ if(表达式){ return 表达式 } if(表达式){ return 表达式 } return 表达式 } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:3","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"switch 语句 if…else…升级版 JS 的 switch 语句设计的不算精致，但确实在某些情况时，比 if…else… 好用 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:4:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 switch(fruit){ case \"banana\"： //... break； case \"apple\": //... break； default: //... } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:4:1","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"break **大部分时候，省略 break 你就完蛋了 ** 当条件符合 banana 时，执行某些语句 … ，遇到 break 跳出 switch 如果没有 break，就会向下跳过case 'apple'，直接执行 apple 的语句 … 看起来很鸡肋 少部分时候，可以利用 break 最早为什么这么设计 break 呢？ 是为了方便「 满足多个条件（case）时 」的判断 如下，case 1 可以默认贯穿到 case 3 （初衷是好的） ​ Swift 的 switch case 语句设计，完爆 JS 的 switch case （apple 出的语言） 执行完一个 case，默认跳出，无需 break 多条件判断：可以直接在一个 case 下写多个条件句 ，无需去掉 break 来表示贯穿 综上，JS 出现的太早了，没有抄到一个好的 switch case switch some value to consider { case value 1: respond to value 1 case value 2, value 3: respond to value 2 or 3 default: otherwise, do something else } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:4:2","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"问号冒号（三元）表达式 表达式1 ? 表达式2 : 表达式3 表达式 最简单的 if…else… 的写法，能用问号冒号就不用 if…else… // 求两个数的最大值 function max(a,b){ if(a\u003eb) return a; else return b; } function max(a,b){ return a\u003eb ? a: b } // 求绝对值 function abs(n){ return n\u003e0 ? n: -n } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:5:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"\u0026\u0026 短路逻辑 与运算 A \u0026\u0026 B \u0026\u0026 C \u0026\u0026 D 取第一个假值，后面就不看了 如果ABC都为真，就取 D。 一般整句表达式的值，不会出现取 true / false，而是取 ABCD 中的一个 只要整个表达式中，有一个是假，整个式子就是假 a\u0026\u0026b if(a){ // 理解：a\u0026\u0026b 等价于，如果a是真，就执行b，否则就什么都不执行 b }else{ } 例 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e5 \u0026\u0026 5 false 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e2 \u0026\u0026 5 5 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e2 \u0026\u0026 console.log('前面全对了') 前面全对了 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e2 \u0026\u0026 5\u003c0 false 例 if(window.f1){ console.log('f1存在') } // 上下效果等价：如果 window.f1为 true ，就会执行 conosole.log('f1存在') window.f1 \u0026\u0026 conosole.log('f1存在') 前端中，如果能写成 \u0026\u0026 的语句，就不写 if…else… 语句 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:6:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"最常见的用法 fn \u0026\u0026 fn() // 如果 fn 存在就执行 fn 例 console \u0026\u0026 console.log \u0026\u0026 console.log('hi') // 如果console存在，就判断console.log是否存在，也存在，就执行打印 hi /* 这么写有什么意义？ 因为 IE 没有 console，如果用 IE 就不执行 console，不然 IE 会报错 */ ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:6:1","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"|| 短路逻辑 或运算 A || B || C || D 取第一个真值，后面就都不看了。 如果ABC都为假，就取 D 一般整句表达式的值，不会出现取 true / false，而是取 ABCD 中的一个 只要整个表达式中，有一个是真，整个式子就是 真 a||b if(!a){ // 理解：a||b 等价于，如果a不是真，就执行b，否则就什么都不执行 b }else{ } 如果能写成 || 的语句，就不写 if…else… ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:7:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"最常见的用法 例：前端中经常有一个种写法 a = a || 100 // 理解：如果a存在就什么都不做，否则 a=100 if(a){ a = a // 自己赋给自己，相当于什么都不做 }else{ a = 100 // 保底值 } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:7:1","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"总结：条件语句 if … else… if…else…的逻辑是最常用的，但是很多情况并不使用它。代码简短时，会用更简便的代码替代这种写法 switch case 不能少了 break A ? B : C 相当常用（A若为真，执行B，A若为假，执行C） A \u0026\u0026 B 相当常用，举例：fn \u0026\u0026 fn() （ fn 存在就执行 fn ） A || B 相当常用，举例： A = A || B （A 存在时就什么都不执行，A 不存在时 B 就是 A 的保底值） ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:8:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"while 循环 用的不多 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 while (表达式) { 语句 } 判断表达式的真假 当表达式为真，执行语句，执行完再判断表达式的真假 直到遇到表达式为假，跳出循环，执行后面的语句 var a = 1 // 初始化 while(a !== 10){ // 判断条件 console.log(a) // 循环体 a = a+1 // 增长(为最终能跳出循环) } 共需要四部分： 1. 初始化 2. 判断条件 3. 循环体 4. 增长 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:1","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"其他 do … while 用得不多，自行了解 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:2","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"while 变态情况：死循环 while(a!==1){ console.log(a) a = a + 0.1 } 原因：浮点数不精确，导致死循环 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:3","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"for 循环 for循环 是 while循环 的语法糖 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法糖 for 是 while 循环的方便写法 写 while 时需要四部分： 1. 初始化 2. 判断条件 3. 循环体 4. 增长 for 将 while 的写法升级、整合，如下 语句1 是用来初始化的 表达式2 是判断条件 语句3 是自增 循环体 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:1","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 for(语句1;表达式2;语句3){ 循环体 } 先执行语句1 然后判断表达式2 如果为真，执行循环体，然后再执行语句3 如果为假，直接退出循环，执行后面的语句 例 for(var i=0;i\u003c5;i++){ console.log(i) // 0 1 2 3 4 } // i 5 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:2","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"变态 for(var i=0;i\u003c5;i++){ setTimeout(()=\u003e{ console.log(i) // 5 5 5 5 5 // console.log(i + '随机数' + Math.random()) },0) } // i 5 9 是 Chrome 的 bug。 5个5是正解。 每轮循环触发 setTimeout 相当于设置一个闹钟命令：过一会再执行 setTimeout 中的语句。而过一会之后，for循环已经走完，i 变为 5。然后闹钟到点，依次执行每轮触发的 setTimeout 中的语句，也就是执行 5轮 console.log( i ) ，就会打印 5 个 5 解决 把 var 替换成 let for(let i=0;i\u003c5;i++){ setTimeout(()=\u003e{ console.log(i) // 0 1 2 3 4 },0) } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:3","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法变形 for(语句1;表达式2;语句3){ 循环体 } 省略 语句 1 ，可在 for 循环外面定义变量 let i = 0 for(; i\u003c5 ; i++){ console.log(i) // 0 1 2 3 4 } 省略 表达式 2 ，会进入死循环 let i = 0 for(; ; i++){ console.log(i) // 0 1 2 3 4 5 6... } 省略 语句 2 \u0026 3 ，会进入死循环 let i = 0 for(; ; ){ console.log(i) // 0 0 0 0 0 0 0... } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:4","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"break 和 continue break 退出所有循环 continue 退出当前一次循环 for(var i=0;i\u003c10;i++){ if(i%2===1){ // 遇到奇数轮次，退出整个for循环 break } } console.log(i) // 1 for(var i=0;i\u003c10;i++){ if(i%2===1){ // 遇到奇数轮次，跳过当次循环 continue }else{ console.log(i) // 0 2 4 6 8 } } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:5","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"label 语法 用的很少，面试会考（概率5%） 这个知识点，除了用来做面试题之外，毫无用处 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:11:0","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 label 语法：在任何情况下，写一个[标识符](# 标识符)，后面写一个代码块 { }（通常包含多句代码），或一句代码 代码块 foo: { console.log(1); break foo; // 跳出foo这个代码块 console.log('本行不会输出') } console.log(2); 一句代码 foo: console.log(2) ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:11:1","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"面试 1 { foo: 1 } 2 foo: 1 // 表示代码块只有一行，叫做 1 console.log(2); 3 { foo: 1 // 一个代码块，第一行是一个标签，标签内容是 1，没有什么实际意义 console.log(2); } 问上面是什么 答： 是一个代码块（属于 label 语法），里面有一个标签 foo，语句就是一个 1 为什么不是一个对象？ 答：如果写成下面形式，a 就是对象了 var a = { foo: 1 } 如果单纯写一个代码块（如下），那就是一个 label，语句为 1 { foo: 1 } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:11:2","tags":["JavaScript","语法"],"title":"JS 的基本语法⚙️","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"JS 的历史","date":"2020-08-12","objectID":"/javascript-history/","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"简单了解「学 JS 的基本要求」，重点了解「JS 的诞生与历史」 ​ ","date":"2020-08-12","objectID":"/javascript-history/:0:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"一些链接 《Code Rush》纪录片，记录了 Firefox 开源的过程，里面有 JS 之父的采访 Chrome 的广告，让你了解 Chrome 有多快 淘宝天猫不再支持 IE 6/7 淘宝天猫不再支持 IE 8 百度指数 【JavaScript 诞生】相关文章： JavaScript 的历史 JavaScript 诞生记⭐ JavaScript 的10个设计缺陷 ​ ","date":"2020-08-12","objectID":"/javascript-history/:1:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"前端的门槛 从 JavaScript 开始，你需要绞尽脑汁了 ​ ","date":"2020-08-12","objectID":"/javascript-history/:2:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"学 JS 的基本要求 ","date":"2020-08-12","objectID":"/javascript-history/:3:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"软要求 对大脑的要求 一、逻辑能力 逻辑分很多种：抽象逻辑、符号逻辑、三段论逻辑（最常用）… 三段论逻辑 示例 JS的数据类型有 number / string / null / undefined / bool / symbol / object 【大前提】 JS的函数不是 number / string / null / undefined / bool / symbol 中的任意一种 所以，JS的函数是object 【根据前两句话，能推出第三句】 好处 写代码基本就是在编写逻辑 ​ 二、质疑自己的能力 程序员不要相信人类，包括你自己 质疑自己、推翻自己 出现 bug ，先质疑自己、再质疑机器 大脑中有6个知识点，通过这6个知识点，写出一个bug，可能某个知识点记错了，不要纠结，不要认死理，懂得质疑和推翻自己。直接把错误的知识点从大脑中擦掉，灌入正确的知识点，来更新你的知识 回想一下 你犯了多少错误 拼错单词 多写了空格、少写了空格 把 O 看成 0，把 0 写成 O 把 iOS 写成 IOS 或者 ios 这不是粗心大意，这是人类不可克服的问题，通过 double check 可以缓解 正着核对一遍，再反着核对一遍 ​ 三、抽象思维 高级程序员必备能力 什么是抽象能力 举例 你订了一份报纸 你关注了偶像明星蔡徐坤的微博 你用JS监听了一个按钮的点击事件 对程序员来说，这三件事是一件事，拥有共同的模式：发布订阅模式。 这就是抽象，把事物的特征进行快速总结。 多练，初级程序员至少锻炼1年，才能具备这种抽象思维。 具备看到一个事物，就能把它抽离成代码示例的能力。 好处 抽象思维，使你的代码能解决更多的问题 而不是兵来将挡、水来土掩，一个一个解决 新手程序员，遇到一个问题就写一段代码 高级程序员，将所有可能问题汇总，写一大坨代码解决全部问题 比如 Vue 和 React 的作者（一套框架解决问题） ​ ","date":"2020-08-12","objectID":"/javascript-history/:3:1","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"硬要求 客观上的要求 一、足够的代码量 达到 1000 行 - 新手 达到 10000 行 - 熟手（至少做过1个比较复杂的项目，常规项目都能做） 达到 50000 行 - 专业选手（至少做过2-3个比较复杂的项目，可能3-5年，看996时间积累） 只能靠时间积累 如何统计自己的代码行数 安装 yarn global add cloc cloc --vcs=git . 可以用来统计一个仓库里的有效代码 注意 如果仓库里有 node_modules 目录等不相关内容 需要把 /node_modules/ 写入 .gitignore 文件 ​ 二、了解足够多的概念 不仅要会写，还要会扯说（面试） 概览 常用常考 闭包、原型类、继承、MVC、Flux、高阶函数、前端工程化 只会用，不会说，面试就完了 如何积累 在课程中提炼 就是记笔记 面试如果能完整说出来，就是满分。新手能说出一般也达到要求了，面试新手就看思路对不对，不需要百分百实现 在大脑中思考 JS需要思考清楚，这些代码到底是在做什么。为什么这样设计、为什么这样用 学JS，必须把疑问直接搞定，不能一直留着，不然会有越来越多的 bug 在博客上总结 思考清楚了，一定要总结、记下来 用于面试 在代码中实践 ​ 三、有足够的踩坑经验 你以为是工作经验吗？ 踩坑经验 何谓专家 **“ 该领域内所有的错误都犯完的人，就是专家 ” ** 如何踩坑 做项目，而且是个人项目 个人项目的意思是所有代码都是你一个人写的 团队合作的大项目，基本上只有两个人做，其他人都是打酱油的 这样你才能全方位踩坑 ​ ","date":"2020-08-12","objectID":"/javascript-history/:3:2","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"总结 软要求 逻辑能力 质疑自己的能力 抽象能力 硬要求 足够多的代码（至少5000行，大项目1000-2000行，小项目200行左右） 足够多的概念 足够多的踩坑经验（记下来自己遇到过什么坑） ​ ​ ","date":"2020-08-12","objectID":"/javascript-history/:3:3","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 的历史 历史和特点 ","date":"2020-08-12","objectID":"/javascript-history/:4:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"发明人 李爵士发明 HTML 赖先生发明 CSS 布兰登发明 JS ​ 布兰登的生平 生平1961年生于美国 物理学转数学与计算机学位 工作七年，负责操作系统与网络开发 又工作三年，负责微内核与电子信号处理相关工作 1995年进入网景公司，为其浏览器开发了 JS 功能 1998年协助成立 Mozilla.org，担任首席架构师 网景死亡（被收购）后，他成立了 Mozilla 基金会，Firefox 就是这个基金会维护的，有纪录片记录了这一过程 2014年晋升为 Mozilla 的 CEO，十天后，被赶下台 原因是他曾捐助过反同性恋的法案（只有异性可结婚） 2015年成立 Brave 公司，开发保护用户隐私的浏览器 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:1","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"总结 牛逼的程序员 从来不会只学一门编程语言 不怕被辞退，总能找到事做 很容易创业，比外行人靠谱得多 可以干到 50 岁以上（基本上都是创办公司或很有钱了） JavaScript 诞生之初，只是一个不起眼的小功能 同时 JS 有很多 bug，我们学习的时候要注意辨别 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:2","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 的诞生 布莱登临危受命 公司要求给浏览器添加一个脚本功能 公司要求这个脚本必须蹭 Java 的流量 布莱登花十天设计了 JS 的最初版本（不是实现） JS的命名 Mocha 摩卡 =\u003e LiveScript =\u003e JavaScript Java 既是编程语言，也是一种咖啡 浏览器一开始同时就支持 Java 和 JavaScript 后来，JS 胜了（在浏览器上），Java就逐渐退出了浏览器平台 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:3","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"浏览器大战 背景：1995年，网景推出 JS 功能，用户纷纷叫好，因为可以在页面上节省流量。 当时的网速非常慢 2~3k/s，用户填写一个表单，点击提交按钮，等待一分钟才刷新页面，反馈结果。 有了 JS 功能之后，点击按钮，马上反馈用户表单信息是否正确，所以用户非常喜欢。 注意：此时的 JavaScript 只是网景提供的一个功能，并不是语言 微软的跟进 1996年8月 IE 3 发布，支持 JScript（微软实现的JS） 浏览器大战开始，每家浏览器的脚本不太一样 网景的反击 1996年11月，网景向 ECMA 提交语言标准，由于版权问题，JS 语言标准不叫 JavaScript，叫 ECMAScript ECMA 发音：ai ke ma ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:4","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"网景之死 被收购 微软的 IE 浏览器由于捆绑进了 Windows，很快超越 1998年，网景浏览器节节败退，公司陷入内忧外患 同年，公司打算搏一搏，将浏览器开源（Firefox） 最终，市场并没有因为开源而重新青睐网景 年底，[美国在线 AOL] 宣布开始收购网景 收购后，网景团队里的程序员纷纷被解雇 布莱登在之后一直协助维护 Firefox 的运营 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:5","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"IE 6 如日中天 你想象不到 IE 6 多么火 2001年，IE 6 随着 Windows XP 一起发布 2004年，IE 6 全球市场占用率 80% 以上 然而，这款浏览器却不兼容 W3C 标准（主要是 CSS) IE 6 也不断爆出安全漏洞 Firefox 打算涅槃重生，重新打败 IE 2005年，IE 7 发布，但打不过 IE 6 2006年，主流浏览器为 IE 6 和 Firefox 2010年，中国的大部分浏览器还是 IE 6 由于盗版 Windows XP 在中国的风行，在很多年里，IE 6 始终占据中国浏览器市场，是前端开发者的恶魔 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:6","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"IE 6 神奇的 bug 下面代码会让 IE 6 直接崩溃，当场死机 \u003cstyle\u003e * { position: relative } \u003c/style\u003e \u003ctable\u003e \u003cinput\u003e \u003c/table\u003e 补充： 「*{ } 星号性能低下」的谣言，就是从 IE6 这个 bug ，开始传出来的 实际上星号没有这个问题，这是 IE6 自己有问题 如果现在还有人说「星号性能低下」，不要反驳他，八九年前的事情现在还在说 星号套星号…可能有问题，但是一个星号，是绝对不会有问题的 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:7","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"Chrome 横空出世 微软的懈怠 由于 IE6 的巨大成功，微软觉得再花费精力不值得，而且没有竞争对手，所以直接解散了 IE6 开发团队 Firefox 的出现让微软重新组建 IE 团队，但不是同一队人，造成 IE7、8 一直问题不断 谷歌抓住机会 2004年，谷歌雇用了一些 Firefox 和 IE 的开发者 2008年，Chrome 终于发布，迅速拿下 1% 份额 2011年，Chrome 份额超过 Firefox 2016年，Chrome 全球份额 62% 欣赏一支 Chrome 的广告 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:8","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"移动市场兴起 智能手机崛起 2010年，iPhone 4 发布 2011年，微软 和 Nokia 联合起来，打算搞一波事情 后来的事情大家都知道，Nokia 手机业务完了 也就是说，手机上基本没有 IE 了 前端程序员表示欣喜若狂，IE 终于快要死了 2016年，淘宝天猫宣布不再支持 IE6、IE7 同年年底，宣布不再支持 IE 8 移动市场的兴起，让中国前端摆脱 IE 十年的恐怖支配 从此，前端快速，不对，是极速发展 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:9","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"ECMAScript 标准的制定 时间 1997年6月，第一版 ECMAScript 发布 1999年12月，第三版发布，这个版本使用最广（IE6支持） 第四版，流产。 2009年12月，第五版发布，增加了一些功能 2015年6月，第六版发布，新浏览器都支持这一版 之后每年发布一版，版本号以年份命名 JS 与 ECMAScript 的关系 ECMAScript 是纸上的标准，JS 是浏览器的实现 纸上标准往往落后于浏览器，先实现，再写进标准 ECMA 只总结，不预演，这样就不会再导致标准流产（写进标准但没浏览器使用的情况） ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:10","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 兴起 杀手级应用 Gmail 2004年愚人节，谷歌发布 Gmail 在线网页 当时的人们认为网页只能用来看新闻和图片 Gmail 的发布让用户和开发者（后端、客户端）眼前一亮 2005年，Jesse 将谷歌用到的技术命名为 AJAX 从此，前端技术正式出现 在此之前的网页开发，都是由 后端 和 设计师 完成 2006年，jQuery 发布，是目前最长寿的 JS 库 后来的十年，jQuery 大发异彩，直到 IE 不行了，jQuery 才稍微没有那么火 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:11","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"中国前端的发展 正式出现时间 2010年左右，中国才有专门的前端岗位 百度搜索指数 前端的来源 一部分来自自学的后端程序员，他们把 Java 的思想代入 JavaScript，面向对象成了JS的主流思想 一部分来自设计师，他们开始学习 CSS，并独创了「重构工程师」岗位（现已没落） 比如张鑫旭，专门研究CSS 上面这两种来源，一种赶鸭子上架，一种不够专业，导致前端特别缺人 缺人 最应该产出前端人才的大学，迟迟没有相关课程 由于早期前端工资比不上后端，所以大部分人选后者 就如同现在很多高材生选择机器学习一样 一些不小心进入前端领域的科班生成长非常迅速 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:12","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 爆发 V8 快如闪电 Chrome 的 JS 引擎叫做 V8（V1到V7是啥) 2009年，Ryan 基于 V8 创建了 Node.js 2010年，Isaac 基于 Node.js 写出了 npm 前端工程师可以在浏览器之外执行 JS 了，Node.js 快速风靡 例：node demo.js 同年，TJ 受 Sinatra 启发，发布了 Express.js 从此，前端工程师可以愉快地写后端应用了！ 爆发 这期间出来的技术太多，以后慢慢介绍：gulp、grunt、yeoman、requirejs、webpack、Angular、React、Vue等 这些技术很多也已经过时了 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:13","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"总结 JS 是历史的选择 一开始浏览器支持很多东西：Java、Flash、VBScript 只有 JS 活到最后 JS 的低开高走 一开始 JS 就是一个玩具语言 但是 JS 每次都走对了风口 JS 推出标准 Gmail 的出现（当时的网站只能看新闻，用户第一次体验到输入网址就能打开一个工具） 移动端 node.js 学习 JS 时需要注意 JS 最初也很混乱，旧的、过时的东西了解就好，考前记忆一些 跟 IE 相关的知识一律忽略 前端是进入互联网行业的捷径 ","date":"2020-08-12","objectID":"/javascript-history/:4:14","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["HTTP"],"content":"🤞🏻 Nobody knows HTTP better than me !! 🤗🤥","date":"2020-08-10","objectID":"/http-2/","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"🤞🏻 “Nobody knows HTTP better than me !! ” 🤥 ​ ","date":"2020-08-10","objectID":"/http-2/:0:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"先导 安装 Node.js 8+ 理解 IP 和 端口 理解 URL 路径和查询参数 ​ ","date":"2020-08-10","objectID":"/http-2/:1:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"演示 Node.js Server ⭐ ","date":"2020-08-10","objectID":"/http-2/:2:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"请求与响应模型 服务器，就是没有显示器的电脑 ​ ","date":"2020-08-10","objectID":"/http-2/:2:1","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"如何发请求 方法 用 Chrome 地址栏 用 curl 命令 概念 帮你发请求的工具叫做「用户代理」 如果使用 Chrome 地址栏发送请求，那么 Chrome 就是我们的「用户代理」 如果使用 curl 命令发送请求，那么 curl 就是我们的「用户代理」 「用户代理」 英文名 User Agent ​ ","date":"2020-08-10","objectID":"/http-2/:2:2","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"如何做出一个响应 ⭐ 用 Chrome 地址栏 或 用 curl 命令 ，可以发出一个请求 那么如何做出一个响应呢？（演示自己发请求-自己响应的过程） 需要用到编程 Node.js 有一个 http 模块可以做到 新建项目目录 node-demo / server.js，将下面代码粘入 ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ 代码细节先不管，直接复制使用。（注意这块目的不是学 nodejs，而是搞清楚 http 的请求和响应） var http = require('http') var fs = require('fs') var url = require('url') var port = process.argv[2] if (!port) { console.log('请指定端口号好不啦？\\nnode server.js 8888 这样不会吗？') process.exit(1) } var server = http.createServer(function (request, response) { var parsedUrl = url.parse(request.url, true) var pathWithQuery = request.url var queryString = '' if (pathWithQuery.indexOf('?') \u003e= 0) { queryString = pathWithQuery.substring(pathWithQuery.indexOf('?')) } var path = parsedUrl.pathname var query = parsedUrl.query var method = request.method /******** 从这里开始看，上面不要看 ************/ console.log('有个傻子发请求过来啦！路径（带查询参数）为：' + pathWithQuery) if (path === '/') { response.statusCode = 200 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(`二哈`) response.end() } else if (path === '/x') { response.statusCode = 200 response.setHeader('Content-Type', 'text/css;charset=utf-8') response.write(`body{color: red;}`) response.end() } else { response.statusCode = 404 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(`你输入的路径不存在对应的内容`) response.end() } /******** 代码结束，下面不要看 ************/ }) server.listen(port) console.log('监听 ' + port + ' 成功\\n请在空中转体720度然后用电饭煲打开 http://localhost:' + port) 注意事项 这些代码就是服务器代码，一般放在服务器上 path 是不带查询参数的路径 /x query 是查询参数的对象形式 {a:1} queryString 是查询参数的字符串形式 ?a=1 pathWithQuery 是带查询参数的路径，一般不用 request 是请求对象 response 是响应对象 \\n 表示回车 ​ 运行机制⭐ 在终端中启动应用： 运行 node server.js 未指定端口号，会有提示 按照提示执行即可 node server.js 8888 或者 node server 8888 这句话就意味着我们的电脑会开一个端口 8888，这个端口被 server.js 监听着 这时候只要有人请求了8888 端口，就会走入 server.js 的代码中，我们注释的那段代码就会运行一遍。每接收到一次请求，就运行一遍 用 curl 发出请求 curl http://127.0.0.1:8080/xxxx。server.js 接收到请求，会做出响应。 如果响应内容乱码，可能是 windows 系统的关系 添加路由 编辑 server.js 文件，添加 if else（限定条件，访问某个路径，响应对应内容） 重新运行 node server.js 8888（修改服务代码，需要重启） if (path === '/') { console.log('有人访问/了') response.end('这就是访问/，响应的内容\\n') // 回车\\n } 下面是，server.js 监听到 curl 命令 请求根路径时 执行的 console.log(…) 后台启动应用： touch log 创建一个 log 文件 node server.js 8888 \u003elog log 2\u003e\u00261 \u0026 返回的数字1144就是这个进程的 ID（目前这个进程已经在后台运行了） 运行后，服务器在后台启动，不占用当前终端 怎么关闭这个后台进程呢？ 执行 kill -9 xxxx xxxx为后台进程的 id数字 kill -9 是最厉害的杀进程的方法 ​ 代码逻辑 语法 `这种字符串` 里面可以回车 '这种字符串' 里面要回车，只能用 \\n 表示 逻辑 每次收到请求都会把中间的代码执行一遍 用 if else 判断路径，并返回响应 如果是已知路径，一律返回 200 如果是未知路径，一律返回 404 Content-Type 表示内容的「类型/语法」（省略后缀，程序员从来不看后缀😎，后缀只是用来告诉计算机要用什么软件打开文件） `text/html`、`text/css` path 不写 /x.css 而写 /x，因为 content-type 中已经声明了类型/语法，所以可省略后缀 .css response.write() 可以填写返回的内容（写入响应内容） 调用 response.end() 表示响应可以发给用户了（调用 response.end() ，就会将响应发送给浏览器） （ 以前不写 end 就会一直等待，现在可能优化了可以不写 end，严谨起见还是都写完整，明确告知可以响应给用户了 ） if (path === '/') { response.statusCode = 200 response.write(` \u003c!DOCTYPE html\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003clink rel=\"stylesheet\" href=\"/x\"\u003e // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 将 html 和 css 结合起来 \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e标题\u003c/h1\u003e \u003c/body\u003e `) response.end() } else if (path === '/x') { response.statusCode = 200 response.setHeader('Content-Type', 'text/css;charset=utf-8') response.write(`body{color: red;}`) response.end() } 如上图就是，通过 link 把 html 和 css 联系起来，成为一个网页，把这个网页通过 http 传送到浏览器上的整个过程：一个路径返回 html 字符串，一个路径响应 css 字符串。 这就是李爵士发明的 URL + HTTP + HTML ​ 注意符号 `` 反引号 `` 可以识别回车、语法 单引号 ‘’ 不能识别回车语法，仅作为字符串 ​ ​ ","date":"2020-08-10","objectID":"/http-2/:2:3","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"遥想当年李爵士 世界上第一个服务器程序 我们也写一个服务器程序 世界上第一个网页 我们在 / 路径返回一个 HTML 内容 然后在 /x 路径返回一个 CSS 内容 然后再 /y 路径返回一个 JS 内容 if (path === '/') { response.statusCode = 200 response.write(` \u003c!DOCTYPE html\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003clink rel=\"stylesheet\" href=\"/x\"\u003e ←←←←←←←←←←←←←← 引入 css \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e标题\u003c/h1\u003e \u003cscript src=\"/y\"\u003e\u003cscript\u003e ←←←←←←←←←←←←←←← 引入 js \u003c/body\u003e `) response.end() } else if (path === '/x') { response.statusCode = 200 response.setHeader('Content-Type', 'text/css;charset=utf-8') response.write(`body{color: red;}`) response.end() } else if(path === \"/y\"){ response.statusCode = 200; response.setHeader(\"Content-Type\", \"text/javascript;charset=utf-8\"); response.write(`console.log('这是JS内容')`; response.end(); } else { response.statusCode = 404; response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(`你输入的路径不存在对应的内容`) response.end() } 注意事项 关于后缀 即使写成 path === \"/y.css\" ，但如果在 Content-Type 中规定是 js 类型，就会按照 js 解析。所以，URL里的css 后缀卵用没有 Content-Type 才是决定文件类型的关键 ​ ","date":"2020-08-10","objectID":"/http-2/:2:4","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"体系化学习 HTTP 必须学会什么 基础概念（有哪些是必会的） 请求、响应 如何调试（用的是 Node.js，可以用 log / debugger ) 本质是学习 HTTP，所以不要在 Nodejs 花费太多时间，只需要搞懂 nodejs 怎么调试即可 在哪查资料（用的是 Node.js，所以看 Node.js 文档） 标准制定者是谁（ HTTP 规格文档：RFC2616（中文）等） 如何学 Copy-抄文档、抄老师 Run-放在自己的机器上运行成功 Modify-加入一点自己的想法，然后重新运行 ​ ","date":"2020-08-10","objectID":"/http-2/:3:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"HTTP 基础概念 必须点击 view source ，才能看到完整的请求、响应 ","date":"2020-08-10","objectID":"/http-2/:4:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"请求 请求动词 路径加查询参数 协议名/版本（所有请求都按照这个格式，简化版）例：GET /x?wd=hi HTTP/1.1 Host: 就是域名或 IP（包括端口号） Accept: text/html（表示浏览器想接收什么内容） 测：根据 accept 返回不同内容 var accept = request.headers['accept']; // 获取请求头中的 accept 的值，赋给变量 if(accept.indexOf('xml')){ response.write('我知道你想访问 XML 内容') }else{ response.write(`\u003c!DOCTYPE html\u003e\u003chtml\u003e...\u003c/html\u003e`) } 浏览器可接收的内容：accept。（大多来说浏览器就是接收 html） 默认先找 html，如果没有 html，可以接收 xhtml、xml、webp、png、igned-exchange（如下） Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0. Content-Type: 表示请求体的格式（例：text/javascript;charset=utf-8） 回车（划分请求头、请求体的界线） 请求体（也就是上传内容） 细节 请求有三部分，用回车隔开，分别是：（与 ↑↑ 对应颜色） 请求行（因为只有一行，所以叫请求行）GET /x?wd=hi HTTP/1.1 请求头 请求体（请求体的格式，是在 content-type 中指定的） 请求动词有 GET / POST / PUT / PATCH / DELETE 等 GET 用于获取内容 POST 用于上传内容 发送post请求：curl -v -X POST --data '上传内容' http://localhost:8888/ 请求体在 GET 请求中一般为空 因为get请求通常用于获取内容，而请求体表示要上传的内容，所以GET请求一般没有请求体 文档位于 RFC2616 第五章 大小写不敏感（随意），最好照着我的写 ​ ","date":"2020-08-10","objectID":"/http-2/:4:1","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"响应 协议名/版本 状态码 状态字符串 Content-Type: 响应体的格式 回车 响应体（也就是下载内容） 细节 响应有三部分，用回车隔开，分别是： 状态行（Status LIne） 响应头 响应体（响应体的格式，在Content-Type中指定） 常见的状态码是考点 200 成功 404 找不到 文档位于 RFC2616 第六章 ​ ","date":"2020-08-10","objectID":"/http-2/:4:2","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"用 curl 构造请求 ","date":"2020-08-10","objectID":"/http-2/:5:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"curl 用法 curl 可以用来改请求动词、查询参数，还可以改第二部分的请求头、第三部分的请求内容… 什么都可以改，请求的东西都可以由自己觉得 只不过需要按照 http 的标准来写 前提条件：server 要处于开启的状态：node server.js 8888 例：curl -v http://localhost:8888 设置请求动词 -X POST 例：curl -v -X POST http://localhost:8888 设置为post请求 注意大小写 设置路径和查询参数 直接在 url 后面加 例：curl -v -X POST http://localhost:8888/xxx?id=xxx 注：在 url 后添加 # 锚点是不会发送到服务器的 设置请求头 -H 'Name: Value' 或者 --header 'Name: Value' 例：curl -v -X POST -H 'Accept: text/html' http://localhost:8888 设置请求体 -d '内容' 或者 --data '内容' curl -v -X POST -H 'ABC: abc' -H 'Content-Type: text/plain;charset=utf-8' -d '请求体内容' http://localhost:8888 在请求体中设置一个 ABC: abc，没有实际意义但是成立的。 text/plain 表示上传的内容是纯文本，编码是 utf-8（中文），内容是’请求体内容’这5个字（每个字占2bytes） 总结：可以使用 curl 随心所欲的构造一个请求 ​ ","date":"2020-08-10","objectID":"/http-2/:5:1","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"用 Node.js 读取请求 读取请求动词 request.method console.log('method:', request.method) // method: GET ... 读取路径 request.url 路径，带查询参数 console.log('路径：', request.url) // 路径：/xxxx?wd=hihihi path 纯路径，不带查询参数 query 只有查询参数 读取请求头 **request.headers['Accept'] ** 读取请求头中的 Accept 值 console.log(\"请求头：\", request.headers) // 请求头：{ host:xxx, ???:???, ... } 读取请求体 比较复杂，先不讲 ​ ","date":"2020-08-10","objectID":"/http-2/:5:2","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"用 Node.js 设置响应 设置响应状态码 response.statusCode = 200 状态码可以任意设置，状态字符串会根据设置的状态码自动改变 但是状态码是有统一的使用规则的，如 200 规定就是表示请求成功时返回的状态码，所以不要随意改变 404 表示请求的网页不存在 。404 页面就是一个普通页面，是 Chrome 提供的，当访问页面不存在时提醒用户 设置响应头 response.setHeader(\"Content-Type\", \"text/html\"); 设置响应体 response.write(\"内容\"） 可追加内容 ​ ","date":"2020-08-10","objectID":"/http-2/:5:3","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"curl 的作用是什么 不单单是用来测试 http 的请求和响应。 curl 可以完成 Chrome 的大多基本功能，但 curl 通过命令行执行，所以不具有可视化能力 下载图片 curl 图片路径.jpg \u003e xxx.jpg （ 在命令行开启的目录中，下载图片并重命名为 xxx ） curl https://i.loli.net/2020/07/15/Q2dnHSgxCcbfhZW.jpg \u003e 3.jpg 测试 请求和响应 … curl 功能很强大，Chrome 的基本功能都可以实现，但不具有可视化 ​ ","date":"2020-08-10","objectID":"/http-2/:5:4","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"HTML / CSS / JS 的本质都是字符串 HTML / CSS / JS 的本质都是字符串，不是文件 本质上我们看到的网页，都是通过 html字符串 渲染的，html字符串 里面请求了 css字符串、js字符串 从演示的 server.js 中就能体现这一点 ​ ​ ","date":"2020-08-10","objectID":"/http-2/:6:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"console.log 调试大法 console.log（打印）这种调试方法，是在所有编程语言中都适用的 JS（console.log）、Java（print）、Python（print）、PHP（echo）… 语言/写法不一样，但原理相同 把可能有问题的代码，打印看看 debug 就是在不断质疑自己的过程 不要过分相信自己，而要相信 console.log() 可以告诉你对错 程序员每天都在问自己错在哪里 ","date":"2020-08-10","objectID":"/http-2/:7:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"URL 懂？！😵","date":"2020-08-04","objectID":"/http-1-url/","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"本文主要围绕 URL ，为学 HTTP 做个铺垫。 ​ ","date":"2020-08-04","objectID":"/http-1-url/:0:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"先导 ","date":"2020-08-04","objectID":"/http-1-url/:1:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"英语：protocol protocol /ˈproʊtəkɑːl/ 协议、礼节、约定 ","date":"2020-08-04","objectID":"/http-1-url/:1:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"李爵士发明的三样东西 WWW = URL + HTTP + HTML HTML 前面已经学了，html + css 本质就是网页 再认识了 URL 和 HTTP ，那么 WWW 我们就基本了解了（ URL 是为 HTTP 做铺垫） ​ ","date":"2020-08-04","objectID":"/http-1-url/:1:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"什么是 IP 要学习 URL 、HTTP，得先从 IP 讲起（⭐剧透：HTTP 的 P 和 IP 的 P 之间有重要联系） IP： Internet（因特网==互联网，整个人类组成的网络就叫互联网，比WWW更加底层）protocol（协议） 由此可见 IP 也是非常底层的，没有 IP 就不能上网 Internet Protocal 主要约定了两件事： 一、如何定位一台设备 二、如何封装数据报文，以跟其他设备交流 具体内容我们不关心 只要你在互联网中，你就有至少一个独特的IP ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"IP 分为内网和外网 内网和外网是不能直接相通的，只能通过路由器作为网关，来连通 路由器：是一个非常重要的设备，连通了内网和外网 例：比如你在玩 LOL，按了一下Q键（第一个技能），怎么让网线那头的对手被Q到？ Q 通过键盘传到路由器，路由器通过电信服务器传到 QQ 的游戏服务器， QQ 的游戏服务器接收到 Q 键后，就将 Q 键发送到对手那里，对手就被 Q 到了 整个过程是非常复杂的，但非常快，按下Q键立马响应，因为这个复杂的过程是以光速的形式来运行的，所以用户感受不到 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"如何获取外网 IP 必须有 外网IP 才能和小伙伴打 LOL、王者荣耀… 首先，你得从电信租用带宽，一年一千多。 （然后需要有个猫（调制解调器），猫是用来把信号转换成路由器能理解的信号。现在普遍是光猫，把光信号变成电信号，变成路由器能理解的网络信号） 你买了一个路由器，然后用电脑和手机分别连接路由器广播出来的无线 WIFl。 有线连接和无线WiFi在本质上没有不同，但在实际使用中，无线可能慢于有线连接 有线连接的下载速度可能超过 10M/s，但无线WIFI连接的设备的下载速度可能无法超过 10M/s 只要路由器连上电信的服务器，那么路由器就会有一个「外网 IP」 ，比如 [ 14.17.32.211 ] 就是一个外网 IP。这就是你在互联网中的地址。 访问 https://ip138.com/ 查看当前外网 IP（通常外网IP不要告诉别人，可以准确定位你的位置） 那么你的所有设备，就全都是这一个 外网 IP 那么如何区分是手机设备…还是笔记本呢？这就依靠「内网 IP」来区分了 但是如果你重启路由器，那么你很有「可能」被重新分配一个「外网 IP」，也就是说你的路由器没有「固定的外网 IP」 如果想固定外网IP ，需要花钱每个月五六千，可以得到一个固定的外网IP（在国内购买这些网络资源通常贵于国外） 但是有个问题，你的路由器的外网 IP 如果是 14.17.32.211，那么你的手机和电脑的 IP 又是什么呢？答案是「内网IP」 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"内网 IP 路由器会在你家里创建一个内网，内网中的设备使用内网IP，一般来说这个IP的格式都是192.168.xxx.xxx。 命令行：ipconfig ，查看当前设备的内网 IP ：192.168.101.10 默认网关中的 IP：192.168.101.1 是路由器的 IP 如果你家足够大，路由器可能功率不够，覆盖不了整个家，用户可能需要买电力猫或再买一个小路由器做中介器之类的手段，来扩大覆盖范围到整个家。 如果家里五六十平米，那路由器基本可以全覆盖。 一般路由会给自己分配一个好记的内网IP，如 192.168.1.1 小米路由器的 IP ，一般都是 192.168.31.1，为了让出一个位置给光猫的 IP 然后路由会给每一个内网中的设备分配一个不同的内网 IP，如电脑是 192.168.1.2，手机是 192.168.1.3，以此类推。 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"路由器的功能 把内网的请求，路由到外部，把外部的响应，路由到内部。具有双向路由的功能，所以也被称为网关 现在路由器有两个 IP，一个外网 IP（电信分配的）和一个内网 IP（自己分配给自己的） 内网中的设备可以互相访问，但是不能直接访问外网 内网设备想要访问外网，就必须经过路由器中转 外网中的设备可以互相访问，但是无法访问你的内网 外网设备想要把内容送到内网，也必须通过路由器 想从网上（外网）下载内容，会先把内容下载到路由器，路由器再把内容下载到用户的设备上 也就是说内网和外网就像两个隔绝的空间，无法互通，唯一的联通点就是路由器 所以路由器有时候也被叫做「网关] 一夫当关，万夫莫开。一旦把路由器拔了，那就与网络世界断联了 ​ 用 http-server 可以创建一个服务 命令行：http-server . -c-1 第一个地址 192.168.xxx.xxx:8080 ，是给手机访问的（需要手机端调试内容时，就可以使用） 第二个地址 127.0.0.1:8080 ，是给电脑访问的 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:4","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"几个特殊的 IP 分别是 127.0.0.1 表示自己（规定死的） localhost 通过 hosts 指定为自己 0.0.0.0 不表示任何设备 ​ 问：hosts 文件在哪？ 答： 在 Windows 系统中，hosts 位于 C:\\Windows\\System32\\drivers\\etc\\hosts 。在 macOS / Linux系统中，hosts 位于 /etc/hosts hosts 文件，用于指定本机 IP （表示自己） 127.0.0.1 / localhost 是 hosts 中默认的 （表示自己） 也可以在 hosts 文件中添加自定义 任何字符串 来表示自己（文件中的#内容均为注释，可删） 写法如下，定义后，就可以使用这些字符串来访问本地服务 + 127.0.0.1 sam + 127.0.0.1 ryuuks 注意：需要通过 http-server 开启本地服务后，下述地址才可以使用 http://localhost:8080/index.html http://127.0.0.1:8080/index.html http://sam:8080/index.html http://ryuuks:8080/index.html 上述地址，均可以访问到 index.html ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:5","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"端口 IP 有了，还需要什么？ 端口 WWW（万维网）= URL + HTTP + HTML URL 就是用来定位服务器的，例如，定位百度的服务器 baidu.com 一台机器可以提供很多服务 每个服务一个号码，这个号码就叫端口号port ","date":"2020-08-04","objectID":"/http-1-url/:3:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"端口 port 一个比喻 麦当劳提供两个窗口，一号快餐，二号咖啡 你去快餐窗口点咖啡会被拒绝，让你去另一个窗口 你去咖啡窗口点快餐结果一样 在计算机世界也是这样，你要提供不同的服务，就需要有不同的窗口。这个窗口，就是端口 port 一台机器可以提供不同服务 要提供 HTTP 服务最好使用 80 端口 要提供 HTTPS 服务最好使用 443 端口 要提供 FTP 服务最好使用 21 端口 一共有 65535 个端口（基本够用） ​ ","date":"2020-08-04","objectID":"/http-1-url/:3:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"我怎么知道应该用什么端口 维基百科一个一个列出来了，需要的时候就对应查找：每个端口用来做什么 端口 描述 80/TCP,UDP 超文本传输协议（HTTP）或 快速UDP网络连接- 用于传输网页 例如：百度服务器要给用户传输一个网页，那就必须用80端口，用其他端口会有问题 443/TCP 超文本传输安全协议（HTTPS）或QUIC HTTPS 协议传输就必须用 443 端口，用其他端口也会有问题 21/TCP,UDP 文件传输协议（FTP） - 控制端口 80后和早期的90后应该在学校见过FTP协议，传文件都是通过 FTP。95后00后可能没见过FTP了 ​ ","date":"2020-08-04","objectID":"/http-1-url/:3:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"端口使用还有什么规则 0 到 1023（2的10次方减1）号端口是留给系统使用的 普通用户绝对不能使用 即使是管理员有使用权限，但也需要输入额外的密码才能使用这些端口，所以也不推荐管理员使用 通常使用 8080 端口做开发，真正部署服务器时，拥有服务器权限才能用 80 端口… 你只有拥有了管理员权限后，才能使用这 1024 个端口 其他端口可以给普通用户使用 比如 http-server 默认使用 8080 端口 一个端口如果被占用，你就只能换一个端口 在其他端口开启服务 在 1234 端口开启服务 命令行：hs -c-1 -p 1234（hs：http-server 简写） http://192.168.101.10:1234 http://127.0.0.1:1234 通过访问 http://localhost:1234/index.html 就可以浏览本地页面 可否强行使用 80 端口，开启服务呢？🉑 仅在 windows 上能直接使用这个端口号，在 Linus 和 Mac 中都必须输入密码才能使用，不推荐 命令行：hs -c-1 -p 80 （在 80 端口开启服务） http://192.168.101.10:80 http://127.0.0.1:80 通过访问 http://localhost/index.html 就可以浏览本地页面（80 是默认端口，可省略） 端口被占用的情况，会有如下报错，换个其他的端口号即可（六万多个端口） hs -c-1 -p 80 =\u003e Error: listen EADDRINUSE 0.0.0.0:80 // EADDRINUSE: error address in use 错误地址正在使用中 hs -c-1 -p 1234 =\u003e Error: listen EADDRINUSE 0.0.0.0:1234 // error address in use hs -c-1 -p 2233 =\u003e http://192.168.101.10:2233 =\u003e http://127.0.0.1:2233 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:3:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"IP 和端口缺一不可 总而言之：IP 和 端口 缺一不可 （记住这句话） IP 是用来定位一个设备。 端口是用来定位一个设备的服务。 有了 IP 和端口，就可以定位一个设备提供的服务了。 例如：百度设备提供的网页服务。腾讯设备提供的聊天服务。淘宝设备提供的支付服务 这些服务都可以通过 IP + 端口 ，实现唯一确定 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:4:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"域名是什么 域名就是对 IP 起一个友好的名字。 域名是以 .com .net .org … 结尾的字符串，仅此而已。需要花钱购买 如：qq.com 在前面搭建个人博客时，已经注册过域名。 我没有自己的服务器，而是将这个域名映射到（指向） github 的服务器上 github 给我 4 个 IP。用户访问时，会访问到这4台中的任何一台服务器。访问的内容都是一样的 ​ 补充： .com 域名，比较便宜，一年50-80 t.tt，曾经是锤子手机的域名，转手价50W。访问 t.tt 跳转至锤子手机官网：smartisan.com 蔡文胜，2000年抢注十多万个域名，倒手生意。 qiyi.com 是百度旗下爱奇艺的域名 为什么我们需要向国外的人购买域名？发域名的机构也很赚钱。这就是美国人欧洲人赚钱的思维，我发明一套东西，用户都需要使用的，那使用一次就要交一次钱。 比如苹果有很多手机专利。谷歌买了摩托罗拉，摩托罗拉也有很多手机专利。谷歌发明了安卓系统，手机厂商用到安卓系统里面的谷歌服务，也需要给谷歌钱。 中国的 5G 出来了，如果以后世界的 5G 应用是由中国主导，关键技术是中国的，那么中国就可以躺着赚钱。如果中国的 5G 搞起来了，那就不单是 5G，周边的所有产业都会全面超过其他国家（所以川普联合各国抵制） 在互联网，每一个新东西出来，都蕴藏着巨大的商机。 如5G ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"域名就是对 IP 的别称 baidu.com 对应什么 IP 命令行：ping baidu.com 220.181.38.148 // 也有 39.156.69.79 qq.com 对应什么 IP 命令行：ping qq.com 125.39.52.26 知识点 先总结：IP 和 域名 之间，没有什么必然的一对一关系 一个域名可以对应不同 IP（这个叫 负载均衡） 这个叫做均衡负载，防止一台机器扛不住 一个 IP 可以对应不同域名（这个叫 共享主机） 比如6个人合买一台主机，这台主机服务6个域名 就叫做共享主机，穷开发者会这么做 或者一个公司提供不同的网站，但不想买两台服务器，就把两个网站（两个域名）放在同一台主机上 ​ 通常 ping 同一个域名，不一定会得到同一个 IP。这里涉及 负载均衡 的问题。 假如，一万人同时访问百度，如果只有一个服务器，就要同时接纳一万人。 如果有100万人同时访问，，即使每人只分配1k内存，也需要 100万 k，那么这台服务器肯定容纳不了 解决方法，把这个域名绑定到4个不同的 IP 上，4个 IP 分别位于 华中、华南、华东、华北。 电信有全国服务器，告诉电信，如果用户来自华中，就访问华中服务器…（1/4分流） 如此实现负载均衡。分散负担，不至于让某个服务器因承受不了而宕机。（网站优化策略） ​ 补充： ping 的作者写的一篇文章：The Story of the PING Program 皮卡丘站起来，是皮卡兵。皮卡丘跑起来是什么？答案 😂 ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"域名和 IP 是怎么对应起来的 通过 DNS Domain Name System （域名系统、域名服务） 当你输入 baidu.com 过程 你的 Chrome 浏览器会向电信/联通提供的 DNS 服务器询问 baidu.com 对应什么IP 电信/联通会回答一个 IP（具体过程很复杂，不研究） 这个过程可以用 nslookup 模拟（ns域名，lookup寻找）命令行：nslookup baidu.com 然后 Chrome 才会向对应 IP 的 80 / 443 端口发送请求 请求内容是查看 baidu.com 的首页 baidu 收到请求，就会把你请求的页面的 index.html 发送给你，index.html 中又会请求 css 、js，加载完css、js，就可以看到 baidu.com 的完整页面 ​ 在 network 中可以查看全部请求 Request URL: https://www.baidu.com/（末尾的 / 表示请求的是baidu的根目录） Response：[得到一个\u003chtml\u003e…\u003c/html\u003e]，浏览器就会把这一串 html 渲染出来（中间遇到 link 会请求对应的图片、css、js等文件） ​ 为什么是 80 或 443 端口？ 因为这是规定。 我们在地址栏输入 baidu.com 时，为什么不用写端口号？如 baidu.com:443 （ IP 和端口不是缺一不可吗！） 服务器默认用 80 提供 http 服务 服务器默认用 443 提供 https 服务 你可以在开发者工具里看到具体的端口 61.135.168.125:443 （ 前面就是服务器 IP ，后面就是网页服务的端口） 访问 http 就是 80，访问 https 就是 443 ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"题外话 前端需要懂点域名知识 www www.baidu.com 和 baidu.com 是同一个域名吗？不是 他们是什么关系 www.baidu.com 和 baidu.com com 是顶级域名（com 全写 company 公司，org 非营利性组织） baidu.com 是二级域名（俗称一级域名）父域名 www.baidu.com 是三级域名（俗称二级）子域名 他们是父子关系 github.io 把子域名 xxx.github.io 免费给你使用 所以 github.io（github公司）和 xxx.github.io（个人网站） 可能不是同一家公司，之间没什么关系 所以你应该知道 www.baidu.com 和 baidu.com 可以不是同一家公司，也可以是 www 是多余的吗？是的，非常多余。 早期人们为了表明自己是 www 而加的，实际上没有必要加，因为所有域名本身就存在与 万维网www中，写上www前缀反倒多此一举 ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"如何请求不同的页面 访问不同的路径，就请求到不同的页面，如下（注意：路径后面不加后缀） https://developer.mozilla.org/zh-CN/docs/Web/HTML https://developer.mozilla.org/zh-CN/docs/Web/CSS 工具 使用 Chrome 开发者工具 Network 面板看看区别 只有 Request URL 不同 ​ ","date":"2020-08-04","objectID":"/http-1-url/:6:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"同一个页面，不同内容 不同的查询参数，返回不同的内容 www.baidu.com/s?wd=hi www.baidu.com/s?wd=hello ​ ","date":"2020-08-04","objectID":"/http-1-url/:7:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"同一个内容，不同位置 锚点可以做到 https://developer.mozilla.org/zh-CN/docs/Web/CSS#参考书 https://developer.mozilla.org/zh-CN/docs/Web/CSS#教程 注意 锚点看起来有中文，实际不支持中文 #参考书 会变成 #%E5%8F%82%E8%80%83%E4%B9%A6 重新编码 锚点是无法在 Network 面板看到的，因为锚点不会传给服务器。 # 井号后面的内容会被浏览器直接吃掉，并不会传到服务器中 锚点仍在当前页面中，只是位置不同而已，并不需要重新请求数据 注意：一定不要把用户传参拼接到 # 后面，会被浏览器当做锚点内容直接吃掉，服务器就无法获取到参数 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:8:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"一个 URL 的完整内容 协议 + 域名 或 IP + 端口号 + 路径 + 查询字符串 + 锚点 协议：分 HTTP 和 HTTPS 域名：用来表示IP对应的名称的字符串 IP ：用来定位一个设备的字符串（分为4段，最大值255） 端口号：提供一个服务，就要有对用端口号（有六万多个） 路径：就是一个字符串，用来判断用户访问什么网页 查询参数：就是这个网页中，用户要具体看什么内容，可能有分页 锚点：内容已经获取到了，通过锚点定位到用户想要具体查看的内容的位置（实现文档内部的定位） 把上述全部加起来，就是 李爵士发明的 URL （统一资源定位符） URL U：Uniform 统一。国际化标准的 R：Resouce 资源。图片、网页…都是资源 L：Locator 定位符。 例： 就算没写，你也应该知道端口 HTTPS 默认端口 443、HTTP 默认端口 80 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:9:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"HTTP（协议） 前面讲了 IP 协议：是用于表示每个设备的地址 而 HTTP 协议：是用来表示如何传输网页的 HTTP协议，是基于 TCP 和 IP 两个协议 先有 TCP、IP，李爵士基于前人发明的这两个协议，发明了新的 HTTP 协议 ​ ","date":"2020-08-04","objectID":"/http-1-url/:10:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"curl 命令 curl /kɜːrl/ 使…卷曲 如何用 curl 命令，发出 HTTP 的请求？ ","date":"2020-08-04","objectID":"/http-1-url/:11:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"用 curl 可以发 HTTP 请求 示例1： curl https://www.baidu.com 执行命令，获取到整个文档。（中文默认 utf-8 编码，而控制台默认 GBK 所以中文会乱码） 我们在 Chrome 的地址栏中输入上述网址，Chrome 也是做了同样的事情，获取到这个html文档并解析 ​ 示例2： curl -v http://baidu.com 只有域名没有路径 -v ： verbose /vɜːrˈboʊs/ 啰嗦（效果：会显示更多内容） 请求的内容 我们发出的 HTTP 请求中，只有域名没有路径，则默认请求根路径，会自动补全根路径的斜杠 / 开启代理，使用了一些代理的功能（非必须） 问了DNS：获取到 baidu.com 的 IP 获取到 IP 后，就开始启动 TCP 开始连接到 baidu.com（ 220.181.38.148 这个 IP） 的 80 端口 连接成功，往 baidu.com 发送了这5行内容 GET请求，请求/根路径，使用 HTTP 协议 1.1 版本 因为一个IP（220.181.38.148）可能对应多个域名，说明需要访问的是这个IP上的 baidu.com 这个域名 说明我是用什么来访问的：用 curl 的 7.61.1 版本来访问的 期待返回什么内容：*/* 表示所有内容我都接收 空行（发送一个回车） 表示请求头部分结束 返回的内容 响应头：先忽略 😂 \u003chtml\u003e \u003cmeta …\u003e \u003c/html\u003e meta 中内容，意为请重新访问 http://www.baidu.com 说明 http://baidu.com 这个 URL 被弃用了，只使用这个最早就有的 URL www.baidu.com 通常直接使用 baidu.com 访问百度的人，基本都是程序员，将程序员的流量导到 www 上 上面请求失败，发起第二次请求 curl -v http://www.baidu.com ​ 示例3： curl -s -v -- https://www.baidu.com 会比上面显示的内容更详细 ​ ","date":"2020-08-04","objectID":"/http-1-url/:11:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"需要理解以下流程 url 会被 curl 工具重写，先请求 DNS 获得 IP 先进行 TCP 连接，TCP 连接成功后，开始发送 HTTP 请求 请求内容看一眼 响应内容看一眼 响应结束后，关闭TCP连接（curl 中没有直接写出来） 真正结束（只有TCP结束才是真正的结束） ​ ","date":"2020-08-04","objectID":"/http-1-url/:11:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"HTTP HTTP 到底做了什么 规定请求的格式是什么，响应的格式是什么 HTTP 规定了请求怎么写： 如何写第6步中的5行请求 HTTP 规定了响应怎么写： 如何写下面响应的内容 ​ 那么 HTTP 到底是怎么规定请求格式和响应格式的？ 下回分解 ✋ ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:11:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"习题 关于 www.baidu.com 和 baidu.com，正确的有（多选）答案 是同一个域名 是不同的域名 它们还有相同的一级域名 baidu.com 关于 hosts 文件，正确的有（多选） 答案 hosts 文件中以 # 开头的表示注释 hosts 中可以添加一行 127.0.0.1 sam，让 sam 成为 127.0.0.1 的别称 hosts 中可以添加一行 sam 127.0.0.1，让 sam 成为 127.0.0.1 的别称 hosts 一般需要用管理员权限才能编辑 HTTP 的英文全称是 ____（注意大小写不要错了） HyperText Transfer Protocol DNS 的英文全称是 ____（注意大小写不要错了） Domain Name System URL 包含哪些部分？（多选）答案 协议 域名或IP 端口 路径 查询参数 锚点 get 或 post ","date":"2020-08-04","objectID":"/http-1-url/:12:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-08-02","objectID":"/css-animation/","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"浏览器的渲染流程、transform、transition、animation ​ ","date":"2020-08-02","objectID":"/css-animation/:0:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"动画的原理 人脑的 bug ","date":"2020-08-02","objectID":"/css-animation/:1:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"动画 定义 由许多静止的画面（帧）， 以一定的速度（如每秒30张）连续播放时， 肉眼因视觉残象产生错觉， 而误以为是活动的画面。 概念 帧：每个静止的画面都叫做帧 播放速度：每秒24帧（影视）或者每秒30帧（游戏） ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:1:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"一个最简单的例子 ","date":"2020-08-02","objectID":"/css-animation/:2:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"将div从左往右移动 http://js.jirengu.com/bagow/1/edit?html,css,js,output JSBin 示例1 通过循环定时器 + 定位 + left 实现动画。控制每隔一小段时间增加 left 值，实现位移 JSBin 示例2 通过延时器 + 添加类名 + transition / transform 实现动画。控制添加类名 原理 每过一段时间（用setlnterval做到）， 将div移动一小段距离， 直到移动到目标地点。 注意性能 需要先搞懂：浏览器的渲染步骤，以及 每个属性会触发什么流程 绿色表示重新绘制（repaint）了 CSS渲染过程依次包含布局、绘制、合成 其中布局和绘制有可能被省略 ​ ","date":"2020-08-02","objectID":"/css-animation/:2:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"前端高手不用 left 做动画 用 transform（变形） JSBin 演示 原理 transform: translateX(0=\u003e300px) 直接修改会被合成，需要等一会修改 transition 过渡属性可以自动脑补中间帧 注意性能 需要先搞懂：浏览器的渲染步骤，以及 每个属性会触发什么流程 transform 优势在于，并没有 relayout（重新布局） 和 repaint（重新绘制）过程 transform 比 left 性能好很多（ 因为 left 会依次经过 relayout、 repaint、composite 3个过程） ​ ","date":"2020-08-02","objectID":"/css-animation/:2:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"如何查看性能 上述 JSBin 示例1/2两种方式，在性能上有什么区别 ？ 查看性能的方式 开启浏览器的【渲染 Rendering 】\u003e 【画图闪烁 Paint flashing】：突出显示需要重新绘制的页面区域（绿色） 如果元素发生的重新渲染（绿）的次数多，则更耗性能 示例1：使用 setInterval ，控制 left 实现动画 （位移全程 demo元素 都呈绿色：说明全程都在进行demo元素的重新渲染绘制） 示例2：添加类名，通过 transition + transform 实现动画 （刷新后，初次渲染呈绿色，移动过程没有发生重新渲染，移动结束的位置重新渲染一次） 总结：显然 ，示例1 更耗性能，全程都需要重新渲染 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:2:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"浏览器的渲染原理 既然讲到这里，提到了性能、渲染，那就深入了解一下 了解浏览器的渲染流程后，再回头看前面2个示例，可能会更好理解它们的不同 ","date":"2020-08-02","objectID":"/css-animation/:3:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"参考文章 Google 团队写的文章（右上角中文） 渲染树构建、布局及绘制 渲染性能 使用 transform 来实现动画 查看CSS各属性触发什么 CSSTriggers.com ​ ","date":"2020-08-02","objectID":"/css-animation/:3:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"浏览器渲染过程 浏览器在获取到 html 和 css 后做了什么？ 步骤 根据 HTML 构建 HTML 树（DOM） 根据 CSS 构建 CSS 树（CSSOM） 将两棵树合并成一颗渲染树（render tree） 根据渲染树，进行 Layout 布局（文档流、盒模型、计算大小和位置） 先定位：某个标签是否在文档流中…（文档流的概念非常重要！！） 定位后，要知道这个标签多高多宽、样式如何… Paint 绘制（填色：把边框颜色、文字颜色、阴影等画出来） Composite 合成（根据层叠关系展示画面） 三棵树 render tree 就是最终用户看到的树 ​ ","date":"2020-08-02","objectID":"/css-animation/:3:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"如何更新样式 ","date":"2020-08-02","objectID":"/css-animation/:4:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"一般我们用 JS 来更新样式 比如 div.style.background='red' 让内联背景变红色 比如 div.style.display='none' 让div消失 比如 div.classList.add('red') （小白才直接加样式，高手从来只加类名） 比如 div.remove()直接删掉节点 ","date":"2020-08-02","objectID":"/css-animation/:4:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"那么这些方法有什么不同吗 有三种不同的渲染方式 详细看下面 ↓↓ ","date":"2020-08-02","objectID":"/css-animation/:4:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"三种更新方式 使用 JS 来更新样式，要经过哪些步骤 ？ 下面有3种代码示例，配合开启浏览器渲染功能，清晰看到执行重新绘制（Paint）的元素 注意 JSBin 中最好全屏查看效果，在 iframe 里看可能有问题 第一种，流程全走一遍 div.remove() 会触发当前消失，其他元素 relayout 重新布局 第二种，跳过 layout 说明没有改变元素的位置和大小，不需要变动布局 比如说：只改变背景颜色，直接 repaint + composite 第三种，跳过 layout 和 paint 没有改变位置、大小，也没有改颜色，只需要合成 例如：只改变 transform，则只需 composite 合成 注意必须全屏查看效果，在 iframe 里看有问题 ​ ","date":"2020-08-02","objectID":"/css-animation/:4:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"每个属性触发什么流程 CSS变态之处来了：挨个尝试吧 还好，程序员喜欢分享 https://csstriggers.com/ 这个网站已经把所有属性全试过了 Blink：谷歌 Chrome 浏览器的内核（一般只看 Chrome 性能渲染） Gecko：火狐浏览器 Firefox WebKit：苹果 Safari 浏览器 EdgeHTML：微软 Edge 浏览器 现在可以解释 为什么 前端高手不用 left 做动画，而用 transform 做动画了 因为执行 left 会触发3个流程：先布局、再绘制、最后合成 而执行 transform 只会触发 1个流程：只合成 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:4:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"CSS动画优化 可以自己总结一篇博客。面试背不出来，可以让面试官去看博客 CSS 性能优化，除了把 left 变成 transform ，还有什么？ 面试可能考察，但这个问题没什么技术含量，就是背 ","date":"2020-08-02","objectID":"/css-animation/:5:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"没什么技术含量 答案都在 Google写的文章 里，谁看完谁牛 X 优化 JS 的执行 （JavaScript） 缩小样式计算的范围并降低其复杂性 （优化 Style 过程） 避免大型、复杂的布局和布局抖动（优化 Layout 布局过程） 简化绘制的复杂度、减小绘制区域（优化 Paint 绘制过程） 坚持仅合成器的属性和管理层计数（优化 Composite 合成过程） 上述每篇文章中的优化方法，都总结在【TL;DR（too long don’t read 太长不看）】部分 每条优化点之间，都没什么规律，就依靠死记硬背（面试问到，可能这些点，如果能答出1个，就得满分） ","date":"2020-08-02","objectID":"/css-animation/:5:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"JS优化 使用 requestAnimationFrame 代替 setTimeout 或 setInterval ","date":"2020-08-02","objectID":"/css-animation/:5:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"CSS优化 使用 will-change 或 translate（transform） ","date":"2020-08-02","objectID":"/css-animation/:5:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"没错 没错，完全就是死记硬背！ 如果面试官问，“ CSS 怎么优化 ”？（通常就是问动画怎么优化，性能上更低耗） 动画尽量使用 will-change 或 translate（transform），不直接使用 left JS 控制的动画中，尽量不使用 setTimeout 和 setInterval，而使用 requestAnimationFrame ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:5:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform 全解 MDN 上讲的非常详细 ","date":"2020-08-02","objectID":"/css-animation/:6:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform 四个常用功能 位移 translate（常用） 缩放 scale（常用） 旋转 rotate（做加载动画可能用到） 倾斜 skew（不常用） 经验 一般都需要配合 transition 过渡 inline 元素不支持 transform，需要先变成 block ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之translate 常用写法 可以写长度length和百分号percentage， ?表示可省略值 translateX(\u003clength-percentage\u003e) （横向） translateY（\u003clength-percentage\u003e) （纵向） translate(\u003clength-percentage\u003e,\u003clength-percentage\u003e?) 可省略第二个值，只写第一个值，默认x轴 translateZ(\u003clength\u003e) （垂直于屏幕的方向） 在三维世界中，才能看出 Z 的变化。 需要配合 perspective 属性，告知浏览器视点的位置 来形成三维。 例：perspective: 1000px 指视点在（位于画面中心）距离屏幕 1000 像素的位置上。 注意：是给父容器设置 perspective \u003cdiv class=\"wrapper\"\u003e \u003cdiv id=\"demo\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e #demo{ width: 100px; height: 200px; border: 1px solid red; margin: 50px; } #demo:hover{ transform: translateZ(50px); /* 元素在z轴（默认垂直屏幕方向）上的位置 */ } .wrapper{ perspective: 1000px; /* 形成三维构图，标注视点位置 */ border: 1px solid black; } \u003c/style\u003e translate3d(x,y,z) translate3d(50px,50px,200px); 同时设定3个轴上的位置 JSBin 演示 经验 要学会看懂 MDN 的语法格式 translate(-50%，-50%) 可做绝对定位元素的居中 #demo{ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) } ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之scale 常用写法 scaleX(\u003cnumber\u003e) scaleY(\u003cnumber\u003e) scale(\u003cnumber\u003e,\u003cnumber\u003e?) JSBin 演示 经验 用得较少，因为缩放容易出现模糊 border 也会跟随缩放 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之rotate 常用写法 rotate 默认以 Z轴为中心轴，进行转动 rotate（[\u003cangle\u003e|\u003czero\u003e]) 以Z轴为中心旋转 rotateZ([\u003cangle\u003e|\u003czero\u003e]) 以Z轴为中心旋转 rotateX([\u003cangle\u003e|\u003czero\u003e]) 以X轴为中心旋转 rotateY（[\u003cangle\u003e|\u003czero\u003e]) 以Y轴为中心旋转 rotate3d 太复杂，无法用语言表述 JSBin 演示 经验 一般用于360度旋转制作 loading 用到时再搜索 rotate MDN 看文档 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之skew 常用写法 skewX([\u003cangle\u003e|\u003czero\u003e]) skewY（[\u003cangle\u003e|\u003czero\u003e]) skew([\u003cangle\u003eI\u003czero\u003e],[\u003cangle\u003e|\u003czero\u003e]?) JSBin 演示 经验 用得较少 用到时再搜 skew MDN 文档 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:5","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform 多重效果 组合使用 transform: scale(0.5) translate(-100%, -100%); transform: none; 取消所有 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:6","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"实践：用 transform 做红心 ","date":"2020-08-02","objectID":"/css-animation/:7:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"跳动的心 JSBin ","date":"2020-08-02","objectID":"/css-animation/:7:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"心得 CSS需要你有想象力，而不是逻辑 CSS给出的属性都很简单，但是可以组合得很复杂 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003ebeating heart\u003c/title\u003e \u003cstyle\u003e *{ margin: 0; padding: 0; box-sizing: border-box; } #heart{ margin: 100px; position: relative; /*border: 1px solid black;*/ display: inline-block; transition: all .5s ease; } #heart:hover{ transform: scale(1.5); } #heart\u003e.bottom{ width: 50px; height: 50px; background-color: red; /*border: 1px solid red;*/ transform: rotate(45deg); } #heart\u003e.left{ width: 50px; height: 50px; background-color: red; /*border: 1px solid red;*/ border-radius: 50% 0 0 50%; transform: rotate(45deg) translateX(31px); position: absolute; bottom:100%; right: 100%; } #heart \u003e .right { width: 50px; height: 50px; background-color: red; /*border: 1px solid red;*/ border-radius: 50% 50% 0 0; transform: rotate(45deg) translate(0,30px); position: absolute; bottom: 100%; left: 100%; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"heart\"\u003e \u003cdiv class=\"left\"\u003e\u003c/div\u003e \u003cdiv class=\"right\"\u003e\u003c/div\u003e \u003cdiv class=\"bottom\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:7:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transition 过渡 学习资料：MDN ","date":"2020-08-02","objectID":"/css-animation/:8:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"作用 补充中间帧 已知开头位置，结尾位置，中间运动轨迹自动补齐 ","date":"2020-08-02","objectID":"/css-animation/:8:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"语法 transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性。 JSBin 示例 transition: 属性名 时长 过渡方式 延迟 transition: left 200ms linear 属性名是指要给哪个属性添加过渡效果 可以用 all 代表所有属性：width | height | left | right | margin-right …… transition: all 200ms 可以用逗号分隔两个不同属性 transition: left 200ms, top 400ms 时长 ：支持 秒 s 和 毫秒 ms 单位。0.5s 可以写成 .5s 过渡方式有：linear（线性匀速） | ease（默认值：缓动） | ease-in | ease-out | ease- in-out | cubic-bezier | step-start | step-end | steps 具体含义要靠数学知识 https://cubic-bezier.com/ 测试运动曲线 ","date":"2020-08-02","objectID":"/css-animation/:8:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"注意 不学常态，学变态 并不是所有属性都能过渡 一个元素，切换可见状态 使用 display: none \u003c=\u003e display: block 没法过渡，会闪现、闪隐【元素消失，不占位置】 使用 opacity: 0 \u003c=\u003e opacity: 1 透明度控制可见状态【可实现过渡效果，缺点是元素消失仍占位置】 推荐使用 visibility: hidden \u003c=\u003e visibility: visible （不要问为什么）【缺点没法过渡、元素消失仍占位置】 button.onclick = () =\u003e { demo.classList.add('end'); /* 解决隐藏后仍占位问题：延迟1s后，将元素删除 */ /* 方法一：使用延时器 */ setTimeout(() =\u003e { demo.remove(); } ,1000) /* 方法二: on事件可能有bug，推荐使用事件监听器 */ demo.ontransitionend = () =\u003e { demo.remove(); } /* on事件 */ demo.addEventLisener('transitionend', () =\u003e { demo.remove(); }) /* 事件监听器 */ } display 和 visibility 的区别 https://www.cnblogs.com/zrenj/p/9785835.html background 颜色可以过渡吗？可以 。 查看示例 opacity 透明度可以过渡吗？ 可以 。 查看示例 不推荐用透明度控制显示隐藏，推荐 visibility opacity: 0 \u003c=\u003e opacity: 1 可实现过渡效果，缺点是元素消失仍占位置，可通过 js 控制 remove() 该元素 ​ ","date":"2020-08-02","objectID":"/css-animation/:8:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"过渡必须要有起始 起始：指一个属性的开始是一个值，该属性的结尾也有一个值。这样才能实现某属性的属性值的变化过渡，中间过渡的效果浏览器会自动补充 一般只有一次动画，或者两次 一次：指只有进入动画 两次：①进入动画、②离开动画 比如 hover 和 非 hover 状态的过渡，就是两次动画 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:8:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"如果除了起始，还有中间点，怎么办 例如：从红色，先变黄色，最后再变绿色，怎么实现 有如下两种办法 ","date":"2020-08-02","objectID":"/css-animation/:9:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"方法① 使用两次 transform 流程： .a === transform ===\u003e .b 然后 .b === transform ===\u003e .c 如何知道到了中间点呢？ 用 setTimeout 或者监听 transitionend 事件。 给元素添加新的类名：执行第二段 transform 效果。 注意：第二段 transform 中必须包含第一段动画效果，不然执行第二段动画可能还原初始位置，有 bug，可自行测试。 JSBin 示例 ","date":"2020-08-02","objectID":"/css-animation/:9:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"方法② 使用 animation 声明关键帧 添加动画 JSBin 示例 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:9:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"animation 动画 ","date":"2020-08-02","objectID":"/css-animation/:10:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"提问 如何让动画停在最后一帧？ 搜索 css animation stop at end 网友给出的答案是：加个 forwards animation: xxx 1.5s forwards; JSBin 演示 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:10:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"@keyframes 完整语法 标准写法 搜索 keyframes MDN 讲得很清楚 一种写法是 from to ：只支持两种状态 另一种写法是百分数：支持添加 n 个帧状态 ​ ","date":"2020-08-02","objectID":"/css-animation/:10:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"animation 缩写语法 animation MDN animation 属性是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式。 Jirengu 视频讲解 JSBin 演示 animation: 时长 | 过渡方式 | 延迟 | 次数 | 方向 | 填充模式 | 是否暂停 | 动画名 ; /* 位置任意 */ 时长：1s 或者 1000ms 过渡方式：跟 transition 取值一样，如 linear 。默认是 ease 先快后慢 延迟时间：1s 或 1000ms 次数：3 或者 2.4 或者 infinite（无限次） 方向：reverse | alternate（交替，非常适合做加载动画） | alternate-reverse 填充模式：none | forwards（保持在动画终点位置） | backwards | both 是否暂停：paused | running pauseBtn.onclick = () =\u003e { demo.style.animationPlayState = 'paused' } /* 点击按钮，暂停demo元素的动画 */ 更多属性值的效果，需要自己尝试。JSBin 演示 以上所有属性都有对应的单独属性 **animation** 只是这些单独属性的**缩写**，上述效果可以通过单独的属性设置\r ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:10:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"实践：用 animation 做红心 JSBin 示例 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003ebeating heart-animation\u003c/title\u003e \u003cstyle\u003e * { margin: 0; padding: 0; box-sizing: border-box; } @keyframes beating { 0% {transform: scale(1)} /*25% {transform: scale(1.25)}*/ /*50% {transform: scale(1.5)}*/ /*75% {transform: scale(1.25)}*/ 100% {transform: scale(1.5)} } #heart { /*border: 1px solid black;*/ display: inline-block; position: relative; margin: 100px; } #heart:hover { animation: beating .5s ease infinite alternate; } #heart \u003e .left { position: absolute; bottom: 50px; left: -50px; width: 50px; height: 50px; /*border: 1px solid red;*/ background: red; border-radius: 50%; transform: rotate(45deg) translateX(43px); } #heart \u003e .right { position: absolute; bottom: 50px; right: -50px; width: 50px; height: 50px; /*border: 1px solid red;*/ background: red; border-radius: 50%; transform: rotate(45deg) translateY(45px); } #heart \u003e .bottom { width: 50px; height: 50px; /*border: 1px solid red;*/ background: red; transform: rotate(45deg); } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"heart\"\u003e \u003cdiv class=\"left\"\u003e\u003c/div\u003e \u003cdiv class=\"right\"\u003e\u003c/div\u003e \u003cdiv class=\"bottom\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-08-02","objectID":"/css-animation/:11:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-29","objectID":"/css-position/","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"复习盒模型、div 的分层、新属性 position 详解、层叠上下文 ​ ","date":"2020-07-29","objectID":"/css-position/:0:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"布局和定位的区别 区别大了 布局是屏幕平面上的 定位是垂直于屏幕的 ​ ","date":"2020-07-29","objectID":"/css-position/:1:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"CSS 定位 还得从文档流和盒模型说起（两个非常重要的概念） ​ ","date":"2020-07-29","objectID":"/css-position/:2:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"复习盒模型 margin 外边距、border 边框、padding 内边距、content 内容 background 背景 ","date":"2020-07-29","objectID":"/css-position/:3:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"问两个问题 背景的范围是从哪到哪？ 【A】border 内边沿围成的区域 ？【B】border 外边沿围成的区域 ？ 如何验证自己的猜想？ border 半透明试试，答案是【B】 注意：在浏览器的元素样式中，可通过 【alt + 上下方向键】，对半透明数值进行 0.1 的 ± 调整 从左边看一个 div，是什么样子？ 元素是有层叠关系的，脑内模拟一个三维立体结构，从左边看一个 div，是什么样子？ background 在文字后面然后呢？ 如何验证自己的猜想？用代码证明即可。 \u003cdiv class=\"demo\"\u003e \u003cspan class=text\u003e你好\u003c/span\u003e \u003c/div\u003e \u003cstyle\u003e .demo{ box-sizing: border-box; border: 5px solid red; width: 100px; height: 100px; background: blue; } .text{ font-size: 100px; /* 让字足够大，测试字能否覆盖住border */ color: green; } \u003c/style\u003e 结论： 文字在最上层，中间是 border，最底层是 background 背景 ​ ​ ","date":"2020-07-29","objectID":"/css-position/:3:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"代码验证：一个 div 的分层 三维立体模型 （SketchUp） 先给出结论（三维图），再在下面进行代码验证 ​ ","date":"2020-07-29","objectID":"/css-position/:4:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"块级子元素与内联子元素的分层位置 让块级元素与内联元素，出现重叠，就可以判断哪个层级更高 \u003cstyle\u003e .demo{ background: rgb(120,184,211); width: 200px; height: 200px; border: 15px solid red; padding: 10px; } .childDiv{ background: white; height: 50px; margin-top: -10px; /* 测试块级元素与文字的分层位置，将div向上移动，与文字重叠，看是否会遮挡文字 */ } \u003c/style\u003e \u003cdiv class=\"demo\"\u003e 文字内容 \u003cdiv class=\"childDiv\"\u003e\u003c/div\u003e \u003c/div\u003e 如上，“文字内容” 和 div.childDiv 属于同级关系 结论： 块级元素位于文字下层 ​ ","date":"2020-07-29","objectID":"/css-position/:4:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"浮动子元素与内联子元素的分层位置 \u003cstyle\u003e .demo{ ... } .float{ float: left; background: white; height: 50px; width: 50px; margin-right: -10px; /* 测试浮动元素与文字的分层位置，将浮动元素向右移动，与文字重叠，看是否会遮挡文字 */ } \u003c/style\u003e \u003cdiv class=\"demo\"\u003e 文字内容 \u003cdiv class=\"float\"\u003e\u003c/div\u003e \u003c/div\u003e 结论： 浮动元素位于文字下层 ​ ","date":"2020-07-29","objectID":"/css-position/:4:2","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"浮动子元素与块级子元素的分层位置 \u003cstyle\u003e .demo{...} .float{...} .childDiv{ height: 50px; background: orange; margin-top: -10px; } \u003c/style\u003e \u003cdiv class=\"demo\"\u003e 文字内容 \u003cdiv class=\"float\"\u003e\u003c/div\u003e \u003cdiv class=\"childDiv\"\u003e\u003c/div\u003e \u003c/div\u003e 结论： 浮动内容（脱离文档流），高于 childDiv（普通文档流元素），低于文字 所以，==脱离文档流==，实际上就是从普通文档流中跳出，比文档流的层级稍微高一点 ​ ","date":"2020-07-29","objectID":"/css-position/:4:3","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"结论 文字内容层级最高，代码写在下面的文字内容，会覆盖上面的 只有浮动元素会脱离文档流（从普通文档流中跳出），比普通文档流的层级稍高 ​ ​ ","date":"2020-07-29","objectID":"/css-position/:4:4","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"新属性 position ","date":"2020-07-29","objectID":"/css-position/:5:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position 取值 static 默认值，当前元素待在文档流里 relative 相对定位，升起来，但不脱离文档流 absolute 绝对定位，定位基准是相对于祖先里的非 static 祖先进行定位 fixed 固定定位，定位基准是 viewport 视口 有诈：后来 css 出的 transform 属性，使 fixed 无法相对 viewport 视口定位，这就是 CSS 的不正交 sticky 粘滞定位，不好描述直接举例 ↓↓ 特别适合做导航：正常状态会存在于文档流中，当向下滚动到 sticky 元素且 sticky 元素即将移出视口时，sticky 元素会始终保持在视口顶部，不会随文档流继续滚动。 兼容性特别差，可以在 caniuse 中查询。 （黄色是需要加前缀or部分支持） ","date":"2020-07-29","objectID":"/css-position/:5:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"经验 如果你写了 absolute，一般都得补一个 relative 如果你写了 absolute 或 fixed，一定要补 top 和 left sticky 兼容性很差，主要用于面试装逼 ​ ","date":"2020-07-29","objectID":"/css-position/:5:2","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position: relative 使用场景 用于做位移（很少用），将两个元素对齐 用于给 absolute 元素做爸爸 配合 z-index z-index: auto 默认值，不创建新层叠上下文 z-index: 0/1/2 z-index: -1/-2 经验 写 z-index: 9999 的都是 菜B 要学会管理 z-index ​ ​ ","date":"2020-07-29","objectID":"/css-position/:5:3","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position: absolute 使用场景 脱离原来的位置，另起一层，比如对话框的关闭按钮，通常是通过绝对定位实现的 鼠标提示 \u003cdiv style=\"height:100px;\"\u003e\u003c/div\u003e \u003cbutton\u003e 点击 \u003cspan class=\"tips\"\u003e提示内容\u003c/span\u003e \u003c/button\u003e \u003cstyle\u003e button{ position: relative; } button span{ position: absolute; border: 1px solid red; white-space: nowrap; bottom: calc(100% + 10px); left: 50%; transform: translateX(-50%); } button span{ display: none; } button:hover span{ display: inline-block; } /* 鼠标悬浮时，显示span */ \u003c/style\u003e 配合 z-index 经验 很多 菜B 都以为 absolute 是相对于 relative 定位的 absolute 是相对于 祖先元素中最近的一个定位元素 只要 position 属性值不是 static 的元素，就是定位元素 某些浏览器上，如果写了 absolute，不写 top / left / bottom / right 会位置错乱 （4个至少写2个） .demo{ position: absolute; top: 0; left: 0; } 善用 left: 100% （效果通常是该元素会出现在定位元素的最右边） 善用 left: 50%; + 加负 margin （负宽度的一半）：实现居中 也可以用 left: 50%; + transform: translateX(-50%); 实现，优点是不需要自己计算宽度的一半 ​ ​ ","date":"2020-07-29","objectID":"/css-position/:5:4","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position: fixed fixed 是相对于【视口】定位的 视口，就是浏览器中普通用户能看到的部分（不包括滚动条） 使用场景 烦人的广告 回到顶部按钮 配合 z-index 经验 如果 fixed 元素所在的容器，具有某些属性，可能会导致 fixed 元素不再相对于视口定位。 .container{ position: relative; } .container \u003e .fixed{ position: fixed; left: 10px; bottom: 10px; } .container{ transform: scale(0.9); } /* 此时fixed元素就不再相对于视口定位 */ 总结：不要把 fixed 元素放到 具有 transform 属性的容器中，可能会产生奇怪的bug（不正交：调这个元素却影响了另一个元素） 手机上尽量不要用这个属性，坑很多，无穷无尽的bug。不信你搜索一下「 移动端 fixed 」 用了，可能就开始996了。一个bug可能引出10个bug ​ ​ ","date":"2020-07-29","objectID":"/css-position/:5:5","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"层叠上下文 ","date":"2020-07-29","objectID":"/css-position/:6:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"div分层 与 position 任意一个元素的 position 取值非 static 时，就成为了定位元素。定位元素的层级，立马超越内联文字，成为最上层元素（跑到所有元素最上层） z-index，默认是 auto 所有定位元素，会以内联文字层为底层，随着 z-index 递增，层级也会递增 如果 z-index 为负值，则层级比 background 还低 （可以无限向下，但是不能低于层叠上下文，也就是不能低于 html ，低于html还有什么意义） ","date":"2020-07-29","objectID":"/css-position/:6:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"什么是层叠上下文 也叫堆叠上下文 层叠上下文，会把所有元素包起来。 默认的层叠上下文，是 html 元素，html 就是会把所有元素包起来 其他元素，也会因为拥有某些属性而变成层叠上下文（导致 z-index 需要重新计算） ​ 比喻 层叠上下文对 z-index 的影响 每个层叠上下文就是一个新的小世界（作用域） 这个小世界里面的 z-index 跟外界无关 处在同一个小世界的 z-index 才能比较 JSBin 示例 a 和 b2 处于同一个层叠小世界，由 container 创造的，如果 container 没有设定 z-index，那么 a 和 b2 就同处于 html 的作用域里面，是具有可比性的。 ​ 哪些不正交的属性可以创建层叠上下文 最简单的就是定位元素设置 z-index = 0 ，就会创建一个层叠上下文 MDN文档有写 文档根元素 html 自成一个层叠上下文 z-index 不为 auto 的定位元素，会开启一个小世界（作用域） 元素的 opacity 小于1，就会创建一个层叠上下文（因为 opacity 会影响内部所有元素） position: fixed; 一定会创建层叠上下文 … 需要记忆的有： z-index=0时会创建层叠上下文 flex元素内部会形成层叠上下文 opacity 不为1 ，就会创建层叠上下文 具有 transform 的元素，会形成一个 层叠上下文 知道这些知识的面试官也不太多，不用花时间背 忘了就搜「 层叠上下文 MDN 」 你说 CSS 为什么不单独创建一个属性做这个事 例如： xxxdisabled: true; /* true就创建层叠上下文，false就不创建；css并没有这种直接功能开关*/ 这就是css的难学之处，互相交叉影响，错综复杂（不正交） ​ ​ ","date":"2020-07-29","objectID":"/css-position/:6:2","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"负 z-index 与层叠上下文的关系 JSBin 示例 .demo 的 z-index = -1，会使 demo 出现在文档流的 bg 的后面 z-index 是默认 auto 时，不具有层叠上下文 记住 ：负 z-index 逃不出 层叠上下文的小世界 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"demo\"\u003e\u003c/div\u003e \u003c/div\u003e .container{ background: rgba(0,255,255,0.5); height: 200px; position: relative; /* z-index 是默认 auto 时，不具有层叠上下文，所以添加z-index=0，创建层叠上下文 */ z-index: 0; /* 注释这行看看 */ } .container \u003e .demo{ width: 50px; height: 50px; background: red; position: absolute; z-index: -1; /* 因为上面z-index:0创建了层叠上下文，所以demo无法逃出这个小世界，不可能比container低 */ } 图一：当 container 不是层叠上下文（也就是没有 z-index: 0; ）时，demo 是 z-index = -1 存在于容器bg之下 图二：当 container 创建层叠上下文，demo 就无法跳出容器之外 ​ 总结： z-index = -1 不一定存在于容器的背景之下。当这个容器是一个层叠上下文时，就不可能存在于容器之外 ","date":"2020-07-29","objectID":"/css-position/:6:3","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-26","objectID":"/css-layout-2/","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"CSS 布局篇（下）：Grid 布局。 ​ ","date":"2020-07-26","objectID":"/css-layout-2/:0:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"如何在两套布局中切换 一个css中，写两种布局，使用 @media 媒体查询来切换 ​ ","date":"2020-07-26","objectID":"/css-layout-2/:1:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"Grid 布局 Grid 布局兼容性并不好，在一两年内都可能不会非常广泛的使用（现在可以不用学的那么仔细） 但功能确实非常强大 flex 更擅长 一维布局，要么横着布局，要么竖着布局 一维布局用 Flex ​ ","date":"2020-07-26","objectID":"/css-layout-2/:2:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"二维布局用 Grid 以下内容主要来自 CSS Tricks 的一篇文章 A Complete Guide to Grid 查看本地代码 ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"Grid 也分 container 和 items 分别记忆 ","date":"2020-07-26","objectID":"/css-layout-2/:3:1","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"成为 container .container{ display: grid | inline-grid; } ","date":"2020-07-26","objectID":"/css-layout-2/:3:2","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"行和列 类似 table 表格（grid 被称为新时代的表格） .container{ display: grid; grid-tamplate-columns: 40px 50px auto 50px 40px; /* 每列宽度（有n个值对应生成n列） */ /* 第1列 第2列 第3列 第4列 第5列 */ grid-tamplate-rows: 25% 100px auto; /* 每行高度（有n个值对应生成n行） */ /* 第1行 第2行 第3行 */ } [1] [2] [3] … [6] 指的是线的序号。用于划分 items 的范围（具体使用见 items 部分 ） ​ 缩写 grid-template grid-template是grid-template-rows（行高）和grid-template-columns（列宽）的缩写形式。 比如说，grid-template: 50% 50% / 200px;将创建一个具有两行的网格，每一行占据50%，以及一个200像素宽的列。 /* 需要包括你的花园上部的60%，以及左侧的200像素。 */ #garden { display: grid; grid-template: 60% 40% / 200px calc(100% - 200px) ; /* 行高↑↑ 列宽↑↑ */ } #water { grid-column: 1; grid-row: 1; } /* 你的花园看起来很棒。现在，你在花园的底部留下了50像素的小路，其他的空间用来种植胡萝卜。 不幸的是，胡萝卜地的20%已经杂草丛生了，最后一次用CSS网格布局来规划你的花园吧！ */ #garden { display: grid; grid-template: calc(100% - 50px) 50px/20% 80% } ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:3","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"指定 items 布局 第一步 搭出大框架：几行几列 有几个区域，就建立几个 items \u003cstyle\u003e * { margin: 0; padding: 0; box-sizing: border-box; } .container { display: grid; grid-template-columns: 40px 50px auto 50px 40px; /* 5列（auto会撑满该行余下空间） */ grid-template-rows: 100px 300px 100px; /* 3行（每行高度累加，成为container的总高度） */ border: 3px solid red; } .a, .b, .c, .d, .e { border: 3px solid black; } \u003c/style\u003e \u003cdiv class=\"container\"\u003e \u003c!-- emmet快捷键: 键入.a+.b+.c+.d ——\u003e tab 创建出5个div，class分别为abcde --\u003e \u003cdiv class=\"a\"\u003e\u003c/div\u003e \u003c!--第1行, 第1列--\u003e \u003cdiv class=\"b\"\u003e\u003c/div\u003e \u003c!--第1行, 第2列--\u003e \u003cdiv class=\"c\"\u003e\u003c/div\u003e \u003c!--第1行, 第3列--\u003e \u003cdiv class=\"d\"\u003e\u003c/div\u003e \u003c!--第1行, 第4列--\u003e \u003cdiv class=\"e\"\u003e\u003c/div\u003e \u003c!--第1行, 第5列--\u003e \u003c/div\u003e container 中的子元素，与列数一一对应。且默认只占据第一行。所以添加 border 后 效果如下图所示 第二步 给每个 item 指定区域、设置范围 grid-xxx-start / grid-xxx-end grid-row-start、grid-row-end grid-column-start、grid-column-end .a{ grid-row-start: 1; /* a从哪条线开始 */ grid-row-end: 3; /* a到哪条线结束 */ /* 指定的两条【线】的中间区域，就是a所占的【行】 */ grid-column-start: 1; grid-column-end: 2; /* 指定的两条【线】的中间区域，就是a所占的【列】 */ } grid-row / grid-column grid-row：grid-row-start / grid-row-end; grid-column: grid-column-start / grid-column-end; /* 上面写法，可以缩写成 ↓ */ .a{ grid-row: 1/3 ; grid-column: 1/2 ; } grid-area grid-area属性接受4个由’/‘分开的值：grid-row-start, grid-column-start, grid-row-end, 最后是 grid-column-end。 ​ 起始行 ↑↑ 起始列 ↑↑ 终止行 ↑↑ 终止列 ↑↑ /* 再进一步缩写 */ .a{ grid-area: 1/1/3/2 ; } 最终效果 ​ 可以给线起名字 但没必要，代码太麻烦。就按照序号就很好 取名结果：如图↘ item可以设置范围，直接用线的名称 .item-a{ grid-column-start: 2; grid-column-end: five; grid-row-start: rowl-start; grid-row-end: 3; } ​ ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:4","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"fr ：单位【份】 容器属性 全称 free space 自由空间 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"a\"\u003ea\u003c/div\u003e \u003cdiv class=\"b\"\u003eb\u003c/div\u003e \u003cdiv class=\"c\"\u003ec\u003c/div\u003e \u003cdiv class=\"d\"\u003ed\u003c/div\u003e \u003cdiv class=\"e\"\u003ee\u003c/div\u003e \u003c!-- \u003cdiv class=\"f\"\u003ef\u003c/div\u003e --\u003e \u003c/div\u003e \u003cstyle\u003e * {margin: 0;padding: 0;box-sizing: border-box;} .container { display: grid; grid-template-columns: 1fr 1fr 1fr; /* fr=份，与flex的份类似：共3列每列占1份，也就是均分 */ grid-template-rows: 1fr 1fr; /* 共2行，每行占1份，均分 */ border: 3px solid red; min-height: 500px; } .a, .b, .c, .d, .e { border: 3px solid black; } .e{ grid-column-start: 2; /* 再单独定义e版块占两列空间 */ grid-column-end: 4; background-color: #ccc; } \u003c/style\u003e ​ 变形 .container { display: grid; grid-template-rows: 1fr 3fr; /* 2行：第2行占3份 */ grid-template-columns: 1fr 2fr 1fr; /* 3列：第2列占2份 */ ... } ​ 平均布局 grid-gap fr 主要用于实现平均布局 容器属性：grid-gap 用于控制间距 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c!-- 应用下面grid布局样式，可实现任意添加.image，都可以实现一排4个、间距12px的布局 --\u003e \u003c/div\u003e \u003cstyle\u003e *{ margin: 0; padding: 0; box-sizing: border-box; } .container{ margin-right: auto; margin-left: auto; margin-top: 30px; outline: 5px solid red; width: 800px; /* 开启grid布局 */ display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; /* 格子布局：1排4个 */ grid-template-rows: 1fr 1fr; grid-gap: 12px; /* 计算每项边距，自动计算位置，四边上的会紧贴 */ } .container\u003ediv{ border: 2px solid black; background-color: #ccc; height: 191px; /* 宽800px，1排4个产品，计算得出：每个产品可占宽191px，则间距为12px */ width: 191px; } \u003c/style\u003e ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:5","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"分区 grid template-areas 名字很长，但非常好用 \u003cdiv class=\"container\"\u003e \u003cheader\u003eheader\u003c/header\u003e \u003caside\u003easide\u003c/aside\u003e \u003cmain\u003emain\u003c/main\u003e \u003cdiv class=\"ad\"\u003ead\u003c/div\u003e \u003cfooter\u003efooter\u003c/footer\u003e \u003c/div\u003e \u003cstyle\u003e .container { min-height: 100vh; /* 最小高度为占满整个屏幕 */ display: grid; grid-template-rows: 60px auto 60px; /* 行高 */ grid-template-columns: 190px auto 100px; /* 列宽 */ /* 布局：以版块名称直接写出布局、位置 */ grid-template-areas: \"header header header\" \"aside main ad\" \". footer .\"; /* 空格通常会写一个不存在的名称，如【.】点 */ grid-gap: 10px; /* 设置空隙 */ } .container \u003e * { border: 2px solid red } .container \u003e header {grid-area: header;} /* 版块命名 */ .container \u003e aside {grid-area: aside;} .container \u003e aside {grid-area: aside;} .container \u003e main {grid-area: main;} .container \u003e .ad {grid-area: ad;} .container \u003e footer {grid-area: footer;} \u003c/style\u003e grid-gap 设置间距 grid-gap：通用间距 grid-row-gap : 行间距 grid-column-gap： 列间距 .container{ ... grid-gap: 10px; } .container{ ... grid-row-gap: 20px; /* 行间距 */ grid-column-gap: 10px; /* 列间距 */ } ​ ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:6","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"实践 ","date":"2020-07-26","objectID":"/css-layout-2/:4:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"布局 Grid 尤其适合不规则布局 ","date":"2020-07-26","objectID":"/css-layout-2/:4:1","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"经验 等到 Grid 普及了，前端对CSS的要求会进一步降低 目前你简单尝试一下 Grid 就可以了 ","date":"2020-07-26","objectID":"/css-layout-2/:4:2","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"示例 第一步：根据设计图，划分行列需求，给每块区域命名 第二步：书写【容器】样式 \u003cdiv class=\"container\"\u003e \u003cheader\u003eheader\u003c/header\u003e \u003cdiv class=\"image bigImage\"\u003ebig\u003c/div\u003e \u003cdiv class=\"image smallImage\"\u003esmall\u003c/div\u003e \u003cdiv class=\"image smallImage\"\u003esmall\u003c/div\u003e \u003cdiv class=\"image smallImage\"\u003esmall\u003c/div\u003e \u003cdiv class=\"image middleImage\"\u003emiddle\u003c/div\u003e \u003cdiv class=\"image middleImage\"\u003emiddle\u003c/div\u003e \u003cdiv class=\"image middleImage\"\u003emiddle\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e * { margin: 0; padding: 0; box-sizing: border-box; } .container { display: grid; grid-template-rows: 50px 200px repeat(4, 100px); /* 重复4个120px，可以使用repeat()缩写语法 */ grid-template-columns: 240px 240px; grid-template-areas: \"header header\" \"big mid1\" \"big mid2\" \"sm1 mid2\" \"sm2 mid3\" \"sm3 mid3\"; } \u003c/style\u003e 第三步：指定每项的名称（所属） .container \u003e * { border: 2px solid black; } .container \u003e header {grid-area: header;} .container \u003e .image:nth-child(2) {grid-area: big;} .container \u003e .image:nth-child(3) {grid-area: sm2;} .container \u003e .image:nth-child(4) {grid-area: sm3;} .container \u003e .image:nth-child(5) {grid-area: mid1;} .container \u003e .image:nth-child(6) {grid-area: mid2;} .container \u003e .image:nth-child(7) {grid-area: mid3;} ​ ​ ","date":"2020-07-26","objectID":"/css-layout-2/:4:3","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"游戏 https://cssgridgarden.com/#zh-cn 忘记用法时，可以通过游戏来快速回忆 ​ grid-area grid-area属性接受4个由’/‘分开的值：grid-row-start, grid-column-start, grid-row-end, 最后是 grid-column-end。 ​ 起始行 ↑↑ 起始列 ↑↑ 终止行 ↑↑ 终止列 ↑↑ #garden { display: grid; grid-template-columns: 20% 20% 20% 20% 20%; grid-template-rows: 20% 20% 20% 20% 20%; } #water-1 { grid-area: 1 / 4 / 6 / 5; } #water-2 { grid-area: 2 / 3 / 5 / 6; } ​ order 如果网格项不是以grid-area、grid-column、grid-row 等显示的，它们会自动按照它们在源程序中出现的位置摆放。同样我们也可以使用order属性来重写它的顺序，这也是网格布局优于表格布局的好处之一。 默认情况下，所有的网格项的order都是0，但是顺序也可以被任意设置为正数或者负数，就像z-index一样。 ​ fr 与 px 结合 #garden { display: grid; grid-template-columns: 50px 1fr 1fr 1fr 50px; grid-template-rows: 20% 20% 20% 20% 20%; } #water { grid-area: 1 / 1 / 6 / 2; } #poison { grid-area: 1 / 5 / 6 / 6; } #garden { display: grid; grid-template-columns: 20% 20% 20% 20% 20%; grid-template-rows: 1fr 1fr 1fr 1fr calc(100% - 50px); } #water { grid-column: 1 / 6; grid-row: 5 / 6; } ","date":"2020-07-26","objectID":"/css-layout-2/:4:4","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-25","objectID":"/css-layout-1/","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"CSS 布局篇（上）： Float 布局、Flex 布局 。 ​ ​ Float 示例代码 https://jsbin.com/vobenim/edit?html,css,output Flex 示例代码 https://jsbin.com/biluwan/edit?html,css,output Flex 青蛙游戏 https://flexboxfroggy.com/#zh-cn ​ ","date":"2020-07-25","objectID":"/css-layout-1/:0:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局是什么 把页面分成一块一块，按左中右、上中下等排列 ","date":"2020-07-25","objectID":"/css-layout-1/:1:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局分类 两种 固定宽度布局，一般宽度为960/1000/1024px （淘宝pc） 不固定宽度布局，主要靠文档流的原理来布局（常用在移动端、响应式，会跟随设备宽度变化） 还记得吗 文档流本来就是自适应的，不需要加额外的样式 第三种布局 响应式布局 意思就是PC上固定宽度，手机上不固定宽度 也就是一种混合布局 ​ ","date":"2020-07-25","objectID":"/css-layout-1/:1:1","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局的两种思路 从大到小 先定下大局 然后完善每个部分的小布局 从小到大 先完成小布局 然后组合成大布局 两种均可 新人推荐用第二种，因为小的简单 老手一般用第一种，因为熟练有大局观 ​ ","date":"2020-07-25","objectID":"/css-layout-1/:1:2","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局需要用到哪些属性 不多哔哔，直接给你所有套路 以前经常说 DIV+CSS 布局，但是现在已经无意于用 DIV 了，就说用 CSS 布局 main、header、footer、nav、aside … 这些标签的出现，已经可以代替 div 了 需要兼容 IE9 吗 不用，只做手机页面（闲鱼），阿里巴巴在顺应手机时代 很老的手机产品要兼容吗？兼容最新浏览器吗？ ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:1:3","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"Float 布局 float 主要是针对 IE 的，而现在公司基本不需要兼容 IE6789。 ","date":"2020-07-25","objectID":"/css-layout-1/:2:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"步骤 子元素上加 float: left 和 width 在父元素上加 .clearfix（清除浮动的影响） \u003c!-- header中没有文档流元素，子元素都浮动了(脱离文档流) ，所以header的高度为0 --\u003e \u003c!-- 添加 clearfix 后，可以清除浮动的影响 --\u003e \u003cheader class=\"clearfix\"\u003e \u003cdiv class=\"logo\"\u003eXDML\u003c/div\u003e \u003cnav\u003e导航\u003c/nav\u003e \u003c/header\u003e \u003cstyle\u003e .logo{float: left;...} /* 脱离文档流 */ nav{float: left;...} \u003c/style\u003e .clearfix:after{ content: ''; display: block; clear: both; } /* 请背过 clearfix 的写法 */ ","date":"2020-07-25","objectID":"/css-layout-1/:2:1","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"经验 有经验者会留一些空间或者最后一个不设 width （或者可以给个 max-width: xxxpx;） 不需要做响应式，因为手机上没有IE，而这个布局是专门为 IE 准备的 IE6/7 存在双倍 margin bug（给浮动元素设置 margin: 10px 在 IE6/7 中实际距离会变成 margin: 20px 的效果） 解决办法有两个 一是将错就错，针对 IE6/7 把 margin 减半 .logo{ float: left; margin-top: 10px; /* 其他浏览器 只能识别这句，无法识别下面属性 */ _margin-top: 5px; /* IE6/7在属性前加 下划线 或 星号 都能识别 */ } 二是神来一笔，再加一个 display: inline-block .logo{ float: left; margin-top: 10px; display: inline-block; /* 微软说：IE6/7遇到margin乘2的bug，就添加这句 */ } 为什么可以这样？你问我，我问谁… ​ ","date":"2020-07-25","objectID":"/css-layout-1/:2:2","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"实践 不同布局 用 float 做两栏布局（如顶部条） 用 float 做三栏布局（如内容区） 用 float 做四栏布局（如导航） 用 float 做平均布局（如产品列表展示区）—— 负margin 曾经淘宝的前端发明了双飞翼布局，不要学，已过时代码 经验 加上头尾，即可满足所有PC页面需求 手机页面傻子才用float float要程序员自己计算宽度，不灵活 float用来应付IE足以 技术总结 JSbin 演示，总结如下 outline 现象描述：计算宽度时，内部3个元素的宽度和=300，外层容器=300，但是还会把最后一个元素挤下去，说明子元素的宽度超出容器的宽度。 原因可能是，虽然设定容器宽度为 300，但是容器添加了边框 border : 1像素，所以容器的内容区域的宽度实际只有 298 px。(仅限 border-box 情况) 解决： 把容器的边框删了 改用 outline: 1px solid red; outline 是在外侧的，不占内部区域，但是outline 样式上会有点奇怪 改用 背景颜色 标识区域 居中 /* margin: 0 auto; 下面两句的写法更好，这句还覆盖了margin上下的距离，css原则是不要写多余的 */ margin-left: auto; margin-right: auto; 只有==块级元素==，才能使用 margin … auto，实现居中。 float实现平均布局 添加一个 父元素 x ，进行 ==负margin== 操作（这个词基本都是高手才懂） 注意：添加 父元素后，clearfix 的位置也需要相应移动到，浮动元素的直属父级上 \u003cdiv class=\"imageList\"\u003e \u003cdiv class=\"x clearfix\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c!--\u003cdiv class=\"image\"\u003e\u003c/div\u003e--\u003e \u003c!--\u003cdiv class=\"image\"\u003e\u003c/div\u003e--\u003e \u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .imageList { outline: 1px solid green; width: 800px; margin-left: auto; margin-right: auto; margin-top: 10px; } .imageList \u003e .x \u003e .image { width: 191px; height: 191px; background-color: #555; border: 1px solid red; float: left; margin-bottom: 10px; margin-right: 12px; } .imageList \u003e .x { margin-right: -12px; } \u003c/style\u003e ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:2:3","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"缩写 html、css （√） navigator —\u003e nav （√） 不能缩写未经约定、达成统一的单词 content —\u003e cnt （x） container 也可以缩写成 cnt 容易误会，所以不要用 ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:3:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"Flex 布局 教程（来自 CSS Tricks) 把教程过一遍，然后忘掉 完成 Flex青蛙游戏 开始用flex！ ","date":"2020-07-25","objectID":"/css-layout-1/:4:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"容器 container 有哪些属性 container ：表示容器，一般用于做父元素 items ：表示容器里面的、直接的子元素，就称为 items（项） 以下都是 container 的样式 ​ 让一个元素变成 flex 容器 只有下面两种写法： .container{ display: flex; /* 或 display: inline-flex; */ } ​ 改变 items 流动方向（主轴） 默认，所有项都会挤在主轴，主轴占满会平均压缩每项宽度，以保证在主轴存放下所有项 .container{ display: flex; border: 1px solid red; flex-direction: row; /* 【默认值】横向（从左到右） */ flex-direction: column; /* 纵向（从上到下） */ flex-direction: row-reverse; /* 横向反向（从右到左） */ flex-direction: column-reverse; /* 纵向反向（从上到下） */ } ​ 改变折行 .container{ display: flex; border: 1px solid red; flex-direction: row; /* 默认横向 */ flex-wrap: wrap-reverse; /* 反向折行, 效果如下图，基本没用 */ } flex-direction和flex-wrap两个属性经常会一起使用，所以有缩写属性flex-flow。这个缩写属性接受两个属性的值，两个值中间以空格隔开。 举个例子，你可以用flex-flow: row wrap去设置行并自动换行。 ​ ​ 主轴对齐方式 默认主轴是 横轴 除非你改变了 flex-direction 方向 .container { justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly; } space-around： 每项左右两边的空间一样 space-evenly：每项间距一样 space-between：把空间放到中间，元素分布两边 ​ 次轴对齐 默认次轴是 纵轴 .container{ align-items: stretch [默认值] | flex-start | flex-end | center | baseline（不需要） } stretch【默认值】 默认所有 items 的高度 与 高度最高的 item 保持一致 如下图，3个 item 都与 2 号 item 一样高 flex-start flex-end center ​ 多行分布 很少用到 默认平均分 ： align-content: stretch (如图) .container{ display: flex; border: 1px solid red; flex-wrap: wrap; height：400px； align-content: flex-start; /* 全部集中到顶部 */ align-content: flex-end; /* 全部集中到底部 */ align-content: center; /* 全部集中到中间 */ align-content: space-between; align-content: space-around; } ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:4:1","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"flex item 有哪些属性 以下都是 item 的属性 item 上加 order 默认 order 为 0 指定 order 后，item 会按照 order 顺序从小到大排列（可以指定为负数） \u003cdiv class=\"container\"\u003e \u003cdiv class=\"item\"\u003e1\u003c/div\u003e \u003cdiv class=\"item\"\u003e2\u003c/div\u003e \u003cdiv class=\"item\"\u003e3\u003c/div\u003e \u003cdiv class=\"item\"\u003e4\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .container{ display: flex; border: 1px solid red; } .item{ width:50px; height:50px; border: 1px solid green; } .item:first-child{ order: 100; } /* 最后 */ .item:nth-child(2){ order: 2; } .item:nth-child(3){ order: 3; } .item:last-child{ order: 1; } /* 最前 */ \u003c/style\u003e ​ item 上加 flex-grow 用于分配多余的空间（控制变胖） flex-grow： 默认为 0. 就是 item 宽度由内容撑开，没内容的话宽度就是0，不会占用多余的空间 给 item 设置 flex-grow 值为 n （\u003e0），就是将分配多余空间给当前 item 占 n 份。 如果一共有3个item，那就平均分配多余空间，每个 item 占 n/3. 当我们不给 item 设置宽度时，item 的宽度是能有多窄有多窄（宽度由内容撑开） 实现宽度能有多宽有多宽，就给 item 添加 flex-grow .item{ flex-grow: 1; /* 每一个 item 平均分配宽度，来占满多余的空间（不是占满整行空间） */ } 需求：从多余的空间中，给2,3 的宽度占 2 份; 给 1,4 占 1 份 空间 .container{ display: flex; border: 1px solid red; } .item{ height:50px; border: 1px solid green; } .item:first-child{ flex-grow: 1; } .item:nth-child(2){ flex-grow: 2; } .item:nth-child(3){ flex-grow: 2; } .item:last-child{ flex-grow: 1; } 经验 当 3 栏布局，如下 只给【导航】设置 flex-grow: 1（实现导航宽度的响应式），logo、头像固定宽度 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"item\"\u003elogo\u003c/div\u003e \u003cdiv class=\"item\"\u003e导航\u003c/div\u003e \u003cdiv class=\"item\"\u003e头像\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .container{ display: flex; border: 1px solid red; } .item{ height:50px; border: 1px solid green; } .item:nth-child(2){ flex-grow: 1; } \u003c/style\u003e ​ flex-shrink 控制如何变瘦 当界面不断变窄，无法存放每项的给定宽度时，每项都需要变窄，flex-shrink 就控制谁瘦的多，谁瘦的少 默认是1（所有item平均收缩，要缩一起缩） 一般写 flex-shrink: 0; 防止变瘦（被设置为 0 的这一项，就算空间不够时，也不会收缩。要缩别找我） .item{ width: 150px; /* 合计宽度最小450px */ height:50px; border: 1px solid green; flex-grow: 1; /* 每项会均分多余空间 */ } .item:first-child{ flex-shrink: 1; } .item:nth-child(2){ flex-shrink: 50; /* 2 的收缩比例较大 */ } .item:last-child{ flex-shrink: 1; } 当宽度缩小达到450px以内，每项宽度不足，此时每项会开始收缩， flex-shrink 值越大，则收缩的越大，flex-shrink 值越小，越不会受到收缩的影响 如下图，宽度收缩450px以内，【导航】最先开始发生了较大的收缩，因为设定了较大的 flex-shrink 值 【logo】和【头像】版块，基本不收缩 ​ flex-basis 控制基准宽度 用法： 默认是 auto（与 item 的 width 值保持一致） 指定宽度：flex-basis: 100px; 相当于指定了 width 值 这个属性比较迷：不是很重要的属性 可以直接用 width 来代替这个属性 ​ 缩写成 flex flex 相当于 flex-grow flex-shrink flex-basis 习惯上我一般不写缩写，容易记错位置 flex 只有以下 4 种形式的写法 .item:first-child{ flex: 1 1 100px; /* grow-1，shrink-1，宽100px */ } .item:nth-child(2){ flex: 1 100 100px; /* grow-1，shrink-100，宽100px */ } .item:last-child{ flex: 1 1 100px; /* grow-1，shrink-1，宽100px */ } 上述，3个item，宽度为100px grow撑开时每个item平均占满所有多余空间 宽度不足时，2 号主要进行收缩 ​ align-self 定制 align-items 用的很少 默认在垂直方向上，都是顶端对齐的 align-self 可以让某一个 item，在垂直方向上，特例独行的展示（指定一个特别的对齐方式） 实现：单独设置，最后一个 item 底部对齐 ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:4:2","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"重点 记住这些代码 display: flex 开启flex布局 flex-direction: row / column 主轴是横向还是纵向 flex-wrap: wrap 空间不足时是否换行 just-content: center / space-between 主轴方向上的对齐方式：居中/分开 align-items: center 次轴方向上的对齐方式：居中，顶，底 工作中基本只用这些 ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:4:3","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"实践 不同布局 用 flex 做两栏布局 用 flex 做三栏布局 用 flex 做四栏布局 用 flex 做平均布局 —— 负 margin 用 flex 组合使用，做更复杂的布局 JSBin 代码 经验 永远不要把 width 和 height 写死，除非特殊说明 PC端通常可以写死。移动端不能写死，需要适配各种尺寸：平板/手机… 用 min-width / max-width / min-height / max-height flex 可以基本满足所有需求 flex 和 margin-xxx : auto 配合有意外的效果——例：左右布局 ​ 什么叫写死 写死 width:100px 不写死 width: 50% max-width: 100px width: 30vw （屏幕宽度的百分之30） min-width: 80% 特点：不使用 px，或者加 min max 前缀 css 最忌讳把宽高写死 ​ 技术总结 左右布局 表示两栏布局-贴左、贴右：可通过以下两句中的任意一句来实现 margin-xxx: auto 更灵活 \u003cstyle\u003e .header { display: flex; border:1px solid black; /*justify-content: space-between; ---------------二者任选其一----------------------*/ } ul { /* margin-left: auto; -------------------------二者任选其一【推荐】------------------*/ display: flex; border: 1px solid green; } ul \u003e li { border: 1px solid red; } \u003c/style\u003e \u003cheader class=\"header\"\u003e \u003cdiv class=\"logo\"\u003e \u003cimg alt=\"\" src=\"./logo.png\"\u003e \u003c/div\u003e \u003cul\u003e \u003cli\u003e首页\u003c/li\u003e \u003cli\u003e课程\u003c/li\u003e \u003cli\u003e优惠\u003c/li\u003e \u003cli\u003e关于\u003c/li\u003e \u003c/ul\u003e \u003c/header\u003e 产品展示格子布局 失败方案 \u003cdiv class=\"imageList\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c/div\u003e .imageList{ border: 1px solid red; width: 800px; margin-right: auto; margin-left: auto; margin-top: 10px; display: flex; flex-wrap: wrap; justify-content: space-between; /* 会导致产品不足数的行 --\u003e 错位 */ } .image{ width: 191px; height: 191px; background-color: #ccc; margin-bottom: 10px; border: 1px solid green; } ​ 负margin方案 \u003cdiv class=\"imageList\"\u003e \u003c!-- 可以命名为 inner 或者 wrapper --\u003e \u003cdiv class=\"x\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e .imageList { outline: 1px solid red; /* 注意：边框去掉或者放在外面，否则占据宽度 */ width: 800px; margin-right: auto; margin-left: auto; margin-top: 10px; } .imageList \u003e .x { display: flex; flex-wrap: wrap; margin-right: -12px; /* 负margin */ } .image { width: 191px; height: 191px; background-color: #ccc; margin-bottom: 10px; border: 1px solid green; margin-right: 12px; /* 每个的间距 */ } ","date":"2020-07-25","objectID":"/css-layout-1/:4:4","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-25","objectID":"/css-basic/","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"熬夜总结 – CSS 基础篇 。 ","date":"2020-07-25","objectID":"/css-basic/:0:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 的历史 ","date":"2020-07-25","objectID":"/css-basic/:1:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 是谁发明的 李爵士的挪威同事赖先生，首先提出 CSS Håkon Wium Lie （挪威语） ","date":"2020-07-25","objectID":"/css-basic/:1:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"赖先生的生平 生平 1991年获得MIT媒体实验室视觉研究理学硕士学位 1994年提出CSS概念而闻名 1999年任Opera的CTO（首席技术官，不分前端后端、只要是技术就负责） 2005年他写公开信给比尔盖茨问为什么IE不支持Web标准，盖茨说IE 7马上发布，他写了 Acid2 用来验证 2006年通过了博士论文答辩 2006年他倡议 Web 网页应使用通用字体格式 2007年他倡议浏览器可以支持video标签 观点 微软的IE常常成为他的批评对象 他也是Web打印概念的倡导者，用HTML和CSS写书 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 的牛 X 之处在哪？ CSS（Cascading Style Sheets）：==层叠==样式表 样式层叠 可以多次对同一选择器进行样式声明 选择器层叠 可以用不同选择器对同一个元素进行样式声明 文件层叠 可以用多个文件进行层叠 这些特性使得 CSS 极度灵活 这也为 CSS 后来被吐槽留下了隐患 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:3","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 的版本 ⭐目前使用最广泛的css版本：css 2.1 版本 2004-2011年间不断更新，没有具体发布时间 版本 时间 重点 CSS 1 1996年 不用管 CSS 2 1998年 添加定位、z-index、media，不用管 **CSS 2.1 ** 2004~2011年 使用最广泛的版本（IE支持） CSS 3 1999年开始起草 现代版本，分模块（IE 8 部分支持） CSS 4* 分模块升级 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:4","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"浏览器对CSS的支持（兼容性） 怎么知道，哪些浏览器，支持哪些特性？ 方法一：几十种浏览器全部跑一遍 方法二：使用 caniuse.com 红色：不支持flex 黄色：部分支持 绿色：完全支持 caniuse.com 使用方法 请收藏此网站 输入你关心的样式，比如 border-radius 或 filter 查看大部分浏览器的支持情况 如果想看更多，点击 Show All 下方会详细说明兼容 bug 有哪些（翻译成中文） 这个网站是怎么运作的 网站主一开始自己测试了一部分浏览器 社区的前端工程师帮助测试各种各样的浏览器 UC 浏览器和 QQ 浏览器当然主要是中国开发者测试 大家把测试结果提交到 GitHub 上 这就是开发者社区的力量、 什么是社区？ 社区不是一个准确存在的概念，大家你帮我我帮你，互相学习，互相分享，就形成了社区。 是一种弱联系。 社区通过汇集的力量将事情给解决好 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:5","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 是艺术 就像画画、折纸 你需要用感性思维来理解 CSS ","date":"2020-07-25","objectID":"/css-basic/:2:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"不要用理性思维 即不要问「为什么会这样」，而是说「原来是这样」 浏览器说是怎么样，就是怎么样 当然有极少情况是浏览器出错了 ","date":"2020-07-25","objectID":"/css-basic/:2:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"为什么 color: red 能让字变红 不要问「为什么」 要说「原来是这样」 所见即所学 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:2:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"体系化学习 有生之年都不太可能把css所有知识学完，因为它太、多、了。只文档可能就有几百页，目录全看一遍都很累：css标准文档（google 搜 css spec） 不是把所有知识都学完，而是在一个新知识点到来的时候，马上学会它。这才是学习CSS体系化最重要的手段 体系化学习 CSS 和 HTML 的过程完全一致 ","date":"2020-07-25","objectID":"/css-basic/:3:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"学一门语言必须学会什么 语法（怎么写代码） css 语法非常简单 [如何调试](#如何调试 CSS)（怎么知道自己代码写错了） node-w3c-validator -i index.html // 查错 在哪查资料（其实就是为了抄代码） MDN 标准制定者是谁 尝试所有方法仍不能解决问题的话，就必须看标准文档了 ","date":"2020-07-25","objectID":"/css-basic/:3:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"如何学 Copy - 抄文档、抄老师 Run - 放在自己的机器上运行成功 Modify - 加入一点自己的想法，然后重新运行 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"语法 超级简单 语法一：样式语法 选择器 { 属性名: 属性值; /*注释*/ } 注意事项 不学常态，学变态 所有符号都是英文符号，如果写错了，浏览器会警告（样式会被划掉） 区分大小写，a 和 A 是不同的东西（特别是大小写很相似的字母，很容易错） 没有 // 注释，只有 /* 注释 */ 这种形式 最后一个分号可以省略，但建议不要省略 任何地方写错了，都不会报错，浏览器会直接忽略 那我怎么知道自己写没写错呢？一会说 语法二：at 语法 @charset \"UTF-8\"; /* 声明字符编码，必须放在第一行 */ @import url(2.css); /* 导入一个额外的css文件 */ @media (min-width: 100px) and (max-width: 200px) { /* 媒体查询 */ 语法一 } 注意事项 @charset 必须放在第一行 前两个 at 语法必须以分号 ; 结尾 @charset \"UTF-8\"; @import url(2.css); @media 语法会单独教学 charset 是字符集的意思，但 UTF-8 是字符编码 encoding（并不是字符集），这是历史遗留问题 最早只有 ASCII 这一种字符集（英文），这个字符集的编码形式就是它自己 后来中国人发现 ASCII 不能表示中文，所以就发明了 GB2312，由中国国家标准局（国标局）发行，GB 就是国家标准的缩写。 GB2312 是一个支持中文简体汉字的字符集。它对应的编码形式，是它自己 后来日本、韩国的文字，我们的 GB2312 也表示不了。国标局还没开始动作，微软先一步发明 GBK，k表示扩展。GBK 可以同时表示 中文、日文、韩文（CJK） 后来中国发现还需要和更多国家建立联系，国标库根本就搞不定，就有一个叫 Unicode 的组织，给全球制作了一个字符集，叫做 Unicode（万国码）。这个码包含非常多国家，特别长，所以必须采用不同的编码形式。 编码形式包含：UTF8/UTF16/UTF32 （选择任意一个即可） 从 Unicode开始字符集和编码形式就不统一了，之前都是统一的 html 1993年左右发明，css 发明于1996年左右，Unicode在1996年之后发明。 charset 原本后面写一个【字符集的名字】，写 GBK/GB2312 ….这种，对应编码形式也是同名的。但是Unicode发明后，字符集名称和编码形式不统一了，所以我们为了表明自己使用的是 Unicode 的那种编码形式，就只能将Unicode的编码形式，写在表示字符集的 charset 的位置。 ==【这就是这个历史问题的发展经过】== 字符集 编码形式 ASCII ASCII GB2312 GB2312 GBK GBK Unicode UTF8/UTF16/UTF32 问： @charset “UTF-8” 指的是什么？ 回答 ：字符集（charset） 是错误的 “UTF-8”指定的不是字符集 charset，而是指定的【 文件编码 】 虽然charset本身是字符集的意思，但后面的 utf-8 指的是 Unicode字符集的**【编码形式】**的一种。这是一个历史遗留问题 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:3","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"如何调试 CSS 方法 使用 W3C 验证器（在线 / 命令行工具）不用试了 node-w3c-validator -i index.html // 可能需要先安装java环境，才能运行 node-w3c-validator Java环境安装、配置 使用 VSCode 看颜色 使用 WebStorm 看颜色 使用开发者工具看警告 浏览器预览页面，右键检查，查看Element中，一般会给出问题警告。有问题的css会被划删除线 如何使用开发者工具 找到你脑中的标签 看它是否有选择器 看它的样式是否被划掉 看它的样式是否有警告 Border 调试法 步骤 怀疑某个元素有问题 就给这个元素加 border border 展示效果没出现？说明选择器错了或者语法错了 通常是 border 上面的代码有问题（因为上面代码执行遇到问题，就会影响下面样式的输出） border 出现了？看看边界是否符合预期 说明选择器没有错、border以上的代码没有错 可以继续往下测试、查找错误 bug 解决了才可以把 border 删掉 记住 CSS 的 border 调试法 就相当于 JS 的 log 调试法 我会再每节课重复这个调试法 ​ 新人常见错误 低级错误 选择器拼写错误 属性名拼写错误 属性值拼写错误 大小写错误 没写分号 中文冒号 没写反花括号 没加单位 非低级错误 没有非低级错误 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:4","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"在哪查资料 网站推荐 Google 搜索关键词时加 MDN CSS tricks（英文），专门收集 css 小技巧的网站 使用方式：在google 搜 [技术名词] css tricks https://css-tricks.com/snippets/css/a-guide-to-flexbox/ 张鑫旭的博客：可能是中国花时间最多来学css的人 使用方式：搜 [技术名词] 张鑫旭 书籍推荐 不推荐买任何书 CSS 和 HTML 一样，以练为主 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:5","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"在哪搜练习素材 PSD Freepik 搜索 PSD web 英文（下载免费的 psd） 如果下载慢，就把域名加入翻墙插件 中文免费 PSD 网站较少，需要多搜一下 365PSD 里的 UI 套件还行 效果图（不提供下载） dribbble.com 顶级设计师社区 可以用肉眼模仿它 商业网站 直接模仿你常去的网站 ​ ","date":"2020-07-25","objectID":"/css-basic/:3:6","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"不要沉迷临摹 每个类型的临摹一两个即可 PC 网站、手机网站、UI 套件 再多无益 ​ ","date":"2020-07-25","objectID":"/css-basic/:3:7","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"遇到查不到的问题，怎么办 遇到查不到的问题，应该去哪里查文档？ ——找标准制定者 李爵士、赖先生 W3C 搜索 CSS spec 可以找到 CSS 最新标准 没人能看完它 你可以看看 CSS 2.1 标准的中文版 正确学 css ，应该是遇到问题，再查资料 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:8","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"基本概念 ","date":"2020-07-25","objectID":"/css-basic/:4:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"要理解几个重要的概念 文档流 Normal Flow 块、内联、内联块 margin 合并 两种盒模型（border-box 更符合人类思维） ​ ","date":"2020-07-25","objectID":"/css-basic/:4:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"文档流 文档流的英文名称叫做 Normal Flow 文档流方向：默认，内联元素从左到右，块级元素从上到下 emmet: span{第$个span元素}*6 + tab ​ ","date":"2020-07-25","objectID":"/css-basic/:4:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"块、内联、内联块 将元素分为：内联元素、块级元素。是一种已经过时的分法。 在新的 HTML5 标准中，元素不分内联、块级。所有元素都可以是内联元素，所有元素都可以是块级元素。 看样式：如果 display:inline， 就是内联元素。如果 display: block 就是块级元素。 内联块：不会出现如【内联元素首尾可以在不同行】的情况，内联块会同行展示，但是又保有 block 的一个特点：不会跨两行（这就是inline和inline-block在流动方向上相似又稍微不同的点） 流动方向 inline 元素从左到右，到达最右边才会换行 block 元素从上到下，每一个都另起一行 inline-block 也是从左到右 宽度 inline 元素 宽度为 内部 inline 元素的和。 不接受用 width 指定宽度。加了也不变化 不要在 inline元素内部，再写 block 元素。它的计算可能乱套的，出现后果自负 block 元素 默认自动计算宽度，可用 width 指定 width: 200px; （200像素）、width: 20em; （20个字宽） 不指定宽度，宽度默认是 width: auto。不是 width: 100%，是能有多宽就占多宽，最大可以占 100% 如下图，每个div元素都有边框，【div默认宽度】=100%-边框宽度。如果【设置div宽度为100%】，那么相当于，整行宽度= div宽度100%+边框宽度，所以会多出边框宽度的一小块位置 ==经验之谈==：给任何元素都尽量，不要设置 width: 100% 的样式。大部分情况写了就等于 bug。 inline-block 元素 结合前两者特点，可用 width 默认情况，与 inline 一致 但是又可以用 width 指定宽度，这一点又与 block 一致 高度 inline 高度 由 line-height（行高） 间接确定，跟 height 无关 （设置height无效） 如下图，为什么外层的 绿div 没有包住 红span、被撑高呢？ 因为 span 的高度，不是【内容高+padding】决定的。padding 改变的不是 span 的实际高度，只是改变了可视的高度。div 框的高度才是 span 的实际高度。 span 的实际高度，由 行高 间接确定。如下图，虽然span的红框仍然没变，但是 div高度变化了。而div包裹的高度才是 span 的实际高度（只需关注外层div高度即可，红框的高度并不是span实际高度） “间接” 怎么理解？ 即使设置行高100px，span的高度也有可能不是100px高 设置不同的字体，会改变 span 的实际高度。经测试：↓↓ 默认，微软雅黑字体、行高是100px的话，实际高度就是100px。 改成宋体、行高是100px，span 的实际高度变成 101px。 改成 monospace(等宽字体)、行高是100px。 实际高度变成 102px 具体知识点叫做：行盒 （可以看文章，能看懂就看，面试官可能都看不懂，前期可以不用研究这么深） block 高度 默认高度，由内部所有 文档流元素 的高度总和 决定的。（由默认行高间接决定） 内层div是脱离文档流的元素，外层div就无法计算上它的高度 后面会介绍：如何脱离文档流、脱离后去哪里了 同时也可以自定义设置 height 高度。这种情况，就忽略内部元素高度。 如果div中没有任何内容，高度为0。区别于span，span中没有内容，也有高度，由 默认的 line-height 决定。 inline-block 高度 默认高度的计算，跟 block 一样。 也可以自定义设置 height。 ","date":"2020-07-25","objectID":"/css-basic/:4:3","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"overflow 溢出 当内容大于容器 当内容的宽度或高度大于容器的，会溢出 可用 overflow 来设置是否显示滚动条 auto 是灵活设置 scroll 是永远显示（基本不用） hidden 是直接隐藏溢出部分 visible 是直接显示溢出部分（默认值） overflow 可以分为 overflow-x 和 overflow-y，通常只用overflow。x和y可能最终效果会与实际需求有差 示例 \u003cdiv style=\"width: 10em; height: 200px;\"\u003e内容......\u003c/div\u003e overflow: visible; /* 默认 */ overflow: hidden; /* 超出部分隐藏 */ overflow: scroll; /* 超出部分可滚动预览，很少有人用。因为内容没溢出时，仍显示滚动条，非常丑 */ overflow: auto; /* 超出时显示滚动条，不超出不显示 */ 横向滚动条 \u003cdiv style=\"width: 10em; height: 200px;\"\u003e 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 \u003cdiv style=\"width:1000px;\"\u003e 内容 \u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e div{ border: 1px solid green; overflow: auto; } span{ border: 1px solid red; } \u003c/style\u003e 内部文档流元素宽度超出外层父元素，就会出现横向滚动条 同时原本的内容，不会因为宽度被内部元素撑开而平铺显示，仍会只显示在第一屏中 ​ ","date":"2020-07-25","objectID":"/css-basic/:4:4","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"脱离文档流 回忆一下 block 高度由内部文档流元素决定，可以设 height 这句话的意思是不是说，有些元素可以不在文档流中 哪些元素脱离文档流 脱离文档流的元素，那么它所在的容器，就不会把它计算进高度中 脱离文档流，就是从普通文档流中跳出，比普通文档流的层级稍高 float position: absolute / fixed 怎么让元素不脱离文档流 不要用上面属性不就不脱离了 ​ ","date":"2020-07-25","objectID":"/css-basic/:4:5","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"盒模型 content box \u0026 border box css 盒模型分为两种：一种是 content-box ，一种是 border-box 二者的区别是： content-box 的宽度，只包含 content 部分 border-box 的宽度，包含 border、padding 和 content 分别是 content-box 内容盒 - 内容，就是盒子的边界 border-box 边框盒 - 边框，才是盒子的边界 公式 content-box width = 内容宽度 border-box width = 内容宽度 + padding + border 哪个好用 border-box 好用 同时指定 padding、width、border 就知道为什么了 ​ ","date":"2020-07-25","objectID":"/css-basic/:4:6","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"margin合并 哪些情况会合并 兄弟 margin 合并 上方元素的 margin-bottom，会和下方元素的 margin-top 重合 父子 margin 合并 给子元素添加 margin-top，效果会作用在父元素上（bf：嵌套崩塌） 第一个子元素的 margin-top，会和 最后一个子元素的 margin-bottom，效果会作用在父元素的 margin-top/bottom 或 和父元素的 margin-top/bottom 重合 记住：只有上下会重叠，左右从来不重叠 如何阻止合并 不要问为什么，CSS 很多效果是试出来了，无法解释清楚 父子合并用 padding / border 挡住 可以用很小的 padding/border 来挡住，让父子的margin无法穿透并重叠 父子合并用 overflow: hidden 挡住 父子合并用 display: flex，不知道为什么，试出来的 兄弟合并是符合预期的 兄弟合并可以用 display: inline-block 消除 总之要一条一条死记。 而且 CSS 的属性逐年增多，每年都可能有新的 为什么css 难学？ 不正交 因为很多没有道理，需要死记硬背的点。 为什么 display: inline-block 可以消除 margin 合并。 并没有 enable-margin-callapse: false 这种选项，翻译一下就知道它是用来单独控制margin合并的。 无法知道 现在写的这句 css，到底会影响哪些属性 什么叫正交？ 当我们调节显示器的亮度时，显示器的对比度不会改变。 而 css 是不正交的，因为我们在写某一个属性时，可能就会改变其他属性的状态、效果 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:4:7","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"基本单位 长度单位 px 像素 em 相对于自身 font-size 的倍数 百分数 整数 rem：等你把 em 滚瓜烂熟了再问 rem vw 和 vh 其他长度单位都用得很少，不用了解 颜色 十六进制 #FF6600 或者 #F60 #000 也支持最后添加 alpha。 #FF660000 全透明、 #FF6600FF 不透、 #FF660088 半透。但兼容性不确定 RGBA 颜色 rgb(0,0,0) 或者 rgba(0,0,0,1) hsl 颜色 hsl(360,100%,100%)：色相、饱和度、明度 hsla(360,100%,100%, 0.5) ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:4:8","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"实践：做一个彩虹 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eJS Bin\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"rainbow\"\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e * { box-sizing: border-box; margin: 0; padding: 0; } body{ background: white; } .rainbow { height: 200px; overflow: hidden; } .rainbow div { overflow: hidden; } .rainbow \u003e div { width: 400px; height: 400px; background: red; border-radius: 50%; } .rainbow \u003e div\u003e div { background: hsl(60, 80%, 50%); height: 380px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div { background: hsl(120, 80%, 50%); height: 360px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div { background: hsl(180, 80%, 50%); height: 340px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv { background: hsl(240, 80%, 50%); height: 320px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv \u003e div { background: hsl(300, 80%, 50%); height: 300px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv \u003e div \u003e div { background: hsl(330, 80%, 50%); height: 280px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv \u003e div \u003e div \u003e div { background: hsl(330, 80%, 100%); height: 260px; margin: 10px; border-radius: 50%; } ","date":"2020-07-25","objectID":"/css-basic/:5:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["HTML 入门"],"content":"❤️ 🧡 💛 💚 💙 💜","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"记录几个标签的简单用法，然后忘掉 🤪 ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:0:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"a 标签 特别常用，但很多人不会用 😳😳 属性 href target download rel=noopener 面试可能会问 作用 跳转外部页面 跳转内部锚点 跳转到邮箱或电话等 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:1:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"href href 是 Hypertext REFerence 超链接 发音 ：应该读 H-Ref /ˈeit∫.rɛf/ href 的取值 网址 https://google.com http://google.com //google.com 【推荐写这种形式】 network 会先请求 http://google.com → http://www.google.com → https://www.google.com 结束 路径 使用 hs 开启服务的目录，就是 /a/b/c 的根目录 双击打开文件，访问的路径是硬盘的根目录 file /a/b/c 以及 a/b/c index.html 以及 ./index.html \u003ca href=\"/a/b/c.html\"\u003ec.html\u003c/a\u003e \u003ca href=\"./index.html\"\u003eindex.html\u003c/a\u003e 伪协议 javascript:代码; \u003ca href=\"javascript:alert(1);\"\u003e\u003c/a\u003e \u003c!--执行js操作：弹出1--\u003e \u003ca href=\"javascript:;\"\u003e\u003c/a\u003e \u003c!--只有这种是什么都不做--\u003e \u003ca href=\"\"\u003ehref为空，页面会刷新\u003c/a\u003e \u003c!--如果有input会被清空--\u003e \u003ca href=\"#\"\u003e#不刷新，但页面会滚动到顶部\u003c/a\u003e 补充：编译器中 p{$}*30 + tab ，会生成 30 个 p 标签，内容 1-30 mailto:邮箱 移动端，通常会直接呼出发邮件的界面，并自动填写收件人邮箱 \u003ca href=\"mailto:ryuukousen@gmail.com\"\u003e给他发邮件\u003c/a\u003e tel:手机号 移动端，直接呼出拨号盘，并自动填写号码 \u003ca href=\"tel:13912345678\"\u003e\u003c/a\u003e id 锚点 跳转到指定标签 href=#xxx \u003ca href=\"#xxx\"\u003e查看aaa\u003c/a\u003e ... \u003cp id='xxx'\u003eaaa\u003c/p\u003e ... ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:1:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"target 在哪个页面打开窗口 内置名字 _blank ：新窗口 _top ：顶级窗口（结合 iframe） _parent ：父级窗口（结合 iframe） _self ：当前窗口（默认值） 程序员命名 window 的 name \u003ca href=\"//google.com\" target=\"asdf\"\u003egoogle\u003c/a\u003e \u003ca href=\"//baidu.com\" target=\"asdf\"\u003ebaidu\u003c/a\u003e target=asdf，表示如果有这个asdf窗口就在这个窗口打开google，如果没有就创建一个新的窗口命名为asdf 控制台输出 window.name 可知当前窗口的名称 iframe 的 name 可以写一个搜索引擎的集合或切换，goodbai 谷歌已经禁用了在 iframe 中引入 \u003ca href=\"//google.com\" target=\"asd\"\u003egoogle\u003c/a\u003e \u003ca href=\"//baidu.com\" target=\"qwe\"\u003ebaidu\u003c/a\u003e \u003ciframe src=\"\" name=asd\u003e\u003c/iframe\u003e \u003ciframe src=\"\" name=qwe\u003e\u003c/iframe\u003e ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:1:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"download 绝大多数浏览器不支持，chrome 不支持 \u003ca href=\"//google.com\" download\u003e下载页面\u003c/a\u003e 作用 不是打开页面，而是下载页面 问题 不是所有浏览器都支持，尤其是手机浏览器可能不支持 ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:1:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"iframe 内嵌窗口 已经很少使用了，还有些老系统再用。新的方式是通过 ajax 实现 \u003ciframe name=\"a\" src=\"a-target-iframe.html\" frameborder=\"0\"\u003e\u003c/iframe\u003e ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:2:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"table ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:3:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"相关标签 thead、tbody、tfoot，即使开发时换了顺序，浏览器识别时仍会按照 head body foot 的顺序解析渲染 table thead tbody tfoot tr td th 一个表头的表格 \u003ctable\u003e \u003cthead\u003e \u003c!-- tr: table row 行--\u003e \u003ctr\u003e \u003c!-- th: table head 表头--\u003e \u003cth\u003e英语\u003c/th\u003e \u003cth\u003e翻译\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003c!-- td: table data 数据 --\u003e \u003ctd\u003ehyper\u003c/td\u003e \u003ctd\u003e超级\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003etarget\u003c/td\u003e \u003ctd\u003e目标\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003ereference\u003c/td\u003e \u003ctd\u003e引用、链接\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003ctfoot\u003e \u003ctr\u003e \u003ctd\u003e空\u003c/td\u003e \u003ctd\u003e空\u003c/td\u003e \u003c/tr\u003e \u003c/tfoot\u003e \u003c/table\u003e 两个表头的表格 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003e小红\u003c/th\u003e \u003cth\u003e小明\u003c/th\u003e \u003cth\u003e小颖\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003cth\u003e数学\u003c/th\u003e \u003ctd\u003e61\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e92\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e语文\u003c/th\u003e \u003ctd\u003e61\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e92\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e英语\u003c/th\u003e \u003ctd\u003e61\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e92\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003ctfoot\u003e \u003ctr\u003e \u003cth\u003e总分\u003c/th\u003e \u003ctd\u003e200\u003c/td\u003e \u003ctd\u003e200\u003c/td\u003e \u003ctd\u003e200\u003c/td\u003e \u003c/tr\u003e \u003c/tfoot\u003e \u003c/table\u003e ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:3:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"相关样式 table-layout auto【默认】：根据单元格中的内容数量，计算单元格宽度 fixed：单元格宽度尽量平均 inherit initial unset border-spacing 设定每个单元格的间隙 \u003cstyle\u003e table{ width: 600px; table-layout: auto; border-spaceing: 10px; } td,th{ border: 1px solid blue; } \u003c/style\u003e border-collapse 通常用于 去掉单元格间隙 \u003cstyle\u003e table{ width: 600px; table-layout: auto; border-collapse: collapse; /* 去掉单元格间隙 */ border-spaceing: 0; /* 去掉单元格间隙 */ } td,th{ border: 1px solid blue; } \u003c/style\u003e 下面这两句常被写进 reset.css 中 border-collapse: collapse; /* 去掉单元格间隙 */ border-spaceing: 0; /* 去掉单元格间隙 */ ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:3:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"img 标签 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:4:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"作用 发出 get 请求，展示一张图片 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:4:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"属性 alt：全称是可替换的，当图片加载失败，会显示 alt 的值 height：只设置 height ，宽度自适应 width：只设置 width ，高度自适应 同时设定，height 和 width，图片可能变形 永远不要让图片变形 src：全称 source ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:4:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"事件 onload/onerror \u003cimg id=\"xxx\" width=\"400\" src=\"dog.jpg\" alt=\"一只狗子\"\u003e \u003cscript\u003e xxx.onload = function(){ console.log(\"图片加载成功\"); } xxx.onerror=function(){ console.log(\"图片加载失败\"); xxx.src = \"/404.jpg\"; // 挽救：图片加载失败，展示404图，放在项目中 } \u003c/script\u003e ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:4:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"响应式 max-width:100% \u003cstyle\u003e *{ margin:0; padding:0; box-sizing: border-box; } img{ max-width: 100%; /* 图片是响应式的，尺寸永远满足各种窗口大小 */ } \u003c/style\u003e ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:4:4","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"可替换元素 https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element 考试可能会问，被问概率30% ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:4:5","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"form 标签 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:5:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"作用 发 get 或 post 请求，然后刷新页面 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:5:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"属性 \u003cform action=\"/xxx\" method=\"POST\"\u003e \u003cinput type=text /\u003e \u003cinput type=submit /\u003e \u003c/form\u003e action 默认需要给一个 action ，就是发送请求的目标地址（HTTP相关）、请求某一个页面的页面地址 需要有后台给我们提供这个地址 method method 属性控制用 GET 还是 POST 来发送请求 autocomplete 自动填写 autocomplete: on / off target 提交到哪个页面：新开页面、当前页面、iframe 与 a 标签写法一致 _blank top ：顶级窗口（结合 iframe） _parent ：父级窗口（结合 iframe） _self ：当前窗口（默认值） window.name \u003ciframe name=xxx\u003e\u003c/iframe\u003e \u003cform action=\"/xxx\" method=\"POST\" autocomplete=\"off\" target=\"a\"\u003e \u003cinput type=text /\u003e \u003cinput type=submit /\u003e \u003c/form\u003e \u003ciframe name=\"a\" src=\"a-target-iframe.html\" frameborder=\"0\"\u003e\u003c/iframe\u003e ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:5:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"事件 onsubmit：用户点击提交会触发这个事件 ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:5:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"type=submit form 中的 button 如果没有指定 type 类型，默认是 type=submit 的，点击 button 就会提交 form 表单。如果指定了其他类型，例如 type=button，按钮就不能提交表单。 一个 form 表单中，必须要有一个 type=submit 的 input 或 button ，才能提交表单。 ​ 修改submit按钮文字 \u003cinput type=\"submit\" /\u003e \u003cinput type=\"submit\" value=\"搞起\" /\u003e ​ submit 按钮的 input 和 button 的区别 \u003cinput type=\"submit\" value=\"搞起\" /\u003e \u003cbutton type=\"submit\"\u003e搞起\u003cbutton\u003e 区别是： input按钮中，不能再添加内容 button按钮中还可以再添加标签内容 \u003cbutton\u003e \u003cstrong\u003e搞起\u003c/strong\u003e \u003cimg src=\"dog.jpg\" alt=\"狗子\"\u003e \u003c/button\u003e ​ ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:5:4","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"input 标签 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:6:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"作用 让用户输入内容 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:6:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"属性 类型 type: button/checkbox/email/file/hidden/ number/password/radio/ search/submit/tel/text \u003cinput type=\"text\" /\u003e \u003cinput type=\"color\" /\u003e \u003cinput type=\"password\" /\u003e \u003cinput type=\"radio\" name=\"gender\" /\u003e男 \u003c!--同一组，取相同的name--\u003e \u003cinput type=\"radio\" name=\"gender\" /\u003e女 \u003cinput type=\"checkbox\" name=\"hobby\" /\u003e唱 \u003c!--同一组，取相同的name--\u003e \u003cinput type=\"checkbox\" name=\"hobby\" /\u003e跳 \u003cinput type=\"checkbox\" name=\"hobby\" /\u003erap \u003cinput type=\"checkbox\" name=\"hobby\" /\u003e篮球 \u003cinput type=\"file\" multiple/\u003e 看不见我吧：\u003cinput type=\"hidden\"\u003e \u003c!-- 通常用于js自动获取并填入 --\u003e \u003ctextarea style=\"resize: none;width:50%;height:50px\"\u003e\u003c/textarea\u003e \u003c!--禁止改变大小--\u003e \u003cselect name=\"\" id=\"\"\u003e \u003coption value=\"\"\u003e-请选择-\u003c/option\u003e \u003coption value=\"1\"\u003e星期一\u003c/option\u003e \u003coption value=\"2\"\u003e星期二\u003c/option\u003e \u003c/select\u003e 其他 （js内容） name/autofocus/checked/disabled/ maxlength/pattern/value/placeholder ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:6:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"事件 （js内容） onchange ：用户改变内容触发 onfocus：用户聚焦时触发 onblur ：用户失焦时触发 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:6:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"验证器 （js内容） HTML5新增功能：自带验证 例： \u003cinput type=\"text\" require/\u003e \u003cinput type=\"password\" require/\u003e ​ ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:6:4","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"其他输入标签 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:7:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"标签 （js内容） select + option textarea label ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:7:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"注意事项 一般不监听 input 的 click 事件 form 里面的 input 都要有 name form 里要放一个 type=submit 才能触发 submit 事件 ​ ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:7:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"补充工具：开启 http 服务 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:8:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"http-server 安装 yarn global add http-server 使用 http-server . -c-1 http-server -c-1 hs -c-1 -c 缓存，-c-1 不要缓存 . 可以省略 http-server 可缩写成 hs 按住ctrl + 点击打开任意链接。地址栏追加 html 文件名，即可浏览 ctrl + C 中断服务器 ​ ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:8:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"parcel 操作更简便 好像有bug ：ctrl + c 无法中断 yarn global add parcel // 安装 parcel a-href.html // 使用 ","date":"2020-07-18","objectID":"/html-a-simple-record-of-html-tags/:8:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"😎💋","date":"2020-07-17","objectID":"/html-introduction/","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"HTML (HyperText Markup Language) 不是一门编程语言，而是一种用来告知浏览器如何组织页面的标记语言。😎💋 HTML 可复杂、可简单，一切取决于开发者。 它由一系列的元素（elements）组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 一对标签（ tags）可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。 ​ ","date":"2020-07-17","objectID":"/html-introduction/:0:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"HTML 是谁发明的 HTML 之父 ","date":"2020-07-17","objectID":"/html-introduction/:1:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"1990年左右诞生 Tim Berners-Lee，称之为李爵士 2004年，英女皇他颁发大英帝国爵级司令勋章 2017年，被颁发图灵奖 ","date":"2020-07-17","objectID":"/html-introduction/:1:1","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"李爵士做了啥？ 自己写了第一个浏览器 自己写了第一个服务器 用自己写的浏览器访问了自己写的服务器 发明了WWW，同时发明了HTML、HTTP和URL ​ ","date":"2020-07-17","objectID":"/html-introduction/:1:2","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"HTML 起手式怎么写 快捷键：感叹号 ! + tab \u003c!DOCTYPE html\u003e ← 文档类型 \u003chtml lang=\"en\"\u003e ← 页面根标签 \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e ← 文件的字符编码 \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e ← 防止页面缩放 \u003cmeta http-equiv\"X-UA-Compatible\" content=\"ie=edge\"\u003e ← 如果在IE打开，告诉IE使用最新内核（IE11） \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e DOCTYPE：文档类型 浏览器支持很多种文档类型（HTML、XHTML…）。 \u003c!DOCTYPE html\u003e 表示告诉浏览器开始写HTML了。 html 标签是根标签 必须要写（如果没写也会自动加上） 可以把 lang 的属性值改为 zh-CN head 和 body 标签，虽然是 html 的子元素，但一般格式上不缩进 head 标签里面存放看不见的元素 viewport 视口、视窗 ​ ","date":"2020-07-17","objectID":"/html-introduction/:2:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"章节标签 章节标签，通常用于表示文章、书的层级（就是内容框架） 标题 h1~h6 章节 section 文章 article 段落 p 头部 header 脚部 footer 主要内容 main 旁支内容 aside 划分 div \u003cbody\u003e \u003cheader\u003e顶部广告\u003c/header\u003e \u003cdiv\u003e \u003cmain\u003e \u003ch1\u003e文章标题\u003c/h1\u003e \u003csection\u003e \u003ch2\u003e第一章\u003c/h2\u003e \u003cp\u003e 一段话一段话一段话一段话一段话一段话一段话一段话一段话一段话一段话 \u003c/p\u003e \u003csection\u003e \u003ch3\u003e1.1 节\u003c/h3\u003e \u003cp\u003e一段话\u003c/p\u003e \u003c/section\u003e \u003csection\u003e \u003ch3\u003e1.2 节\u003c/h3\u003e \u003cp\u003e一段话\u003c/p\u003e \u003c/section\u003e \u003c/section\u003e \u003c/main\u003e \u003caside\u003e 参考资料 1 2 3 \u003c/aside\u003e \u003c/div\u003e \u003cfooter\u003e\u0026copy; xxx版权所有\u003c/footer\u003e \u003c/body\u003e ​ ​ ","date":"2020-07-17","objectID":"/html-introduction/:3:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"全局属性 任何标签都可以有的属性 ​ ","date":"2020-07-17","objectID":"/html-introduction/:4:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"class ： 类名 \u003cstyle\u003e ← style标签也有contenteditable 属性，可以被编辑 [class=middle]{ /* 早期写法--缺点：当一个标签存在多个类名，就无法通过匹配单个类名来找到这个标签 */ background: black; color: white; } .middle{ /* 简写 */ background: black; color: white; } \u003c/style\u003e ​ ","date":"2020-07-17","objectID":"/html-introduction/:4:1","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"contenteditable ：让标签可以被编辑 style标签，也有 contenteditable 属性，可以被编辑 可以将 style 标签放到 body里面，然后添加 style { display : block; } ，style 标签中的样式内容就会显示在浏览器中，然后给style标签添加contenteditable 属性，就可以在浏览器总直接修改样式，并实时刷新 \u003cbody\u003e \u003cstyle contenteditable\u003e style{ display: block; } .xxx{ border: 10px solid orange; } \u003c/style\u003e \u003cp class=\"xxx\" contenteditable\u003e这段话可以直接在浏览器中编辑修改内容\u003c/p\u003e \u003c/body\u003e contenteditable\" contenteditable ​ ","date":"2020-07-17","objectID":"/html-introduction/:4:2","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"hidden ：让标签隐藏 \u003ch1 class=\"title\" hidden\u003e\u003c/h1\u003e .title{ display: block /* 直接添加属性hidden而隐藏的元素，可以通过设置样式 display: block，再显示回来 */ } ​ ","date":"2020-07-17","objectID":"/html-introduction/:4:3","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"id ：全局唯一 id 用来表示【全局唯一的标签】 id 的全局唯一性没有保障，就算有两个重复的 id，HTML 也不会提示我写错了 class足够了，不到万不得已不要用 id ，因为 id 重复使用也不会报错，可能误导开发者 \u003cheader id=\"xxx\"\u003e\u003c/header\u003e \u003cdiv id=\"xxx\"\u003e\u003c/div\u003e #xxx{ /* 此时设置的样式会同时对两个id=xxx元素生效，id被重复使用不会报错，那id的唯一性就毫无意义了 */ } id 中有很多不能使用的词：parent、self、top … 控制台输入 window. 弹出属性列表中所有的词都不能用，因为这些词是 window 已经有的全局属性 \u003cheader id=\"top\"\u003e\u003c/header\u003e \u003cscript\u003e top.style.border=\"10px solid red\" // 直接调用不能获取到top元素，与window对象中的全局属性重名 var ele = document.getElementById(\"top\") // 通过这种方式可以获取到 top 元素，但单词略复杂 \u003c/script\u003e ​ ","date":"2020-07-17","objectID":"/html-introduction/:4:4","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"style ：行内样式 \u003cdiv style=\"border: 10px solid red\" id=\"a\"\u003e\u003c/div\u003e js 中写 a.style.border = \"100px solid green\" 会覆盖 div元素中的行内样式 ​ ","date":"2020-07-17","objectID":"/html-introduction/:4:5","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"tabindex ：顺序 在浏览页面时，网页中按钮都只通过键盘 tab 控制切换选中。而这里的 tabindex 属性就是控制，切换的顺序 被选中的会有一圈不明显的蓝色边框 \u003ca tabindex=1\u003e首页\u003c/a\u003e \u003cp tabindex=3\u003e一段话\u003c/p\u003e \u003cfooter tabindex=2\u003e\u0026copy;版权所有\u003c/footer\u003e tabindex 可以是正数，不必是连续的 tabindex 可以是 0，表示最后才被 tab 访问 tabindex 可以是 -1，表示不可被 tab 访问 ​ ","date":"2020-07-17","objectID":"/html-introduction/:4:6","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"title ：鼠标指向时显示的内容 单行文字溢出，使用省略号 将鼠标移动到这段文字上时，应该能展示出全部文字内容，包括溢出隐藏的部分 \u003cp class=\"xxx\" title=\"显示一段超长的话\"\u003e一段超长的话\u003c/p\u003e \u003cstyle\u003e .xxx { text-overflow: ellipsis; /* 超出部分用省略号 */ overflow: hidden; /* 超出隐藏 */ white-space: nowrap; /* 不换行 */ } \u003c/style\u003e ​ ​ ","date":"2020-07-17","objectID":"/html-introduction/:4:7","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"内容标签 ","date":"2020-07-17","objectID":"/html-introduction/:5:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"ol+li ordered list + list item ol ：有序列表 ol 不能含有 li 之外的任何元素、字符 ","date":"2020-07-17","objectID":"/html-introduction/:5:1","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"ul+li unordered list + list item ul ：无序列表 ","date":"2020-07-17","objectID":"/html-introduction/:5:2","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"dl+dt+dd description list + term + data dl ：description list —— 描述列表 dt ：description term —— 描述项 dd ：猜测是 description data —— 描述信息 ","date":"2020-07-17","objectID":"/html-introduction/:5:3","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"pre preview 的缩写 用的较少 html 特点：HTML 代码里的多处空格、回车、tab 等内容，默认会被转化为一个空格 pre 的作用是，可以保留开发者键入的空白位置（pre 有默认样式，很丑，如下） pre\" pre ","date":"2020-07-17","objectID":"/html-introduction/:5:4","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"code 等宽字体 用 code 标签包裹的内容，字符是等宽的。但默认内容在同行展示，无法换行 使用 pre 可以让 code 的内容换行 code \u0026 pre+code\" code \u0026 pre+code ","date":"2020-07-17","objectID":"/html-introduction/:5:5","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"hr 水平分割线 horizontal ","date":"2020-07-17","objectID":"/html-introduction/:5:6","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"br break 的缩写 换行 ​ ","date":"2020-07-17","objectID":"/html-introduction/:5:7","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"a anchor 的缩写 超链接 href target 国内开发习惯使用 _blank 在新标签打开链接。 国外开发通常不写 target，他们觉得会让浏览器网页越开越多（他们习惯：通过鼠标中间点击打开新标签页，默认左键点击同屏跳转） ","date":"2020-07-17","objectID":"/html-introduction/:5:8","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"em emphasis 的缩写 emphasis 意为强调，效果字体斜体 ​ ","date":"2020-07-17","objectID":"/html-introduction/:5:9","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"strong 字体加粗 表示重要 ​ ","date":"2020-07-17","objectID":"/html-introduction/:5:10","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"q quote 的缩写 quote 意为引用 quote标签：内联，行内，不换行 ​ ","date":"2020-07-17","objectID":"/html-introduction/:5:11","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"blockquote 引用 块级，换行 quote \u0026 blockquote\" quote \u0026 blockquote ","date":"2020-07-17","objectID":"/html-introduction/:5:12","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["工具"],"content":"最近 Typora 有了更新，终于支持图床功能了 🎉！新增了原生对 PicGo-Core 的调用，可以自动上传 markdown 内的图片，尝鲜一波！","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"​ Typora 是一款简单、高效而且优雅的 Markdown 编辑器，它提供了一种所见即所得的全新的 Markdown 写作体验。它把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时生成预览效果。Typora 的一切都围绕纯粹的生产效率而设计。 Typora一直是我最喜欢的 markdown 编辑器，写博客、记笔记的首选软件。相信大部分朋友也在使用 Typora 这款软件。 但是 Typora 之前是不支持图床功能的，只能通过第三方插件实现图片自动上传的功能。不过最近 Typora 有了更新，终于支持图床功能了，新增了原生对 PicGo-Core 的调用，可以自动上传 markdown 内的图片，赶紧尝鲜一波。 ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:0:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"1. 安装 PicGo-Core 因为Typora已经原生支持PicGo-Core, 所以只需要在软件内下载一下就可以了(PS: 下面这张图就是用的自动上传, 很方便) 首先点击上面红色1的位置，选择 PicGo-Core，再点3（不要问我2去哪儿了….就当他不存在），并等待下载完成。 ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:1:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"2. 安装 smms 插件 直接点击红色5的位置，根据文本内容找到 PicGo-Core 的程序目录 注意，上图中我们只需关心红框中的路径下的 picgo.exe 文件，其他信息都不管 找到目录后，我们在picgo的目录下启动命令行，执行如下命令，并等待安装成功 .\\picgo.exe install smms-user ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:2:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"3. 配置 PicGo-Core 安装完成之后点击红色4的位置（红标顺序不代表点击顺序），打开 PicGo-Core 的配置文件，按照下面的格式无脑全选替换就行 { \"picBed\": { \"current\": \"smms-user\", \"uploader\": \"smms-user\", \"smms-user\": { \"Authorization\": \"这里替换成你自己的\" }, \"transformer\": \"path\" }, \"picgoPlugins\": { \"picgo-plugin-smms-user\": true } } 没有 Authorization 的自己去这里申请一个： https://sm.ms/home/apitoken 申请前需要注册一个账号，这个没啥难度，就不细说了。 ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:3:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"4. 体验效果 保存配置之后，我们直接在 Typora 内粘贴一张图片，就会自动提示上传中 或者在已有的本地图片上面按右键，也可以弹出上传图片的按钮，整个操作非常便捷。 ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:4:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"这里是文章描述，本文用于测试一些 Markdown 语法和样式展现","date":"2020-07-14","objectID":"/tools-test-markdown/","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"本文用于测试一些 Markdown 语法和样式展现 ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:0:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"文章摘要 \u003c!--more--\u003e [more注释]之前的内容，会作为文章摘要显示在主页。尽量不要包含代码块、图片、表格等模块。如果 [more注释] 之前的内容为空，则将自动添加 description 内容为文章摘要，显示在主页中。 ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:1:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"文章置顶 weight: 1 // Front-matter ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:2:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"常用语法 主题文档链接 ​ 反引号 ==高亮== ​ 加粗 ​ 斜体 下划线 这是一个链接哦。 ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:3:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"markdown 支持 emoji 在 config.toml 中开启/关闭 emoji 支持 表情包大全：https://hugoloveit.com/zh-cn/emoji-support/ 冒号joy冒号 冒号jack_o_lantern冒号 冒号heart冒号 😂 🎃 ❤️ ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:4:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"有序列表 有序列表1 无序列表 无序列表 有序列表2 有序列表3 ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:5:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"无序列表 无序列表 无序列表 无序列表 无序列表 在这里添加一个脚注 1 无序列表 无序列表 ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:6:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"复选框 - [x] Write the press release - [x] Update the website - [ ] Contact the media Write the press release Update the website Contact the media ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:7:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"代码块 console.log(\"test\") \u003cdiv class=\"box\" style=\"color:red;\"\u003e\u003c/div\u003e body{ font-size: 20px; } ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:8:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"内置 Shortcodes 语法支持 ","date":"2020-07-14","objectID":"/tools-test-markdown/:9:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"横幅 This is a tip 一个 danger 横幅 This is a tip 一个 note 横幅 This is a tip 一个 tip 横幅 ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:9:1","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"图片 Iceland (figure) ​ 点击图片放大，点击空白缩小↘ Iceland (image)\" Iceland (image) ​ ","date":"2020-07-14","objectID":"/tools-test-markdown/:9:2","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"二级标题 ","date":"2020-07-14","objectID":"/tools-test-markdown/:10:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"三级标题 四级标题 五级标题 六级标题 ​ 这是一段脚注 https://xxx 这是一段脚注 ↩︎ ","date":"2020-07-14","objectID":"/tools-test-markdown/:10:1","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["个人博客的创建之路"],"content":"Valine + LeanCloud","date":"2020-03-15","objectID":"/blog-comments-valine-leancloud/","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"hugo 博客添加评论系统 Valine Valine - 一款快速、简洁且高效的无后端评论系统。 Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho等博客程序在使用Valine。 所以，理论上它也是支持 Hugo 的， 实践证明，确实如此。其特性如下： 快速 安全 Emoji 😉 无后端实现 MarkDown 全语法支持 轻量易用(~15kb gzipped) 文章阅读量统计 v1.2.0-beta1+ 下面就讲一下如何一步步添加 Valine 支持的。 Tips: 整个过程，是以Loveit主题为例的，其它主题操作大同小异。 配置之前应该先阅读Valine快速开始 ​ ","date":"2020-03-15","objectID":"/blog-comments-valine-leancloud/:0:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"Leancloud相关配置 评论系统依赖于 leancloud，所以需要先在leancloud中进行相关的准备工作。 登录 或 注册 LeanCloud（国际版） 必须验证邮箱和手机号 成功后，进入后台点击左上角的创建应用： 创建好应用，进入应用，点击【组件】 左边栏找到【设置】，然后点击【应用Key】，此时记录出现的 App ID 和 App Key，后面配置文件中会用到： 因为评论和文章阅读数统计依赖于存储，所以还需要建立两个新的存储 Class 左边栏找到并点击【存储】，点击【创建Class】 创建两个存储Class，分别命名为: Counter 和 Comment； 仅修改 ACL 的 write 权限 还需要为应用添加安全域名，左边栏点击【设置】，找到【安全中心】，点击后会看到【安全域名】设置框，输入博客使用的域名，点击保存即可： ​ ","date":"2020-03-15","objectID":"/blog-comments-valine-leancloud/:1:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"config.toml 添加参数 添加 Valine 参数项： [params.page.comment.valine] enable = true appId = \"xxxxxxxxxxxxxxxxxxxxxx\" appKey = \"xxxxxxxxxxx\" placeholder = \"说点什么吧...（提醒：填写邮箱，若有人回复您，您将及时收到提醒邮件！）\" avatar = \"mp\" meta= \"\" pageSize = 10 lang = \"\" visitor = false recordIP = true highlight = true enableQQ = false serverURLs = \"\" # LoveIt 新增 | 0.2.6 emoji 数据文件名称, 默认是 \"google.yml\" # (\"apple.yml\", \"google.yml\", \"facebook.yml\", \"twitter.yml\") # 位于 \"themes/LoveIt/assets/data/emoji/\" 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \"assets/data/emoji/\" emoji = \"apple.yml\" 上面几项内容的含义，这里简单一说，具体还是要看 Valine官网中配置相关的内容： 参数 用途 enable 这是用于主题中配置的，不是官方Valine的参数，true时控制开启此评论系统 appId 这是在 leancloud 后台应用中获取的，也就是上面提到的 App ID appKey 这是在 leancloud 后台应用中获取的，也就是上面提到的 App Key notify 用于控制是否开启邮件通知功能，具体参考邮件提醒配置 verify 用于控制是否开启评论验证码功能 avatar 用于配置评论项中用户头像样式，有多种选择：mm, identicon, monsterid, wavatar, retro, hide。详细参考：头像配置 placehoder 评论框的提示符 visitor 控制是否开启文章阅读数的统计功能, 详情阅读文章阅读数统计 ","date":"2020-03-15","objectID":"/blog-comments-valine-leancloud/:2:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"完善评论通知 ⭐️⭐️ Valine 评论邮件提醒功能不太健全，通知邮件中没有文章直达链接，Valine 官网中提供了评论系统第三方功能扩展Valine链接，按照链接中的说明，非常详细的步骤，一步步很容易实现完备的评论系统后台管理以及邮件提醒功能，部分高级配置点我了解。这里简单列举步骤如下： ","date":"2020-03-15","objectID":"/blog-comments-valine-leancloud/:3:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"步骤 进入leancloud，【云引擎】【部署项目】【git】 填写仓库地址： https://github.com/zhaojun1998/Valine-Admin 填写分支： master 此外，你需要设置云引擎的环境变量以提供必要的信息，点击云引擎的设置页，设置如下信息： 必选参数 SITE_NAME : 网站名称。 SITE_URL : 网站地址, 最后不要加 / 。 SMTP_USER : SMTP 服务用户名，一般为邮箱地址。 SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式 SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、\"Yahoo\"、...... ，全部支持请参考 : Nodemailer Supported services。 — 如这里没有你使用的邮件提供商，请查看自定义邮件服务器 SENDER_NAME : 寄件人名称。 设置完环境变量，必须重新部署，邮件提醒功能才会生效 云引擎 —— 设置 —— 云引擎域名（如：jackma），保存 然后进入 存储 —— _User 添加一个用户，只需 User，password，email 三个信息即可。（为了安全考虑，此 email 必须为配置中的 SMTP_USER 或 TO_EMAIL， 否则不允许登录） 此时可以使用定义的主机域名登录后台管理系统了，地址为：[云引擎域名jackma].avosapps.us，用户名为刚设置的邮箱。 LeanCloud 休眠策略 首先需要添加环境变量，ADMIN_URL : 云引擎域名，如：https://jackma.avosapps.us（重启生效） 然后点击【云引擎】【定时任务】【创建定时任务】，按照图片上填写：0 0/20 7-23 * * ? 添加后，要记得点击启用 启用成功后，每 20 分钟在【云引擎】的 - 应用【日志】中可以看到提示 登录上面主机域名进入后台瞅一瞅： 我自己沙发了一条评论 日志提示： 进入后台后可以看到： 同时，我也收到了通知邮件： 至此完成了 Valine 评论系统的添加和完善，喝杯咖啡☕️庆祝一下！ ","date":"2020-03-15","objectID":"/blog-comments-valine-leancloud/:3:1","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"崩 免费的体验版，基本崩了。 评论提醒功能，可能必须经常手动部署。阅读量仍正常记录，不受牵连。 ​ ","date":"2020-03-15","objectID":"/blog-comments-valine-leancloud/:3:2","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"参考 Valine Valine-Admin leancloud-休眠策略 hugo博客添加评论系统Valine 将 Valine 切换至 leancloud 国际版 ","date":"2020-03-15","objectID":"/blog-comments-valine-leancloud/:4:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"hugo 搜索功能 Algolia","date":"2020-03-13","objectID":"/blog-search-algolia/","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"hugo 搜索功能 Algolia ","date":"2020-03-13","objectID":"/blog-search-algolia/:0:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"前言 Hugo是由 Steve Francis 大神(http://spf13.com/)基于Go语言开发的静态网站构建工具。没错你现在看到的本博客就是基于Hugo的，使用 Hugo 创建一个网站是非常简单的，基本上没有什么门槛，官方还提供了大量的主题供你选择，你只需要专心写的文章就行。不过有个问题是搜索，我们知道搜索属于动态行为了，如何给静态网站增加搜索功能呢？当然我们可以使用Google的站内搜索功能，Hugo 官方也提供了一些开源的和商业的解决方案，今天我们要介绍的就是一个非常优秀的商业解决方案：Algolia。 ","date":"2020-03-13","objectID":"/blog-search-algolia/:1:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"注册 前往官方网站https://www.algolia.com/ 使用 GitHub 或 Google 帐号登录。 登录完成后根据提示信息填写一些基本的信息即可。 注册完成后前往 Dashboard，我们可以发现 Algolia 会默认给我们生成一个 app。 默认的 app 可以在 settings → Applications 中重命名 选择 Indices，添加一个新的索引，我这里命名为blog，创建成功后，我们可以看到提示中还没有任何记录。 Algolia 为我们提供了三种方式来增加记录：手动添加、上传 json 文件、API。 ","date":"2020-03-13","objectID":"/blog-search-algolia/:2:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"修改 config.toml 配置 以下内容，基于 Loveit 主题测试生效 [params.algolia] appId = \"你的Application ID\" indexName = \"你的索引名字\" searchOnlyKey = \"你的Search-Only API Key\" 执行 hugo，会自动生成 public/index.json 用于索引 ","date":"2020-03-13","objectID":"/blog-search-algolia/:3:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"上传索引文件 生成索引文件之后，我们需要上传到 Algolia 的服务器。 ","date":"2020-03-13","objectID":"/blog-search-algolia/:4:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"手动上传 这一步是可选的，不过还是建议跟着做一下。 点击侧栏 Indices ，点击 Upload record(s) 按钮上传上一步生成的 index.json 文件。 上传成功之后，我们就可以马上尝试搜索了： 可以看到搜索的关键词有相应的匹配结果，说明我们生成的索引文件是正确的。 ","date":"2020-03-13","objectID":"/blog-search-algolia/:4:1","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"自动上传 每次写完博文都手动上传索引文件无疑是痛苦的、无意义的重复劳动。 因此我们需要把上传索引文件的操作自动化，在自动部署的时候顺便完成即可。 这里我们采用npm包 atomic-algolia 来完成上传操作。 安装 atomic-algolia 包 npm install atomic-algolia --save 修改根目录下的 package.json 文件（没有就新建），在 scripts 下添加 \"algolia\": \"atomic-algolia\" { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } 注意 \"test\" 那一行末尾有个英文逗号，不要漏了。 根目录下新建 .env 文件，内容如下： ALGOLIA_APP_ID=你的Application ID ALGOLIA_INDEX_NAME=你的索引名字 ALGOLIA_INDEX_FILE=public/index.json ALGOLIA_ADMIN_KEY=你的Admin API Key 注意替换你自己 Algolia 索引的信息。 另外特别注意 ALGOLIA_ADMIN_KEY 可以用来管理你的索引，所以尽量不要提交到公共仓库。可以添加到 .gitignore 中 上传索引的命令 你可以本地执行 npm run algolia 查看运行效果： 可以看到我们成功添加了记录。 后续，可以把下面的命令加到你的部署脚本中： npm run algolia // 在hugo命令后面执行 ","date":"2020-03-13","objectID":"/blog-search-algolia/:4:2","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"参考资料 Hugo添加Algolia搜索支持 atomic-algolia 插件 Hugo 集成 Algolia 搜索 ","date":"2020-03-13","objectID":"/blog-search-algolia/:5:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"个人博客绑定域名","date":"2020-03-12","objectID":"/blog-buy-setup-a-domain/","tags":["博客","域名","部署"],"title":"💰个人博客绑定域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"买个域名玩玩！ ","date":"2020-03-12","objectID":"/blog-buy-setup-a-domain/:0:0","tags":["博客","域名","部署"],"title":"💰个人博客绑定域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"个人博客绑定域名 ","date":"2020-03-12","objectID":"/blog-buy-setup-a-domain/:1:0","tags":["博客","域名","部署"],"title":"💰个人博客绑定域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"购买域名 namesilo （方便、无需填写个人真实信息）和阿里云（中文、可能需要实名填写详细信息） namesilo 进入官网，搜索并选中需求的域名（domain），进行注册 支付，使用支付宝，需设置支付宝邮箱 购买成功后，等待跳转。邮箱也会收到购买成功的邮件。 每年需要续费，不续费，会有一个保护期，保护期过了，域名就重新开放购买 点击 Manage my Domains 【管理我的域名】。 初次进入可能需要填写基本信息。点击 create my new account。只要保证当前账户邮箱是真实的即可 在域名管理页面，点击蓝色圆形按钮，可以进入 【Manage DNS】 管理DNS页面 ​ 阿里云 进入官网，注册一个账户，国内账户通常需要提供真实的手机号/姓名/身份证等。 在【域名与网站】选项卡中，选择【域名注册】；或者直接在搜索框进入【域名 控制台】选择【域名注册】 搜索域名，加入清单，结算 个人 or 企业 填写 [个人] 信息 支付 ​ ","date":"2020-03-12","objectID":"/blog-buy-setup-a-domain/:1:1","tags":["博客","域名","部署"],"title":"💰个人博客绑定域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"配置 GitHub Pages 添加域名 找到 github pages 中的 custom domain ，添加域名，SAVE 保存 仓库会多出一个 CNAME 文件，记录配置的域名 注意：不勾选 Enforce HTTPS。现在不用开启 HTTPS（不开启比较方便测试） 勾选后，所有与当前仓库相关的页面，可能都需要变成 https，可能还需要申请免费证书之类的，hin麻烦 ​ ","date":"2020-03-12","objectID":"/blog-buy-setup-a-domain/:1:2","tags":["博客","域名","部署"],"title":"💰个人博客绑定域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"配置 DNS 最终效果是，让 4个A记录出现在域名的DNS管理页面中，就搞定了 配置四条 A 记录 找到 github pages 中的 custom domain ，点击 Learn more ，找到【配置 apex 域】 找到 4 个IP，配置到域名中 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 namesilo 配置 A 记录 （点击蓝色圆形按钮）进入某个域名的管理页面，点击选择 A 会生成一个配置，然后依次将4个IP 多填入提交，生成4条配置。只保留这4条配置，将其他默认存在的配置删除即可，默认提供的配置都是没用的 阿里云 配置 A 记录 基本同 namesilo 在域名DNS解析中，添加 4 条 A 记录 IP 下拉框选择 @ ​ 测试DNS是否配置成功 打开命令行，运行nslookup liubingxuan.xyz 命令行能打印出4条A记录的IP，就说明配置的DNS生效了 刚配置完可能没法立即生效，需要等待（可能半小时、一天或更久，只能等，听天由命😢 ） Windows 用户：nslookup 域名 Mac 用户：dig + noall + answer 域名 A 记录可能要很久才会生效，等就好了 ​ ","date":"2020-03-12","objectID":"/blog-buy-setup-a-domain/:1:3","tags":["博客","域名","部署"],"title":"💰个人博客绑定域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"无法访问域名 如果全部配置成功，但仍无法访问域名、进入博客或者博客乱码，就只能放弃域名方案 😭。。。 把仓库中的 CNAME（自定义域名） 删掉。settings中 custom domain 也删掉。 ","date":"2020-03-12","objectID":"/blog-buy-setup-a-domain/:1:4","tags":["博客","域名","部署"],"title":"💰个人博客绑定域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"如何用 hugo 搭建个人博客","date":"2020-03-07","objectID":"/blog-start-a-hugo/","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"第一篇正式博文，我想给大家分享下我的博客的创建过程吧！🥇 ​ Hugo 是由 Go 语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 ​ ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:0:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"安装 Hugo 官方教程 英文 Mac 安装方式 brew install hugo hugo version Windows 安装方式 去 Hugo releases 页面 下载 hugo_xxx_Windows- 64bit.zip 解压，把 hugo.exe 放到 D:\\Software\\hugo\\hugo.exe 把 D:\\Software\\hugo\\ 加到 PATH 重启终端，运行 hugo version 查看版本 ​ ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:1:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"快速搭建博客 官方文档教程，必看！ ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:2:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"准备、提交 新建 blog 目录，运行 hugo new site xxx.github.io-generator ， xxx 为 github 用户名 。会在当前目录中创建 xxx.github.io-generator 文件夹（博客生成器） 进入博客生成器目录，git init 选择并下载主题 ，放到 themes 目录下 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 遇到报错 ↘ fatal: unable to access 'https://github.com/dillonzq/LoveIt.git/': error setting certificate verify locations: CAfile: D:/Software/Git/mingw64/ssl/certs/ca-bundle.crt CApath: none 解决办法：使用 git clone 出现 fatal: unable to access 'https://github.com/...' ，执行代码 ​↓ git config --system http.sslverify false // 把证书校验禁用 然后，将主题添加到站点配置中：echo 'theme = \"LoveIt\"' \u003e\u003e config.toml // 主题目录的名称 创建新文章：hugo new posts/first_post.md D:\\blog\\xxx.github.io-generator\\content\\posts\\first_post.md created 编辑文章后，修改 draft: false。draft : true 表示处于草稿状态，此时Hugo不会真正发布它 初次创建博客或修改主题，需将主题文档中给出的配置，粘贴到 config.toml 文件中。 baseURL 配置成 http://[用户名].github.io/ hugo server -D 建立本地访问 https://localhost:1313 预览博客 hugo 创建一个新的目录 public/，这就是需要提交到 github，最终生成线上博客的目录 根目录下，新建 .gitignore 文件，添加 /public/。使得 /public 可以自成一个仓库 进入public cd public，git init git add . git commit ​ ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:2:1","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"第一次部署 登录 github，创建博客专用仓库，仓库名必须为 ： [用户名].github.io 。 进入 public 目录，git remote add origin xxx git push -u origin master 进入 github 博客仓库的 Settings，找到 GitHub Pages ，选择 master ，保存 通过 http://[用户名].github.io 就能访问博客 ​ ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:2:2","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"以后的部署 在 xxx.github.io-creator 目录（注意确保自己不在 public 目录）里运行 hugo new posts/第二篇博客.md 运行 code posts/第二篇博客.md 对文件进行编辑，注意不要把文件原本的内容 front matter 给删了，直接在后面另起一行写新内容。 hugo server -D 建立本地访问 https://localhost:1313 预览博客 运行 hugo -D，得到新的 public 目录 进入 public 目录 cd public，执行一下操作 git add . 注意有一个点 git commit -m update git push -f 其中 -f 是强制上传的意思 等待几分钟后，你的博客就会出现第二篇文章了！ 通过 http://[用户名].github.io 访问博客 ​ ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:2:3","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"备份博客生成器 generator 程序员永远都会留备份 新建仓库 xxx.github.io-generator 将本地 xxx.github.io-generator 目录，git init，git add . ，git commit -m backup，git remote add origin xxx，git push -u origin master 即可 如果在执行 add 时，提示我们需要执行 rm 操作，可能是因为主题目录下已经存在 .git 文件，主题目录本身就是一个本地仓库了，那和 generator 目录会形成一个嵌套子目录的关系，that’s not good . 我们需要把主题目录下的 .git 文件删除 如果嵌套了，可以创建 .gitignore 文件。把【嵌套的子目录】添加到【.gitignore】中，忽略不上传 ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:3:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"网站基础配置 ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:4:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"网站 ico 图标配置 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在根目录下的 /static 目录中。利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件。 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color 。 ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:4:1","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"域名配置 博客根目录下的 /static 目录中，新建文件 CNAME 无后缀，填入域名 touch CNAME echo \"[你的域名]\" \u003e\u003e CNAME 执行 hugo ，会在 public 目录下生成 CNAME 文件。 push 到 github 后，会自动识别 CNAME 文件中的域名，填入 Github pages 的 custom domain 中，就无需手动配置域名啦！👍 ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:4:2","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"头像配置 博客根目录下的 /assets/images 目录中，存放名为 avatar.png 的图片。 执行 hugo，会在 public/images 目录下生成 avatar.png。push 到 github 后，网站会自动识别 avatar.png 作为网站头像 ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:4:3","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"文章 Front-matter 配置 title: \"主标题\" subtitle: \"这里是副标题\" draft: false #是否为草稿 weight: 1 #表示置顶。数字越小，文章越靠前 toc: auto: false # true自动收放，false全部展开不能收缩 author: \"Sam\" authorLink: \"https://liubingxuan.xyz/\" #设置作者名的链接 description: \"这里是文章描述。可在鼠标悬停文章封面图时显示此处内容\" license: \"转载请注明出处\" images: [] # 页面图片, 用于 Open Graph 和 Twitter Cards. tags: [\"标签1\",\"标签2\"] categories: [\"文章所处的大分类\"] #featuredImagePreview: \"https://i.loli.net/2020/07/15/QY8Ac1ojVqtl9XB.png\" 指定封面图网络地址 #featuredImage: \"https://i.loli.net/2020/07/15/QY8Ac1ojVqtl9XB.png\" resources: - name: \"featured-image\" # 指定文章内顶部封面图 src: \"featured-image.jpg\" - name: \"featured-image-preview\" # 指定文章在首页显示的封面图。可省略并默认使用featured-image src: \"featured-image-preview.jpg\" hiddenFromHomePage: false # 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: false # 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: false #如果设为 true, 这篇文章会使用 twemoji. lightgallery: true # 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: true # 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: true # 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: true # 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: true #如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: false #如果设为 true, 在 RSS 中将会显示全文内容. # ...... 更多配置，详见 Hugo 文档、Front Matter ","date":"2020-03-07","objectID":"/blog-start-a-hugo/:4:4","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"}]