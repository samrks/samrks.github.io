[{"categories":["JavaScript"],"content":"执行时机，又称调用时机，是 JS 函数的重要要素之一。","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:0:0","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"JS 函数的执行时机 执行时机，或说调用时机，是 JS 函数的要素之一 先抛出结论：JS 函数的执行时机不同，结果不同 下面逐例分析：函数调用执行的时机，是如何影响结果的 ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:0","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例1 let a = 1 function fn(){ console.log(a) } 输出：[未知] 分析：函数只有被调用才会执行。上述代码中的函数 fn 并未被调用，输出更无从说起。 ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:1","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例2 let a = 1 function fn(){ console.log(a) } fn() 输出：1 ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:2","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例3 let a = 1 function fn(){ console.log(a) // 看到这可能会认为是打印 1 // 但此时函数未被调用，可以忽略整个函数。不要提前把 a=1 带入到函数中做记号 } a = 2 // a变成2 fn() 输出：2 ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:3","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例4 let a = 1 function fn(){ console.log(a) } fn() // 看时机：函数被调用，此时 a=1 a = 2 输出：1 ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:4","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例5 let a = 1 function fn(){ setTimeout(() =\u003e { console.log(a) },0) } fn() a = 2 输出：2 分析： setTimeout 口语化理解相当于“过一会”、“尽快”（意思是忙完当前手头事，就立马执行里面的语句） 举个栗子： 你在打游戏（运行这段代码） 别人叫你去吃饭（fn()被调用） 你说马上去”（遇到 setTimeout ） “马上去” 的潜台词，是要先把这局游戏打完才去😜（继续向下执行 a=2） 现在打完了（其他代码全部走完） 可以去吃饭了 （console.log(a)） ​ ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:5","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例6 💡 let i = 0 for(i = 0; i\u003c6; i++){ setTimeout(() =\u003e { console.log(i) },0) } 输出：6 6 6 6 6 6 分析： 首先，let 声明一个 i 。 let i 写在 for 循环外，所以 let i（声明 i）不会参与到循环中。始终只有一个 i 开始 for 循环，逐步拆分 ↓ i=0 （i\u003c6） 遇到 setTimeout（执行完其他代码，再执行这里 setTimeout 中的语句）—— stand by ① i++ =\u003e i=1 （i\u003c6） 遇到 setTimeout —— stand by ② i++ =\u003e i=2 （i\u003c6） 遇到 setTimeout —— stand by ③ i++ =\u003e i=3 （i\u003c6） 遇到 setTimeout —— stand by ④ i++ =\u003e i=4 （i\u003c6） 遇到 setTimeout —— stand by ⑤ i++ =\u003e i=5 （i\u003c6） 遇到 setTimeout —— stand by ⑥ i++ =\u003e i=6 不符合条件 i\u003c6。 循环结束。 stand by 完毕，开始依次执行 ①②③④⑤⑥，此时 i=6 console.log(i) // 6 console.log(i) // 6 console.log(i) // 6 console.log(i) // 6 console.log(i) // 6 console.log(i) // 6 ​ 变形 for(var i = 0; i\u003c6; i++){ // 相当于只有一个 i setTimeout(()=\u003e{ console.log(i) },0) } // 6 6 6 6 6 6 ​ ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:6","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例7 💡 for(let i = 0; i\u003c6; i++){ // 相当于在每一次循环的代码块中各声明了一个i。一共声明了6个i setTimeout(()=\u003e{ console.log(i) },0) } 输出： 0 1 2 3 4 5 分析： for 和 let 连用，可以近似的理解为：每轮循环创建了一个作用域 { } let 特性，仅在当前作用域有效 { let i = 0， 满足 i \u003c 6 setTimeout(() =\u003e console.log(i), 0) // stand by ① } { let i = 1， 满足 i \u003c 6 setTimeout(() =\u003e console.log(i), 0) // stand by ② } ... { let i = 5， 满足 i \u003c 6 setTimeout(() =\u003e console.log(i), 0) // stand by ⑥ } { let i = 6， 不满足 i\u003c6 ，循环结束 } // 此时 stand by 完毕，开始依次执行 ①②③④⑤⑥ // 因为 let 存在作用域限制，所以每个 log 打印的都是其所在作用域的 i { console.log(i) // 0 } { console.log(i) // 1 } ... { console.log(i) // 5 } ​ 变形1 for (var i=0; i\u003c6; i++){ ! function(j){ setTimeout(function(){ console.log(j) }, 0) }(i) } 输出：0 1 2 3 4 5 分析：利用「立即执行函数」的参数，保存下 i 值 ​ 变形2 for (var i=0; i\u003c6; i++) { setTimeout((j) =\u003e { console.log(j) }, 0, i) } 输出：0 1 2 3 4 5 分析：利用 setTimeout 的第 3 个参数，保存下 i 值。一旦定时器到期，会作为参数传递给 function ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:7","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"JS 函数的基本介绍","date":"2020-09-14","objectID":"/javascript-function/","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"定义函数、call / apply / bind、大师调用法、调用时机、作用域、闭包、形参、调用栈、函数提升、arguments、this、箭头函数、立即执行函数。 ​ ","date":"2020-09-14","objectID":"/javascript-function/:0:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数是对象 函数怎么会是对象……看起来不一样啊 解释起来非常抽象，请直接接受这个结论 函数是一种特殊的对象 ","date":"2020-09-14","objectID":"/javascript-function/:1:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"定义一个函数 ","date":"2020-09-14","objectID":"/javascript-function/:2:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"1️⃣ 具名函数 function 函数名(形式参数1, 形式参数2){ 语句 return 返回值 } ","date":"2020-09-14","objectID":"/javascript-function/:2:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"2️⃣ 匿名函数 上面的具名函数，去掉函数名就是匿名函数 匿名函数，通常要声明一个变量进行赋值，不然函数就消失了 let a = function(x, y){ return x+y } 也叫函数表达式 ps：等号左边是声明变量 a 并赋值。等号右边部分，才是函数表达式 ","date":"2020-09-14","objectID":"/javascript-function/:2:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"例 function fn(x,y){ return x+y } ------------------------------- 上面是具名函数，函数名为fn； ------------------------------- 下面是匿名函数，函数没有名字，但是声明一个变量a来容纳这个函数的地址 let a = function(x,y){ return x+y } 变态 let a = function fn(x,y){return x+y} // fn(1,2) // 报错 fn 不存在：fn is not defined // 为什么？ a(1,2) // 3 解： 如果 fn 函数式的声明是在等号右边，那么这个 fn 的作用域就只能在等号右边、这块高亮的范围 出了这块高亮范围，fn 就不存在 其他地方要用这个函数，只能用 a 来调用 ​ function fn(x,y){return x+y} fn(1,2) // 3 如果没有左边赋值的操作，那么 fn 在哪里都可以用 ​ ","date":"2020-09-14","objectID":"/javascript-function/:2:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"3️⃣ 箭头函数 写法 let f1 = x =\u003e x*x let f2 = (x,y) =\u003e x+y // 多个形参，则圆括号不能省 let f3 = (x,y) =\u003e { return x+y } // 写了return，则花括号不能省 let f4 = (x,y) =\u003e {console.log('x+y='); return x+y } // 多语句时，花括号不能省，return不能省 变态：函数返回值是一个对象 // let f5 = (x,y) =\u003e {name:x, age: y} // JS 中 {} 被优先当做【代码块(label语法)】的起始，而不是对象 let f5 = (x,y) =\u003e ({name:x, age: y}) 函数返回值是一个对象，需要加个圆括号，表示里面是一个整体，不是一个代码块 可以看出 JS 这门语言每次添加新的语法时，可能都多少会有点小bug，大概是因为它要兼容以前得版本，所以有些错误它也解决不了（不是门很严谨的语言） ​ ","date":"2020-09-14","objectID":"/javascript-function/:2:4","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"4️⃣ 用构造函数 // 单语句 let f = new Function('x', 'y', 'return x+y') // 多语句 let f = new Function('x', 'y', 'console.log(\\'hi\\'); return x+y') f(1,2) // hi // 3 基本没人用，但是能让你知道函数是谁构造的 所有函数都是 Function 构造出来的 包括 Object、Array、Function 也是 （这里都省略了 window. ） Function 本身也是由自己构造出来的（在对象原型的笔记中解释过） ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:2:5","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数自身 vs. 函数调用（区别） fn V.S. fn() ","date":"2020-09-14","objectID":"/javascript-function/:3:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数自身 let fn = () =\u003e console.log('hi') fn 结果 不会有任何结果 因为 fn 没有执行（执行就是调用，调用就是执行） ","date":"2020-09-14","objectID":"/javascript-function/:3:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数调用 let fn = () =\u003e console.log('hi') fn() 结果 打印出 hi 有圆括号才是调用 ","date":"2020-09-14","objectID":"/javascript-function/:3:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"再进一步 let fn = () =\u003e console.log('hi') // 很多人认为fn就是函数，实际上这里的fn只是保存了函数的地址 let fn2 = fn // 把fn保存的地址复制给fn2 fn2() 结果 fn 保存了匿名函数的地址 这个地址被复制给了 fn2 fn2() 调用了匿名函数 实际上 fn 和 fn2 都是对匿名函数的引用而已 真正的函数既不是 fn 也不是 fn2 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:3:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数的要素（9 个）🤩 9个概念需要知道，其他函数的教程，都没这里讲的细 ","date":"2020-09-14","objectID":"/javascript-function/:4:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"每个函数都有这些东西 调用时机 作用域 闭包 形式参数 返回值 调用栈 函数提升 arguments（除了箭头函数） this（除了箭头函数） JS 的三座大山 原型、原型链 this AJAX 搞懂这三座大山，vue、react、angular … 就都可以去学了。 但如果三个有任何一个没搞清楚，那就还是 JS 没入门的水平。你会感觉一直在 JS 的屏障/瓶颈中 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"1️⃣ 调用时机 🧐 JS 函数的执行时机 —— 时机不同，结果不同 例1 let a = 1 function fn(){ console.log(a) } 问打印出多少？答：不知，因为没有调用（函数只有被调用才会执行） 例2 let a = 1 function fn(){ console.log(a) } fn() 问打印出多少？答：1 例3 let a = 1 function fn(){ console.log(a) // 很多人看到这，会认为是打印 1。 // 但此时函数根本没执行过，可以完全忽略整个函数，不要提前就把 a=1 带入到函数中做记号 } a = 2 // 到这里，a变成2了 fn() 问打印出多少？答：2 例4 let a = 1 function fn(){ console.log(a) } fn() // 看时机：函数被调用，此时a=1 a = 2 问打印出多少？答：1 例5 let a = 1 function fn(){ setTimeout(()=\u003e{ // setTimeout 相当于过一会、尽快（意思是当前手头事忙完，就立马执行里面的语句） console.log(a) },0) } fn() a = 2 举个栗子：你在打游戏（运行这段js），你妈叫你去吃饭（fn()被调用） ，你说马上去（执行setTimeout）。说了马上去，意思是要先把这局游戏打完才去（继续向下执行a=2）。现在打完了(js全部走完)，可以吃饭 console.log(a) 问打印出多少？答：2 例6 💡 let i = 0 // 注意：let i 写在for外面，相当于 i 只声明了一个。let i（声明i）的过程不会参加到循环中 for(i = 0; i\u003c6; i++){ setTimeout(()=\u003e{ // 忙完手头事（for循环）立马执行里面的语句 console.log // 【异步】 console.log(i) // 6 6 6 6 6 6 },0) } 上面代码块打印出多少？答：不是 0、1、2、3、4、5，而是 6 个 6 变形： for(i = 0; i\u003c6; i++){ // 相当于只有一个 i setTimeout(()=\u003e{ console.log(i) // 6 6 6 6 6 6 },0) } ------------------------------------------------- for(let i = 0; i\u003c6; i++){ // 这样相当于在每一次循环体的代码块中各声明了一个i，一共声明了6个i setTimeout(()=\u003e{ console.log(i) // 0 1 2 3 4 5 },0) } 例7 💡 for(let i = 0; i\u003c6; i++){ // 这样相当于在每一次循环体的代码块中各声明了一个i，一共声明了6个i // 每次循环都会创建一个i 进行赋值，然后留在这个空间中。6次循环创建6个新的i在各自的{}中，互不干涉 // 细品：类似于刻舟求剑，每次刻一下，剑的位置竟随着舟的移动也发生了变化 setTimeout(()=\u003e{ console.log(i) },0) } 问打印出多少？答：是 0、1、2、3、4、5。 因为 JS 在 for 和 let 一起用的时候会加东西，每次循环会多创建一个 i（我服了 JS） ​ 总结 setTimeout 就是尽快、等一会，但是不是现在。相当于先干完手头的，然后去做 setTimeout 里面的 JS 函数的「调用时机」，由于变量的值可能会发生改变，所以每次求值的时候都要想一想所有代码执行的顺序是怎样的。如果不能确定代码执行的顺序，那么最终结果可能就是不对的。 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"2️⃣ 作用域 每个函数都会默认创建一个作用域 作用域特别简单，就是画圈圈 例1 function fn(){ let a = 1 // let声明的变量的作用域仅在当前这个 {...} 中 } console.log(a) // 报错 a is not defined // a不存在 问：是不是因为 fn 没执行，导致 a 不存在 ？？ 例2 function fn(){ let a = 1 } fn() console.log(a) // 即使 fn 执行了，a 还是不存在，仍旧报错 答：就算 fn 执行了，也访问不到作用域里面的 a 跟执不执行没有关系。 let 声明的变量的作用域非常好找。 在 let 声明语句的前面找到一个 { ，在 let 语句后面找到一个 } ，这俩半个花括号组成的作用域{ } ，就是 let 变量的作用域 ​ 全局变量 vs. 局部变量 在顶级作用域声明的变量是【全局变量】 挂载到 window 上的属性是【全局变量】 其他都是【局部变量】 function fn(){ let a = 1 // let 声明的变量 a，仅在fn函数的{}内生效，所以是局部变量 } let b = 2 // let声明的变量b，是在顶级作用域声明的，所以是全局变量，全局可访问 window.c = 3 // 在window上声明变量c，c就是全局变量，全局可访问 function f1(){ window.d = 4 console.log(c) } function f2(){ console.log(d) } f1() // 3 // 函数里也可以访问到 window 上的 c f2() // 4 // f2函数中能访问到f1函数中，声明在window 上的变量d 只要是挂载在window上的变量，不论在哪个作用域声明/挂载的，都是全局变量，全局可访问 为什么有些方法可以直接使用，因为是挂在 window 上的 例如： Object / window.Object 、parseInt / window.parseInt … 函数可嵌套 作用域也可嵌套 就近原则 function f1(){ let a = 1 function f2(){ // 在f1函数中声明了一个f2函数 let a = 2 console.log(a) } console.log(a) a = 3 f2() } f1() // 1 // 2 作用域规则 如果多个作用域有同名变量 a （如上） 那么查找 a 的声明时，就向上取最近的作用域 简称「就近原则」 查找 a（分清作用域）的过程与函数执行无关 函数的作用域与函数执行无关 —— 静态作用域（又叫 词法作用域，属于编译原理的知识） 函数的作用域与函数执行有关 —— 动态作用域，但 JS 里没有动态作用域，只有静态 但 a 的值与函数执行有关 例4 ⭐️ 看懂这个例子，作用域就没什么问题了 function f1(){ let a = 1 function f2(){ let a = 2 function f3(){ console.log(a) } a = 22 f3() } console.log(a) a = 100 f2() } f1() // 1 // 22 作用域总结：==「就近原则」== ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"3️⃣ 闭包 闭包上面讲过了 —— 讲过了吗？！ 重看例4 function f1(){ let a = 1 function f2(){ --------------------------- let a = 2 function f3(){ console.log(a) // f3里面用到了外层函数f2的变量 a ，那么 a 和 f3 就是闭包 } --------------------------- a = 22 f3() } console.log(a) a = 100 f2() } f1() 闭包 如果一个函数用到了外部的变量 那么这个函数加这个变量 就叫做闭包 左边的 a 和 f3 组成了闭包 闭包的用途以后讲，这里先把【闭包】的形式记下来即可 你也可以先搜一下 “ 闭包这么简单吗？怎么看到网上讲的各种花里胡哨… ” frank：在 JS 基础知识这方面，我很有自信，我比其他所有在网上教你的人都懂。网上教的乱七八糟的 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:4","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"4️⃣ 形式参数 形式参数的意思就是非实际参数 function add(x, y){ return x+y } // 其中 x 和 y 就是【形参】，因为并不是实际的参数，x/y并【不代表任何实际的值】，仅代表参数的【顺序】 add(1,2) // 调用 add 时，1 和 2 是实际参数【实参】，会被赋值给 x 和 y 其他 JS 教程可能会说： JS 传参时分为「值传递」和「地址传递」。 上面记法太复杂，如果你搞懂了内存图，就知道没那么麻烦。 实际上，传参就是把 stack 里记的内容拷贝给形参（不要区分什么值和地址，太麻烦了） function add(x, y){ return x+y } add(1,2) // 3 // x接收到的 1，和 add(1,2) 这里的1，不是同一个1，只是复制了一份给 x function addObject(x,y){ return x.value + y.value } addObject({value:1},{value:2}) // 3 // 怎么知道调用时，赋给x的{value:1}和 addObject(x,y)中x接收到的{value:1}是不是同一个 // 测试一下 let a = {value:1} let b = {value:2} function addObject(x,y){ // 执行函数不仅把value加起来，还偷偷把x的内容改掉，看看是否影响到外面定义的x x.name = 'xxx' return x.value + y.value } addObject(a,b) // 3 a // {value: 1, name: \"xxx\"} // 诶! a被改了 如果搞懂内存图，就会知道，当我们在赋值时，只是把 a 存的 stack 内容，拷贝给形参 实际上，传参就是把 stack 里记的内容拷贝给形参（不要区分什么值和地址，太麻烦了） 而形参 x / y ，应该会存储在「不知道什么区」（代指任何应该出现的区） ​ 形参可认为是变量声明 其实，形参的本质就是变量声明 「形参」并不特殊，就是个语法糖 // 上面代码近似等价于下面代码 function add(){ var x = arguments[0] // 为什么用 var ? 答：历史原因，当时发明形参时 就只有var声明 var y = arguments[1] return x+y } ​ 形参可多可少 形参只是给参数取名字而已 function add(x){ // 只声明一个形参，如果传了两个参数，怎么拿到第2个形参呢？ return x + arguments[1] } add(1,2) // 3 arguments 就是所有形参组成的数组 所以我们没有必要，把形参全部声明出来。通过 arguments 就可以全部获取到 function add(x,y,z){ return x+y // z 怎么办？无所谓，声明着玩 } add(3,4) // 7 JS 代码就是这么随意，形参爱多就多，爱少就少，没有规则约束 后来这种特性造成一些问题，比如 TypeScript 兴起，TS 要求形参必须按照严格的类型和顺序 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:5","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"5️⃣ 返回值 每个函数都有返回值 不存在没有返回值的函数 function hi(){ console.log('hi') } hi() 没写 return，会默认返回值是 undefined function hi(){ return console.log('hi') } hi() // hi // 会照常执行语句的打印效果，并不表示这是语句的返回值 // undefined // 返回值 return console.log('hi') 也就是说返回值为 console.log(‘hi’) 的值，也就是 log 函数 的返回值，因为 log 函数没有 return，所以最终的值就是 undefined return 的结果，还是比较严谨的 ​ 函数执行完了后才会返回 如果不执行，就不会有返回值 执行了，才会有返回值 ​ 只有函数有返回值 1+2 的返回值为 3 ❌ （这是我们常见的一种口误，没有 return 哪来的返回值） 1+2 的值为 3 ✅ ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:6","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"6️⃣ 调用栈 ⭐️ MDN：Call stack 很抽象。是函数非常重要的要素。 什么是调用栈 JS 引擎在调用一个函数前 需要把函数所在的环境 push 到一个数组里 这个数组叫做调用栈 等函数执行完了，就会把环境弹(pop)出来 然后 return 到之前的环境，继续执行后续代码 举例 console.log(1) console.log('1+2的结果为' + add(1,2)) console.log(2) 调用栈的作用（抽象） 计算机是健忘的，每次进到一个函数，都要记下来等会要回到哪。把记录写到「调用栈」中 所以要把这个回到的地址，写到这个调用栈里面 ——「压栈」 在进入一个函数后，还要再进入另一个函数（嵌套的），那也要把这个子函数的地址放到栈里 等当前子函数执行完毕，就**「弹栈」**—— 告诉计算机函数执行完要回到哪了。当前父函数执行完，再弹栈… 弹栈，会立刻删除调用栈列表中压栈时存下的对应信息。 MDN 调用栈 这个模型还是比较重要的。 JS 每次进入一个函数之前，先存档，执行完毕，没什么问题就读档，消掉前面的档 类似玩游戏打boss之前要存档，dead了后，就能自动读档到打boss之前的游戏进度 —— 与 JS 的流程不是非常一致，就是大概意思. 主要理解上面的流程图 「栈」会不会满呢？ 如果使用递归函数，就有可能把栈压满。 因为递归函数，可能会一直不停的在压栈。 递归函数 阶乘 当 n 不等于 1，就执行 n × f(n-1) 当 n 等于 1，就返回 1 function f(n){ return n !== 1 ? n* f(n-1) : 1 } ​ 理解递归 层层递进↘，再层层回归↙ —— 递归 f(4) = 4 * f(3) = 4 * (3 * f(2)) = 4 * (3 * (2 * f(1))) = 4 * (3 * (2 * (1))) = 4 * (3 * (2)) = 4 * (6) 24 先递进↘，再回归↙ 很多教程中，说递归就是不停的调用自己，实际上是不正确的理解 调用自己 !== 递归。调用自己有时候会死循环的，死循环就不是递归。递归——先递进，再回归、 递归的尽头，就在 f(1) === 1 这个关键点。 ​ 递归函数的调用栈 递归函数的调用栈很长 请画出阶乘 (4) 的调用栈 阶乘 4 ，会压 4 次栈 阶乘 10000 ，会压 10000 次栈 （数值太大，Chrome 计算不了） 试试「阶加」10000，压 10000 次栈 function sum(n){ return n !== 1 ? n+ sum(n-1) : 1 } sum(10000) // 50005000 sum(20000) // Maximum call stack size exceeded 【爆栈】 爆栈 如果调用栈中压入的帧过多，程序就会崩溃 —— 爆栈 function sum(n){ return n !== 1 ? n+ sum(n-1) : 1 } sum(10000) // 要压10000次栈 // 50005000 sum(20000) // 要压20000次栈 // 已经报错。Maximum call stack size exceeded 可以用二分法，试试 Chrome 最多能压多少次栈 sum(15000) // 爆栈 sum(12500) // 爆栈 sum(11431) // 爆栈 sum(11430) // 65328165 Chrome 的调用栈的长度，大概 11000 ~ 12000 左右，不是固定值（因为里面可能已经放了一些别的东西） ​ 调用栈最长有多少 使用下面代码，可以测试一个浏览器的调用栈的长度 function computeMaxCallStackSize() { try { return 1 + computeMaxCallStackSize(); } catch (e) { // 报错说明 stack overflow 了 return 1; } } Chrome 12578 Firefox 26773 Node 12536 Chrome 和 Node 的用的是同一个 JS 引擎，所以测出来差不多。 Firefox 用的是自己的 JS 引擎，所以可能大一些 ​ 总结————————————— 什么是调用栈 就是我们进入一个函数时，要先把这个环境存下来，然后再进去，不然函数执行完就不知道怎么回去了。 要存的东西很多，就需要一个数组来保存。这个保存函数所在环境的数组，就叫「调用栈」 调用栈的长度大概是在一万到两万左右，超过这个值程序就会崩溃 —— 爆栈 ​ ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:7","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"7️⃣ 函数提升 什么是函数提升 不管你把具名函数声明在哪里，它都会跑到第一行 function fn(){} 示例 add(1,2) function add(x,y){ return x+y } // 3 有一种代码规范就是，把所有声明的函数，都集中放到最后面，这样代码阅读起来就更简洁 拓展 如果同时声明 变量 add 和 函数 add，那 add 到底是谁呢？ let add = 1 function add(){} 报错：add 已经被声明了。 输出 add，结果为 函数 add。（函数会提升，自动变成 ↓↓ 这样） function add(){} let add = 1 let 特性：如果这个变量已经存在，就不允许再次重复声明，会直接报错 但是用 var 声明，就不会报错 var add = 1 function add(){} var add function add(){} 由上，用 var 可能有很多问题，搞不清到底表示函数还是什么。（押题再讲 var） 如果只用 let ，那世界就清净了。因为只要 let 重复声明，就会报错，避免上述搞不清变量到底是谁的 bug 学习方法：难得东西着重去学；简单的东西，可以放到面试准备阶段背 就比如：var 很复杂，但又没什么用，只是面试会考到。所以我们只在面试准备阶段，讲一下 ​ 什么不是函数提升 let fn = function(){} 这是赋值，右边的匿名函数声明不会提升，你在什么时候写，它就什么时候声明 例 add(1,2) // 报错 let add = function(x,y){return x+y} // 这个函数的声明并没有提升，导致声明前先调用，所以会报错 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:8","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"8️⃣ arguments ","date":"2020-09-14","objectID":"/javascript-function/:4:9","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"9️⃣ this ⚡️ arguments 和 this，是除了箭头函数，每个函数都有的。 箭头函数，是新出的语法，故意摒弃了这两个特性。 可见，新的语法并不认为这俩是好东西 正如 JS 之父说的：JS 的原创之处并不优秀、优秀之处并非原创 arguments 和 this 就是 JS 原创的，使得 JS 语法特别独特，也特别不好用 ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:10","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"理解 arguments 译为：参数 注意 arguments 是所有参数组成的伪数组 每次调用函数时，都会对应产生一个 arguments 我们应该尽量不对 arguments 内的元素进行修改，修改 arguments 会让代码变得令人疑惑 function fn(){ console.log(arguments) } fn() fn(1) fn(1,'a') 发现：打印 arguments，结果类似数组 实际上， arguments 是包含所有参数的伪数组。 arguments 数组的原型是「根对象」——包含对象的共有属性。没有 push、shift、join … 这些数组共有方法 没有数组共有方法的数组，就是「伪数组」 「伪数组」怎么变真数组 ？ 通过 Array.from(array) 可以把任何不是数组的东西，转换为真数组（具有数组的共有属性） ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:5:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"理解 this ⚡️ this 可以说是 JS 的 “ 千古奇案 ” —— 各种取值，眼花缭乱 ","date":"2020-09-14","objectID":"/javascript-function/:6:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"情况一 如果不给任何条件，那么 this 默认指向 window（包含所有全局变量） 这种情况，通常用不上。因为如果要获取 window 上的某变量，直接写就行 window.xxx ，不需要用 this 来指代 function fn(){ console.log(this) } ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"如何指定 this 目前只能用 fn.call(…) 情况一 如果传的 this 不是对象，JS 会尽量封装成对象 function fn(){ console.log(this) } fn.call(1) // → 对象1 fn.call(undefined) // → window 什么叫「封装成对象」？ 就是 new Number(1) // 具有 number 的共有属性 —— 但基本没人用 怎么禁用这个自动封装的特性 ？ 例：传数字 1，最终 this 就是指向【数字 1】，而不被自动封装成【对象 1】 // 很简单，在声明函数的时候，【使用严格模式】，相当于告诉 JS 不要随便添加东西 function fn(){ 'use strict' console.log(this) } fn.call(1) fn.call(undefined) ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"同时指定 this 和 arguments 目前可以用 fn.call(xxx, 1,2,3) 传 this 和 arguments 第1个参数是 this，后面所有参数是 arguments xxx 作为 this，会被自动转化成对象（JS 的糟粕） function fn(){ console.log(this) console.log(arguments) } fn.call(1,2,3,4) ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"“ this 是隐藏参数、arguments 是普通参数 ” this 是参数（此结论是 frank 个人的） ↑↑ 是什么意思呢 ？ —— 我们需要花很多例子，来理解这句话 要理解 this，先从 JS 中把 this 排除出去。就是看看不用 this，能不能达到跟 this 一样的功能 ！ ","date":"2020-09-14","objectID":"/javascript-function/:6:4","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"假设没有 this let person = { name: 'frank', sayHi(){ console.log(`你好，我叫` + person.name) // 以前是使用 this.name，改成 person.name } } 为什么这里可以用 person.name，应该还没完成 person 的声明吧 ？ 因为这是一个函数，函数等会儿才会执行，等到执行时，person 不是已经完成了声明吗 ！！所以这是可以的 我们在 person 对象中声明一个函数的时候，在函数中可以用变量 person 得到这个对象的引用 在不准用 this 的前提下，这段代码是合法的，也符合我们的预期 我们可以用直接保存了对象地址的变量获取 ‘name’ 我们把这种办法简称为引用 （ 一个变量保存了一个对象的地址，就叫引用） 问题一 如果先声明了这个函数，后声明对象 let sayHi = function(){ console.log(`你好，我叫` + person.name) // 函数声明时怎么知道会有 person 变量呢，person 还没声明 ？ // 虽然执行上没问题，但先后逻辑上确实略有不通之处 } let person = { name: 'frank', 'sayHi': sayHi // 引用sayHi函数 } person sayHi() 分析 person 如果改名，sayHi 中引用 person 的地方也必须跟着修改，否则 sayHi 函数就挂了 甚至有可能有 2 个单独 JS 文件，一个放着 person，而 sayHi 函数在另一个文件里面。 这样就显得更加奇怪：一个文件居然需要知道另一个文件中有什么变量 所以我们可能不是很希望 sayHi 函数里出现 person 引用 （感觉上这个代码有点不好，但也不是那么不好，较尴尬令人不爽 🙃 ） ​ 问题二 ⚡️⚡️ 对象还好，如果用 类 class 的话，问题就更大了。 class Person{ constructor(name){ this.name = name // this 指临时的新对象，这里的 this 是 new 强制指定的。我们就不讨论了 😅 } sayHi(){ console.log(???) // 问题在这，怎么打印出name呢？声明类时，还没有new出任何实例对象，没法引用 } } 我们想在 sayHi 中获取到当前对象的 name，但此时根本就没有当前对象，那怎么获取 ？ 我们就需要一种机制，来获取到未来的对象的 name 的引用 分析 这里只有类，还没创建对象，故不可能获取对象的引用 那么如何拿到对象的 name 属性？ 🤔 ​ 需要一种办法拿到未来的对象 复述问题：我们需要在函数中，获取一个对象的引用，但这个对象还未创建，那要怎么获取 ？ 怎样才能获取的未来对象的引用，以便拿到对象的 name 属性？ → 怎样在不知道对象名字的情况下，拿到对象的引用 ？ 一种土办法，用参数（传参） 对象 let person = { name: 'frank', sayHi(p){ console.log(`你好，我叫` + p.name) } } person.sayHi(person) // 用参数的形式，把你要得到的对象，传给了你 // 这种方法，看起来很冗余、很挫 类 class Person{ constructor(name){ this.name = name } sayHi(p){ console.log(`你好，我叫` + p.name) } } ​ 谁会用这种办法 —— Python Python 在每一个函数中加了一个参数，并且约定这个参数就是后面创建的新对象 class Person: def __init__(self, name): # 构造函数 self.name = name def sayHi(self): print('Hi, I am ' + self.name) person = Person('frank') person.sayHi() # Python 默认会把 sayHi 前面的 person 作为参数传到 sayHi 中，所以 self 就是这个参数 特点 每个函数都接受一个额外的 self 这个 self 就是后面会创建并传进来的对象 只不过 Python 会偷偷帮你传对象 person.sayHi() 等价于 person.sayHi(person) person 就被传给 self 了（得到了一个未来的对象的引用） 这其实是任何语言都要解决的问题 —— 在写代码的时候，不知道后面要创建的对象叫什么 ​ JS 没有模仿 Python 的思路 JS 走了另一条路 —— 更难理解的路 —— 这就是 JS 的第二座大山 this ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:5","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"JS 在每个函数里加了 this ⚡️⚡️ JS 没有像 Python 那样加一个参数，而是发明了一个关键字 —— this 在任何一个函数里，可用 this 获取到那个你现在还不知道名字的对象 let person = { name: 'frank', sayHi(隐藏的this){ console.log(`你好，我叫` + this.name) } } person.sayHi() ---------------------------------------------------- class Person{ constructor(name){ this.name = name } sayHi(p){ console.log(`你好，我叫` + p.name) } } let person = new Person('frank') person.sayHi() // 隐式的写了 this = p （JS引擎擅自执行的操作） // ↑↑ 相当于 ↓↓ // person.sayHi(person) // JS 和 Python 做了一样的处理：会自动把 person 传给 sayHi // 然后 person 被传给 this 了（person 是个地址） JS 做的第 1 件事：把 this关键字 赋予 sayHi。 JS 做的第 2 件事：把 person(地址) 传给 this。 综上，就是把 person 给了 sayHi 这样，每个函数都能用 this 获取一个未知对象（person）的引用了 ","date":"2020-09-14","objectID":"/javascript-function/:6:6","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"person.sayHi() 会隐式地把 person 作为 this 传给 sayHi （ 而不是像 Python 一样作为第 1 个参数 self ，传给 sayHi ） 方便 sayHi 获取 person 对应的对象 ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:7","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"总结 总结一下目前的知识 我们想让函数获取对象的引用 但是并不想通过变量名做到 Python 通过额外的 self 参数做到 JS 通过额外的 this 做到： person.sayHi() 会把 person 自动传给 sayHi，sayHi 可以通过 this 引用 person 其他 注意 person.sayHi 和 person.sayHi() 的区别 注意 person.sayHi() 的断句 (person.sayHi) ( ) ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:8","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"这就引出另一个问题 💡 到底哪个对 let person = { name: 'frank', sayHi(){ // 隐藏的this参数 console.log(`你好，我叫` + this.name) } } // 自动隐式的把 person 传给 sayHi person.sayHi() // 省略传参 ？ person.sayHi(person) // 完整传参 ？ 哪种写法是对的 省略形式反而对了，完整形式反而是错的 JS 怎么解决这种不和谐 [Python](#谁会用这种办法 —— Python) 至少有明确的约定：这种 person.sayHi() 写法就会把 person 传给 sayHi 的第 1 个显式参数 self 。 那 JS 要怎么解释 this 的存在呢 ？（函数并没有显式的形参，this 完全是一个不成文的、隐性的约定） JS 提供两种调用形式 ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:9","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"两种调用🧐 小白调用法 🚫 person.sayHi() 会自动把 person 传到函数里，作为 this 大师调用法 ✅ 使用 JS 新出的调用方法：call person.sayHi.call(person) 需要自己手动把 person 传到函数里，作为 this （更为清晰） let person = { name: 'frank', sayHi(){ console.log(`你好，我叫` + this.name) } } person.sayHi.call({name:1}) // call 里传什么 this 就是什么，非常清晰 应该学习哪种？ 学习大师调用法，因为小白调用法你早就会了 从这段笔记开始，默认用大师调用法 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:10","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"指定 this 😈 ","date":"2020-09-14","objectID":"/javascript-function/:7:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"call 指定 this call 是 JS 新出的调用方法。call 会使得所有东西变得明朗起来 let person = { name: 'frank', sayHi(){ console.log(`你好，我叫` + this.name) // call传什么this就是什么 } } person.sayHi.call({name:1}) // call 里传什么 this 就是什么，非常清晰 person.sayHi.call({name:'jack'}) ------------------------------------------------------------------------------- // 大多数情况，我们需要this就是当前对象 person.sayHi.call(person) person.sayHi() // 为什么不用这种写法？因为隐藏了太多细节，只适合小白 ","date":"2020-09-14","objectID":"/javascript-function/:7:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"所有函数调用，必须强迫自己使用「大师调用法」—— call / apply ​ 例1 有一个 add 函数，不需要用到 this，那如何使用 call 调用 ？ function add(x,y){ return x+y } 没有用到 this add.call(undefined, 1,2) // 3 // call的第1个参数是指定this的，后面所有参数作为实参传递给函数对应形参 为什么要多写一个 undefined 因为第一个参数要作为 this 但是代码里没有用 this 所以只能用 undefined 占位 其实用 null 也可以 ​ 例2 Array.prototype.forEach 这个函数就用到了 this Array.prototype.forEach2 = function(){ console.log(this) } let array = [1,2,3] array.forEach2() // 小白写法：脑子一懵，就不知道了this是什么了 array.forEach2.call(array) // [1,2,3] // 大师写法：规定了call里面的就是this，所以清晰明了的知道此时打印的this就是传进去的array数组本身 尝试写出完整的 forEach 函数 forEach 功能是遍历当前数组。当前数组在哪呢？ 就是 this，this 就可以作为未来数组的引用 Array.prototype.forEach2 = function(fn){ // 传一个方法fn for(let i=0; i\u003cthis.length; i++){ fn(this[i], i, this) // 对每一个元素，执行fn方法 } } Tips 我们在看一个函数的代码时，不要想 this 的值是什么 ， 因为 this 的值是不确定的，没人知道 只有在函数被调用时（用大师法传进 this），才清晰的知道 this 是什么 如何调用 Array.prototype.forEach2 = function(fn){ for(let i=0; i\u003cthis.length; i++){ fn(this[i], i, this) } } let array = [1,2,3] array.forEach2.call(array, item =\u003e console.log(item) ) // 大师：显式的指定了this array.forEach2(item =\u003e console.log(item) ) // 小白：隐式的把array作为this this 是什么 由于大家使用 forEach2 的时候总是习惯于用 arr.forEach2 所以 arr 就被自动传给 forEach2 了 ​ this 一定是数组吗 不一定，比如 Array.prototype.forEach2 = function(fn){ for(let i=0; i\u003cthis.length; i++){ fn(this[i], i, this) } } // 我们可以指定 this 为一个对象转化的伪数组 Array.prototype.forEach2.call({0:'a',1:'b',length:2}, item=\u003econsole.log(item) ) 所以 this 就是我们可以任意指定的参数而已。 使用小白写法，JS 就会猜你想要的 this 是什么，绝大部分情况都能猜对。 ​ ","date":"2020-09-14","objectID":"/javascript-function/:7:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"总结 this 的两种使用方法 不论什么方式调用函数，实际上都在传递 this 。 区别在于：你【知道】传的 this 什么 或【不知道】 隐式传递 fn(1,2) // 等价于 fn.call(undefined, 1, 2) obj.child.fn(1) // 等价于 obj.child.fn.call(obj.child, 1) // 一个对象的属性上的fn函数 显式传递 fn.call(undefined, 1,2) fn.apply(undefined, [1,2]) apply 区别 apply 要在后面其他参数的部分，加上中括号 [ ] apply 后面的参数要用数组的形式来表示 只是写法形式不同，其他都和 call 是一样的 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:7:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"绑定 this 如果不确定 this 是什么，可以使用 bind 强制绑定 使用 .bind 可以让 this 不被改变 function f1(p1, p2){ console.log(this, p1, p2) } let f2 = f1.bind({name:'frank'}) // 那么 f2 就是 f1 绑定了 this 之后的新函数 f2() // 等价于 f1.call({name:'frank'}) // 打印结果：{name: \"frank\"} undefined undefined // this是传进来的对象，p1/p2没传所以是undefined f2 是 f1 的 this 绑定之后的版本 调 f2 相当于调 f1，唯一的区别就是，f2 的 this 被绑定了，绑定成通过 bind 传递的参数 有什么用呢？ —— 后面学 vue / react 可能就天天遇到了 ​ .bind 还可以绑定其他参数 bind 除了可以绑定 this，其实可以用来绑定所有参数 function f1(p1, p2){ console.log(this, p1, p2) } let f3 = f1.bind({name:'frank'}, 'hi') f3() // 等价于 f1.call({name:'frank'}, hi) // 已经绑死了：this是这个对象，p1是'hi' f3(3) // 因为 this 和 p1 已经绑死了，所以这里传的 3 会作为 p2 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:7:4","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"箭头函数 「箭头函数」没有 arguments 和 this 。 上面讲 this 用了大量篇幅，因为 this 功能太复杂且隐晦。所以新版 JS 就放弃了 this ","date":"2020-09-14","objectID":"/javascript-function/:8:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数里面的 this 就是外面的 this 默认的 this 是 window console.log(this) // window console.log(this === window) // true let fn = () =\u003e console.log(this) // 这里的this无需确认，外面的this是什么，箭头函数里面的this就是什么 fn() // window 例 对于箭头函数来说，变量就是普通变量 let a = 1 let fn = () =\u003e console.log(a) fn() // 1 函数打印变量a 。就近原则，先找函数里有没有变量a，没有。就用函数外的变量a this 同理，箭头函数里面没有 this 变量，就找外层的 this 变量。所以箭头函数中的 this 就是外面的 this ​ ","date":"2020-09-14","objectID":"/javascript-function/:8:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"就算用 call 也无法指定 this 怎么证明箭头函数里面没有 this 呢？ 可以用 call 来尝试指定箭头函数的 this 。 结果，无法指定，this 仍然指向 window let fn = () =\u003e console.log(this) fn.call({name:'frank'}) // 仍是 window 不论是用 call 、 bind … 都无法改变箭头函数中 this 的指向，永远是和 函数外的this 保持一致。 除非外面的 this 改变了，否则 箭头函数的 this 不会变化 ","date":"2020-09-14","objectID":"/javascript-function/:8:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"箭头函数没有 arguments let fn = ()=\u003e console.log(arguments) // arguments是所有参数组成的伪数组 fn(1,2,3) // 报错：arguments is not defined 没有 this ，没有 arguments 的函数就是「箭头函数」 ","date":"2020-09-14","objectID":"/javascript-function/:8:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"总结 每个函数都有这些东西 调用时机：决定了变量的值 作用域：同时多个作用域，遵循「就近原则」 闭包：如果一个函数用到了外部的变量，那么这个函数加这个变量，就叫做闭包 形式参数：给参数取名字，相当于声明一个变量 返回值：return ，默认 return undefined 调用栈：进去每个函数前都要先压栈，出来函数前要弹栈 函数提升：函数跑到最前面 arguments（除了箭头函数）：包含所有参数的伪数组 this（除了箭头函数）：引用一个当前不存在的对象，是 call() 方法的第一个参数 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:9:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"立即执行函数 只有 JS 有的变态玩意，现在用得少 ","date":"2020-09-14","objectID":"/javascript-function/:10:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"声明局部变量（ES6 之前） 在 ES6 之前，怎么获得一个局部变量 例 // 以前只有 var声明时 var a = 1 // a 是一个全局变量 // 如果想声明一个局部变量，必须写一个函数 function fn(){ var a = 2 // 在函数里，声明的 a 才是局部变量 console.log(a) } fn() // 2 console.log(a) // 1 用函数确能得到局部变量，但也同时增加了一个全局的函数（不也是全局变量），这与初衷相悖 思考 / 办法 思考：如果函数没有名字，那就不会生成一个全局函数，然后直接调用这个没名的函数不就行了 办法：声明一个匿名函数，然后直接调用执行 —— 没有暴露任何一个全局变量 或 全局函数 function fn(){ var a = 2 // 获得局部变量a，但副作用是又带来一个全局函数 console.log(a) } fn() // 2 ----------------------------------------- ↑↑ 改写成 ↓↓ --------------- // 去掉函数名 function(){ var a = 2 // 获得局部变量a，但副作用是又带来一个全局函数 console.log(a) } () // 把圆括号加到匿名函数的后面 // 上面就是声明一个匿名函数，然后直接调用执行 执行 / 报错 function(){ var a = 2 console.log(a) } () // Uncaught SyntaxError: Function statements require a function name 执行，报错（JS认为语法不对） 解决 JS 的程序员绞尽脑汁，找到一些解决办法 ↓↓ 匿名函数前加一个操作符 + function(){ var a = 2 console.log(a) } () // 2 // NaN（返回值并不影响需求，所以放着就好） 只要做一个运算，上面函数的写法都可以直接执行，不会再报错（与 undefined 运算，返回都是 NaN） + function(){...}() // NaN - function(){...}() // NaN 1* function(){...}() // NaN // 乘号必须左右都有值 取反也可以 ! 返回值为 undefined =\u003e ! undefined =\u003e true ! function(){...}() // true … 这样我们终于就得到 JS 中，只要一个局部变量的方法 总结：为得到一个局部变量，不得不去造一个函数，并执行这个函数 —— 这也是 JS（旧） 的问题 ","date":"2020-09-14","objectID":"/javascript-function/:10:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"总结原理 ES 5 时代，为了得到局部变量，必须引入一个函数 但是这个函数如果有名字，就得不偿失 于是这个函数必须是匿名函数 声明匿名函数，然后立即加个 () 执行它 但是 JS 标准认为这种语法不合法 所以 JS 程序员寻求各种办法 最终发现，只要在匿名函数前面加个运算符即可 !、~、()、+、- 都可以 但是这里面有些运算符会往上走 所以方方推荐永远用 ! 来解决 ​ ","date":"2020-09-14","objectID":"/javascript-function/:10:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"声明局部变量（ES6 之后） { let a = 2 console.log(a) } 2 undefined console.log(a) // 报错 a is not defined ","date":"2020-09-14","objectID":"/javascript-function/:10:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"注意事项 推荐永远用 ! 来解决 用 +、括号 … 可能有 bug console.log('hi') // 没有这句时，代码执行一切正常，返回值也是 undefined。一旦有这句话，代码执行就不同了 (function(){ var a = 2 console.log(a) } ()) JS 有个特点：它的回车是没有意义的 // 上面代码执行过程，如下 console.log('hi') =\u003e log函数返回值 undefined =\u003e undefined(function(){}()) 因为回车是没有意义的，等同于 undefined 后面跟着一对 ( )，所以把 undefined 当成函数执行，必然报错 总结 永远不要用 【圆括号】来写立即执行函数（圆括号会往上面代码凑，甚至可能连起来执行） 虽然可以用【分号】来强制结束/分隔两个语句 。但显然也没感叹号方便 这是 JS 中唯一需要加分号 ; 的地方，其他任何代码不需要分号 console.log('hi'); // 可以用 ; 分隔两个语句 // 如果别人用了圆括号，一定要在前面加 ; 分号 (function(){ var a = 2 console.log(a) } ()) 用【感叹号】最合适，因为感叹号不会往上面代码看，只会往后看 ","date":"2020-09-14","objectID":"/javascript-function/:10:4","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"JS 数组的基本介绍","date":"2020-09-11","objectID":"/javascript-array/","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"「数组的基本方法」「伪数组」「数组的增删改查」「索引越界！」 ​ ","date":"2020-09-11","objectID":"/javascript-array/:0:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"数组对象 一种特殊的对象 ","date":"2020-09-11","objectID":"/javascript-array/:1:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"JS 其实没有真正的数组 只是用对象去模拟数组 其他语言、基于底层的语言，比如 C 语言，会告诉你【数组是连续的内存分配】 ","date":"2020-09-11","objectID":"/javascript-array/:2:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"JS 数组不是典型数组 ","date":"2020-09-11","objectID":"/javascript-array/:3:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"典型的数组 元素的数据类型相同 使用连续的内存存储 通过数字下标获取元素 ","date":"2020-09-11","objectID":"/javascript-array/:3:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"但 JS 的数组不这样 JS 的数组，实际上是用 key / value 模拟的，本质是对象 元素的数据类型可以不同 内存不一定是连续的（对象是随机存储的） 不支持数字下标，而是通过字符串下标 这意味着数组可以有任何 key 比如 let arr = [1,2,3] Object.keys(arr) // [\"0\", \"1\", \"2\"] arr['xxx'] = 'xxx' // 下标为'xxx'，值为'xxx' arr.yyy = 'yyy' ","date":"2020-09-11","objectID":"/javascript-array/:3:2","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"创建一个数组 💡 ","date":"2020-09-11","objectID":"/javascript-array/:4:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"新建 let arr = [1,2,3] // 简写 let arr = new Array(1,2,3) // 正规：方便理解原理 let arr = new Array(3) // [empty × 3] 数组为空，但 length为3 ","date":"2020-09-11","objectID":"/javascript-array/:4:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"转化（ Array.from 用字符串创建数组） let arr = '1,2,3'.split(',') // [\"1\", \"2\", \"3\"] let arr = '123'.split('') Array.from('123') // 最新的ES标准提供的api：会把不是数组的东西，尝试变成数组 例 Array.from(123) // [] Array.from(true) // [] Array.from({name: 'sam'}) // [] Array.from({0:'a', 1:'b', 2:'c'}) // [] Array.from({0:'a', 1:'b', 2:'c', length: 3}) // [\"a\", \"b\", \"c\"] 总结：Array.from() 只在符合以下条件的情况下，才能把对象转换成数组 条件1 ：这个对象需要有 0,1,2,3… 这种形式的属性，符合数组的下标 条件2： 这个对象需要有 length 属性 满足以上条件，Array.from(xxx) 就可以尝试把 一个对象 转化成 真正的数组 变态情况 前面提到：JS 的数组 不支持数字下标，而是通过字符串下标。 那这里要转化的对象{0:'a', 1:'b', 2:'c'}的 key 值 0,1,2 都是数字，为什么可以被识别？ 答：当 JS 发现 0,1,2 是数字格式，会先自动调用 (1).toString() 方法，把数字全部转化为 字符串 对象中的下标为 0,1,2 但 length 不为 3 的情况 答：会以 length 为主，有多余的就删，不足就补 undefined。总之，length 值不变 对象中的下标为乱序 答：不会依照下标的乱序来转换数组，而是自动调整为顺序排列内容 ","date":"2020-09-11","objectID":"/javascript-array/:4:2","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"伪数组 伪数组的原型链中并没有数组的原型 换言之，如果一个数组，不具有数组的共有属性（push、pop…等方法），那它就是一个伪数组 可以通过 Array.from() 变成真正的数组 下面的是【真数组】 arr = [1,2,3,4] // new Array(1,2,3,4) arr.__proto__ === Array.prototype // true arr.__proto__.__proto__ === Object.prototype // true arr.__proto__.__proto__ === Array.prototype.__proto__ // true 下面的是【伪数组】 \u003cdiv\u003e1\u003c/div\u003e \u003cdiv\u003e2\u003c/div\u003e \u003cdiv\u003e3\u003c/div\u003e \u003cscript\u003e let divList = document.querySelectorAll('div') // 获取文档中所有div元素，组成一个数组 console.log(divList) // 伪数组 divList.push(4) // 报错 TypeError: divList.push is not a function 伪数组不具有数组的共有属性 let divArray = Array.from(divList) // 把【伪数组】转换为【真数组】 console.log(divArray) \u003c/script\u003e divList【伪数组】 ↓↓ divArray 【真数组】 ↓↓ 总结：没有数组共有属性的「数组」，就是伪数组 不知道 JS 为什么要设计伪数组，没什么用。 如果拿到的是伪数组，尽量转换成真数组，再操作 ​ ","date":"2020-09-11","objectID":"/javascript-array/:4:3","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"合并两个数组，得到新数组 不改变原数组 let arr1 = [3,3,3], arr2 = [4,4,4] arr1.concat(arr2) // [3, 3, 3, 4, 4, 4] // 返回一个新数组，原数组不改变 ","date":"2020-09-11","objectID":"/javascript-array/:4:4","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"截取一个数组的一部分 不改变原数组 let arr1 = [1,2,3,4,5,6] arr1.slice(2) // 从第3个元素开始，获得新数组 [3,4,5,6] // 原数组 arr1 不改变 ","date":"2020-09-11","objectID":"/javascript-array/:4:5","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"截取数组全部 不改变原数组 相当于把原数组复制了一遍 slice(0) 经常用于复制数组。JS 并没有提供专门的复制数组的方法，所以要实现复制效果，就使用 slice(0) let arr1 = [1,2,3,4,5,6] let arr2 = arr1.slice(0) // 全部截取，赋给arr2 注意，所以 JS 原生提供的，都是【浅拷贝】，没有深拷贝 深拷贝在【押题】中讲解 ","date":"2020-09-11","objectID":"/javascript-array/:4:6","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"数组的增删改查 ❤️ ","date":"2020-09-11","objectID":"/javascript-array/:5:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"删元素 🙁 跟对象一样 let arr = ['a','b','c'] delete arr['0'] // arr[0] 可不加引号，此时js会自动加引号 arr // [empty, 'b', 'c'] // 变成【稀疏数组】 delete arr[1] delete arr[2] arr // [empty × 3] // 变成【稀疏数组】 神奇，即使把元素全部 delete ，数组的长度也没有变 ​ 稀疏数组 稀疏数组：只有长度 length，但没有对应的下标，这种数组就是稀疏数组 （感兴趣可以取了解一下，稀疏数组没什么好处，倒是有很多 bug） 例 1 let arr = [1,2,3] arr[3] = 4 // 数组原本3个元素，下标0,1,2 // 现在添加第4个元素、下标为3 arr // [1,2,3,4] // 仍是普通数组，没有异常 arr[100] = 101 // 数组原本4个元素，下标0,1,2,3，现在跳级直接添加下标为100的元素 arr // [1, 2, 3, 4, empty × 96, 101] // 如果跳级添加下标，会导致数组变成【稀疏数组】// length: 101 例 2 let arr = [1,2,3] delete arr[1] arr // [1,empty,3] length: 3 // 使用 delete 删除数组元素，也会导致【稀疏数组】 ​ 🙁 如果直接改 length 可以删元素吗 let arr = [1,2,3,4,5] arr.length = 1 arr // [1] 我X，居然可以？！ JS 真神奇 重要忠告：不要随便改 length 🈲 尽量不要使用 delete 和 改 length 的方式，删除数组元素 ​ 😍 推荐 3 种 API 一个对象提供的函数，就叫做 API 。书写形式： 对象.方法名() 删除头部的元素 arr.shift() // arr 被修改，并返回被删元素 删除尾部的元素 arr.pop() // arr 被修改，并返回被删元素 删除中间的元素（允许增加元素） arr.splice(index) // 从下标为 index 的位置开始删除后面所有元素 arr.splice(index, 3) // 从下标为 index 的位置开始删除 3 个元素 arr.splice(index, 1) // 从下标为 index 的位置开始删除 1 个元素 arr.splice(-index, 3) // 从倒数第 index 位开始删除 3 个元素（index为负时，不表示下标） arr.splice(index, 1, 'x') // 并在删除位置添加 'x' arr.splice(index, 1, 'x', 'y') // 并在删除位置添加 'x'，'y' splice MDN 功能非常强大 示例 let arr = [1,2,3] arr.shift() // 1 // arr.shift() 删除第一个元素，返回被删除元素 arr // [2,3] let arr = [1,2,3] arr.pop() // 3 // arr.pop() 删除最后一个元素，返回被删除元素 arr // [1,2] let arr = [1,2,3,4,5,6,7] arr.splice(2,1) // [3] // arr.slice(2,1) 在下标为2的位置删除1个元素，返回被删除元素组成的数组 arr // [1,2,4,5,6,7] let arr = [1,2,3,4,5,6,7] arr.splice(2,3) // [3,4,5] // 从下标2开始删除3个元素，返回被删除元素组成的数组 arr // [1,2,6,7] let arr = [1,2,3,4,5,6,7] arr.splice(2,3,0) // [3,4,5] // 从下标2开始删除3个元素，添加元素0。返回被删除元素组成的数组 arr // [1,2,0,6,7] arr.splice(2,1,3,4,5) // [0] // 从下标2开始删除1个元素，添加元素3,4,5。返回被删除元素组成的数组 arr // [1,2,3,4,5,6,7] arr.splice(-1,1,777) // [7] // 从倒数第1位删除1个元素，添加元素777。返回被删除元素组成的数组 ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:5:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"查看所有元素 遍历 🙁 查看所有属性名 let arr = [1,2,3,4,5] arr.x = 'xxx' Object.keys(arr) // 遍历属性名 Object.values(arr) // 遍历属性值 for(let key in arr){ console.log(`${key}: ${arr[key]}`) } // for-in 更适用于遍历对象 Object.keys 、 Object.values、for…in… 这 3 种方法，都更适用于遍历对象，不适合遍历数组 通常我们遍历数组，只希望查看对应正常顺序的下标的元素。 如果遍历数组，获取到一个下标为 ‘x’ 的元素，可能是很奇怪的😱（如下图） 所以上述三种方式，虽然可以用，但不是最适合/最常见的遍历数组的方式 ​ 😍 查看数字（字符串）属性名和值 for 循环 用 for 循环遍历（可以自己控制下标） 让下标 i 从 0 增长到 length-1 let arr = [1,2,3,4,5] arr.x = 'xxx' for(let i=0; i\u003carr.length; i++){ console.log(`${i}: ${arr[i]}`) } for 循环，是访问数组的比较常见的形式 for…in… 用来访问对象 forEach forEach 接收一个函数作为参数。这种函数，称为回调函数 forEach 的作用：就是遍历数组的每一项，访问到每一个元素都执行一遍回调函数。 该回调函数，默认参数 【第1个形参】表示元素本身，通常写作 item 【第2个形参】表示当前下标，通常写作 index 【第3个形参】表示数组本身，通常写作 array （大部分情况用不到） 形参的名称无所谓，顺序是关键 例 1 let arr = [1,2,3,4,5] arr.forEach(function(item, index){ // 回调函数的默认第1个形参item表示元素本身、第2个形参index表示当前下标 console.log(`${index}: ${item}`) }) 也可以用 forEach/map 等原型上的函数 手写 forEach 为了更好地理解上述代码（forEach）是怎么实现遍历数组的 下面手动封装一个 forEach 函数 function forEach(array, fn){ for(let i = 0; i\u003carray.length; i++){ // 访问传入的 array 的每一项，对每项执行什么操作呢？↓ fn(array[i], i, array) // 对每一项调用 fn，把数组的相关值作为参数传入到 fn 中 } } forEach 用 for 访问 array 的每一项 对每一项调用 fn(array[i], i, array)。数组有几项，fn 就执行几次 为什么要传入 array 呢？不为什么，规定如此。 例 2 let arr = ['a','b','c'] forEach(arr, function(x,y,z){ console.log(x,y,z) }) 注意：例 2 是 forEach(arr,function)的形式 ，例 1 是 arr.forEach(function) 的形式。 两种写法其实是等价的。因为 JS 会自动把顺序倒过来，按照 例2 的形式执行 面试问：区别是什么 两者区别，回答的关键点就是：前者能实现、而后者做不到的 实际上大多数情况，for 和 forEach 都是通用的 只有一种情况 for 循环里面有 break 和 continue，而 forEach 是不支持的 forEach 只是个普通函数，而 for 是个 关键字，关键字的功能可能会更强大一点 示例 let arr = [1,2,3,4,5,6,7,8] for(let i=0; i\u003carr.length; i++){ console.log(`${i}: ${arr[i]}`) if(i===3){break;} } ----------------------------------------------------- let arr = [1,2,3,4,5,6,7,8] arr.forEach(function(item, i){ console.log(item) if(i===3){return false} // 无效 }) ⭐️区别： for 循环中间，可以 break 或 continue。而 forEach 一旦开始就会一直走到尾，即使 return 也无法结束 for 是关键字，{ } 是块级作用域。而 forEach 是一个函数，{ } 是函数作用域 ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:5:2","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"查看单个属性 跟对象一样 let arr = [111,222,333] arr[0] 注意：不论给下标什么数字，一定都会变成字符串。JS 中没有「数字下标」这么一说 ​ 索引越界 ⭐️ 「索引越界」指给的数组索引（下标）不存在 下述两种情况，需要注意避免 arr[arr.length] === undefined arr[-1] === undefined 例 for(let i=0; i\u003c=arr.length; i++){ // i===length时，数组中并没有对应元素，值为 undefined console.1og(arr[i].toString()) } // 报错：Cannot read property 'toString' of undefined （ undefined不是对象，没有toString ） 访问任何不存在的下标时，得到的结果都是 undefined 当碰到报错 Cannot read property ‘xxx’ of undefined，很有可能是数组的索引越界了 解决办法：console.log 大法 ​ 查找某个元素是否在数组里 ❌ 方法一：遍历 降智写法 let arr = [11,22,33,44,55] for(let i=0; i\u003carr.length; i++){ if(arr[i]===22){ console.log('arr中存在22') }else{ console.log('不存在') } } 😍 方法二：API indexOf 返回只要不是 -1 ，就说明存在 arr.indexOf(item) // 存在返回下标，否则返回 -1 例 let arr = [11,22,33,44,55] arr.indexOf(22) // 1 arr.indexOf(11) // 0 arr.indexOf(66) // -1 ​ 查找满足条件的元素 ❌降智写法：遍历 let arr = [1,2,3,4] for(let i=0; i\u003carr.length; i++){ if(arr[i]%2===0){ console.log(`数组中的偶数：${arr[i]}`) } } // 数组中的偶数：2 // 数组中的偶数：4 😍更好的方法：使用 find arr.find(item =\u003e item%2 === 0) // 找第一个偶数 完整写法 find 用法：找到第一个符合条件（return true）的元素，就停止，并返回这个元素 let arr = [1,2,3,4] arr.find(function(x){ return x%2 === 0 }) // 2 ​ 查找满足条件的元素的索引 findIndex 用法：找到第一个符合条件（return true）的元素，就停止，并返回这个元素的下标 arr.findlndex(item =\u003e item%2 === 0) // 找第一个偶数的索引 例 let arr = [11,22,33,44] arr.findIndex(function(x){ return x%2 === 0 }) // 1 ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:5:3","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"增加数组中的元素 ❌ 不推荐 let arr = [1,2,3] arr[3] = 4 // 数组原本3个元素，下标0,1,2 // 现在添加第4个元素、下标为3 arr // [1,2,3,4] // 仍是普通数组，没有异常 arr[100] = 101 // 数组原本4个元素，下标0,1,2,3，现在跳级直接添加下标为100的元素 arr // [1, 2, 3, 4, empty × 96, 101] // 如果跳级添加下标，会导致数组变成【稀疏数组】// length: 101 arr[index] 的方式，可以增加数组元素 但如果跳级增加下标，会导致数组变成【稀疏数组】，所以不推荐这种方式 ​ ​ ✅ 在尾部加元素 arr.push(newItem) // 修改 arr，返回新长度 arr.push(item1, item2) // 修改 arr，返回新长度 例 let arr = [1,2,3] arr.push('a','b','c') // 6 // 修改原数组，并返回该数组的新长度 arr // [1, 2, 3, \"a\", \"b\", \"c\"] arr.push(666) arr // [1, 2, 3, \"a\", \"b\", \"c\", 666] ​ ✅ 在头部加元素 arr.unshift(newItem) // 修改 arr，返回新长度 arr.unshift(item1, item2) // 修改 arr，返回新长度 例 let arr = [1,2,3] arr.unshift('x','y','z') // [\"x\", \"y\", \"z\", 1, 2, 3] arr.unshift(777) // [777, \"x\", \"y\", \"z\", 1, 2, 3] ​ ✅ 在中间添加元素 splice MDN 功能强大 前面讲，可以用 splice 来[删除指定位置的元素](# 删除中间的元素（允许增加元素）)，这里用来往指定位置添加元素 arr.splice(index, 0, 'x') // 在 index 处插入'x'，原元素向后移一位 // 第2个参数写 0 表示不删除元素 arr.splice(index, 0, 'x', 'y') 例 let arr = [1,2,3] arr.splice(1,0,666) // [] // 返回被删除元素组成的数组，0表示不删除元素，所以返回空数组 arr // [1, 666, 2, 3] splice：可以删除元素、添加元素 （会用 splice 基本可以对数组进行任何操作） ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:5:4","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"修改数组中的元素 直接修改 例 let arr = [1,2,3] arr[1] = 0 arr // [1,0,3] 例 let arr = [1,2,3] arr.splice(1,1,0) // [2] // 把下标为1的元素删除，插入一个0 // 相当于修改元素 arr // [1,0,3] ​ 反转顺序 reverse arr.reverse() // 修改原数组 例 let arr = [1,2,3] arr.reverse() // [3,2,1] arr // [3,2,1] 著名面试题 翻转字符串 let s = 'abcde' s.split('') // [\"a\", \"b\", \"c\", \"d\", \"e\"] s.split('').reverse() // [\"e\", \"d\", \"c\", \"b\", \"a\"] s.split('').reverse().join('') // \"edcba\" ​ 自定义顺序 sort 把乱序，改为【从大到小】或【从小到大】的顺序 arr.sort((a,b) =\u003e a-b) // 会改变原数组 从小到大 let arr = [5,2,4,3,1] arr.sort() // [1,2,3,4,5] // sort 默认【从小到大】排序 从大到小怎么实现 ？ // sort 接收一个回调 let arr = [3,5,2,4,1] arr.sort(function(a,b){ // 两个形参，表示每次进行两两比较的两个数值 if(a\u003eb){ return 1 }else if(a===b){ return 0 }else{ return -1 } }) // [1, 2, 3, 4, 5] ---------------------------------------------------------------------------------- arr.sort(function(a,b){ if(a\u003eb){ return -1 }else if(a===b){ return 0 }else{ return 1 } }) // [5, 4, 3, 2, 1] 例 let arr = [ {name:'Kate', score: 99}, {name:'Jack', score: 85}, {name:'Ryan', score: 100} ] 需求：根据每一项的 score 进行排序 arr.sort() // 显然无效，因为 JS 看不出要怎么比较，我们需要指定给 JS：让它用每一项的 score 来进行比较 怎么指定？用回调函数 let arr = [ {name:'Kate', score: 99}, {name:'Jack', score: 85}, {name:'Ryan', score: 100} ] arr.sort(function(a,b){ // a/b代表两两比较的数组元素（也就是3个对象） if(a.score \u003e b.score){return 1} else if(a.score === b.score){return 0} else{return -1} }) 简化写法 let arr = [5,2,4,3,1] arr.sort(function(a,b){ return a-b // a\u003eb返回一个正数，a\u003cb返回负数，a===b返回0 }) // [1, 2, 3, 4, 5] ------------------------------------------------- let arr = [5,2,4,3,1] arr.sort(function(a,b){ return b-a // b\u003ea返回一个正数，b\u003ca返回负数，a===b返回0 }) // [5, 4, 3, 2, 1] ==\u003e 箭头函数，进一步简化 arr.sort((a,b)=\u003ea-b) // 从小到大 arr.sort((a,b)=\u003eb-a) // 从大到小 arr.sort((a,b) =\u003e a.score - b.score) // 从小到大 arr.sort((a,b) =\u003e b.score - a.score) // 从大到小 ​ ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:5:5","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"数组变换 ⚡️ 高级 API map([🐮, 🥔, 🐔, 🌽], cook) // n变n =\u003e [🍔, 🍟, 🍗, 🍿] filter([🍔, 🍟, 🍗, 🍿], isNotMeet) // n变少 =\u003e [🍟, 🍿] reduce([🍔, 🍟, 🍗, 🍿], eat) // n变1 =\u003e 💩 ​ ","date":"2020-09-11","objectID":"/javascript-array/:6:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"map n 变 n ES6 新方法 map map 会对数组进行遍历，可以对每一项都执行指定的操作（对数组元素每一项进行一一映射） map 方法的返回值为【数组每一项经过回调处理后的返回值 组成的新数组】 返回新的数组，不改变原数组 语法： Array.map(function(ele, index, arr){...}); 回调函数 参数1：遍历的元素 item 参数2：元素下标 index 参数3：原数组 array （通常用不到这个参数） 例 1 let arr = [1,2,3,4]; arr.map(function(ele,index,arr){ console.log(\"ele ==\u003e \", ele,\" index ==\u003e \", index ,\" arr ==\u003e \",arr) }) // [undefined,undefined,undefined,undefined] 因为回调里没有 return，所以会采用函数的默认返回值 undefined，作为每一项回调处理后的返回值，并将这4个返回值组成新的数组，作为最终返回值 所以最后结果就是 4 个 undefined 组成的新数组 总结： 对每一项元素进行处理的语句要写在 return 后面。 否则每一项处理后的返回值都是 undefined 例 2 需求：对 arr 进行操作（每个数乘2），返回新的数组[2,4,6,8] // 以前的方法: for循环 let arr = [1,2,3,4] let newArr = []; for(let i = 0; i \u003c arr.length; i++){ newArr.push(arr[i]*2); // 返回新数组 } console.log(newArr) // [2,4,6,8] -------------------------------------------------------------- // ES6: map let newArr = arr.map(function(ele){ return ele*2 }); // 用箭头函数进行重构：return 的语句可以直接写在箭头后，省略'return' let newArr = arr.map(ele =\u003e ele*2); console.log(arr, newArr) // [1,2,3,4] [2,4,6,8] 例 3 ：计算每一项的平方 需求：把 arr 的每一项都平方 （这个也可[用 reduce 实现](# 计算每一项的平方)） for 循环（旧） let arr = [1, 2, 3, 4, 5, 6] for(let i=0; i\u003carr.length; i++){ arr[i] = arr[i] * arr[i] // 在原数组上进行修改 } arr // [1, 4, 9, 16, 25, 36] 使用 map 简化过程（ES6 新增） let arr = [1, 2, 3, 4, 5, 6] arr.map(item =\u003e item * item) // [1, 4, 9, 16, 25, 36] 返回新数组，原数组不改变 ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:6:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"filter n 变少 用于筛选数组中符合条件的全部元素，返回的是这些元素组成的新数组 返回新的数组，不改变原数组 区别于 find 方法 find方法 查找符合条件的第一个元素，并返回这个元素；没有符合条件的元素，返回 undefined filter方法 查找符合条件的全部元素，并返回这些元素组成的新数组；没有符合条件的元素，返回空数组[ ] 例 1 需求：筛选出 arr 中的偶数（也可以用 reduce 实现） let arr = [1, 2, 3, 4, 5, 6] arr.filter(item =\u003e item%2 === 0 ) // [2, 4, 6] // 把符合条件、返回true的item，筛选出来组成新数组 例 2 需求：筛选出大于等于3的元素 let arr = [1, 2, 3, 4, 5, 6] let newArr = arr.filter((ele , index , arr) =\u003e{ return ele \u003e= 3 console.log(ele) // 不会执行这句，因为函数中遇到 return 就返回（结束）了 }) console.log(newArr); // [3,4] 需求：筛选出大于等于10的元素 let arr = [1, 2, 3, 4, 5, 6] arr.filter( ele =\u003e ele \u003e= 10 ) // [] 例 3 ：删除元素 需求：删除数组中值为 3 的元素 方法一：filter 会把符合条件的全部元素删除 let arr = [3,4,5,6,3,3,3,7] arr = arr.filter(ele =\u003e ele!==3 ) // 筛选出不等于3的元素，相当于从数组中删除值为3的元素 // filter会返回新的数组，再重新赋值给原数组，相当于从原数组中删除 值为3的元素 方法二：findIndex + splice 会把符合条件的第一个元素删除 let arr = [3,4,5,6,3,3,3,7] let index = arr.findIndex(ele =\u003e ele === 3) // 找到下标，通过splice方法从数组中删除对应下标的元素 arr.splice(index,1) // [3] arr // [4, 5, 6, 3, 3, 3, 7] ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:6:2","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"reduce n 变 1 reduce 是数组里面最难理解，也是功能最强大的 API（第二名是 splice） reduce 可以代替 map 和 filter，只不过对新人有一定难度 求数组元素之和 用 for 循环实现 let arr = [1,2,3,4,5] let sum = 0 // 作为结果的初始值为0 for(let i=0;i \u003carr.length;i++){ sum += arr[i] // sum = sum + arr[i] } console.log(sum) // 15 用 reduce 来实现 let arr = [1,2,3,4,5] // arr.reduce(()=\u003e{}, 0) // reduce中，0作为结果的初始值，写在第2个参数上 // 第1个参数是一个函数：规定每一次遍历要对上一次的结果进行什么操作 arr.reduce((total,current)=\u003etotal+current, 0) // 15 // reduce的回调函数，默认形参1是上一次的返回值（初始0），形参2是当前元素 // 求和，就是要把上一次的结果再加上当前元素，获得二者的和，所以回调执行的就是 total+current // total初始值为0（相当于上面for循环例子中的sum） 第1轮，遍历获取元素 1，执行回调，total为初始值0 + current是当前遍历到的元素1，回调返回0+1=\u003e 1 第2轮，遍历获取元素 2，执行回调，total为上一次的返回值 1 + current：2，回调返回 1+2 =\u003e 3 第3轮，遍历获取元素 3，执行回调，total为上一次的返回值 3 + current：3，回调返回 3+3 =\u003e 6 第4轮，遍历获取元素 4，执行回调，total为上一次的返回值 6 + current：4，回调返回 6+4 =\u003e 10 第5轮，遍历获取元素 5，执行回调，total为上一次的返回值 10 + current：5，回调返回 10+5 =\u003e 15 变形 计算数组中成员的总年龄 var arr = [ {name: \"张三\", age: 40}, {name: \"李四\", age: 50}, {name: \"王五\", age: 60} ] arr.reduce((total, current) =\u003e { console.log(total, current.age) // 0 40 // 40 50 // 90 60 return total + current.age }, 0) // 150 计算每一项的平方 用 map 实现 let arr = [1, 2, 3, 4, 5, 6] arr.map(item =\u003e item * item) // [1, 4, 9, 16, 25, 36] 返回新数组，原数组不改变 用 reduce 实现 let arr = [1, 2, 3, 4, 5, 6] // arr.reduce((total,current)=\u003e{ return total.push(current*current) }, []) // 报错 total.push is not a function 因为 push 的返回值并不是新的数组，而是length，所以不能用 push // 连接两个数组，用 concat arr.reduce((result, item)=\u003e{ return result.concat(item * item) }, []) // [1, 4, 9, 16, 25, 36] 补充：concat 用法：不修改原数组，返回新数组 let arr = [0,1] // [0, 1] arr = arr.concat(2) // [0, 1, 2] 所以必须重新赋值给arr，才能实现push效果 arr = arr.concat([3,4]) // [0, 1, 2, 3, 4] ​ 筛选出所有偶数 用 filter 实现 let arr = [1, 2, 3, 4, 5, 6] arr.filter(item =\u003e item%2 === 0 ) // [2, 4, 6] // 把符合条件、返回true的item，筛选出来组成新数组 用 reduce 实现 let arr = [1, 2, 3, 4, 5, 6] arr.reduce((result,item)=\u003e{ if(item%2===1){ // 如果是奇数，不做任何处理，直接返回 原result return result }else{ // 如果是偶数，就把偶数连到result中，再返回新数组，作为下一轮的result return result.concat(item) } },[]) 简写 let arr = [1, 2, 3, 4, 5, 6] arr.reduce((result,item)=\u003e item % 2 === 1 ? result : result.concat(item) , []) 再进一步探索（炫技） let arr = [1, 2, 3, 4, 5, 6] arr.reduce((result,item)=\u003e // item % 2 === 1 ? result : result.concat(item) // 原理：如果item是奇数就不concat到result中 // ==\u003e 换言之，若是奇数，可concat一个空 // item%2===1 ? result.concat() : result.concat(item) // ==\u003e 也就是，我总是需要concat一个东西 ==\u003e 那就可以转换为 result.concat(item % 2 === 1 ? [] : item) , []) // [2, 4, 6] 将多维数组，转为一维数组 // reduce的参数total和current也可以执行【数组合并】这样的操作 var arr = [1, 2, 3, [4], 6, [1, 2, 3, [4]]]; var fun = function(arr) { var newArr = arr.reduce((total, current) =\u003e { if (current instanceof Array) { //递归 var news = fun(current); // 返回一个数组 total = total.concat(news); return total // 将返回的数组拼接回total中 } else { total.push(current); return total } }, []) //[]：表示给total赋初始值，total是一个空数组 return newArr } console.log(fun(arr)); 多维数组转为一维数组，也可以用flat方法等【方法很多，可以查看es6入门2/zuoye目录中的大家的解法】 reduce 叫做累加器 对数组进行遍历，执行加减乘除操作等等 reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 常用来【求和】 语法：array.reduce(function(total, current, currentIndex, arr), initialValue) 参数 total ： 必需。上一次循环计算结束后的return返回值； 如果回调函数没有return，则第二次循环时total为undefined **参数 current **： 必需。当前的元素 参数 currentIndex：可选。当前元素下标 参数 arr：可选。原数组 参数 initialValue：可选。传递给函数的初始值 ","date":"2020-09-11","objectID":"/javascript-array/:6:3","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"题目 ","date":"2020-09-11","objectID":"/javascript-array/:7:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"第一题：把数字变成星期 let arr = [0,1,2,2,3,3,3,4,4,4,4,6] let arr2 = arr.map((item,index)=\u003e{ if(item===0){return '周日'} if(item===1){return '周一'} if(item===2){return '周二'} if(item===3){return '周三'} if(item===4){return '周四'} if(item===5){return '周五'} if(item===6){return '周六'} }) console.log(arr2) // ['周日', '周一', '周二', '周二', '周三', '周三', '周三', '周四', '周四', '周四', '周四','周六'] 参考答案 let arr = [0,1,2,2,3,3,3,4,4,4,4,6] let arr2 = arr.map((i)=\u003e{ const hash = {0:'周日',1:'周一',2:'周二',3:'周三',4:'周四',5:'周五',6:'周六'} return hash[i] }) console.log(arr2) ","date":"2020-09-11","objectID":"/javascript-array/:7:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"第二题：找出所有大于 60 分的成绩 let scores = [95,91,59,55,42,82,72,85,67,66,55,91] let scores2 = scores.filter(item=\u003eitem \u003e 60) console.log(scores2) // [95, 91, 82, 72, 85, 67, 66, 91] 参考答案 let scores = [95,91,59,55,42,82,72,85,67,66,55,91] let scores2 = scores.filter(n =\u003e n\u003e= 60) console.log(scores2) // [95,91,82,72,85,67,66, 91] ","date":"2020-09-11","objectID":"/javascript-array/:7:2","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"第三题：算出所有奇数之和 let arr = [95,91,59,55,42,82,72,85,67,66,55,91] let arr2 = arr.reduce((sum,n)=\u003e{ if(n%2===0){return sum} else{return sum+n} }) console.log(arr2) let scores = [95,91,59,55,42,82,72,85,67,66,55,91] let sum = scores.reduce((sum,n)=\u003e n%2===1 ? sum+n : sum, 0) console.log(sum) // 598 参考答案 let scores = [95,91,59,55,42,82,72,85,67,66,55,91] let sum = scores.reduce((sum, n)=\u003e{ return n%2===0?sum:sum+n },0) console.log(sum) // 奇数之和：598 ​ ","date":"2020-09-11","objectID":"/javascript-array/:7:3","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"面试题 ","date":"2020-09-11","objectID":"/javascript-array/:8:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"数据变换 let arr = [ {名称: '动物', id: 1, parent: null}, {名称: '狗', id: 2, parent: 1}, {名称: '猫', id: 3, parent: 1} ] // 数组变成对象 { id: 1, 名称：'动物', children:[ {id: 2, 名称：'狗', children: null}, {id: 3, 名称：'猫', children: null} ] } 解 test-1，先想当然的试试 arr.reduce((result,item)=\u003e{ result[item.id] = item return result }, {}) test-2， 如果在parent为null时，才往 result 添加 id，值为 item.id；parent不为空，就把 item 添加到 result.children数组中 初始化 result 把 id 和 children 加进去（注意children是数组） arr.reduce((result,item)=\u003e{ if(item.parent === null){ result.id = item.id result['名称'] = item['名称'] }else{ delete item.parent item.children = null result.children.push(item) } return result }, {id: null, children: []}) 完。 ","date":"2020-09-11","objectID":"/javascript-array/:8:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"JS 对象分类——原型 \u0026 类","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"「构造函数」「原型」「new 操作符」「类 class」 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:0:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"对象需要分类吗？ 这是一个值得思考的问题 我们来做一个小程序 输出各种形状的面积和周长 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:1:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"一个正方形 Square 代码 let square = { width: 5, getArea(){ return this.width * this.width // 先简单的把this理解成当前对象，在「函数篇」会重新学习this }， getLength(){ return this.width * 4 } } 分析 声明一个「正方形」对象 「正方形」拥有三个属性：边长、面积、周长 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:2:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"一打正方形 💡 let square1 = { width: 5, getArea(){ return this.width * this.width }， getLength(){ return this.width * 4 } } let square2 = { width: 5, getArea(){ return this.width * this.width }， getLength(){ return this.width * 4 } } let square3 = { ... } ... let square12 = { ... } 写12遍。这样写代码的，要么是新人，要么是傻子。 这么写非常累，如果修改，需要逐个修改，非常非常麻烦 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"用 for 循环实现（浪费内存） let squareList = [] for(let i=0; i\u003c12; i++){ // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c squareList[i] = { // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c width: 5, getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 } } } 如果 width 不全是 5，怎么实现 let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c for(let i=0; i\u003c12; i++){ squareList[i] = { width: widthList[i], // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 } } } 分析 虽然实现了需求，但上面写法仍属于「垃圾代码」，浪费了太多内存，自己画 内存图 就知道了 squareList[0].getArea === squareList[1].getArea // false \u003cimg src=\"https://i.loli.net/2020/09/03/kQiTnhXL92HNabF.jpg\" alt=\"内存图-循环过程\" /\u003e 会画内存图的人， 比其他人理解的更好 内存中，一共创建了 24 个函数，其中 22 个都是多余重复的 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"借助原型 √ 将12个正方形对象的共有属性放到原型里 代码 let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] let squarePrototype = { getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 } } for(let i=0; i\u003c12; i++){ squareList[i] = Object.create(squarePrototype) // 每一个正方形都以squarePrototype为原型，共享方法 squareList[i].width = widthList[i] } squareList[0].getArea === squareList[1].getArea // true 分析 有人指出创建一个正方形的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来 还是垃圾代码！创建square的代码太分散了！ 在上面基础上，应该再把代码抽离到一个函数里，实现调用函数 就可以创建正方形 —— 封装函数 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"抽离到函数（封装）⭐️ 将创建正方形的代码，整合到一个 function 中 直接调用 function 即可创建出对应个数的正方形对象 这种过程就叫做「封装」 把细节写到一个函数里，调用函数、传参，就搞定了 let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] function createSquare(width){ // 此函数叫做「构造函数」详见一下版块 let obj = Object.create(squarePrototype) // 以 squarePrototype 为原型创建空对象 obj.width = width return obj } let squarePrototype = { getArea(){ return this.width * this.width } getLength(){ return this.width * 4 } } for(let i=0; i\u003c12; i++){ squareList[i] = createSquare(widthList[i]) // 这下创建 square 很简单了吧！ } ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"构造函数 ⭐️ 就是可以构造出对象的函数 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:4:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"函数和原型结合（进一步封装）⭐️ 进一步封装 squarePrototype 原型 和 creatSquare 函数，还是分散的 能不能组合在一起？ let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] function createSquare(width){ // 构造函数：用于创建 square 对象 let obj = Object.create(createSquare.squarePrototype) // 先使用后定义？NO，这里并未执行，执行时已经定义完了 obj.width = width return obj } createSquare.squarePrototype = { // 把原型放到构造函数上，结合够紧密了吗？ getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 }, constructor: createSquare // 再把构造函数放到原型上，方便通过原型找到构造函数 // 原型和构造函数互相引用，非常紧密 // 可以通过createSquare函数，找到原型squarePrototype。也可以拿到原型，方便的找到createSquare函数 } for(let i=0; i\u003c12; i++){ squareList[i] = createSquare(widthList[i]) console.log(squareList[i].constructor) // ƒ createSquare(width){...} // 打印 constructor 可以知道谁构造了 squareList[0→11] 对象：你妈是谁？ } 函数上面也可以用「点 . 」？ 因为函数属于对象 此时，代码已经没有进一步优化的空间了 这段代码几乎完美 为什么不固定下来，让每个JS开发者直接用呢? 这时 JS 就有了 new 操作符 来帮我们实现 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:4:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"new 操作符 ⭐️ 让我们感受JS之父的爱 JS 之父创建了 new 关键字，可以让我们可以再少写几行代码 JS 的 new 到底是干什么的？⚡️⚡️⚡️⚡️（必读！！！） 函数和原型结合（重写）⭐️⭐️ let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] function Square(width){ // 构造函数 this.width = width } Square.prototype.getArea = function(){ return this.width * this.width } Square.prototype.getLength = function(){ return this.width * 4 } for(let i=0; i\u003c12; i++){ squareList[i] = new Square(widthList[i]) console.log(squareList[i].constructor) } // 多美，几乎没有一句多余的废话 每个函数创建时，都自带有prototype属性，这是JS之父故意的 每个prototype都自带有constructor属性，也是故意的 function f1(){} console.dir(f1) f1.prototype.constructor === f1 // true // 函数原型上的constructor等于函数本身 ​ 对比 上面的代码被简化为下面的代码 唯一的区别是要用 new 来调用 细节 creatSquare =\u003e Square 函数名变了 之前需要创建对象，让对象的原型指向拥有 getArea 和 getLength 的那个对象 。 现在这句话不用写了，new 会帮我们实现 用 this 代表新的对象（this 会指向临时对象） return obj 也不用写了，new 会帮我们实现（函数原本三行，压缩成一行，其他 new 会帮我们实现） 现在，把 getArea 和 getLength 通过「点方法」挨个添加到 prototype 上，不能直接给 prototype 赋新值，会导致丢失原本的 constructor（可以用 Object.assign 批量添加） 最后，声明新对象时，用 new Square(width) ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:4:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"总结 ⚡️⚡️⚡️ JS 的 new 到底是干什么的？⚡️⚡️⚡️⚡️（必读！！！） ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"new X() 自动做了四件事情 自动创建空对象 自动为空对象关联原型，原型地址指定为 X.prototype 自动将空对象作为 this 关键字运行构造函数 this 就是我们new构造函数创建的对象 自动 return this ——这就是 JS 之父的爱 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"构造函数 X X 函数本身负责给对象本身添加属性 X.prototype 对象负责保存对象的共用属性 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"原型与共有属性的关系 因为 JS 引擎按照「堆栈」来分配内存、存储数据 根据「堆栈」的规则，简单类型在「栈区 Stack」存储，复杂类型在「堆区 Heap」存储 X.prototype 的值是，原型的地址 因为原型是一个对象，对象是以「堆」的形式存储，所以严格来说，X.prototype的值是：原型的地址 这个地址，对应到计算机中的那一坨内存，才是原型本身 而原型中，有很多属性/方法：toString、valueOf … 它们就是「共有属性」（原创的词） 共有属性的集合就是原型 如果会画内存图，会理解的更清楚 ↓↓↓ ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"示例 function Dog(name){ this.name = name this.color = 'white' this.kind = '萨摩耶' // this 就是我们new构造函数创建的对象 } Dog.prototype.say = function(){ console.log('汪汪') } // 共用函数 Dog.prototype.run = function(){ console.log('狗在跑') } let dog1 = new Dog('小白') Dog.prototype.x = '狗' // 共用的不一定都是函数, 也可以共用属性。 let dog2 = new Dog('小黑') dog1.x // '狗' dog2.x // '狗' ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:6:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"题外话：代码规范 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:7:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"大小写 所有构造函数（专门用于创建对象的函数）首字母大写 所有被构造出来的对象，首字母小写 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:7:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"词性 new 后面的函数（构造函数），使用名词形式。 如 new Person()、new Object() 普通函数，一般使用动词开头。如 createSquare(5)、createElement('div') 其他规则以后再说 ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:7:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"总结一个非常重要的公式 💋 也是 JS 里唯一的一个公式 很多前端对于原型的理解是通过画图，实际上是可以通过公式来表示的 只有方方的课才能看到，若愚的课也没有 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"如何确定一个对象的原型 为什么 let obj = new Object()的原型是 Object.prototype let arr = new Array()的原型是 Array.prototype let square = new Square()的原型是 Square.prototype let fn = new Function()的原型是 Function.prototype 可以总结出，一个对象通过 new XXX 创建出来，那么 XXX.prototype 就是这个对象的原型 因为 new 操作故意这么做的 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"结论 你是谁构造的 你的原型就是谁的 prototype 属性 对应的对象 很多前端会说 prototype 就是原型 实际上、严格来说，prototype 只是存了个地址，不是对象。 prototype 地址对应的那块内存、内存中所有共有属性的集合，才是原型对象本身 ⚡️⚡️⚡️⚡️ 原型公式 ⚡️⚡️⚡️ 对象.__proto__ === 其构造函数.prototype ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"例 💋 function X(width){ this.width = width } X.prototype.getArea = function(){ return this.width * this.width } X.prototype.getLength = function(){ return this.width * 4 } let a = new X(5) let b = new X(6) 构造函数的原型：X.prototype 是 #309 构造出的对象 a 和 b 的原型 ： a.__proto__ 和 b.__proto__ 也是 #309 补充：#109 结构 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"参考资料 JS 中 __proto__ 和 prototype 存在的意义是什么？ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:4","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"做几个题 来理解公式：对象.__proto__ === 其构造函数.prototype 难度1 let x = {} 请问： x的原型是什么？ Object.prototype x.__proto__的值是什么？ Object.prototype 上面两个问题是等价的吗？ 请用内存图画出x的所有属性 答： Object.prototype // x的原型 Object.prototype // x.__proto__ x.__proto__ === Object.prototype // true 二者是等价的 x.__proto__ === window.Object.prototype // true 「window.」可省略 ​ 难度2 function Square(width){ this.width = width } let square = new Square(5) ⚡️⚡️⚡️ 请问： square的原型是什么？ square.__proto__的值是什么？ 请用内存图画出 square 的所有属性 答： Square.prototype // square的原型 Square.prototype // square.__proto__ // 1/2两个问题是等价的（带入公式理解） ​ 难度3 请问： Object.prototype 是哪个函数构造出来的？ Object.prototype 的原型是什么？ Object.prototype.__proto__ 值是什么? 请用内存图画出上述内容 答： 未知，Object.prototype 是默认就存在的，没有谁把它构造出来 没有原型 Object.prototype.__proto__ === null // true ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:5","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"构造函数、prototype、new 通过 Square 的例子，已经可以基本理解了 构造函数 用来创建对象的函数，就是构造函数（特点：首字母大写） ​ prototype 不论构造函数、还是普通函数，每一个函数（对象）都有一个 prototype，用来存放共有属性 每个对象都有原型，但除了「根对象 Object.prototype」比较特殊，Object.prototype 这个对象的原型为空 null function add(x,y){return x+y} add.prototype // 不仅是构造函数，普通函数也有 prototype delete add.prototype // false 而且删不掉，仍然存在 ​ new：会帮我们做四件事情（省略了很多代码） 创建一个临时对象 把这个对象指向一个原型 把这个对象作为 this 来运行这个构造函数 return this ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:9:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"Square 最终版（存疑） function Square(width){ this.width = width } Square.prototype.getArea = function(){ return this.width * this.width } Square.prototype.getLength = function(){ return this.width * 4 } let square = new Square(5) square.width // 5 square.getArea() // 25 square.getLength() // 20 为什么说存疑：因为还有一个更简化的版本，后面再讲 ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:10:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"圆形 Circle function Circle(radius){ this.radius = radius } Circle.prototype.getLength = function(){ return this.radius * Math.PI } Circle.prototype.getArea = function(){ return Math.pow(this.radius, 2) * Math.PI } let c1 = new Circle(10) c1.radius // 10 c1.getLength() // 31.41592653589793 c1.getArea() // 314.1592653589793 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:11:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"长方形 Rectangle 两个参数：宽、高 function Rect(width, height){ this.width = width this.height = height } Rect.prototype.getArea = function(){ return this.width * this.height } Rect.prototype.getLength = function(){ return (this.width + this.height) * 2 } let r1 = new Rect(4,5) r1.width r1.height r1.getLength() r1.getArea() ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:12:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"对象需要分类吗？🧐 回到最初的问题 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"答案是 需要分类 因为不同的对象有不同的功能，某些对象具有相同功能，某些对象具有不同功能 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"理由一 有很多对象拥有一样的属性和行为 需要把它们分为同一类 如 square1 和 square2 如 圆1、圆2、圆3，都是圆 如 长方形1、长方形2，都是长方形 … 这样创建类似对象的时候就很方便 直接 new 一个 Square、new Circle、new Rect … 然后传参，就能创建出相应图形的对象 就不需要【 let square1 = {…}; let square2 = {…} 然后把所有属性写一遍】，这样会很麻烦 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"理由二 但是还有很多对象拥有其他的属性和行为 所以就需要不同的分类 比如 Square / Circle / Rect 就是不同的分类 Array / Function 也是不同的分类 而 Object 创建出来的对象，是最没有特点的对象（没有什么额外更多的功能，相对比较普通） let x = {} // 等价于 let x = new Object() ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"类型 vs. 类 「 类型 \u0026 类 」有什么区别 ？ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:14:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"类型 类型是 JS 数据的分类，有 7 种 四基两空一对象 string number boolean symbol null undefined object ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:14:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"类 类是针对于对象的分类，有无数种 Object 创建出来的对象，是最没有特点的对象 只要觉得需要再创建一个分类，就再写一个 构造函数，new 出来新的分类对象 常见的有 Array、Function、Date(日期)、RegExp(正则) 等 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:14:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"有特色的类 ⭐️ 上面提到 Object 创建的的对象，是最没有特色的类 那什么是有特色的的类？举两个例子：数组对象、函数对象 （在其他语言中，数组、函数可能都不是对象，但在 JS 中，数组/函数 都属于对象） ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:15:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"数组对象 定义一个数组 let arr = [1,2,3] // 简写 let arr = new Array(1,2,3) // 元素为 1,2,3 // arr [1,2,3] let arr = new Array(3) // 长度为 3 // arr [empty×3] ​ 数组对象的自身属性 let arr = [1,2,3] // arr的自身属性有 4 个： '0'/'1'/'2'/'length' 注意，属性名没有数字，只有字符串 属性名：‘0’/‘1’/‘2’ ，都是字符串 灰色属性，是不能被遍历到的：如 length、__proto__ 数组对象的共用属性 共有属性非常多，都存储在数组对象的 __proto__ 中 'push'/'pop'/'shift'/'unshift'/'join' ...... ​ 数组对象 比 普通对象，多一层 原型 let obj = {} let arr = [1,2,3] obj.__proto__ === Object.prototype // true obj.__proto__ === arr.__proto__.__proto__ // true arr.__proto__.__proto__ === Object.prototype // true ​ 调用共有属性时，采用就近原则 在 arr 自身的原型上找到这个属性时，就不会再去 对象原型 上找 arr.toString == arr.__proto__.__proto__.toString // false arr.toString == arr.__proto__.toString // true ​ 各个【共有属性】，用法都在 MDN，基本与其英文原意相关 后面会有单独课程 教这些 API。所谓的 API 就是【数组有哪些函数、对象有哪些函数】 推 push() 方法，将一个或多个元素添加到数的末尾，并返回该数组的新长度。 弹 pop()方法，从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 提档 shift() 方法，从数组中删除第一个元素，并返回该元素的值。 降档 unshift() 方法，将一个或多个元素添加到数组的开头，并返回该数组的新长度。（修改原数组） 联结 join() 方法，将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。 联结 concat() 方法，用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 … let arr = [1,2,3] arr.push(0) // 4 返回数组的新长度 arr // [1,2,3,0] arr.pop() // 0 返回被删除的元素的值 arr // [1,2,3] arr.shift() // 1 返回被删除的元素的值 arr // [2,3] arr.unshift(0) // 3 返回数组的新长度 arr // [0,2,3] arr.join('哈') // \"0哈2哈3\" 直接返回字符串 let arr1 = [1,1], arr2 = [2,2], arr3 = [3,3] arr1.concat(arr2) // [1, 1, 2, 2] arr1.concat(arr2, arr3) // [1, 1, 2, 2, 3, 3] ... ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:15:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"函数对象 定义一个函数 function fn(x,y){return x+y} // 声明函数 fn let fn2 = function fn(x,y){return x+y} // 声明函数 fn，并赋给变量fn2 let fn3 = (x,y) =\u003e x+y let fn4 = new Function('x','y', 'return x+y') // 声明的是匿名函数，并将它赋给 fn4 function fn1(x,y){return 'fn1'} // 声明函数 fn let fn2 = function fn(x,y){return 'fn2'} // 声明函数 fn，并赋给变量fn2 let fn3 = (x,y) =\u003e 'fn3' // 声明函数 fn3 let fn4 = new Function('x','y', 'return `fn4`') // 声明的是匿名函数，并将它赋给 fn4 函数对象自身属性 'name' / 'length' ​ 函数对象共用属性 共有属性非常多，都存储在函数对象的 __proto__ 中 'call' / 'apply' / 'bind' 这三个属性是重点 后面会有单独课程介绍函数 ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:15:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"JS 终极一问：谁构造了ta ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"window 是谁构造的 Window 可以通过 constructor 属性看出构造者 window.constructor === Window // true window.__proto__ === Window.prototype // true ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"window.Object 是谁构造的 window.Function ==因为所有函数都是 window.Function 构造的== window.Object.constructor === window.Function // true window.Object.__proto__ === window.Function.prototype // true ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"window.Function 是谁构造的 window.Function 因为所有函数都是 window.Function 构造的 window.Function.constructor === window.Function // true 自己构造的自己？并不是这样，这是「上帝(浏览器)」的安排 浏览器构造了 Function，然后指定它的构造者是自己 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"ES6 ：class 语法 💋 JS 构造对象目前有两种方式，一种是用【构造函数+prototype】，一种是用【class】 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"prototype 是过时的 ？ 非常遗憾，下面代码（构造函数）被某些前端认为是过时的 function Square(width){ this.width = width } Square.prototype.getArea = function(){ return this.width * this.width } Square.prototype.getLength = function(){ return this.width * 4 } 学习资料：你可以不会 class，但是一定要学会 prototype ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"ES6 ：class 语法 class 是用来声明一个类，类是用来创建对象的，不讲究什么内存共用 class Square{ constructor(width){ // constructor中写对象里的属性 this.width = width } getArea(){ // 对象里的函数 return this.width * this.width } getLength(){ // 对象里的函数 return this.width * 4 } } 注意：方法不能写成 getLength: function(){ ... } 这种形式 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"class 语法引入了更多概念 class Square{ static x = 1 // static表示x属于Square，调用需采用 Square.x 的写法 \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c width = 0 // 初始化 width 的值 // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c constructor(width){ this.width = width } getArea(){ return this.width * this.width } getLength(){ return this.width * 4 } get area2(){ // 只读属性：调用时直接Square.area2就会执行，无需括号 \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c return this.width * this.width } } class 引入更多的语法，这些语法多来自 Java世界 或 c#世界（跟 JS 以前的世界是格格不入的） ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"用 class 重写 Circle class Circle{ constructor(radius){ this.radius = radius } getArea(){ return Math.pow(this.radius, 2) * Math.PI } getLength(){ return this.radius * 2 * Math.PI } } let circle = new Circle(10) circle.radius circle.getArea() circle.getLength() ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:4","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"用 class 重写 Rectangle class Rectangle{ constructor(width, height){ this.width = width this.height = height } getArea(){ return this.width * this.height } getLength(){ return (this.width + this.height) * 2 } } let rect = neww Rectangle(4,5) rect.width rect.height rect.getArea() rect.getLenght() ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:5","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"易混淆语法 语法1： class Person{ sayHi(name){} } // 等价于 function Person(){} Person.prototype.sayHi = function(name){} 语法2： 注意冒号变成了等于号 class Person{ sayHi = (name)=\u003e{} // 注意，一般我们不在这个语法里使用普通函数，多用箭头函数 } // 等价于 function Person(){ this.sayHi = (name)=\u003e{} } ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:6","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"不要强求完全转换成 ES5 大部分 class 语法都可以转为 ES5 语法，但并不是 100% 能转，有些 class 语法你意思理解就行，不需要强行转换为 ES5。 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:7","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"原型好，还是类好？ 都是用来给对象分类的 目前，先推荐用 class 但是 class 的语法知识比较复杂，还需要再多花点时间学习 （关于类和对象的新语法有 页面1，页面2 和 页面3） 原型的知识，上面👆已经全部讲过了 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:18:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"JS 对象的基本用法","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"「增」「删」「改」「查」「原型」 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:0:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"回顾 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:1:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"七种数据类型 number、string、booleansymbol undefined、null object 四基(本类型)两空一对象 (bigInt) ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:1:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"五个 falsy 值 null、undefined 0、NaN '' （空字符串） ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:1:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"JS 对象 是学习 JS 的三座大山之一 对象（原型） this AJAX ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:2:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"对象 object 对象的基础知识 object ，是第七种数据类型，唯一 一种「复杂类型」 其他六种（numbe、string、boolean、symbol、null、undefined），叫做「简单类型」。因为这六种不包含其他任何东西，而 object 对象包含其他内容 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"定义 无序的数据集合 键值对的集合 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"写法 let 对象名 = { key: value // 属性名/键名 : 属性值 } 对象的写法，与 block（代码块）类似，只是碰巧都有 { } 。 要注意区分 { } 是对象，还是代码块 例 let obj = { 'name': 'sam', 'age': 18 } // 不论'name'/'age'(属性名)是否有引号，它都只能是字符串 let obj = new Object({'name': 'sam'}) // 正规写法 console.log({ 'name': 'sam', 'age': 18 }) // 创建匿名对象 JS 既然可以通过字面量方式创建对象，为什么还要有第二种 new Object() 的方式创建 ? 实际上第二种 new Object() 才是正规创建对象的写法，第一种属于简化版 因为简化了代码，所以通常都是用第一种写法 ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"细节 ==键名是字符串==，不是标识符，可以包含任意字符 只要是字符串就行：空串、空格串、emoji 、数字字符串 … （任何一个 Unicode 能表达的串都 ok ） 标识符 规则：（变量）不能以数字开头 属性名的引号可省略，省略之后需按照标识符的规则命名，特例：允许纯数字的键名 就算引号省略了，键名也还是字符串（重要） 例 var obj1 = { '': 1 } var obj2 = { 2: 123, name:'fff', 'age':12 } var obj3 = { ' ': 2 } var obj4 = { '👍': 'zan' } // Object.keys(对象名) 获取对象中的 key名 组成的数组 Object.keys(obj1) // [\"\"] // 空串也是字符串，合法 Object.keys(obj2) // [\"2\", \"name\", \"age\"] Object.keys(obj3) // [\" \"] Object.keys(obj4) // [\"👍\"] // 所以不论怎么写，key 都是字符串 属性名 每个 key 都是对象的属性名（property） 属性值 每个 value 都是对象的属性值 ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:3","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"奇怪的属性名 所有属性名会自动变成字符串 let obj = { 1: 'a', // \"1\" 3.2: 'b', // \"3.2\" 1e2: true, // \"100\" 1e-2: true, // \"0.01\" .234: true, // \"0.234\" 0xFF: true // \"255\" }; Object.keys(obj) // [\"1\", \"100\", \"255\", \"3.2\", \"0.01\", \"0.234\"] JS 可能会自动换算「属性名」，所以如果不想被自动换算，给属性名加上「引号」即可解决 细节 Object.keys(obj) 可以得到 obj 的所有 key 组成的数组 这个 API 需要会使用 「变量」作属性名 如何用变量做属性名 之前都是用常量做属性名（所有不是变量的都是常量） let p1 = 'name' let obj = { p1 : 'sam'} 这样写，属性名为 'p1' let obj = { [p1] : 'sam' } 这样写，属性名为 'name' （ ES 6 ） let aa = 'xxx' // 想用变量a作为属性名 var obj = { aa: 1111 } // {aa: 1111} var obj = { 'aa': 1111 } // {aa: 1111} var obj = { [aa]: 1111 } // {xxx: 1111} // ES6之后 ES6之前，实现变量作属性名 ↓↓ ，需两行代码实现。ES6之后一行 ↑↑ 即可 let aa = 'xxx' var obj = {} obj[aa] = 1111 console.log(obj) // {xxx: 1111} 对比 不加 的属性名会自动变成字符串 加了 则会当做变量求值 值如果不是字符串，则会自动变成字符串 var obj = { [1+2+3+4]: '十' } console.log(obj) // { 10: \"十\" } Object.keys(obj) // [ \"10\" ] ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:4","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"对象的隐藏属性（原型 💡） 隐藏属性 JS 中，每一个对象 都有一个 隐藏属性 __proto__ 这个隐藏属性，储存着其 共有属性组成的对象的地址 这个共有属性组成的对象，叫做原型 也就是说，隐藏属性 储存着 原型的地址 __proto__ 存储了一个地址，这个地址所代表的内存空间中的对象，叫做原型 / 共有属性 代码示例 var obj = {} obj.toString() // 居然不报错 因为 obj 的隐藏属性对应的对象（原型 / 共有属性）上有 toString() ​ 举个栗子：什么叫共有属性 将共有的属性，提取出来单独存储成一个对象。最大的好处，就是省内存 每次声明一个 chinese 时，无需重复写入：国籍、肤色、发色 … 等 chinese 公共的属性，直接用一个特定属性（–proto–），存储共有属性所在的内存地址即可 var chinese1 = { name: '小兰' } var chinese2 = { name: '小红' } ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:5","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"超纲知识 前面提到，对象中所有的 key 都是字符串 实际上，ES 6 中稍微做了调整：除了字符串，symbol 也能做属性名 let a = Symbol() let obj = { [a]: 'Hello' } 这有什么用呢？ 目前，屁用都没用，很久很久以后可能会有用（方方从没用过） 在学习「迭代」时会用到（但前端不流行迭代，所以根本没机会用） ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:6","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"增删改查 「增删改查」对象的属性 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"删除属性 delete 操作符：用于删除对象的某个属性 delete obj.xxx delete obj['xxx'] 作用：删除 obj 的 xxx 属性 请区分「属性值为 undefined」和「不含属性名」 不含属性名 直接删除属性名 var obj = {name: 'sam', age: 18} delete obj.name // 或 delete obj['name'] console.log(obj) // {age: 18} // console.log(obj.name) // undefined 判断是否删除成功 'xxx' in obj === false // 返回 true 说明该属性名已被删除 （不能省略引号） 含有属性名，但是值为 undefined 仅删除属性值，保留属性名 'xxx' in obj \u0026\u0026 obj.xxx === undefined var obj = {name: 'sam', age: 18} obj.name = undefined console.log(obj) // {name: undefined, age: 18} // console.log(obj.name) // undefined 注意 obj.xxx === undefined obj.xxx === undefined 不能断定 ‘xxx’ 是否为 obj 的属性 let obj = {} let obj2 = {x:undefined} obj.x === undefined // true obj.x === undefined // true 所以说 这句话无法判断出 x 到底是不是 obj 的属性 用 in 和 hasOwnProperty 可以判断 let obj = {} let obj2 = {x:undefined} 'x' in obj // false 'x' in obj2 // true obj.hasOwnProperty('x') // false obj2.hasOwnProperty('x') // true 类比 你有没有卫生纸？ A: 没有 // 不含属性名 B: 有，但是没带 // 含有属性名，但是值为 undefined 程序员就是这么严谨 「没有」和「undefined」是两个概念 没有就是没有，undefined 就是 undefined 绝不含糊 需要细心，发现细微的区别 ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"查看所有属性（读属性） 例 var obj = {name: 'sam', age: 18} 查看自身所有属性 无法打印【共有属性 __proto__】 Object.keys(obj) // [\"name\", \"age\"] Object.values(obj) // [\"sam\", 18] Object.entries(obj) // [Array(2), Array(2)] =\u003e 0:[\"name\", \"sam\"] 1:[\"age\", 18] 查看自身+共有属性 dir 指以目录的形式，可以查看到【共有属性 __proto__】 console.dir(obj) // 查看 obj内容 及 共有属性 【推荐】 obj.__proto__ // 也可以直接打印共有属性（但不推荐此法，因为隐藏属性的命名是不固定的，不同浏览器可能规定不同） 或者自己依次用 Object.keys 打印出 obj.__proto__ 判断一个属性是自身的还是共有的 判断一个属性是否是某个对象的属性，可以用 in ，但是 in 无法区分是自身的还是共有的 \"name\" in obj // true \"toString\" in obj // true obj.hasOwnProperty('toString') // false obj.hasOwnProperty('name') // true obj.hasOwnProperty('age') // true ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"原型 原型，就是隐藏属性 所指向的对象 每个对象都有原型 原型里存着对象的共有属性 比如 obj 的原型就是一个对象 obj.__proto__ 存着这个原型对象的地址 这个原型对象里有 toString / constructor / valueOf 等属性 对象的原型也是对象 既然每个对象都有原型，且原型也是对象，那么可以推出：原型上也有原型 所以对象的原型上也有原型 obj = { } 空对象的原型即为所有对象的原型 这个原型包含所有对象的共有属性，是对象的根 这个原型也有原型，是 null 【/nʌl/】 原型为 null 的对象，就是对象的根 console.log(obj.__proto__) // 原型对象（根对象） console.log(obj.__proto__.__proto__) // null 原型上的原型 ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:3","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"查看属性 两种方法查看属性 **中括号语法：obj[‘key’] ** 点语法：obj.key 坑新人语法：obj[key] // 中括号里是变量，【变量 key】 值一般不等于【字符串 ‘key’】 var obj = {name: 'sam', age: 18} obj['name'] // 'sam' obj.name // 'sam' obj[name] // undefined console.log(name) // \"\" window.name = 'age' obj[name] // 18 // 等同于 obj['age'] 变态 obj['na'+'me'] // 'sam' obj[console.log('name')] // name // 先执行log命令，打印内容 // undefined // log 函数的返回值为 undefined，相当于执行 obj[undefined] =\u003e undefined ​ 请优先使用中括号语法 【点语法】会误导你，让你以为 key 不是字符串 等你确定不会弄混两种语法，再改用点语法 obj.name 等价于 obj[‘name’] obj.name 不等价于 obj[name] 简单来说，obj.name 这里的 name 是字符串，而不是变量 let name = ‘sam’ 此时 obj[name] 等价于 obj[‘sam’] ，而不是 obj[‘name’] 和 obj.name ​ 考题 区分变量 name 和 常量字符串 'name' 代码 let list = ['name', 'age', 'gender'] let person = {name:'sam', age:18, gender:'man'} for(let i = 0; i \u003c list.length; i++){ let name = list[i] console.log(person???) } // 使得 person 的所有属性被打印出来 选项 console.log(person.name) ✘ // sam sam sam console.log(person[name]) ✔ // sam 18 man 区分 name 和 ‘name’ 为什么这么重要 因为如果你现在不搞清楚，那么你在学 Vue 的时候，会更加迷惑 ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:4","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"修改或增加属性（写属性） 直接赋值 直接赋值，name 属性已存在，就相当于修改属性值；name 属性不存在，就会新增这个属性，值为 sam let obj = {name: 'sam'} // name 是字符串 obj.name = 'sam' // name 是字符串 ✔ obj['name'] = 'sam' // ✔ obj[name] = 'sam' // 错，因name为变量，值不一定等于'name' obj['na'+'me'] = 'sam' // ✔ let key = 'name'; obj[key] = 'sam' let key = 'name'; obj.key = 'sam' // 错，因为obj.key等价于obj['key']，相当于给obj增加了key属性 值为sam ​ 批量赋值 let obj = {name: 'sam'} Object.assign(obj, {name:'123', age: 18, gender: 'man'}) // name 属性已存在，就相当于修改属性值；name 属性不存在，就会新增这个属性，值为'123' console.log(obj) // {name:'123', age: 18, gender: 'man'} assign ：赋值的意思 Object.assign() ：是 ES6 新出的 API ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:5","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"修改或增加共有属性 JS 特性： 读取时，可以读取到（原型上的）共有属性。 写入时，只写在自己身上，不会影响（原型）共有属性 无法通过自身修改或增加共有属性 原型上的属性，无法通过自身直接修改 let obj = {}, obj2 = {} // 共有 toString 方法 obj.toString = 'xxx' // 只会在改 obj 自身属性，不会覆盖共用的 toString 方法 obj.toString // 'xxx' obj.toString() // 报错 obj.toString is not a function obj2.toString // ƒ toString() { [native code] } 还是在原型上的方法 obj2.toString() // \"[object Object]\" 偏要修改或增加原型上的属性 obj.__proto__.toString = 'xxx' // 不推荐用 __proto__ Object.prototype.toString = 'xxx' console.dir(obj.toString) // obj.__proto__ 存的地址，等价于 window.Object.prototype 存的地址 obj.__proto__ === window.Object.prototype // true 这是 JS 非常危险的特型，一旦修改，会使得原型上的属性非常不可信 —— JS 的脆弱性 一般来说，不要修改原型，会引起很多问题：代码崩溃/异常… ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:6","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"修改隐藏属性 不推荐使用 __proto__ 修改原型 例1 let obj = {name:'sam'} console.log(obj) // {name:\"sam\", __proto__: Object} obj.__proto__ = null console.log(obj) // {name:\"sam\"} 没有proto原型了，变成非常纯净的对象，不能调用任何功能 例2 let person = {name:'sam'} let person2 = {name: 'jack'} let common = {kind: 'human', '国籍': '中国'， hairColor: 'black'} person.__proto__ = common person2.__proto__ = common 上述，使用 __proto__ 直接修改原型，不推荐，性能非常低 ​ 推荐使用 Object.create 修改对象的原型 规范的修改对象的原型，使用 Object.create 【功能：用于指定原型】 var obj = Object.create({name:'sam'}) console.log(obj) // { __proto__:{name:'sam'} } 用法 ↓ let common = {kind: 'human', '国籍': '中国'， hairColor: 'black'} let obj = Object.create(common) // 以common为原型对象，创建obj obj.name = 'sam' // 点方法，挨个添加属性，或 批量修改/添加属性 Object.assign(obj,{ ... }) ... Object.create() 第二个参数，写法比较麻烦 let person = Object.create(common, { name: { value: 'sam' } }) console.log(person) // {name:'sam', __proto__: Object} =\u003e 规范的写法：大概是，要改就一开始就改；别后来再改，如person.__proto__ = common 影响性能 ​ ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:7","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"总结 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"删 delete obj['name'] 'name' in obj // false // in 用于判断某个对象中是否含这个属性，缺点：无法区分是自身的，还是原型上共有的 obj.hasOwnProperty('name') // false // 只有对象自身含有这个属性，才会返回 true ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"查 Object.keys(obj) console.dir(obj) // 目录形式，详细 obj['name'] obj.name // 记住这里的 name 是字符串 obj[name] // 记住这里的 name 是变量 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"改 改自身 obj['name'] = 'jack' 批量改自身 Object.assign(obj, {age:18, ...}) 改某个共有属性 obj.__proto__['toString'] = 'xxx' // 强烈不推荐 改某个共有属性 Object.prototype['toString'] = 'xxx' 换原型 obj.__proto__ = common // 强烈不推荐 换原型 let obj = Object.create(common) // 注：所有 proto 代码都是强烈不推荐写的。学习时可以用用，但是工作中不要用 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:3","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"增 基本同上，已有属性则改；没有属性则增。 查：属于读，可以读到原型链 改 和 增：属于写，只能改自身，不能改到原型 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:4","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"JS 的数据类型","date":"2020-08-27","objectID":"/javascript-something-about-data-type/","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"「如何存数字\u0026字符」「JS 的数据类型」「64位浮点数 」「变量声明 var / let / const」「类型转换」 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:0:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数据为什么需要类型 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:1:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数字与字符串 都是一，为什么要分 1 和 '1' 功能不同 数字是数字，字符串是字符串，要严谨 数字能加减乘除，字符串不行 字符串能表示电话号码，数字不行 存储形式不同 JS中，数字 number 是用64位浮点数的形式存储的 JS中，字符串是用类似 UTF8 形式存储的（UCS-2) ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:1:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"如何存数字 进制转二进制即可 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:2:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"二进制 10转2 31变成二进制： 经过一番尝试： 所以31（十进制）= 01111（二进制） 不是套公式吗？程序员从来不套公式 🙃 2转10 100011变成十进制 每一位乘以2的N次方，然后加起来即可 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:2:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"用十六进制表示二进制 为什么用十六进制，因为二进制写起来太慢了：011110001011010 记住 8 4 2 1 对应 X X X X 从右往左每四位改写成一位：011110001011010 得到 3，12，5，10； 16进制中，把大于9的数字改为ABCDEF 0123456789 A B C D E F 10 11 12 13 14 15 于是得到 3C5A，你也可以用计算器的程序员模式 HEX表示16进制，BIN表示2进制 OCT表示8进制，DEC表示10进制 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:2:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"如何存字符 转成数字即可（但字符有几万个，数字只有0-9），解决办法就是把所有字符都编号 注意，\"1\" 不能用 1 来表示 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"用 0 ~ 127 表示所有符号 （2^7^ = 128） 0 表示结束字符 10 表示换行 13 表示回车 32 表示空格 33 到 47 表示标点 48 到 57 表示数字符号（存 0 用 48 表示） 65 到 90 表示大写字母（存 A 用 65 表示） 97 到 122 表示小写字母（存 a 用 97 表示） 127 表示删除键 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"中文怎么表示？ 1990-1995年左右，中国开始有人买得起电脑了 简单，还是编号 中国国家标准局来编，名称为「国标23121」 ​ 用 0000 ~ FFFF 表示汉字 用两个字节，表示一个汉字（一个字节是8个0/1位） 一个 16 进制数是4个0/1位 FFFF 就是 4x4=16 位，也就是两个字节 最多收录 2^16=65536 个字符 但只收录了6000多常用汉字、西文字母和日文假名（没有收录生僻字、繁体字、韩文…） 「你」的 GB2312 编号为 C4E3 「牛」的 GB2312 编号为 C5A3 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"生僻字 随着计算机的普及，政府、学习开始采用计算机管理录入信息 中国人的名字里有生僻字！ 例 李瓛 =\u003e 李* 陶喆 =\u003e 陶吉吉 怎么表示生僻字、繁体字、韩文呢，之前的忘了编进去 微软出手了，推出了一个国标扩展，简称 GBK ​ GBK 国标扩 含 21886 个汉字和图形符号 收录了中日韩使用的几乎所有汉字 完全兼容 GB2312 依然使用 16 位（两字节） 后来国标局推出 GB18030 想取代 GBK 但 GB18030 不兼容 GB2312，导致没人使用 GB18030，而是一直使用国标扩 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"泰文、藏文 继续编号，这回一次性解决全世界需求 —— 推出 万国码 Unicode 字符集 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"万国码 Unicode 优点 已收录13万字符（大于16位），全世界通用 以后还会继续扩充，不会停止 最新版(2019)只添加了一个字 —— 令和的合体字 （日本的新元号） 日文有很多合体字。如，「株式会社」被合成一个字；元号也都被合成一个字 缺点 两个字节不够用，每个字符要用三个及以上字节 这样所有文件都扩大50%，不划算 那怎么办？ 虽然用Unicode，但存的时候偷懒，这样行不行 UTF-8 就被发明出来了，还真行 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"UTF-8 Unicode 是字符集，UTF-8是编码形式 鸡贼的存法 英文用 1 个字节存，中文用 3 个字节存 存储「a」 a 对应的 Unicode 编号为 97，十六进制为61 Unicode 直接存：000000000000000001100001 UTF-8 偷懒存法：01100001 UTF-8 使得所有字母，从三字节变一字节，比 GBK 还省 存储「你」 你 对应的 Unicode 编号为 4F60（16位） Unicode 直接存：000000000100111101100000 UTF-8 偷懒存法：111001001011110110100000 还是三字节，没有省，但是字母都能省一点 UTF-8 中的 8 的意思是 最少可用 8 位，存一个字符。（可能用 8/16/24 位存一个字符） UTF-8 的规则 这一块看不懂就跳过，反正不考。记住去餐馆排队的比喻即可 以「你a」为例 11100100 10111101 10100000 01100001 如何知道上述内容表示什么字符？ 读 8 位信息 11100100 发现开头有3个1，就认为这个字符有3个八位 于是再往后读两个 8 位信息 10111101 10100000 10 表示当前这8位是跟着前面一起的 前面的 10 不要，其他合起来，得 0100 111101 100000 前面补8个0，这就还原为 Unicode 的「你」了： 000000000100111101100000 再读 8 位信息 01100001 发现开头是 0，就认为这个字符只占 8 位 前面补16个0，这就还原为 Unicode 的「a」 了： 000000000000000001100001 上面 4 个字节，存了两个字符。UTF-8 平均每个字符需要 2 个字节 Unicode 每个字符至少占 3 个字节，UTF-8 的存储方法更节省空间 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:6","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"终于搞清如何存字符了 全世界的字符，都是先把字符进行编号，然后存下编号（10进制变2进制） ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:7","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数字1 和 字符1 的区别 功能不同：数字1 可以进行运算，加减乘除… （ 字符只能相加 =\u003e 拼接字符 ） 存储形式不同：数字是转为二进制直接存储，字符需要经过编码变成数字再存储 数字1 ，最终存的是 1 字符1 ，最终存的是 49 ​ 既然字符也是存的数字，那么计算机怎么知道存的是字符还是数字呢？ 答：计算机并不知道这段0/1是字符还是数字。 但计算机可以通过看文件格式判断，如果是 .txt 那就全都是字符串，如果在 Excel 中存一个1 ，就是数字1 计算机并不知道用户存的0/1到底什么意思，但可以通过其他辅助信息得知（如后缀）或者其他方式约定（比如在文件开头约定：0表示数字，1表示字符串，2表示布尔值…这种方式）。 http 只支持字符串，在 html 中写一个1，就是字符串1 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:4:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"JS 中的数据类型 💡 7 种（大小写无所谓） 数字 number 字符串 string 布尔 bool 符号 symbol（JS 从 ruby 抄的，基本没人用） 空 undefined 空 null 对象 object 总结：四基两空一对象 bigint（新增第8种） 以下不是数据类型 数组、函数、日期、正则… 它们都是特殊的对象 object，所以它们都属于object ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数字 number number 是由64位(0/1)浮点数组成的 JS 的 number 全都是以小数（浮点数）的形式存储的，没有单独的整数 写法 整数写法 1 小数写法 0.1 科学计数法 1.23e4 （1.23×10^4^ ） 八进制写法（用得少） 0 或 00 或 0o 开头，就是 8进制 0123 或 00123 或 0o123 十六进制写法 0x3F 或 0X3F （用得少） 0x 或 0X 开头 二进制写法 0b11 或 0B11（用得少） 0b 或 0B 开头 特殊值 正0和负0 0分三种：0、+0、-0 都是 0，基本没什么区别 只在一种情况有区别（要严谨） 1/0 或 1/+0 =\u003e Infinity 1/-0 =\u003e -Infinity 无穷大 Infinity、+Infinity、-Infinity 无法表示的数字 NaN (Not a Number) 0/0 =\u003e NaN 但 NaN 仍是一个数字 NaN 永远不会和另一个 NaN 相等 NaN == NaN // false 64位浮点数 网道教程 JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 1 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的“位运算”部分。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 0.1 + 0.2 === 0.3 // false 0.3 / 0.1 // 2.9999999999999996 (0.3 - 0.2) === (0.2 - 0.1) // false 根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 … 为什么说【 number 是由 64位(0/1)浮点数组成的】 ？ （看↓图）一共（1+11+52）64 位，就可以表示 js 中的所有数字，包括小数、NaN … JS数字的存储形式 浮点就是浮动的点，意思就是小数点会乱动 123.456 可以表示为 1.23456 × 10^2^ ，也可以表示为 12345.6 × 10^-2^（0.01） 如果小数点可以浮动，那就是浮点数 也有定点数，就是指 有效数位、指数数位 都是固定的（少用） ​ ​ 64位存储一个 number 符号占1位 浮点数的第一位，0表示正号，1表示负号。「+0」的第一位是 0，「-0」的第一位是 1 指数占11位 指的是 10 的 n 次方，把这个 n 存到这11位里（11位可以存2048，因为有正负所以范围是 -1023~1024） 有效数字占52位（开头的 1. 省略） 10进制的小数，第一位永远可以为 1.xxx ，如 0.123 =\u003e 1.23 × 10^-1^ ​ 例：存 0.5 先将0.5转为二进制（看0.5是多少个二分之一，凑）=\u003e 1.0 × 2^-1^ 0.5是1个二分之一，所以 0.5 的二进制是 0.1 0.1存成64位形式 =\u003e 1.0 × 2^-1^ 正：0，负：1 指数部分（有正负） 有效数字（省掉第一个1.） 0 -1 0 ​ 例：存 0.625 看0.625有多少个二分之一（转为二进制，凑一下） 0.625 = 0.5 + 0.125 = 1/2 + 1/8 = 1×2^-1^ + 1×2^-3^ 所以 0.625 表示成 二进制就是 0.101 0.101 ↑ ↑ -1 -3 0.101存成 64位形式 =\u003e 1.01 × 2^-1^ 正：0，负：1 指数部分（有正负） 有效数字（省掉第一个1.） 0 -1 01 ​ 范围和精度 范围（忽略符号位） 指数拉满、有效数字拉满，得到最大二进制数字 Number.MAX_VALUE: 1.7976931348623157e+308 指数负方向拉满、有效数字最小 1，得到最小值 Number.MIN_VALUE: 5e-324 精度（有效数字） 最多只能到 52 + 1 个二进制位表示有效数字 2^53^ 对应的十进制是 9 后面 15 个零 所以 15 位有效数字都能精确表示 16 位有效数字如果小于 90 开头，也能精确表示 9110000000000001 就存不下来 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"字符串 string 字符串 string 在 JS 中，每个字符占两个字节（定长）。是阉割版的 UTF8。 因为 1995 年发布 JS ，当时 Unicode 并未流行，甚至还没有推出第一个可用版本。 写法 - 单引号 '你好' - 双引号 \"你好\" - 反引号 `你好` (ES6) 注意 引号不属于字符串的一部分，就像书名号不属于书名的一部分一样 如果要在单引号里面包含单引号怎么办? 错误写法 'it's ok' JS 引擎会认为 'it' 就结束了，后面的看不懂，可能就会报错 Chrome 中这种写法如果不报错，那就是 Chrome 的误导💩🤬 正确写法 'it\\'s ok' // 这就是转义 \"it's ok\" `it's ok` ​ 转义 用另一种写法表示你想要的东西 \\' 表示 ' \\\" 表示 \" \\n 表示 换行 \\r 表示 回车 \\t 表示 tab制表符 \\\\ 表示 \\ \\uFFFF 表示对应的 Unicode 字符 \\xFF 表示前256个 Unicode 字符（16进制） 例 '\\u4f60' =\u003e \"你\" '\\x31' =\u003e \"1\" （10进制的49转16进制为 31） '\\x32' =\u003e \"2\" '\\x33' =\u003e \"3\" ​ 多行字符串 如果你想要在字符串里回车 let s=`这样是 可以的 用【反引号】很容易做到` 以前没有反引号的时候 写起来很麻烦，是比较古老的知识，想了解可以看阮一峰的网道教程 ​ 字符串的属性 “ 等等，对象才有属性，为什么字符串也有属性 ” 记住一点：只有对象才有属性，字符串、数字、布尔是没有属性这么一说的 那为什么这里讲「字符串的属性」？（源于对象，学完对象才能解答） 字符串的长度 string.length '123'.length // 3 '\\n\\t\\r'.length // 3 （1个换行、1个tab、1个回车） '\\\\\\\\\\\\'.length // 3 （2个反斜杠表示1个\\） ''.length // 0 （空字符串） ' '.length // 1 （1个空格字符串） ' '.length // 2 （2个空格字符串） 字符串的下标 通过下标读取字符 string[index] let s='hello' s[0] // \"h\" 注意 index 从0开始 s[0]是第一个字符 注意 index 不到 length 一个字符串的最大 index 为 length - 1 let s='hello' s[5] // undefined 居然不报错 s[4] // 'o' ​ base64 转码 window.btoa 正常字符串转为Base64编码的字符串 window.atob Base64 编码的字符串转为原来的字符串 一般用来隐藏招聘启事里的简历 邮箱：YWJjZGVmZ0BnbWFpbC5jb20= 编码 window.btoa('abcdefg@gmail.com') // YWJjZGVmZ0BnbWFpbC5jb20= 解码 window.atob('YWJjZGVmZ0BnbWFpbC5jb20=') // abcdefg@gmail.com 有时候也用来自欺欺人 所谓的「加密」，也就能骗过一部分外行 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"布尔 boolean 真或假 只有两个值：true / false （全都小写） 下列运算符会得到 bool 值 否定运算 !value 相等运算 1==2、1!=2、3===4、3!==4 比较运算 1\u003e2、1\u003e=2、3\u003c4、3\u003c=4 if 配 bool if 语句常常需要判断真假 if(value){...} else {...} 问题来了 如果 value 是 bool 值还好说 如果 value 不是 bool 值咋办，谁真谁假 1 是真还是假，0 是真还是假 '1' 是真还是假，'0' 是真还是假 五个 falsy 值 falsy 就是相当于 false，但又不是 false 的值 分别是 undefined null 0 NaN '' // ''和' '不是一个玩意再次声明，请保持严谨 整个 JavaScript 中，除了上述 5 个 falsy 值 和 false 本身（6个假值）之外 其他任何值都是【真值】，包括数组、函数、对象… ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"undefined 和 null 两种空类型，空空如也 为什么有两个空 这就是 JS 的原创（💩）之处 其他任何一种语言，都只有一个空类型 区别 没有本质区别 细节一 如果一个变量声明了，但没有赋值，那么默认值就是 undefined，而不是 null 细节二 如果一个函数，没有写 return，那么默认 return undefined，而不是 null 细节三 前端程序员习惯上，把非对象的空值写为 undefined，把对象的空值写为 null 但仅仅是习惯上而已 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"symbol 符号 不怎么常用的数据类型（大概率完全不会用到） 直接看文章吧 更详细更权威的知识参考下面的自学链接。 自学链接： MDN： Symbol - JavaScript 阮一峰：ECMAScript 6入门 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"bigint （2020.6 新增） 2020 年 6 月 JS 新增了一种类型：bigint 关于 bigint 的详细介绍，请看 MDN。 目前 bigint 用得很少。面试也基本不考，工作中也较少用到。因为太新了。 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:6","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"变量声明 var / let / const ⭐️ 强烈推荐阅读：《我用了两个月的时间才理解 let》 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"三种声明方式 var a=1 let a=1 const a=1 a=1 区别 var 是过时的、不好用的方式 let 是新的，更合理的方式 const 是声明时必须赋值，且不能再改的方式 最后这种方式是错误的，不准这样声明 var 变量提升 押题时再讲，有兴趣可以提前看网道教程 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"var 声明 直接跳过 我们写代码不用 var 面试押题前单独讲解 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"let 声明 规则（特点） 遵循块作用域，即：使用范围不能超出 { } 不能重复申明 可以赋值，也可以不赋值 必须先声明，再使用。否则报错 全局声明的 let 变量，不会变成 window 的属性 for 循环配合 let 有奇效 例 1 // 遵循块作用域，使用范围不能超出{} { let b=1 // let声明的b只能作用在声明的这个{}里面 console.log(b) // 1 } console.log(b) // Uncaught ReferenceError: b is not defined // 报错：b未被定义 例 2 let a=1 let a=2 // Uncaught SyntaxError: Identifier 'a' has already been declared // 报错：标识符a已被声明 不能重复声明：在同一个作用域，只能有一个 a let a=1 { let a=2 // 这样是可以的。因为a是在{}中的，与{}块外面的a不算重复声明 } 例 3 let a // 声明时可以赋值，也可以不赋值 console.log(a) // undefined let b = true console.log(b) // true 例 4 // 必须先声明，再使用，否则报错 { console.log(b) // Uncaught ReferenceError: Cannot access 'b' before initialization let b=1 } // 报错：不能访问 b 在初始化之前 例 5 // 全局声明的 let 变量，不会变成 window 的属性 let abc='abc' console.log(window.abc) // undefined var abc = 'abc' console.log(window.abc) // 'abc' // 这其实是 var 的 bug 。为什么声明变量会变成 window 上的属性？这是var强加的 // let就改掉这个bug了，let就是单纯声明变量，不做多余操作 例 6 for(var i=0;i\u003c5;i++){ setTimeout(()=\u003e console.log(i),0) // 5 5 5 5 5 } for(let i=0;i\u003c5;i++){ setTimeout(()=\u003e console.log(i),0) // 0 1 2 3 4 } ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"const 声明 规则 跟 let 相同的点 遵循 { } 块作用域 不能重复声明 先声明后使用 不会变成 window 属性 跟 let 只有一条不同：声明时就要赋值，赋值后不能改 const 声明的是一个 只读变量，也叫做「常量」 例 // const声明变量，声明时不赋值，就会报错 const i // Uncaught SyntaxError: Missing initializer in const declaration // 报错：const声明中缺少初始化 // 声明后，又重新赋值，会报错 const i=100 i=101 // Uncaught TypeError: Assignment to constant variable // 报错：赋值给常量 // for循环中，修改变量值，会报错 for(const i=2;i\u003c5;i++){ // Uncaught TypeError: Assignment to constant variable // 报错：赋值给常量 setTimeout(()=\u003e console.log(i),0) // 2 } ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"指定值，同时也指定了类型 变量声明 指定了值，同时也指定了类型 但是值和类型都可以随意变化 var a=1 // number类型 a=2 a='字符串' ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"name 和 ‘name’ 的区别 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:7:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"name 是变量 变量，意味着「值」「类型」可变，可能是 ‘name’，也可能是 ‘hello’ 变量，存在内存的「不知道什么区」 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:7:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"‘name’ 是字符串、常量 「常量」就是不变量 ‘name’ 只能是 ‘name’ ，不能是其他值 字符串，存在「Stack 区」 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:7:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"类型转换 ⚡️ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"number =\u003e string String(n) // 前端通常不会用这种写法，太麻烦了 n + '' // 前端都是用这种 例 var n=1 console.log(String(n)) // 1 [黑色字符串] console.log(n+'') // 1 [黑色字符串] console.log(''+n) // 1 [黑色字符串] console.log(n) // 1 [蓝色数字] JS bug String(1000000) // \"1000000\" String(1000000000000) // \"1000000000000\" String(1000000000000000000000000) // \"1e+24\" （0变多，就变成科学计数法的字符串了） // 后来JS补救了：即使0变多，也不会转成科学计数法 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"string =\u003e number Number(s) parseInt(s) / parseFloat(s) s-0 / +s // 前端都是用这种最省事的写法 例 var s='123' console.log(Number(s)) // 123 [蓝色数字] console.log(parseInt(s)) // 123 [蓝色数字] 虽然显示的是整数，实际上是小数，number只有一种64位浮点数 console.log(parseFloat(s)) // 123 [蓝色数字] console.log(s-0) // 123 [蓝色数字] console.log(+s) // 123 [蓝色数字] console.log(s) // 123 [黑色字符串] JS bug // ES6之前，parseInt()自动识别：看到0开头就认为是8进制 parseInt('0123') // 83 (8进制的0123转为10进制 =\u003e 83) // 1*8^2+2*8^1+3*8^0=83 // ES6之后，parseInt()默认就是10进制 parseInt('0123') // 123 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"x =\u003e bool Boolean(x) !!x 例 // 把1/0变成布尔类型 Boolean(1) // true Boolean(0) // false // 上述方法，前端从来不用，太麻烦 // 前端直接用 !! （两次取反） 这种方法因为比较装B，所以在前端界比较流行 !!1 // true !!'aaa' // true （ !!aaa 不加引号就是变量，这里变量需要先声明才能使用） var obj={}; !!obj // true function foo(){}; !!foo // true !!0 // false !!NaN // false !!'' // false !!null // false !!undefined // false !!abc // abc is not defined var abc !!abc // false var abc=123 !!abc // true ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"x =\u003e string String(x) x.toString() 例 true.toString() // \"true\" false.toString() // \"false\" JS bug 1.toString() // 报错，js读到「1.」认为这是个小数，后面应该跟着数字，结果读到「t」，就直接报错 // 解决办法 (1).toString() // \"1\" 1 .toString() // \"1\" 1..toString() // \"1\" // 合法。js读到「1.」认为是 1.0 1.0.toString() // \"1\" ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"补充：JS 秘密花园 Google 搜索 「JS 秘密花园」，里面就讲了 JS 的各种奇葩事情 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"JS 的基本语法","date":"2020-08-24","objectID":"/javascript-basic-syntax/","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"内容包括「什么是表达式和语句」「标识符的规则」「 if else 语句」「 while for 语句」「 label 」 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:0:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"推荐书籍 适合入门《网道 JavaScript 教程》 适合进阶《你不知道的 JavaScript（上卷）》 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:1:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"JS 语法 ⭐️ 开始学习 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"表达式与语句 表达式 1+2 表达式的值为 3 add(1,2) 表达式的值为函数的返回值 console.log 表达式的值为函数本身（因为没加括号） console.log(3) 表达式的值为多少？（面试) 表达式的值就是函数的返回值 ，log函数的返回值为 undefined 所以 console.log(3) 表达式的值为 undefined 语句 var a=1 是一个语句 二者的区别 表达式一般都有值，语句可能有也可能没有 语句一般会改变环境（声明、赋值） 上面两句话并不是绝对的 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"大小写敏感 不要写错 var a 和 var A 是不同的 object 和 Object 是不同的 function 和 Function 是不同的 具体含义后面说 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"空格 大部分空格没有实际意义 var a = 1 和 var a=1 没有区别 加回车，大部分时候也不影响 只有一个地方不能加回车，那就是 return 后面 return 后面不加东西，js 会自动补充成 return undefined function fn(){ return 3 } function fn(){ return [undefined] // return 和 3 之间加了一个回车，js会自动补充为 return undefined 3 } 唯独 return 后面不能加回车，其他多离谱的回车都没问题 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:3","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"标识符 规则 第一个字符，可以是 Unicode 字母 / $ / _ / 中文 后面的字符，除了上面所说，还可以有数字 注意，首位不能是数字 var 9$ Uncaught SyntaxError: Invalid or unexpected token // SyntaxError意为语法错误，token理解成字符串 变量名是标识符 以下都是合法的标识符用法 var _ = 1 var $ = 2 var ______= 6 var 你好 = 'hi' 其他标识符用到再说 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:4","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"注释 谣言：“ 写代码要多写注释。” 注释，分为：好的注释、不好的注释 不好的注释 不好的注释：告诉别人我写了什么 把代码翻译成中文 可能埋没了重要的注释。有用的信息和噪音的比例（信噪比）要低 过时的注释 发泄不满的注释 好的注释 好的注释：告诉别人为什么我要这么写 踩坑注解 为什么代码会写得这么奇怪，遇到什么 bug 遇到某个 bug，代码非得这么奇怪的写，才能避开这个 bug（这种也需要注释出来） ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:5","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"区块 block 把代码包在一起 { let a=1 let b=2 } 常常与 if / for / while 合用 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:6","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"if 语句 如果 … 那么 … ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 if(表达式){语句1}else{语句2} { } 在语句只有一句的时候可以省略，不建议这样做 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"变态情况 (表达式) 里可以非常变态，如 a=1 const a=2 if(a=1){ console.log('a是1') // 最终打印这句，因为 = 是赋值，=== 才是判断是否相等 }else{ console.1og('a不是1') } 语句1 里可以非常变态，如嵌套的 if else 语句2 里可以非常变态，如嵌套的 if else 缩进也可以很变态，如面试题常常下套 const a=1 if(a===2) console.log('a') console.log('a等于2') 上述代码执行结果为：因为不写 { } 时，只默认第一个语句是跟随 if 条件的，有一个**无形的 { } **括住了第一句，相当于下面效果 const a=1 if(a===2) { console.log('a') } console.log('a等于2') 注：js 中是没有【行】的概念，即使两句写在一行，结果不变，仍是只括住第一个语句 const a=1 if(a===2) { console.log('a'); } console.log('a等于2') 如果用 逗号分隔呢？ const a=1 if(a===2) { console.log('a'), console.log('a等于2') } console.log('a???') 逗号，表示这句话没结束。所以默认两个 console 就变成一个语句了（效果如上） 分号；表示这句话结束了。 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"使用最没有歧义的写法 最推荐使用的写法 永远不要省略花括号 { }，即使只有一个语句。这是最不会产生歧义的写法 if(表达式){ 语句 }else if(表达式){ 语句 }else{ 语句 } 次推荐使用的写法 该写法，只在函数里有用 基于函数 return 的特点：执行 return ，函数就结束了，不再往下执行 function fn(){ if(表达式){ return 表达式 } if(表达式){ return 表达式 } return 表达式 } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:3","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"switch 语句 if…else…升级版 JS 的 switch 语句设计的不算精致，但确实在某些情况时，比 if…else… 好用 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:4:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 switch(fruit){ case \"banana\"： //... break； case \"apple\": //... break； default: //... } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:4:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"break **大部分时候，省略 break 你就完蛋了 ** 当条件符合 banana 时，执行某些语句 … ，遇到 break 跳出 switch 如果没有 break，就会向下跳过case 'apple'，直接执行 apple 的语句 … 看起来很鸡肋 少部分时候，可以利用 break 最早为什么这么设计 break 呢？ 是为了方便「 满足多个条件（case）时 」的判断 如下，case 1 可以默认贯穿到 case 3 （初衷是好的） ​ Swift 的 switch case 语句设计，完爆 JS 的 switch case （apple 出的语言） 执行完一个 case，默认跳出，无需 break 多条件判断：可以直接在一个 case 下写多个条件句 ，无需去掉 break 来表示贯穿 综上，JS 出现的太早了，没有抄到一个好的 switch case switch some value to consider { case value 1: respond to value 1 case value 2, value 3: respond to value 2 or 3 default: otherwise, do something else } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:4:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"问号冒号（三元）表达式 表达式1 ? 表达式2 : 表达式3 表达式 最简单的 if…else… 的写法，能用问号冒号就不用 if…else… // 求两个数的最大值 function max(a,b){ if(a\u003eb) return a; else return b; } function max(a,b){ return a\u003eb ? a: b } // 求绝对值 function abs(n){ return n\u003e0 ? n: -n } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:5:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"\u0026\u0026 短路逻辑 与运算 A \u0026\u0026 B \u0026\u0026 C \u0026\u0026 D 取第一个假值，后面就不看了 如果ABC都为真，就取 D。 一般整句表达式的值，不会出现取 true / false，而是取 ABCD 中的一个 只要整个表达式中，有一个是假，整个式子就是假 a\u0026\u0026b if(a){ // 理解：a\u0026\u0026b 等价于，如果a是真，就执行b，否则就什么都不执行 b }else{ } 例 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e5 \u0026\u0026 5 false 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e2 \u0026\u0026 5 5 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e2 \u0026\u0026 console.log('前面全对了') 前面全对了 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e2 \u0026\u0026 5\u003c0 false 例 if(window.f1){ console.log('f1存在') } // 上下效果等价：如果 window.f1为 true ，就会执行 conosole.log('f1存在') window.f1 \u0026\u0026 conosole.log('f1存在') 前端中，如果能写成 \u0026\u0026 的语句，就不写 if…else… 语句 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:6:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"最常见的用法 fn \u0026\u0026 fn() // 如果 fn 存在就执行 fn 例 console \u0026\u0026 console.log \u0026\u0026 console.log('hi') // 如果console存在，就判断console.log是否存在，也存在，就执行打印 hi /* 这么写有什么意义？ 因为 IE 没有 console，如果用 IE 就不执行 console，不然 IE 会报错 */ ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:6:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"|| 短路逻辑 或运算 A || B || C || D 取第一个真值，后面就都不看了。 如果ABC都为假，就取 D 一般整句表达式的值，不会出现取 true / false，而是取 ABCD 中的一个 只要整个表达式中，有一个是真，整个式子就是 真 a||b if(!a){ // 理解：a||b 等价于，如果a不是真，就执行b，否则就什么都不执行 b }else{ } 如果能写成 || 的语句，就不写 if…else… ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:7:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"最常见的用法 例：前端中经常有一个种写法 a = a || 100 // 理解：如果a存在就什么都不做，否则 a=100 if(a){ a = a // 自己赋给自己，相当于什么都不做 }else{ a = 100 // 保底值 } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:7:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"总结：条件语句 if … else… if…else…的逻辑是最常用的，但是很多情况并不使用它。代码简短时，会用更简便的代码替代这种写法 switch case 不能少了 break A ? B : C 相当常用（A若为真，执行B，A若为假，执行C） A \u0026\u0026 B 相当常用，举例：fn \u0026\u0026 fn() （ fn 存在就执行 fn ） A || B 相当常用，举例： A = A || B （A 存在时就什么都不执行，A 不存在时 B 就是 A 的保底值） ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:8:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"while 循环 用的不多 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 while (表达式) { 语句 } 判断表达式的真假 当表达式为真，执行语句，执行完再判断表达式的真假 直到遇到表达式为假，跳出循环，执行后面的语句 var a = 1 // 初始化 while(a !== 10){ // 判断条件 console.log(a) // 循环体 a = a+1 // 增长(为最终能跳出循环) } 共需要四部分： 1. 初始化 2. 判断条件 3. 循环体 4. 增长 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"其他 do … while 用得不多，自行了解 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"while 变态情况：死循环 while(a!==1){ console.log(a) a = a + 0.1 } 原因：浮点数不精确，导致死循环 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:3","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"for 循环 for循环 是 while循环 的语法糖 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法糖 for 是 while 循环的方便写法 写 while 时需要四部分： 1. 初始化 2. 判断条件 3. 循环体 4. 增长 for 将 while 的写法升级、整合，如下 语句1 是用来初始化的 表达式2 是判断条件 语句3 是自增 循环体 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 for(语句1;表达式2;语句3){ 循环体 } 先执行语句1 然后判断表达式2 如果为真，执行循环体，然后再执行语句3 如果为假，直接退出循环，执行后面的语句 例 for(var i=0;i\u003c5;i++){ console.log(i) // 0 1 2 3 4 } // i 5 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"变态 for(var i=0;i\u003c5;i++){ setTimeout(()=\u003e{ console.log(i) // 5 5 5 5 5 // console.log(i + '随机数' + Math.random()) },0) } // i 5 9 是 Chrome 的 bug。 5个5是正解。 每轮循环触发 setTimeout 相当于设置一个闹钟命令：过一会再执行 setTimeout 中的语句。而过一会之后，for循环已经走完，i 变为 5。然后闹钟到点，依次执行每轮触发的 setTimeout 中的语句，也就是执行 5轮 console.log( i ) ，就会打印 5 个 5 解决 把 var 替换成 let for(let i=0;i\u003c5;i++){ setTimeout(()=\u003e{ console.log(i) // 0 1 2 3 4 },0) } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:3","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法变形 for(语句1;表达式2;语句3){ 循环体 } 省略 语句 1 ，可在 for 循环外面定义变量 let i = 0 for(; i\u003c5 ; i++){ console.log(i) // 0 1 2 3 4 } 省略 表达式 2 ，会进入死循环 let i = 0 for(; ; i++){ console.log(i) // 0 1 2 3 4 5 6... } 省略 语句 2 \u0026 3 ，会进入死循环 let i = 0 for(; ; ){ console.log(i) // 0 0 0 0 0 0 0... } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:4","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"break 和 continue break 退出所有循环 continue 退出当前一次循环 for(var i=0;i\u003c10;i++){ if(i%2===1){ // 遇到奇数轮次，退出整个for循环 break } } console.log(i) // 1 for(var i=0;i\u003c10;i++){ if(i%2===1){ // 遇到奇数轮次，跳过当次循环 continue }else{ console.log(i) // 0 2 4 6 8 } } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:5","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"label 语法 用的很少，面试会考（概率5%） 这个知识点，除了用来做面试题之外，毫无用处 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:11:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 label 语法：在任何情况下，写一个[标识符](# 标识符)，后面写一个代码块 { }（通常包含多句代码），或一句代码 代码块 foo: { console.log(1); break foo; // 跳出foo这个代码块 console.log('本行不会输出') } console.log(2); 一句代码 foo: console.log(2) ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:11:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"面试 1 { foo: 1 } 2 foo: 1 // 表示代码块只有一行，叫做 1 console.log(2); 3 { foo: 1 // 一个代码块，第一行是一个标签，标签内容是 1，没有什么实际意义 console.log(2); } 问上面是什么 答： 是一个代码块（属于 label 语法），里面有一个标签 foo，语句就是一个 1 为什么不是一个对象？ 答：如果写成下面形式，a 就是对象了 var a = { foo: 1 } 如果单纯写一个代码块（如下），那就是一个 label，语句为 1 { foo: 1 } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:11:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"JS 的历史","date":"2020-08-12","objectID":"/javascript-history/","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"简单了解「学 JS 的基本要求」，重点了解「JS 的诞生与历史」 ​ ","date":"2020-08-12","objectID":"/javascript-history/:0:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"一些链接 《Code Rush》纪录片，记录了 Firefox 开源的过程，里面有 JS 之父的采访 Chrome 的广告，让你了解 Chrome 有多快 淘宝天猫不再支持 IE 6/7 淘宝天猫不再支持 IE 8 百度指数 【JavaScript 诞生】相关文章： JavaScript 的历史 JavaScript 诞生记⭐ JavaScript 的10个设计缺陷 ​ ","date":"2020-08-12","objectID":"/javascript-history/:1:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"前端的门槛 从 JavaScript 开始，你需要绞尽脑汁了 ​ ","date":"2020-08-12","objectID":"/javascript-history/:2:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"学 JS 的基本要求 ","date":"2020-08-12","objectID":"/javascript-history/:3:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"软要求 对大脑的要求 一、逻辑能力 逻辑分很多种：抽象逻辑、符号逻辑、三段论逻辑（最常用）… 三段论逻辑 示例 JS的数据类型有 number / string / null / undefined / bool / symbol / object 【大前提】 JS的函数不是 number / string / null / undefined / bool / symbol 中的任意一种 所以，JS的函数是object 【根据前两句话，能推出第三句】 好处 写代码基本就是在编写逻辑 ​ 二、质疑自己的能力 程序员不要相信人类，包括你自己 质疑自己、推翻自己 出现 bug ，先质疑自己、再质疑机器 大脑中有6个知识点，通过这6个知识点，写出一个bug，可能某个知识点记错了，不要纠结，不要认死理，懂得质疑和推翻自己。直接把错误的知识点从大脑中擦掉，灌入正确的知识点，来更新你的知识 回想一下 你犯了多少错误 拼错单词 多写了空格、少写了空格 把 O 看成 0，把 0 写成 O 把 iOS 写成 IOS 或者 ios 这不是粗心大意，这是人类不可克服的问题，通过 double check 可以缓解 正着核对一遍，再反着核对一遍 ​ 三、抽象思维 高级程序员必备能力 什么是抽象能力 举例 你订了一份报纸 你关注了偶像明星蔡徐坤的微博 你用JS监听了一个按钮的点击事件 对程序员来说，这三件事是一件事，拥有共同的模式：发布订阅模式。 这就是抽象，把事物的特征进行快速总结。 多练，初级程序员至少锻炼1年，才能具备这种抽象思维。 具备看到一个事物，就能把它抽离成代码示例的能力。 好处 抽象思维，使你的代码能解决更多的问题 而不是兵来将挡、水来土掩，一个一个解决 新手程序员，遇到一个问题就写一段代码 高级程序员，将所有可能问题汇总，写一大坨代码解决全部问题 比如 Vue 和 React 的作者（一套框架解决问题） ​ ","date":"2020-08-12","objectID":"/javascript-history/:3:1","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"硬要求 客观上的要求 一、足够的代码量 达到 1000 行 - 新手 达到 10000 行 - 熟手（至少做过1个比较复杂的项目，常规项目都能做） 达到 50000 行 - 专业选手（至少做过2-3个比较复杂的项目，可能3-5年，看996时间积累） 只能靠时间积累 如何统计自己的代码行数 安装 yarn global add cloc cloc --vcs=git . 可以用来统计一个仓库里的有效代码 注意 如果仓库里有 node_modules 目录等不相关内容 需要把 /node_modules/ 写入 .gitignore 文件 ​ 二、了解足够多的概念 不仅要会写，还要会扯说（面试） 概览 常用常考 闭包、原型类、继承、MVC、Flux、高阶函数、前端工程化 只会用，不会说，面试就完了 如何积累 在课程中提炼 就是记笔记 面试如果能完整说出来，就是满分。新手能说出一般也达到要求了，面试新手就看思路对不对，不需要百分百实现 在大脑中思考 JS需要思考清楚，这些代码到底是在做什么。为什么这样设计、为什么这样用 学JS，必须把疑问直接搞定，不能一直留着，不然会有越来越多的 bug 在博客上总结 思考清楚了，一定要总结、记下来 用于面试 在代码中实践 ​ 三、有足够的踩坑经验 你以为是工作经验吗？ 踩坑经验 何谓专家 **“ 该领域内所有的错误都犯完的人，就是专家 ” ** 如何踩坑 做项目，而且是个人项目 个人项目的意思是所有代码都是你一个人写的 团队合作的大项目，基本上只有两个人做，其他人都是打酱油的 这样你才能全方位踩坑 ​ ","date":"2020-08-12","objectID":"/javascript-history/:3:2","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"总结 软要求 逻辑能力 质疑自己的能力 抽象能力 硬要求 足够多的代码（至少5000行，大项目1000-2000行，小项目200行左右） 足够多的概念 足够多的踩坑经验（记下来自己遇到过什么坑） ​ ​ ","date":"2020-08-12","objectID":"/javascript-history/:3:3","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 的历史 历史和特点 ","date":"2020-08-12","objectID":"/javascript-history/:4:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"发明人 李爵士发明 HTML 赖先生发明 CSS 布兰登发明 JS ​ 布兰登的生平 生平1961年生于美国 物理学转数学与计算机学位 工作七年，负责操作系统与网络开发 又工作三年，负责微内核与电子信号处理相关工作 1995年进入网景公司，为其浏览器开发了 JS 功能 1998年协助成立 Mozilla.org，担任首席架构师 网景死亡（被收购）后，他成立了 Mozilla 基金会，Firefox 就是这个基金会维护的，有纪录片记录了这一过程 2014年晋升为 Mozilla 的 CEO，十天后，被赶下台 原因是他曾捐助过反同性恋的法案（只有异性可结婚） 2015年成立 Brave 公司，开发保护用户隐私的浏览器 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:1","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"总结 牛逼的程序员 从来不会只学一门编程语言 不怕被辞退，总能找到事做 很容易创业，比外行人靠谱得多 可以干到 50 岁以上（基本上都是创办公司或很有钱了） JavaScript 诞生之初，只是一个不起眼的小功能 同时 JS 有很多 bug，我们学习的时候要注意辨别 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:2","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 的诞生 布莱登临危受命 公司要求给浏览器添加一个脚本功能 公司要求这个脚本必须蹭 Java 的流量 布莱登花十天设计了 JS 的最初版本（不是实现） JS的命名 Mocha 摩卡 =\u003e LiveScript =\u003e JavaScript Java 既是编程语言，也是一种咖啡 浏览器一开始同时就支持 Java 和 JavaScript 后来，JS 胜了（在浏览器上），Java就逐渐退出了浏览器平台 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:3","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"浏览器大战 背景：1995年，网景推出 JS 功能，用户纷纷叫好，因为可以在页面上节省流量。 当时的网速非常慢 2~3k/s，用户填写一个表单，点击提交按钮，等待一分钟才刷新页面，反馈结果。 有了 JS 功能之后，点击按钮，马上反馈用户表单信息是否正确，所以用户非常喜欢。 注意：此时的 JavaScript 只是网景提供的一个功能，并不是语言 微软的跟进 1996年8月 IE 3 发布，支持 JScript（微软实现的JS） 浏览器大战开始，每家浏览器的脚本不太一样 网景的反击 1996年11月，网景向 ECMA 提交语言标准，由于版权问题，JS 语言标准不叫 JavaScript，叫 ECMAScript ECMA 发音：ai ke ma ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:4","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"网景之死 被收购 微软的 IE 浏览器由于捆绑进了 Windows，很快超越 1998年，网景浏览器节节败退，公司陷入内忧外患 同年，公司打算搏一搏，将浏览器开源（Firefox） 最终，市场并没有因为开源而重新青睐网景 年底，[美国在线 AOL] 宣布开始收购网景 收购后，网景团队里的程序员纷纷被解雇 布莱登在之后一直协助维护 Firefox 的运营 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:5","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"IE 6 如日中天 你想象不到 IE 6 多么火 2001年，IE 6 随着 Windows XP 一起发布 2004年，IE 6 全球市场占用率 80% 以上 然而，这款浏览器却不兼容 W3C 标准（主要是 CSS) IE 6 也不断爆出安全漏洞 Firefox 打算涅槃重生，重新打败 IE 2005年，IE 7 发布，但打不过 IE 6 2006年，主流浏览器为 IE 6 和 Firefox 2010年，中国的大部分浏览器还是 IE 6 由于盗版 Windows XP 在中国的风行，在很多年里，IE 6 始终占据中国浏览器市场，是前端开发者的恶魔 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:6","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"IE 6 神奇的 bug 下面代码会让 IE 6 直接崩溃，当场死机 \u003cstyle\u003e * { position: relative } \u003c/style\u003e \u003ctable\u003e \u003cinput\u003e \u003c/table\u003e 补充： 「*{ } 星号性能低下」的谣言，就是从 IE6 这个 bug ，开始传出来的 实际上星号没有这个问题，这是 IE6 自己有问题 如果现在还有人说「星号性能低下」，不要反驳他，八九年前的事情现在还在说 星号套星号…可能有问题，但是一个星号，是绝对不会有问题的 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:7","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"Chrome 横空出世 微软的懈怠 由于 IE6 的巨大成功，微软觉得再花费精力不值得，而且没有竞争对手，所以直接解散了 IE6 开发团队 Firefox 的出现让微软重新组建 IE 团队，但不是同一队人，造成 IE7、8 一直问题不断 谷歌抓住机会 2004年，谷歌雇用了一些 Firefox 和 IE 的开发者 2008年，Chrome 终于发布，迅速拿下 1% 份额 2011年，Chrome 份额超过 Firefox 2016年，Chrome 全球份额 62% 欣赏一支 Chrome 的广告 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:8","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"移动市场兴起 智能手机崛起 2010年，iPhone 4 发布 2011年，微软 和 Nokia 联合起来，打算搞一波事情 后来的事情大家都知道，Nokia 手机业务完了 也就是说，手机上基本没有 IE 了 前端程序员表示欣喜若狂，IE 终于快要死了 2016年，淘宝天猫宣布不再支持 IE6、IE7 同年年底，宣布不再支持 IE 8 移动市场的兴起，让中国前端摆脱 IE 十年的恐怖支配 从此，前端快速，不对，是极速发展 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:9","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"ECMAScript 标准的制定 时间 1997年6月，第一版 ECMAScript 发布 1999年12月，第三版发布，这个版本使用最广（IE6支持） 第四版，流产。 2009年12月，第五版发布，增加了一些功能 2015年6月，第六版发布，新浏览器都支持这一版 之后每年发布一版，版本号以年份命名 JS 与 ECMAScript 的关系 ECMAScript 是纸上的标准，JS 是浏览器的实现 纸上标准往往落后于浏览器，先实现，再写进标准 ECMA 只总结，不预演，这样就不会再导致标准流产（写进标准但没浏览器使用的情况） ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:10","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 兴起 杀手级应用 Gmail 2004年愚人节，谷歌发布 Gmail 在线网页 当时的人们认为网页只能用来看新闻和图片 Gmail 的发布让用户和开发者（后端、客户端）眼前一亮 2005年，Jesse 将谷歌用到的技术命名为 AJAX 从此，前端技术正式出现 在此之前的网页开发，都是由 后端 和 设计师 完成 2006年，jQuery 发布，是目前最长寿的 JS 库 后来的十年，jQuery 大发异彩，直到 IE 不行了，jQuery 才稍微没有那么火 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:11","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"中国前端的发展 正式出现时间 2010年左右，中国才有专门的前端岗位 百度搜索指数 前端的来源 一部分来自自学的后端程序员，他们把 Java 的思想代入 JavaScript，面向对象成了JS的主流思想 一部分来自设计师，他们开始学习 CSS，并独创了「重构工程师」岗位（现已没落） 比如张鑫旭，专门研究CSS 上面这两种来源，一种赶鸭子上架，一种不够专业，导致前端特别缺人 缺人 最应该产出前端人才的大学，迟迟没有相关课程 由于早期前端工资比不上后端，所以大部分人选后者 就如同现在很多高材生选择机器学习一样 一些不小心进入前端领域的科班生成长非常迅速 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:12","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 爆发 V8 快如闪电 Chrome 的 JS 引擎叫做 V8（V1到V7是啥) 2009年，Ryan 基于 V8 创建了 Node.js 2010年，Isaac 基于 Node.js 写出了 npm 前端工程师可以在浏览器之外执行 JS 了，Node.js 快速风靡 例：node demo.js 同年，TJ 受 Sinatra 启发，发布了 Express.js 从此，前端工程师可以愉快地写后端应用了！ 爆发 这期间出来的技术太多，以后慢慢介绍：gulp、grunt、yeoman、requirejs、webpack、Angular、React、Vue等 这些技术很多也已经过时了 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:13","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"总结 JS 是历史的选择 一开始浏览器支持很多东西：Java、Flash、VBScript 只有 JS 活到最后 JS 的低开高走 一开始 JS 就是一个玩具语言 但是 JS 每次都走对了风口 JS 推出标准 Gmail 的出现（当时的网站只能看新闻，用户第一次体验到输入网址就能打开一个工具） 移动端 node.js 学习 JS 时需要注意 JS 最初也很混乱，旧的、过时的东西了解就好，考前记忆一些 跟 IE 相关的知识一律忽略 前端是进入互联网行业的捷径 ","date":"2020-08-12","objectID":"/javascript-history/:4:14","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["HTTP"],"content":"🤞🏻 Nobody knows HTTP better than me !! 🤗🤥","date":"2020-08-10","objectID":"/http-2/","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"🤞🏻 “Nobody knows HTTP better than me !! ” 🤥 ​ ","date":"2020-08-10","objectID":"/http-2/:0:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"先导 安装 Node.js 8+ 理解 IP 和 端口 理解 URL 路径和查询参数 ​ ","date":"2020-08-10","objectID":"/http-2/:1:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"演示 Node.js Server ⭐ ","date":"2020-08-10","objectID":"/http-2/:2:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"请求与响应模型 服务器，就是没有显示器的电脑 ​ ","date":"2020-08-10","objectID":"/http-2/:2:1","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"如何发请求 方法 用 Chrome 地址栏 用 curl 命令 概念 帮你发请求的工具叫做「用户代理」 如果使用 Chrome 地址栏发送请求，那么 Chrome 就是我们的「用户代理」 如果使用 curl 命令发送请求，那么 curl 就是我们的「用户代理」 「用户代理」 英文名 User Agent ​ ","date":"2020-08-10","objectID":"/http-2/:2:2","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"如何做出一个响应 ⭐ 用 Chrome 地址栏 或 用 curl 命令 ，可以发出一个请求 那么如何做出一个响应呢？（演示自己发请求-自己响应的过程） 需要用到编程 Node.js 有一个 http 模块可以做到 新建项目目录 node-demo / server.js，将下面代码粘入 ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ 代码细节先不管，直接复制使用。（注意这块目的不是学 nodejs，而是搞清楚 http 的请求和响应） var http = require('http') var fs = require('fs') var url = require('url') var port = process.argv[2] if (!port) { console.log('请指定端口号好不啦？\\nnode server.js 8888 这样不会吗？') process.exit(1) } var server = http.createServer(function (request, response) { var parsedUrl = url.parse(request.url, true) var pathWithQuery = request.url var queryString = '' if (pathWithQuery.indexOf('?') \u003e= 0) { queryString = pathWithQuery.substring(pathWithQuery.indexOf('?')) } var path = parsedUrl.pathname var query = parsedUrl.query var method = request.method /******** 从这里开始看，上面不要看 ************/ console.log('有个傻子发请求过来啦！路径（带查询参数）为：' + pathWithQuery) if (path === '/') { response.statusCode = 200 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(`二哈`) response.end() } else if (path === '/x') { response.statusCode = 200 response.setHeader('Content-Type', 'text/css;charset=utf-8') response.write(`body{color: red;}`) response.end() } else { response.statusCode = 404 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(`你输入的路径不存在对应的内容`) response.end() } /******** 代码结束，下面不要看 ************/ }) server.listen(port) console.log('监听 ' + port + ' 成功\\n请在空中转体720度然后用电饭煲打开 http://localhost:' + port) 注意事项 这些代码就是服务器代码，一般放在服务器上 path 是不带查询参数的路径 /x query 是查询参数的对象形式 {a:1} queryString 是查询参数的字符串形式 ?a=1 pathWithQuery 是带查询参数的路径，一般不用 request 是请求对象 response 是响应对象 \\n 表示回车 ​ 运行机制⭐ 在终端中启动应用： 运行 node server.js 未指定端口号，会有提示 按照提示执行即可 node server.js 8888 或者 node server 8888 这句话就意味着我们的电脑会开一个端口 8888，这个端口被 server.js 监听着 这时候只要有人请求了8888 端口，就会走入 server.js 的代码中，我们注释的那段代码就会运行一遍。每接收到一次请求，就运行一遍 用 curl 发出请求 curl http://127.0.0.1:8080/xxxx。server.js 接收到请求，会做出响应。 如果响应内容乱码，可能是 windows 系统的关系 添加路由 编辑 server.js 文件，添加 if else（限定条件，访问某个路径，响应对应内容） 重新运行 node server.js 8888（修改服务代码，需要重启） if (path === '/') { console.log('有人访问/了') response.end('这就是访问/，响应的内容\\n') // 回车\\n } 下面是，server.js 监听到 curl 命令 请求根路径时 执行的 console.log(…) 后台启动应用： touch log 创建一个 log 文件 node server.js 8888 \u003elog log 2\u003e\u00261 \u0026 返回的数字1144就是这个进程的 ID（目前这个进程已经在后台运行了） 运行后，服务器在后台启动，不占用当前终端 怎么关闭这个后台进程呢？ 执行 kill -9 xxxx xxxx为后台进程的 id数字 kill -9 是最厉害的杀进程的方法 ​ 代码逻辑 语法 `这种字符串` 里面可以回车 '这种字符串' 里面要回车，只能用 \\n 表示 逻辑 每次收到请求都会把中间的代码执行一遍 用 if else 判断路径，并返回响应 如果是已知路径，一律返回 200 如果是未知路径，一律返回 404 Content-Type 表示内容的「类型/语法」（省略后缀，程序员从来不看后缀😎，后缀只是用来告诉计算机要用什么软件打开文件） `text/html`、`text/css` path 不写 /x.css 而写 /x，因为 content-type 中已经声明了类型/语法，所以可省略后缀 .css response.write() 可以填写返回的内容（写入响应内容） 调用 response.end() 表示响应可以发给用户了（调用 response.end() ，就会将响应发送给浏览器） （ 以前不写 end 就会一直等待，现在可能优化了可以不写 end，严谨起见还是都写完整，明确告知可以响应给用户了 ） if (path === '/') { response.statusCode = 200 response.write(` \u003c!DOCTYPE html\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003clink rel=\"stylesheet\" href=\"/x\"\u003e // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 将 html 和 css 结合起来 \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e标题\u003c/h1\u003e \u003c/body\u003e `) response.end() } else if (path === '/x') { response.statusCode = 200 response.setHeader('Content-Type', 'text/css;charset=utf-8') response.write(`body{color: red;}`) response.end() } 如上图就是，通过 link 把 html 和 css 联系起来，成为一个网页，把这个网页通过 http 传送到浏览器上的整个过程：一个路径返回 html 字符串，一个路径响应 css 字符串。 这就是李爵士发明的 URL + HTTP + HTML ​ 注意符号 `` 反引号 `` 可以识别回车、语法 单引号 ‘’ 不能识别回车语法，仅作为字符串 ​ ​ ","date":"2020-08-10","objectID":"/http-2/:2:3","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"遥想当年李爵士 世界上第一个服务器程序 我们也写一个服务器程序 世界上第一个网页 我们在 / 路径返回一个 HTML 内容 然后在 /x 路径返回一个 CSS 内容 然后再 /y 路径返回一个 JS 内容 if (path === '/') { response.statusCode = 200 response.write(` \u003c!DOCTYPE html\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003clink rel=\"stylesheet\" href=\"/x\"\u003e ←←←←←←←←←←←←←← 引入 css \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e标题\u003c/h1\u003e \u003cscript src=\"/y\"\u003e\u003cscript\u003e ←←←←←←←←←←←←←←← 引入 js \u003c/body\u003e `) response.end() } else if (path === '/x') { response.statusCode = 200 response.setHeader('Content-Type', 'text/css;charset=utf-8') response.write(`body{color: red;}`) response.end() } else if(path === \"/y\"){ response.statusCode = 200; response.setHeader(\"Content-Type\", \"text/javascript;charset=utf-8\"); response.write(`console.log('这是JS内容')`; response.end(); } else { response.statusCode = 404; response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(`你输入的路径不存在对应的内容`) response.end() } 注意事项 关于后缀 即使写成 path === \"/y.css\" ，但如果在 Content-Type 中规定是 js 类型，就会按照 js 解析。所以，URL里的css 后缀卵用没有 Content-Type 才是决定文件类型的关键 ​ ","date":"2020-08-10","objectID":"/http-2/:2:4","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"体系化学习 HTTP 必须学会什么 基础概念（有哪些是必会的） 请求、响应 如何调试（用的是 Node.js，可以用 log / debugger ) 本质是学习 HTTP，所以不要在 Nodejs 花费太多时间，只需要搞懂 nodejs 怎么调试即可 在哪查资料（用的是 Node.js，所以看 Node.js 文档） 标准制定者是谁（ HTTP 规格文档：RFC2616（中文）等） 如何学 Copy-抄文档、抄老师 Run-放在自己的机器上运行成功 Modify-加入一点自己的想法，然后重新运行 ​ ","date":"2020-08-10","objectID":"/http-2/:3:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"HTTP 基础概念 必须点击 view source ，才能看到完整的请求、响应 ","date":"2020-08-10","objectID":"/http-2/:4:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"请求 请求动词 路径加查询参数 协议名/版本（所有请求都按照这个格式，简化版）例：GET /x?wd=hi HTTP/1.1 Host: 就是域名或 IP（包括端口号） Accept: text/html（表示浏览器想接收什么内容） 测：根据 accept 返回不同内容 var accept = request.headers['accept']; // 获取请求头中的 accept 的值，赋给变量 if(accept.indexOf('xml')){ response.write('我知道你想访问 XML 内容') }else{ response.write(`\u003c!DOCTYPE html\u003e\u003chtml\u003e...\u003c/html\u003e`) } 浏览器可接收的内容：accept。（大多来说浏览器就是接收 html） 默认先找 html，如果没有 html，可以接收 xhtml、xml、webp、png、igned-exchange（如下） Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0. Content-Type: 表示请求体的格式（例：text/javascript;charset=utf-8） 回车（划分请求头、请求体的界线） 请求体（也就是上传内容） 细节 请求有三部分，用回车隔开，分别是：（与 ↑↑ 对应颜色） 请求行（因为只有一行，所以叫请求行）GET /x?wd=hi HTTP/1.1 请求头 请求体（请求体的格式，是在 content-type 中指定的） 请求动词有 GET / POST / PUT / PATCH / DELETE 等 GET 用于获取内容 POST 用于上传内容 发送post请求：curl -v -X POST --data '上传内容' http://localhost:8888/ 请求体在 GET 请求中一般为空 因为get请求通常用于获取内容，而请求体表示要上传的内容，所以GET请求一般没有请求体 文档位于 RFC2616 第五章 大小写不敏感（随意），最好照着我的写 ​ ","date":"2020-08-10","objectID":"/http-2/:4:1","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"响应 协议名/版本 状态码 状态字符串 Content-Type: 响应体的格式 回车 响应体（也就是下载内容） 细节 响应有三部分，用回车隔开，分别是： 状态行（Status LIne） 响应头 响应体（响应体的格式，在Content-Type中指定） 常见的状态码是考点 200 成功 404 找不到 文档位于 RFC2616 第六章 ​ ","date":"2020-08-10","objectID":"/http-2/:4:2","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"用 curl 构造请求 ","date":"2020-08-10","objectID":"/http-2/:5:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"curl 用法 curl 可以用来改请求动词、查询参数，还可以改第二部分的请求头、第三部分的请求内容… 什么都可以改，请求的东西都可以由自己觉得 只不过需要按照 http 的标准来写 前提条件：server 要处于开启的状态：node server.js 8888 例：curl -v http://localhost:8888 设置请求动词 -X POST 例：curl -v -X POST http://localhost:8888 设置为post请求 注意大小写 设置路径和查询参数 直接在 url 后面加 例：curl -v -X POST http://localhost:8888/xxx?id=xxx 注：在 url 后添加 # 锚点是不会发送到服务器的 设置请求头 -H 'Name: Value' 或者 --header 'Name: Value' 例：curl -v -X POST -H 'Accept: text/html' http://localhost:8888 设置请求体 -d '内容' 或者 --data '内容' curl -v -X POST -H 'ABC: abc' -H 'Content-Type: text/plain;charset=utf-8' -d '请求体内容' http://localhost:8888 在请求体中设置一个 ABC: abc，没有实际意义但是成立的。 text/plain 表示上传的内容是纯文本，编码是 utf-8（中文），内容是’请求体内容’这5个字（每个字占2bytes） 总结：可以使用 curl 随心所欲的构造一个请求 ​ ","date":"2020-08-10","objectID":"/http-2/:5:1","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"用 Node.js 读取请求 读取请求动词 request.method console.log('method:', request.method) // method: GET ... 读取路径 request.url 路径，带查询参数 console.log('路径：', request.url) // 路径：/xxxx?wd=hihihi path 纯路径，不带查询参数 query 只有查询参数 读取请求头 **request.headers['Accept'] ** 读取请求头中的 Accept 值 console.log(\"请求头：\", request.headers) // 请求头：{ host:xxx, ???:???, ... } 读取请求体 比较复杂，先不讲 ​ ","date":"2020-08-10","objectID":"/http-2/:5:2","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"用 Node.js 设置响应 设置响应状态码 response.statusCode = 200 状态码可以任意设置，状态字符串会根据设置的状态码自动改变 但是状态码是有统一的使用规则的，如 200 规定就是表示请求成功时返回的状态码，所以不要随意改变 404 表示请求的网页不存在 。404 页面就是一个普通页面，是 Chrome 提供的，当访问页面不存在时提醒用户 设置响应头 response.setHeader(\"Content-Type\", \"text/html\"); 设置响应体 response.write(\"内容\"） 可追加内容 ​ ","date":"2020-08-10","objectID":"/http-2/:5:3","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"curl 的作用是什么 不单单是用来测试 http 的请求和响应。 curl 可以完成 Chrome 的大多基本功能，但 curl 通过命令行执行，所以不具有可视化能力 下载图片 curl 图片路径.jpg \u003e xxx.jpg （ 在命令行开启的目录中，下载图片并重命名为 xxx ） curl https://i.loli.net/2020/07/15/Q2dnHSgxCcbfhZW.jpg \u003e 3.jpg 测试 请求和响应 … curl 功能很强大，Chrome 的基本功能都可以实现，但不具有可视化 ​ ","date":"2020-08-10","objectID":"/http-2/:5:4","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"HTML / CSS / JS 的本质都是字符串 HTML / CSS / JS 的本质都是字符串，不是文件 本质上我们看到的网页，都是通过 html字符串 渲染的，html字符串 里面请求了 css字符串、js字符串 从演示的 server.js 中就能体现这一点 ​ ​ ","date":"2020-08-10","objectID":"/http-2/:6:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"console.log 调试大法 console.log（打印）这种调试方法，是在所有编程语言中都适用的 JS（console.log）、Java（print）、Python（print）、PHP（echo）… 语言/写法不一样，但原理相同 把可能有问题的代码，打印看看 debug 就是在不断质疑自己的过程 不要过分相信自己，而要相信 console.log() 可以告诉你对错 程序员每天都在问自己错在哪里 ","date":"2020-08-10","objectID":"/http-2/:7:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"URL 懂？！😵","date":"2020-08-04","objectID":"/http-1-url/","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"本文主要围绕 URL ，为学 HTTP 做个铺垫。 ​ ","date":"2020-08-04","objectID":"/http-1-url/:0:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"先导 ","date":"2020-08-04","objectID":"/http-1-url/:1:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"英语：protocol protocol /ˈproʊtəkɑːl/ 协议、礼节、约定 ","date":"2020-08-04","objectID":"/http-1-url/:1:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"李爵士发明的三样东西 WWW = URL + HTTP + HTML HTML 前面已经学了，html + css 本质就是网页 再认识了 URL 和 HTTP ，那么 WWW 我们就基本了解了（ URL 是为 HTTP 做铺垫） ​ ","date":"2020-08-04","objectID":"/http-1-url/:1:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"什么是 IP 要学习 URL 、HTTP，得先从 IP 讲起（⭐剧透：HTTP 的 P 和 IP 的 P 之间有重要联系） IP： Internet（因特网==互联网，整个人类组成的网络就叫互联网，比WWW更加底层）protocol（协议） 由此可见 IP 也是非常底层的，没有 IP 就不能上网 Internet Protocal 主要约定了两件事： 一、如何定位一台设备 二、如何封装数据报文，以跟其他设备交流 具体内容我们不关心 只要你在互联网中，你就有至少一个独特的IP ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"IP 分为内网和外网 内网和外网是不能直接相通的，只能通过路由器作为网关，来连通 路由器：是一个非常重要的设备，连通了内网和外网 例：比如你在玩 LOL，按了一下Q键（第一个技能），怎么让网线那头的对手被Q到？ Q 通过键盘传到路由器，路由器通过电信服务器传到 QQ 的游戏服务器， QQ 的游戏服务器接收到 Q 键后，就将 Q 键发送到对手那里，对手就被 Q 到了 整个过程是非常复杂的，但非常快，按下Q键立马响应，因为这个复杂的过程是以光速的形式来运行的，所以用户感受不到 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"如何获取外网 IP 必须有 外网IP 才能和小伙伴打 LOL、王者荣耀… 首先，你得从电信租用带宽，一年一千多。 （然后需要有个猫（调制解调器），猫是用来把信号转换成路由器能理解的信号。现在普遍是光猫，把光信号变成电信号，变成路由器能理解的网络信号） 你买了一个路由器，然后用电脑和手机分别连接路由器广播出来的无线 WIFl。 有线连接和无线WiFi在本质上没有不同，但在实际使用中，无线可能慢于有线连接 有线连接的下载速度可能超过 10M/s，但无线WIFI连接的设备的下载速度可能无法超过 10M/s 只要路由器连上电信的服务器，那么路由器就会有一个「外网 IP」 ，比如 [ 14.17.32.211 ] 就是一个外网 IP。这就是你在互联网中的地址。 访问 https://ip138.com/ 查看当前外网 IP（通常外网IP不要告诉别人，可以准确定位你的位置） 那么你的所有设备，就全都是这一个 外网 IP 那么如何区分是手机设备…还是笔记本呢？这就依靠「内网 IP」来区分了 但是如果你重启路由器，那么你很有「可能」被重新分配一个「外网 IP」，也就是说你的路由器没有「固定的外网 IP」 如果想固定外网IP ，需要花钱每个月五六千，可以得到一个固定的外网IP（在国内购买这些网络资源通常贵于国外） 但是有个问题，你的路由器的外网 IP 如果是 14.17.32.211，那么你的手机和电脑的 IP 又是什么呢？答案是「内网IP」 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"内网 IP 路由器会在你家里创建一个内网，内网中的设备使用内网IP，一般来说这个IP的格式都是192.168.xxx.xxx。 命令行：ipconfig ，查看当前设备的内网 IP ：192.168.101.10 默认网关中的 IP：192.168.101.1 是路由器的 IP 如果你家足够大，路由器可能功率不够，覆盖不了整个家，用户可能需要买电力猫或再买一个小路由器做中介器之类的手段，来扩大覆盖范围到整个家。 如果家里五六十平米，那路由器基本可以全覆盖。 一般路由会给自己分配一个好记的内网IP，如 192.168.1.1 小米路由器的 IP ，一般都是 192.168.31.1，为了让出一个位置给光猫的 IP 然后路由会给每一个内网中的设备分配一个不同的内网 IP，如电脑是 192.168.1.2，手机是 192.168.1.3，以此类推。 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"路由器的功能 把内网的请求，路由到外部，把外部的响应，路由到内部。具有双向路由的功能，所以也被称为网关 现在路由器有两个 IP，一个外网 IP（电信分配的）和一个内网 IP（自己分配给自己的） 内网中的设备可以互相访问，但是不能直接访问外网 内网设备想要访问外网，就必须经过路由器中转 外网中的设备可以互相访问，但是无法访问你的内网 外网设备想要把内容送到内网，也必须通过路由器 想从网上（外网）下载内容，会先把内容下载到路由器，路由器再把内容下载到用户的设备上 也就是说内网和外网就像两个隔绝的空间，无法互通，唯一的联通点就是路由器 所以路由器有时候也被叫做「网关] 一夫当关，万夫莫开。一旦把路由器拔了，那就与网络世界断联了 ​ 用 http-server 可以创建一个服务 命令行：http-server . -c-1 第一个地址 192.168.xxx.xxx:8080 ，是给手机访问的（需要手机端调试内容时，就可以使用） 第二个地址 127.0.0.1:8080 ，是给电脑访问的 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:4","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"几个特殊的 IP 分别是 127.0.0.1 表示自己（规定死的） localhost 通过 hosts 指定为自己 0.0.0.0 不表示任何设备 ​ 问：hosts 文件在哪？ 答： 在 Windows 系统中，hosts 位于 C:\\Windows\\System32\\drivers\\etc\\hosts 。在 macOS / Linux系统中，hosts 位于 /etc/hosts hosts 文件，用于指定本机 IP （表示自己） 127.0.0.1 / localhost 是 hosts 中默认的 （表示自己） 也可以在 hosts 文件中添加自定义 任何字符串 来表示自己（文件中的#内容均为注释，可删） 写法如下，定义后，就可以使用这些字符串来访问本地服务 + 127.0.0.1 sam + 127.0.0.1 ryuuks 注意：需要通过 http-server 开启本地服务后，下述地址才可以使用 http://localhost:8080/index.html http://127.0.0.1:8080/index.html http://sam:8080/index.html http://ryuuks:8080/index.html 上述地址，均可以访问到 index.html ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:5","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"端口 IP 有了，还需要什么？ 端口 WWW（万维网）= URL + HTTP + HTML URL 就是用来定位服务器的，例如，定位百度的服务器 baidu.com 一台机器可以提供很多服务 每个服务一个号码，这个号码就叫端口号port ","date":"2020-08-04","objectID":"/http-1-url/:3:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"端口 port 一个比喻 麦当劳提供两个窗口，一号快餐，二号咖啡 你去快餐窗口点咖啡会被拒绝，让你去另一个窗口 你去咖啡窗口点快餐结果一样 在计算机世界也是这样，你要提供不同的服务，就需要有不同的窗口。这个窗口，就是端口 port 一台机器可以提供不同服务 要提供 HTTP 服务最好使用 80 端口 要提供 HTTPS 服务最好使用 443 端口 要提供 FTP 服务最好使用 21 端口 一共有 65535 个端口（基本够用） ​ ","date":"2020-08-04","objectID":"/http-1-url/:3:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"我怎么知道应该用什么端口 维基百科一个一个列出来了，需要的时候就对应查找：每个端口用来做什么 端口 描述 80/TCP,UDP 超文本传输协议（HTTP）或 快速UDP网络连接- 用于传输网页 例如：百度服务器要给用户传输一个网页，那就必须用80端口，用其他端口会有问题 443/TCP 超文本传输安全协议（HTTPS）或QUIC HTTPS 协议传输就必须用 443 端口，用其他端口也会有问题 21/TCP,UDP 文件传输协议（FTP） - 控制端口 80后和早期的90后应该在学校见过FTP协议，传文件都是通过 FTP。95后00后可能没见过FTP了 ​ ","date":"2020-08-04","objectID":"/http-1-url/:3:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"端口使用还有什么规则 0 到 1023（2的10次方减1）号端口是留给系统使用的 普通用户绝对不能使用 即使是管理员有使用权限，但也需要输入额外的密码才能使用这些端口，所以也不推荐管理员使用 通常使用 8080 端口做开发，真正部署服务器时，拥有服务器权限才能用 80 端口… 你只有拥有了管理员权限后，才能使用这 1024 个端口 其他端口可以给普通用户使用 比如 http-server 默认使用 8080 端口 一个端口如果被占用，你就只能换一个端口 在其他端口开启服务 在 1234 端口开启服务 命令行：hs -c-1 -p 1234（hs：http-server 简写） http://192.168.101.10:1234 http://127.0.0.1:1234 通过访问 http://localhost:1234/index.html 就可以浏览本地页面 可否强行使用 80 端口，开启服务呢？🉑 仅在 windows 上能直接使用这个端口号，在 Linus 和 Mac 中都必须输入密码才能使用，不推荐 命令行：hs -c-1 -p 80 （在 80 端口开启服务） http://192.168.101.10:80 http://127.0.0.1:80 通过访问 http://localhost/index.html 就可以浏览本地页面（80 是默认端口，可省略） 端口被占用的情况，会有如下报错，换个其他的端口号即可（六万多个端口） hs -c-1 -p 80 =\u003e Error: listen EADDRINUSE 0.0.0.0:80 // EADDRINUSE: error address in use 错误地址正在使用中 hs -c-1 -p 1234 =\u003e Error: listen EADDRINUSE 0.0.0.0:1234 // error address in use hs -c-1 -p 2233 =\u003e http://192.168.101.10:2233 =\u003e http://127.0.0.1:2233 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:3:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"IP 和端口缺一不可 总而言之：IP 和 端口 缺一不可 （记住这句话） IP 是用来定位一个设备。 端口是用来定位一个设备的服务。 有了 IP 和端口，就可以定位一个设备提供的服务了。 例如：百度设备提供的网页服务。腾讯设备提供的聊天服务。淘宝设备提供的支付服务 这些服务都可以通过 IP + 端口 ，实现唯一确定 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:4:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"域名是什么 域名就是对 IP 起一个友好的名字。 域名是以 .com .net .org … 结尾的字符串，仅此而已。需要花钱购买 如：qq.com 在前面搭建个人博客时，已经注册过域名。 我没有自己的服务器，而是将这个域名映射到（指向） github 的服务器上 github 给我 4 个 IP。用户访问时，会访问到这4台中的任何一台服务器。访问的内容都是一样的 ​ 补充： .com 域名，比较便宜，一年50-80 t.tt，曾经是锤子手机的域名，转手价50W。访问 t.tt 跳转至锤子手机官网：smartisan.com 蔡文胜，2000年抢注十多万个域名，倒手生意。 qiyi.com 是百度旗下爱奇艺的域名 为什么我们需要向国外的人购买域名？发域名的机构也很赚钱。这就是美国人欧洲人赚钱的思维，我发明一套东西，用户都需要使用的，那使用一次就要交一次钱。 比如苹果有很多手机专利。谷歌买了摩托罗拉，摩托罗拉也有很多手机专利。谷歌发明了安卓系统，手机厂商用到安卓系统里面的谷歌服务，也需要给谷歌钱。 中国的 5G 出来了，如果以后世界的 5G 应用是由中国主导，关键技术是中国的，那么中国就可以躺着赚钱。如果中国的 5G 搞起来了，那就不单是 5G，周边的所有产业都会全面超过其他国家（所以川普联合各国抵制） 在互联网，每一个新东西出来，都蕴藏着巨大的商机。 如5G ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"域名就是对 IP 的别称 baidu.com 对应什么 IP 命令行：ping baidu.com 220.181.38.148 // 也有 39.156.69.79 qq.com 对应什么 IP 命令行：ping qq.com 125.39.52.26 知识点 先总结：IP 和 域名 之间，没有什么必然的一对一关系 一个域名可以对应不同 IP（这个叫 负载均衡） 这个叫做均衡负载，防止一台机器扛不住 一个 IP 可以对应不同域名（这个叫 共享主机） 比如6个人合买一台主机，这台主机服务6个域名 就叫做共享主机，穷开发者会这么做 或者一个公司提供不同的网站，但不想买两台服务器，就把两个网站（两个域名）放在同一台主机上 ​ 通常 ping 同一个域名，不一定会得到同一个 IP。这里涉及 负载均衡 的问题。 假如，一万人同时访问百度，如果只有一个服务器，就要同时接纳一万人。 如果有100万人同时访问，，即使每人只分配1k内存，也需要 100万 k，那么这台服务器肯定容纳不了 解决方法，把这个域名绑定到4个不同的 IP 上，4个 IP 分别位于 华中、华南、华东、华北。 电信有全国服务器，告诉电信，如果用户来自华中，就访问华中服务器…（1/4分流） 如此实现负载均衡。分散负担，不至于让某个服务器因承受不了而宕机。（网站优化策略） ​ 补充： ping 的作者写的一篇文章：The Story of the PING Program 皮卡丘站起来，是皮卡兵。皮卡丘跑起来是什么？答案 😂 ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"域名和 IP 是怎么对应起来的 通过 DNS Domain Name System （域名系统、域名服务） 当你输入 baidu.com 过程 你的 Chrome 浏览器会向电信/联通提供的 DNS 服务器询问 baidu.com 对应什么IP 电信/联通会回答一个 IP（具体过程很复杂，不研究） 这个过程可以用 nslookup 模拟（ns域名，lookup寻找）命令行：nslookup baidu.com 然后 Chrome 才会向对应 IP 的 80 / 443 端口发送请求 请求内容是查看 baidu.com 的首页 baidu 收到请求，就会把你请求的页面的 index.html 发送给你，index.html 中又会请求 css 、js，加载完css、js，就可以看到 baidu.com 的完整页面 ​ 在 network 中可以查看全部请求 Request URL: https://www.baidu.com/（末尾的 / 表示请求的是baidu的根目录） Response：[得到一个\u003chtml\u003e…\u003c/html\u003e]，浏览器就会把这一串 html 渲染出来（中间遇到 link 会请求对应的图片、css、js等文件） ​ 为什么是 80 或 443 端口？ 因为这是规定。 我们在地址栏输入 baidu.com 时，为什么不用写端口号？如 baidu.com:443 （ IP 和端口不是缺一不可吗！） 服务器默认用 80 提供 http 服务 服务器默认用 443 提供 https 服务 你可以在开发者工具里看到具体的端口 61.135.168.125:443 （ 前面就是服务器 IP ，后面就是网页服务的端口） 访问 http 就是 80，访问 https 就是 443 ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"题外话 前端需要懂点域名知识 www www.baidu.com 和 baidu.com 是同一个域名吗？不是 他们是什么关系 www.baidu.com 和 baidu.com com 是顶级域名（com 全写 company 公司，org 非营利性组织） baidu.com 是二级域名（俗称一级域名）父域名 www.baidu.com 是三级域名（俗称二级）子域名 他们是父子关系 github.io 把子域名 xxx.github.io 免费给你使用 所以 github.io（github公司）和 xxx.github.io（个人网站） 可能不是同一家公司，之间没什么关系 所以你应该知道 www.baidu.com 和 baidu.com 可以不是同一家公司，也可以是 www 是多余的吗？是的，非常多余。 早期人们为了表明自己是 www 而加的，实际上没有必要加，因为所有域名本身就存在与 万维网www中，写上www前缀反倒多此一举 ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"如何请求不同的页面 访问不同的路径，就请求到不同的页面，如下（注意：路径后面不加后缀） https://developer.mozilla.org/zh-CN/docs/Web/HTML https://developer.mozilla.org/zh-CN/docs/Web/CSS 工具 使用 Chrome 开发者工具 Network 面板看看区别 只有 Request URL 不同 ​ ","date":"2020-08-04","objectID":"/http-1-url/:6:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"同一个页面，不同内容 不同的查询参数，返回不同的内容 www.baidu.com/s?wd=hi www.baidu.com/s?wd=hello ​ ","date":"2020-08-04","objectID":"/http-1-url/:7:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"同一个内容，不同位置 锚点可以做到 https://developer.mozilla.org/zh-CN/docs/Web/CSS#参考书 https://developer.mozilla.org/zh-CN/docs/Web/CSS#教程 注意 锚点看起来有中文，实际不支持中文 #参考书 会变成 #%E5%8F%82%E8%80%83%E4%B9%A6 重新编码 锚点是无法在 Network 面板看到的，因为锚点不会传给服务器。 # 井号后面的内容会被浏览器直接吃掉，并不会传到服务器中 锚点仍在当前页面中，只是位置不同而已，并不需要重新请求数据 注意：一定不要把用户传参拼接到 # 后面，会被浏览器当做锚点内容直接吃掉，服务器就无法获取到参数 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:8:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"一个 URL 的完整内容 协议 + 域名 或 IP + 端口号 + 路径 + 查询字符串 + 锚点 协议：分 HTTP 和 HTTPS 域名：用来表示IP对应的名称的字符串 IP ：用来定位一个设备的字符串（分为4段，最大值255） 端口号：提供一个服务，就要有对用端口号（有六万多个） 路径：就是一个字符串，用来判断用户访问什么网页 查询参数：就是这个网页中，用户要具体看什么内容，可能有分页 锚点：内容已经获取到了，通过锚点定位到用户想要具体查看的内容的位置（实现文档内部的定位） 把上述全部加起来，就是 李爵士发明的 URL （统一资源定位符） URL U：Uniform 统一。国际化标准的 R：Resouce 资源。图片、网页…都是资源 L：Locator 定位符。 例： 就算没写，你也应该知道端口 HTTPS 默认端口 443、HTTP 默认端口 80 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:9:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"HTTP（协议） 前面讲了 IP 协议：是用于表示每个设备的地址 而 HTTP 协议：是用来表示如何传输网页的 HTTP协议，是基于 TCP 和 IP 两个协议 先有 TCP、IP，李爵士基于前人发明的这两个协议，发明了新的 HTTP 协议 ​ ","date":"2020-08-04","objectID":"/http-1-url/:10:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"curl 命令 curl /kɜːrl/ 使…卷曲 如何用 curl 命令，发出 HTTP 的请求？ ","date":"2020-08-04","objectID":"/http-1-url/:11:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"用 curl 可以发 HTTP 请求 示例1： curl https://www.baidu.com 执行命令，获取到整个文档。（中文默认 utf-8 编码，而控制台默认 GBK 所以中文会乱码） 我们在 Chrome 的地址栏中输入上述网址，Chrome 也是做了同样的事情，获取到这个html文档并解析 ​ 示例2： curl -v http://baidu.com 只有域名没有路径 -v ： verbose /vɜːrˈboʊs/ 啰嗦（效果：会显示更多内容） 请求的内容 我们发出的 HTTP 请求中，只有域名没有路径，则默认请求根路径，会自动补全根路径的斜杠 / 开启代理，使用了一些代理的功能（非必须） 问了DNS：获取到 baidu.com 的 IP 获取到 IP 后，就开始启动 TCP 开始连接到 baidu.com（ 220.181.38.148 这个 IP） 的 80 端口 连接成功，往 baidu.com 发送了这5行内容 GET请求，请求/根路径，使用 HTTP 协议 1.1 版本 因为一个IP（220.181.38.148）可能对应多个域名，说明需要访问的是这个IP上的 baidu.com 这个域名 说明我是用什么来访问的：用 curl 的 7.61.1 版本来访问的 期待返回什么内容：*/* 表示所有内容我都接收 空行（发送一个回车） 表示请求头部分结束 返回的内容 响应头：先忽略 😂 \u003chtml\u003e \u003cmeta …\u003e \u003c/html\u003e meta 中内容，意为请重新访问 http://www.baidu.com 说明 http://baidu.com 这个 URL 被弃用了，只使用这个最早就有的 URL www.baidu.com 通常直接使用 baidu.com 访问百度的人，基本都是程序员，将程序员的流量导到 www 上 上面请求失败，发起第二次请求 curl -v http://www.baidu.com ​ 示例3： curl -s -v -- https://www.baidu.com 会比上面显示的内容更详细 ​ ","date":"2020-08-04","objectID":"/http-1-url/:11:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"需要理解以下流程 url 会被 curl 工具重写，先请求 DNS 获得 IP 先进行 TCP 连接，TCP 连接成功后，开始发送 HTTP 请求 请求内容看一眼 响应内容看一眼 响应结束后，关闭TCP连接（curl 中没有直接写出来） 真正结束（只有TCP结束才是真正的结束） ​ ","date":"2020-08-04","objectID":"/http-1-url/:11:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"HTTP HTTP 到底做了什么 规定请求的格式是什么，响应的格式是什么 HTTP 规定了请求怎么写： 如何写第6步中的5行请求 HTTP 规定了响应怎么写： 如何写下面响应的内容 ​ 那么 HTTP 到底是怎么规定请求格式和响应格式的？ 下回分解 ✋ ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:11:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"习题 关于 www.baidu.com 和 baidu.com，正确的有（多选）答案 是同一个域名 是不同的域名 它们还有相同的一级域名 baidu.com 关于 hosts 文件，正确的有（多选） 答案 hosts 文件中以 # 开头的表示注释 hosts 中可以添加一行 127.0.0.1 sam，让 sam 成为 127.0.0.1 的别称 hosts 中可以添加一行 sam 127.0.0.1，让 sam 成为 127.0.0.1 的别称 hosts 一般需要用管理员权限才能编辑 HTTP 的英文全称是 ____（注意大小写不要错了） HyperText Transfer Protocol DNS 的英文全称是 ____（注意大小写不要错了） Domain Name System URL 包含哪些部分？（多选）答案 协议 域名或IP 端口 路径 查询参数 锚点 get 或 post ","date":"2020-08-04","objectID":"/http-1-url/:12:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-08-02","objectID":"/css-animation/","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"浏览器的渲染流程、transform、transition、animation ​ ","date":"2020-08-02","objectID":"/css-animation/:0:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"动画的原理 人脑的 bug ","date":"2020-08-02","objectID":"/css-animation/:1:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"动画 定义 由许多静止的画面（帧）， 以一定的速度（如每秒30张）连续播放时， 肉眼因视觉残象产生错觉， 而误以为是活动的画面。 概念 帧：每个静止的画面都叫做帧 播放速度：每秒24帧（影视）或者每秒30帧（游戏） ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:1:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"一个最简单的例子 ","date":"2020-08-02","objectID":"/css-animation/:2:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"将div从左往右移动 http://js.jirengu.com/bagow/1/edit?html,css,js,output JSBin 示例1 通过循环定时器 + 定位 + left 实现动画。控制每隔一小段时间增加 left 值，实现位移 JSBin 示例2 通过延时器 + 添加类名 + transition / transform 实现动画。控制添加类名 原理 每过一段时间（用setlnterval做到）， 将div移动一小段距离， 直到移动到目标地点。 注意性能 需要先搞懂：浏览器的渲染步骤，以及 每个属性会触发什么流程 绿色表示重新绘制（repaint）了 CSS渲染过程依次包含布局、绘制、合成 其中布局和绘制有可能被省略 ​ ","date":"2020-08-02","objectID":"/css-animation/:2:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"前端高手不用 left 做动画 用 transform（变形） JSBin 演示 原理 transform: translateX(0=\u003e300px) 直接修改会被合成，需要等一会修改 transition 过渡属性可以自动脑补中间帧 注意性能 需要先搞懂：浏览器的渲染步骤，以及 每个属性会触发什么流程 transform 优势在于，并没有 relayout（重新布局） 和 repaint（重新绘制）过程 transform 比 left 性能好很多（ 因为 left 会依次经过 relayout、 repaint、composite 3个过程） ​ ","date":"2020-08-02","objectID":"/css-animation/:2:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"如何查看性能 上述 JSBin 示例1/2两种方式，在性能上有什么区别 ？ 查看性能的方式 开启浏览器的【渲染 Rendering 】\u003e 【画图闪烁 Paint flashing】：突出显示需要重新绘制的页面区域（绿色） 如果元素发生的重新渲染（绿）的次数多，则更耗性能 示例1：使用 setInterval ，控制 left 实现动画 （位移全程 demo元素 都呈绿色：说明全程都在进行demo元素的重新渲染绘制） 示例2：添加类名，通过 transition + transform 实现动画 （刷新后，初次渲染呈绿色，移动过程没有发生重新渲染，移动结束的位置重新渲染一次） 总结：显然 ，示例1 更耗性能，全程都需要重新渲染 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:2:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"浏览器的渲染原理 既然讲到这里，提到了性能、渲染，那就深入了解一下 了解浏览器的渲染流程后，再回头看前面2个示例，可能会更好理解它们的不同 ","date":"2020-08-02","objectID":"/css-animation/:3:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"参考文章 Google 团队写的文章（右上角中文） 渲染树构建、布局及绘制 渲染性能 使用 transform 来实现动画 查看CSS各属性触发什么 CSSTriggers.com ​ ","date":"2020-08-02","objectID":"/css-animation/:3:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"浏览器渲染过程 浏览器在获取到 html 和 css 后做了什么？ 步骤 根据 HTML 构建 HTML 树（DOM） 根据 CSS 构建 CSS 树（CSSOM） 将两棵树合并成一颗渲染树（render tree） 根据渲染树，进行 Layout 布局（文档流、盒模型、计算大小和位置） 先定位：某个标签是否在文档流中…（文档流的概念非常重要！！） 定位后，要知道这个标签多高多宽、样式如何… Paint 绘制（填色：把边框颜色、文字颜色、阴影等画出来） Composite 合成（根据层叠关系展示画面） 三棵树 render tree 就是最终用户看到的树 ​ ","date":"2020-08-02","objectID":"/css-animation/:3:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"如何更新样式 ","date":"2020-08-02","objectID":"/css-animation/:4:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"一般我们用 JS 来更新样式 比如 div.style.background='red' 让内联背景变红色 比如 div.style.display='none' 让div消失 比如 div.classList.add('red') （小白才直接加样式，高手从来只加类名） 比如 div.remove()直接删掉节点 ","date":"2020-08-02","objectID":"/css-animation/:4:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"那么这些方法有什么不同吗 有三种不同的渲染方式 详细看下面 ↓↓ ","date":"2020-08-02","objectID":"/css-animation/:4:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"三种更新方式 使用 JS 来更新样式，要经过哪些步骤 ？ 下面有3种代码示例，配合开启浏览器渲染功能，清晰看到执行重新绘制（Paint）的元素 注意 JSBin 中最好全屏查看效果，在 iframe 里看可能有问题 第一种，流程全走一遍 div.remove() 会触发当前消失，其他元素 relayout 重新布局 第二种，跳过 layout 说明没有改变元素的位置和大小，不需要变动布局 比如说：只改变背景颜色，直接 repaint + composite 第三种，跳过 layout 和 paint 没有改变位置、大小，也没有改颜色，只需要合成 例如：只改变 transform，则只需 composite 合成 注意必须全屏查看效果，在 iframe 里看有问题 ​ ","date":"2020-08-02","objectID":"/css-animation/:4:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"每个属性触发什么流程 CSS变态之处来了：挨个尝试吧 还好，程序员喜欢分享 https://csstriggers.com/ 这个网站已经把所有属性全试过了 Blink：谷歌 Chrome 浏览器的内核（一般只看 Chrome 性能渲染） Gecko：火狐浏览器 Firefox WebKit：苹果 Safari 浏览器 EdgeHTML：微软 Edge 浏览器 现在可以解释 为什么 前端高手不用 left 做动画，而用 transform 做动画了 因为执行 left 会触发3个流程：先布局、再绘制、最后合成 而执行 transform 只会触发 1个流程：只合成 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:4:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"CSS动画优化 可以自己总结一篇博客。面试背不出来，可以让面试官去看博客 CSS 性能优化，除了把 left 变成 transform ，还有什么？ 面试可能考察，但这个问题没什么技术含量，就是背 ","date":"2020-08-02","objectID":"/css-animation/:5:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"没什么技术含量 答案都在 Google写的文章 里，谁看完谁牛 X 优化 JS 的执行 （JavaScript） 缩小样式计算的范围并降低其复杂性 （优化 Style 过程） 避免大型、复杂的布局和布局抖动（优化 Layout 布局过程） 简化绘制的复杂度、减小绘制区域（优化 Paint 绘制过程） 坚持仅合成器的属性和管理层计数（优化 Composite 合成过程） 上述每篇文章中的优化方法，都总结在【TL;DR（too long don’t read 太长不看）】部分 每条优化点之间，都没什么规律，就依靠死记硬背（面试问到，可能这些点，如果能答出1个，就得满分） ","date":"2020-08-02","objectID":"/css-animation/:5:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"JS优化 使用 requestAnimationFrame 代替 setTimeout 或 setInterval ","date":"2020-08-02","objectID":"/css-animation/:5:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"CSS优化 使用 will-change 或 translate（transform） ","date":"2020-08-02","objectID":"/css-animation/:5:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"没错 没错，完全就是死记硬背！ 如果面试官问，“ CSS 怎么优化 ”？（通常就是问动画怎么优化，性能上更低耗） 动画尽量使用 will-change 或 translate（transform），不直接使用 left JS 控制的动画中，尽量不使用 setTimeout 和 setInterval，而使用 requestAnimationFrame ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:5:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform 全解 MDN 上讲的非常详细 ","date":"2020-08-02","objectID":"/css-animation/:6:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform 四个常用功能 位移 translate（常用） 缩放 scale（常用） 旋转 rotate（做加载动画可能用到） 倾斜 skew（不常用） 经验 一般都需要配合 transition 过渡 inline 元素不支持 transform，需要先变成 block ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之translate 常用写法 可以写长度length和百分号percentage， ?表示可省略值 translateX(\u003clength-percentage\u003e) （横向） translateY（\u003clength-percentage\u003e) （纵向） translate(\u003clength-percentage\u003e,\u003clength-percentage\u003e?) 可省略第二个值，只写第一个值，默认x轴 translateZ(\u003clength\u003e) （垂直于屏幕的方向） 在三维世界中，才能看出 Z 的变化。 需要配合 perspective 属性，告知浏览器视点的位置 来形成三维。 例：perspective: 1000px 指视点在（位于画面中心）距离屏幕 1000 像素的位置上。 注意：是给父容器设置 perspective \u003cdiv class=\"wrapper\"\u003e \u003cdiv id=\"demo\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e #demo{ width: 100px; height: 200px; border: 1px solid red; margin: 50px; } #demo:hover{ transform: translateZ(50px); /* 元素在z轴（默认垂直屏幕方向）上的位置 */ } .wrapper{ perspective: 1000px; /* 形成三维构图，标注视点位置 */ border: 1px solid black; } \u003c/style\u003e translate3d(x,y,z) translate3d(50px,50px,200px); 同时设定3个轴上的位置 JSBin 演示 经验 要学会看懂 MDN 的语法格式 translate(-50%，-50%) 可做绝对定位元素的居中 #demo{ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) } ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之scale 常用写法 scaleX(\u003cnumber\u003e) scaleY(\u003cnumber\u003e) scale(\u003cnumber\u003e,\u003cnumber\u003e?) JSBin 演示 经验 用得较少，因为缩放容易出现模糊 border 也会跟随缩放 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之rotate 常用写法 rotate 默认以 Z轴为中心轴，进行转动 rotate（[\u003cangle\u003e|\u003czero\u003e]) 以Z轴为中心旋转 rotateZ([\u003cangle\u003e|\u003czero\u003e]) 以Z轴为中心旋转 rotateX([\u003cangle\u003e|\u003czero\u003e]) 以X轴为中心旋转 rotateY（[\u003cangle\u003e|\u003czero\u003e]) 以Y轴为中心旋转 rotate3d 太复杂，无法用语言表述 JSBin 演示 经验 一般用于360度旋转制作 loading 用到时再搜索 rotate MDN 看文档 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之skew 常用写法 skewX([\u003cangle\u003e|\u003czero\u003e]) skewY（[\u003cangle\u003e|\u003czero\u003e]) skew([\u003cangle\u003eI\u003czero\u003e],[\u003cangle\u003e|\u003czero\u003e]?) JSBin 演示 经验 用得较少 用到时再搜 skew MDN 文档 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:5","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform 多重效果 组合使用 transform: scale(0.5) translate(-100%, -100%); transform: none; 取消所有 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:6","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"实践：用 transform 做红心 ","date":"2020-08-02","objectID":"/css-animation/:7:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"跳动的心 JSBin ","date":"2020-08-02","objectID":"/css-animation/:7:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"心得 CSS需要你有想象力，而不是逻辑 CSS给出的属性都很简单，但是可以组合得很复杂 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003ebeating heart\u003c/title\u003e \u003cstyle\u003e *{ margin: 0; padding: 0; box-sizing: border-box; } #heart{ margin: 100px; position: relative; /*border: 1px solid black;*/ display: inline-block; transition: all .5s ease; } #heart:hover{ transform: scale(1.5); } #heart\u003e.bottom{ width: 50px; height: 50px; background-color: red; /*border: 1px solid red;*/ transform: rotate(45deg); } #heart\u003e.left{ width: 50px; height: 50px; background-color: red; /*border: 1px solid red;*/ border-radius: 50% 0 0 50%; transform: rotate(45deg) translateX(31px); position: absolute; bottom:100%; right: 100%; } #heart \u003e .right { width: 50px; height: 50px; background-color: red; /*border: 1px solid red;*/ border-radius: 50% 50% 0 0; transform: rotate(45deg) translate(0,30px); position: absolute; bottom: 100%; left: 100%; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"heart\"\u003e \u003cdiv class=\"left\"\u003e\u003c/div\u003e \u003cdiv class=\"right\"\u003e\u003c/div\u003e \u003cdiv class=\"bottom\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:7:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transition 过渡 学习资料：MDN ","date":"2020-08-02","objectID":"/css-animation/:8:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"作用 补充中间帧 已知开头位置，结尾位置，中间运动轨迹自动补齐 ","date":"2020-08-02","objectID":"/css-animation/:8:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"语法 transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性。 JSBin 示例 transition: 属性名 时长 过渡方式 延迟 transition: left 200ms linear 属性名是指要给哪个属性添加过渡效果 可以用 all 代表所有属性：width | height | left | right | margin-right …… transition: all 200ms 可以用逗号分隔两个不同属性 transition: left 200ms, top 400ms 时长 ：支持 秒 s 和 毫秒 ms 单位。0.5s 可以写成 .5s 过渡方式有：linear（线性匀速） | ease（默认值：缓动） | ease-in | ease-out | ease- in-out | cubic-bezier | step-start | step-end | steps 具体含义要靠数学知识 https://cubic-bezier.com/ 测试运动曲线 ","date":"2020-08-02","objectID":"/css-animation/:8:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"注意 不学常态，学变态 并不是所有属性都能过渡 一个元素，切换可见状态 使用 display: none \u003c=\u003e display: block 没法过渡，会闪现、闪隐【元素消失，不占位置】 使用 opacity: 0 \u003c=\u003e opacity: 1 透明度控制可见状态【可实现过渡效果，缺点是元素消失仍占位置】 推荐使用 visibility: hidden \u003c=\u003e visibility: visible （不要问为什么）【缺点没法过渡、元素消失仍占位置】 button.onclick = () =\u003e { demo.classList.add('end'); /* 解决隐藏后仍占位问题：延迟1s后，将元素删除 */ /* 方法一：使用延时器 */ setTimeout(() =\u003e { demo.remove(); } ,1000) /* 方法二: on事件可能有bug，推荐使用事件监听器 */ demo.ontransitionend = () =\u003e { demo.remove(); } /* on事件 */ demo.addEventLisener('transitionend', () =\u003e { demo.remove(); }) /* 事件监听器 */ } display 和 visibility 的区别 https://www.cnblogs.com/zrenj/p/9785835.html background 颜色可以过渡吗？可以 。 查看示例 opacity 透明度可以过渡吗？ 可以 。 查看示例 不推荐用透明度控制显示隐藏，推荐 visibility opacity: 0 \u003c=\u003e opacity: 1 可实现过渡效果，缺点是元素消失仍占位置，可通过 js 控制 remove() 该元素 ​ ","date":"2020-08-02","objectID":"/css-animation/:8:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"过渡必须要有起始 起始：指一个属性的开始是一个值，该属性的结尾也有一个值。这样才能实现某属性的属性值的变化过渡，中间过渡的效果浏览器会自动补充 一般只有一次动画，或者两次 一次：指只有进入动画 两次：①进入动画、②离开动画 比如 hover 和 非 hover 状态的过渡，就是两次动画 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:8:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"如果除了起始，还有中间点，怎么办 例如：从红色，先变黄色，最后再变绿色，怎么实现 有如下两种办法 ","date":"2020-08-02","objectID":"/css-animation/:9:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"方法① 使用两次 transform 流程： .a === transform ===\u003e .b 然后 .b === transform ===\u003e .c 如何知道到了中间点呢？ 用 setTimeout 或者监听 transitionend 事件。 给元素添加新的类名：执行第二段 transform 效果。 注意：第二段 transform 中必须包含第一段动画效果，不然执行第二段动画可能还原初始位置，有 bug，可自行测试。 JSBin 示例 ","date":"2020-08-02","objectID":"/css-animation/:9:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"方法② 使用 animation 声明关键帧 添加动画 JSBin 示例 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:9:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"animation 动画 ","date":"2020-08-02","objectID":"/css-animation/:10:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"提问 如何让动画停在最后一帧？ 搜索 css animation stop at end 网友给出的答案是：加个 forwards animation: xxx 1.5s forwards; JSBin 演示 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:10:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"@keyframes 完整语法 标准写法 搜索 keyframes MDN 讲得很清楚 一种写法是 from to ：只支持两种状态 另一种写法是百分数：支持添加 n 个帧状态 ​ ","date":"2020-08-02","objectID":"/css-animation/:10:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"animation 缩写语法 animation MDN animation 属性是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式。 Jirengu 视频讲解 JSBin 演示 animation: 时长 | 过渡方式 | 延迟 | 次数 | 方向 | 填充模式 | 是否暂停 | 动画名 ; /* 位置任意 */ 时长：1s 或者 1000ms 过渡方式：跟 transition 取值一样，如 linear 。默认是 ease 先快后慢 延迟时间：1s 或 1000ms 次数：3 或者 2.4 或者 infinite（无限次） 方向：reverse | alternate（交替，非常适合做加载动画） | alternate-reverse 填充模式：none | forwards（保持在动画终点位置） | backwards | both 是否暂停：paused | running pauseBtn.onclick = () =\u003e { demo.style.animationPlayState = 'paused' } /* 点击按钮，暂停demo元素的动画 */ 更多属性值的效果，需要自己尝试。JSBin 演示 以上所有属性都有对应的单独属性 **animation** 只是这些单独属性的**缩写**，上述效果可以通过单独的属性设置\r ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:10:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"实践：用 animation 做红心 JSBin 示例 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003ebeating heart-animation\u003c/title\u003e \u003cstyle\u003e * { margin: 0; padding: 0; box-sizing: border-box; } @keyframes beating { 0% {transform: scale(1)} /*25% {transform: scale(1.25)}*/ /*50% {transform: scale(1.5)}*/ /*75% {transform: scale(1.25)}*/ 100% {transform: scale(1.5)} } #heart { /*border: 1px solid black;*/ display: inline-block; position: relative; margin: 100px; } #heart:hover { animation: beating .5s ease infinite alternate; } #heart \u003e .left { position: absolute; bottom: 50px; left: -50px; width: 50px; height: 50px; /*border: 1px solid red;*/ background: red; border-radius: 50%; transform: rotate(45deg) translateX(43px); } #heart \u003e .right { position: absolute; bottom: 50px; right: -50px; width: 50px; height: 50px; /*border: 1px solid red;*/ background: red; border-radius: 50%; transform: rotate(45deg) translateY(45px); } #heart \u003e .bottom { width: 50px; height: 50px; /*border: 1px solid red;*/ background: red; transform: rotate(45deg); } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"heart\"\u003e \u003cdiv class=\"left\"\u003e\u003c/div\u003e \u003cdiv class=\"right\"\u003e\u003c/div\u003e \u003cdiv class=\"bottom\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-08-02","objectID":"/css-animation/:11:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-29","objectID":"/css-position/","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"复习盒模型、div 的分层、新属性 position 详解、层叠上下文 ​ ","date":"2020-07-29","objectID":"/css-position/:0:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"布局和定位的区别 区别大了 布局是屏幕平面上的 定位是垂直于屏幕的 ​ ","date":"2020-07-29","objectID":"/css-position/:1:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"CSS 定位 还得从文档流和盒模型说起（两个非常重要的概念） ​ ","date":"2020-07-29","objectID":"/css-position/:2:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"复习盒模型 margin 外边距、border 边框、padding 内边距、content 内容 background 背景 ","date":"2020-07-29","objectID":"/css-position/:3:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"问两个问题 背景的范围是从哪到哪？ 【A】border 内边沿围成的区域 ？【B】border 外边沿围成的区域 ？ 如何验证自己的猜想？ border 半透明试试，答案是【B】 注意：在浏览器的元素样式中，可通过 【alt + 上下方向键】，对半透明数值进行 0.1 的 ± 调整 从左边看一个 div，是什么样子？ 元素是有层叠关系的，脑内模拟一个三维立体结构，从左边看一个 div，是什么样子？ background 在文字后面然后呢？ 如何验证自己的猜想？用代码证明即可。 \u003cdiv class=\"demo\"\u003e \u003cspan class=text\u003e你好\u003c/span\u003e \u003c/div\u003e \u003cstyle\u003e .demo{ box-sizing: border-box; border: 5px solid red; width: 100px; height: 100px; background: blue; } .text{ font-size: 100px; /* 让字足够大，测试字能否覆盖住border */ color: green; } \u003c/style\u003e 结论： 文字在最上层，中间是 border，最底层是 background 背景 ​ ​ ","date":"2020-07-29","objectID":"/css-position/:3:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"代码验证：一个 div 的分层 三维立体模型 （SketchUp） 先给出结论（三维图），再在下面进行代码验证 ​ ","date":"2020-07-29","objectID":"/css-position/:4:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"块级子元素与内联子元素的分层位置 让块级元素与内联元素，出现重叠，就可以判断哪个层级更高 \u003cstyle\u003e .demo{ background: rgb(120,184,211); width: 200px; height: 200px; border: 15px solid red; padding: 10px; } .childDiv{ background: white; height: 50px; margin-top: -10px; /* 测试块级元素与文字的分层位置，将div向上移动，与文字重叠，看是否会遮挡文字 */ } \u003c/style\u003e \u003cdiv class=\"demo\"\u003e 文字内容 \u003cdiv class=\"childDiv\"\u003e\u003c/div\u003e \u003c/div\u003e 如上，“文字内容” 和 div.childDiv 属于同级关系 结论： 块级元素位于文字下层 ​ ","date":"2020-07-29","objectID":"/css-position/:4:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"浮动子元素与内联子元素的分层位置 \u003cstyle\u003e .demo{ ... } .float{ float: left; background: white; height: 50px; width: 50px; margin-right: -10px; /* 测试浮动元素与文字的分层位置，将浮动元素向右移动，与文字重叠，看是否会遮挡文字 */ } \u003c/style\u003e \u003cdiv class=\"demo\"\u003e 文字内容 \u003cdiv class=\"float\"\u003e\u003c/div\u003e \u003c/div\u003e 结论： 浮动元素位于文字下层 ​ ","date":"2020-07-29","objectID":"/css-position/:4:2","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"浮动子元素与块级子元素的分层位置 \u003cstyle\u003e .demo{...} .float{...} .childDiv{ height: 50px; background: orange; margin-top: -10px; } \u003c/style\u003e \u003cdiv class=\"demo\"\u003e 文字内容 \u003cdiv class=\"float\"\u003e\u003c/div\u003e \u003cdiv class=\"childDiv\"\u003e\u003c/div\u003e \u003c/div\u003e 结论： 浮动内容（脱离文档流），高于 childDiv（普通文档流元素），低于文字 所以，==脱离文档流==，实际上就是从普通文档流中跳出，比文档流的层级稍微高一点 ​ ","date":"2020-07-29","objectID":"/css-position/:4:3","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"结论 文字内容层级最高，代码写在下面的文字内容，会覆盖上面的 只有浮动元素会脱离文档流（从普通文档流中跳出），比普通文档流的层级稍高 ​ ​ ","date":"2020-07-29","objectID":"/css-position/:4:4","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"新属性 position ","date":"2020-07-29","objectID":"/css-position/:5:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position 取值 static 默认值，当前元素待在文档流里 relative 相对定位，升起来，但不脱离文档流 absolute 绝对定位，定位基准是相对于祖先里的非 static 祖先进行定位 fixed 固定定位，定位基准是 viewport 视口 有诈：后来 css 出的 transform 属性，使 fixed 无法相对 viewport 视口定位，这就是 CSS 的不正交 sticky 粘滞定位，不好描述直接举例 ↓↓ 特别适合做导航：正常状态会存在于文档流中，当向下滚动到 sticky 元素且 sticky 元素即将移出视口时，sticky 元素会始终保持在视口顶部，不会随文档流继续滚动。 兼容性特别差，可以在 caniuse 中查询。 （黄色是需要加前缀or部分支持） ","date":"2020-07-29","objectID":"/css-position/:5:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"经验 如果你写了 absolute，一般都得补一个 relative 如果你写了 absolute 或 fixed，一定要补 top 和 left sticky 兼容性很差，主要用于面试装逼 ​ ","date":"2020-07-29","objectID":"/css-position/:5:2","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position: relative 使用场景 用于做位移（很少用），将两个元素对齐 用于给 absolute 元素做爸爸 配合 z-index z-index: auto 默认值，不创建新层叠上下文 z-index: 0/1/2 z-index: -1/-2 经验 写 z-index: 9999 的都是 菜B 要学会管理 z-index ​ ​ ","date":"2020-07-29","objectID":"/css-position/:5:3","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position: absolute 使用场景 脱离原来的位置，另起一层，比如对话框的关闭按钮，通常是通过绝对定位实现的 鼠标提示 \u003cdiv style=\"height:100px;\"\u003e\u003c/div\u003e \u003cbutton\u003e 点击 \u003cspan class=\"tips\"\u003e提示内容\u003c/span\u003e \u003c/button\u003e \u003cstyle\u003e button{ position: relative; } button span{ position: absolute; border: 1px solid red; white-space: nowrap; bottom: calc(100% + 10px); left: 50%; transform: translateX(-50%); } button span{ display: none; } button:hover span{ display: inline-block; } /* 鼠标悬浮时，显示span */ \u003c/style\u003e 配合 z-index 经验 很多 菜B 都以为 absolute 是相对于 relative 定位的 absolute 是相对于 祖先元素中最近的一个定位元素 只要 position 属性值不是 static 的元素，就是定位元素 某些浏览器上，如果写了 absolute，不写 top / left / bottom / right 会位置错乱 （4个至少写2个） .demo{ position: absolute; top: 0; left: 0; } 善用 left: 100% （效果通常是该元素会出现在定位元素的最右边） 善用 left: 50%; + 加负 margin （负宽度的一半）：实现居中 也可以用 left: 50%; + transform: translateX(-50%); 实现，优点是不需要自己计算宽度的一半 ​ ​ ","date":"2020-07-29","objectID":"/css-position/:5:4","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position: fixed fixed 是相对于【视口】定位的 视口，就是浏览器中普通用户能看到的部分（不包括滚动条） 使用场景 烦人的广告 回到顶部按钮 配合 z-index 经验 如果 fixed 元素所在的容器，具有某些属性，可能会导致 fixed 元素不再相对于视口定位。 .container{ position: relative; } .container \u003e .fixed{ position: fixed; left: 10px; bottom: 10px; } .container{ transform: scale(0.9); } /* 此时fixed元素就不再相对于视口定位 */ 总结：不要把 fixed 元素放到 具有 transform 属性的容器中，可能会产生奇怪的bug（不正交：调这个元素却影响了另一个元素） 手机上尽量不要用这个属性，坑很多，无穷无尽的bug。不信你搜索一下「 移动端 fixed 」 用了，可能就开始996了。一个bug可能引出10个bug ​ ​ ","date":"2020-07-29","objectID":"/css-position/:5:5","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"层叠上下文 ","date":"2020-07-29","objectID":"/css-position/:6:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"div分层 与 position 任意一个元素的 position 取值非 static 时，就成为了定位元素。定位元素的层级，立马超越内联文字，成为最上层元素（跑到所有元素最上层） z-index，默认是 auto 所有定位元素，会以内联文字层为底层，随着 z-index 递增，层级也会递增 如果 z-index 为负值，则层级比 background 还低 （可以无限向下，但是不能低于层叠上下文，也就是不能低于 html ，低于html还有什么意义） ","date":"2020-07-29","objectID":"/css-position/:6:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"什么是层叠上下文 也叫堆叠上下文 层叠上下文，会把所有元素包起来。 默认的层叠上下文，是 html 元素，html 就是会把所有元素包起来 其他元素，也会因为拥有某些属性而变成层叠上下文（导致 z-index 需要重新计算） ​ 比喻 层叠上下文对 z-index 的影响 每个层叠上下文就是一个新的小世界（作用域） 这个小世界里面的 z-index 跟外界无关 处在同一个小世界的 z-index 才能比较 JSBin 示例 a 和 b2 处于同一个层叠小世界，由 container 创造的，如果 container 没有设定 z-index，那么 a 和 b2 就同处于 html 的作用域里面，是具有可比性的。 ​ 哪些不正交的属性可以创建层叠上下文 最简单的就是定位元素设置 z-index = 0 ，就会创建一个层叠上下文 MDN文档有写 文档根元素 html 自成一个层叠上下文 z-index 不为 auto 的定位元素，会开启一个小世界（作用域） 元素的 opacity 小于1，就会创建一个层叠上下文（因为 opacity 会影响内部所有元素） position: fixed; 一定会创建层叠上下文 … 需要记忆的有： z-index=0时会创建层叠上下文 flex元素内部会形成层叠上下文 opacity 不为1 ，就会创建层叠上下文 具有 transform 的元素，会形成一个 层叠上下文 知道这些知识的面试官也不太多，不用花时间背 忘了就搜「 层叠上下文 MDN 」 你说 CSS 为什么不单独创建一个属性做这个事 例如： xxxdisabled: true; /* true就创建层叠上下文，false就不创建；css并没有这种直接功能开关*/ 这就是css的难学之处，互相交叉影响，错综复杂（不正交） ​ ​ ","date":"2020-07-29","objectID":"/css-position/:6:2","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"负 z-index 与层叠上下文的关系 JSBin 示例 .demo 的 z-index = -1，会使 demo 出现在文档流的 bg 的后面 z-index 是默认 auto 时，不具有层叠上下文 记住 ：负 z-index 逃不出 层叠上下文的小世界 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"demo\"\u003e\u003c/div\u003e \u003c/div\u003e .container{ background: rgba(0,255,255,0.5); height: 200px; position: relative; /* z-index 是默认 auto 时，不具有层叠上下文，所以添加z-index=0，创建层叠上下文 */ z-index: 0; /* 注释这行看看 */ } .container \u003e .demo{ width: 50px; height: 50px; background: red; position: absolute; z-index: -1; /* 因为上面z-index:0创建了层叠上下文，所以demo无法逃出这个小世界，不可能比container低 */ } 图一：当 container 不是层叠上下文（也就是没有 z-index: 0; ）时，demo 是 z-index = -1 存在于容器bg之下 图二：当 container 创建层叠上下文，demo 就无法跳出容器之外 ​ 总结： z-index = -1 不一定存在于容器的背景之下。当这个容器是一个层叠上下文时，就不可能存在于容器之外 ","date":"2020-07-29","objectID":"/css-position/:6:3","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-26","objectID":"/css-layout-2/","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"CSS 布局篇（下）：Grid 布局。 ​ ","date":"2020-07-26","objectID":"/css-layout-2/:0:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"如何在两套布局中切换 一个css中，写两种布局，使用 @media 媒体查询来切换 ​ ","date":"2020-07-26","objectID":"/css-layout-2/:1:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"Grid 布局 Grid 布局兼容性并不好，在一两年内都可能不会非常广泛的使用（现在可以不用学的那么仔细） 但功能确实非常强大 flex 更擅长 一维布局，要么横着布局，要么竖着布局 一维布局用 Flex ​ ","date":"2020-07-26","objectID":"/css-layout-2/:2:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"二维布局用 Grid 以下内容主要来自 CSS Tricks 的一篇文章 A Complete Guide to Grid 查看本地代码 ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"Grid 也分 container 和 items 分别记忆 ","date":"2020-07-26","objectID":"/css-layout-2/:3:1","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"成为 container .container{ display: grid | inline-grid; } ","date":"2020-07-26","objectID":"/css-layout-2/:3:2","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"行和列 类似 table 表格（grid 被称为新时代的表格） .container{ display: grid; grid-tamplate-columns: 40px 50px auto 50px 40px; /* 每列宽度（有n个值对应生成n列） */ /* 第1列 第2列 第3列 第4列 第5列 */ grid-tamplate-rows: 25% 100px auto; /* 每行高度（有n个值对应生成n行） */ /* 第1行 第2行 第3行 */ } [1] [2] [3] … [6] 指的是线的序号。用于划分 items 的范围（具体使用见 items 部分 ） ​ 缩写 grid-template grid-template是grid-template-rows（行高）和grid-template-columns（列宽）的缩写形式。 比如说，grid-template: 50% 50% / 200px;将创建一个具有两行的网格，每一行占据50%，以及一个200像素宽的列。 /* 需要包括你的花园上部的60%，以及左侧的200像素。 */ #garden { display: grid; grid-template: 60% 40% / 200px calc(100% - 200px) ; /* 行高↑↑ 列宽↑↑ */ } #water { grid-column: 1; grid-row: 1; } /* 你的花园看起来很棒。现在，你在花园的底部留下了50像素的小路，其他的空间用来种植胡萝卜。 不幸的是，胡萝卜地的20%已经杂草丛生了，最后一次用CSS网格布局来规划你的花园吧！ */ #garden { display: grid; grid-template: calc(100% - 50px) 50px/20% 80% } ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:3","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"指定 items 布局 第一步 搭出大框架：几行几列 有几个区域，就建立几个 items \u003cstyle\u003e * { margin: 0; padding: 0; box-sizing: border-box; } .container { display: grid; grid-template-columns: 40px 50px auto 50px 40px; /* 5列（auto会撑满该行余下空间） */ grid-template-rows: 100px 300px 100px; /* 3行（每行高度累加，成为container的总高度） */ border: 3px solid red; } .a, .b, .c, .d, .e { border: 3px solid black; } \u003c/style\u003e \u003cdiv class=\"container\"\u003e \u003c!-- emmet快捷键: 键入.a+.b+.c+.d ——\u003e tab 创建出5个div，class分别为abcde --\u003e \u003cdiv class=\"a\"\u003e\u003c/div\u003e \u003c!--第1行, 第1列--\u003e \u003cdiv class=\"b\"\u003e\u003c/div\u003e \u003c!--第1行, 第2列--\u003e \u003cdiv class=\"c\"\u003e\u003c/div\u003e \u003c!--第1行, 第3列--\u003e \u003cdiv class=\"d\"\u003e\u003c/div\u003e \u003c!--第1行, 第4列--\u003e \u003cdiv class=\"e\"\u003e\u003c/div\u003e \u003c!--第1行, 第5列--\u003e \u003c/div\u003e container 中的子元素，与列数一一对应。且默认只占据第一行。所以添加 border 后 效果如下图所示 第二步 给每个 item 指定区域、设置范围 grid-xxx-start / grid-xxx-end grid-row-start、grid-row-end grid-column-start、grid-column-end .a{ grid-row-start: 1; /* a从哪条线开始 */ grid-row-end: 3; /* a到哪条线结束 */ /* 指定的两条【线】的中间区域，就是a所占的【行】 */ grid-column-start: 1; grid-column-end: 2; /* 指定的两条【线】的中间区域，就是a所占的【列】 */ } grid-row / grid-column grid-row：grid-row-start / grid-row-end; grid-column: grid-column-start / grid-column-end; /* 上面写法，可以缩写成 ↓ */ .a{ grid-row: 1/3 ; grid-column: 1/2 ; } grid-area grid-area属性接受4个由’/‘分开的值：grid-row-start, grid-column-start, grid-row-end, 最后是 grid-column-end。 ​ 起始行 ↑↑ 起始列 ↑↑ 终止行 ↑↑ 终止列 ↑↑ /* 再进一步缩写 */ .a{ grid-area: 1/1/3/2 ; } 最终效果 ​ 可以给线起名字 但没必要，代码太麻烦。就按照序号就很好 取名结果：如图↘ item可以设置范围，直接用线的名称 .item-a{ grid-column-start: 2; grid-column-end: five; grid-row-start: rowl-start; grid-row-end: 3; } ​ ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:4","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"fr ：单位【份】 容器属性 全称 free space 自由空间 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"a\"\u003ea\u003c/div\u003e \u003cdiv class=\"b\"\u003eb\u003c/div\u003e \u003cdiv class=\"c\"\u003ec\u003c/div\u003e \u003cdiv class=\"d\"\u003ed\u003c/div\u003e \u003cdiv class=\"e\"\u003ee\u003c/div\u003e \u003c!-- \u003cdiv class=\"f\"\u003ef\u003c/div\u003e --\u003e \u003c/div\u003e \u003cstyle\u003e * {margin: 0;padding: 0;box-sizing: border-box;} .container { display: grid; grid-template-columns: 1fr 1fr 1fr; /* fr=份，与flex的份类似：共3列每列占1份，也就是均分 */ grid-template-rows: 1fr 1fr; /* 共2行，每行占1份，均分 */ border: 3px solid red; min-height: 500px; } .a, .b, .c, .d, .e { border: 3px solid black; } .e{ grid-column-start: 2; /* 再单独定义e版块占两列空间 */ grid-column-end: 4; background-color: #ccc; } \u003c/style\u003e ​ 变形 .container { display: grid; grid-template-rows: 1fr 3fr; /* 2行：第2行占3份 */ grid-template-columns: 1fr 2fr 1fr; /* 3列：第2列占2份 */ ... } ​ 平均布局 grid-gap fr 主要用于实现平均布局 容器属性：grid-gap 用于控制间距 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c!-- 应用下面grid布局样式，可实现任意添加.image，都可以实现一排4个、间距12px的布局 --\u003e \u003c/div\u003e \u003cstyle\u003e *{ margin: 0; padding: 0; box-sizing: border-box; } .container{ margin-right: auto; margin-left: auto; margin-top: 30px; outline: 5px solid red; width: 800px; /* 开启grid布局 */ display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; /* 格子布局：1排4个 */ grid-template-rows: 1fr 1fr; grid-gap: 12px; /* 计算每项边距，自动计算位置，四边上的会紧贴 */ } .container\u003ediv{ border: 2px solid black; background-color: #ccc; height: 191px; /* 宽800px，1排4个产品，计算得出：每个产品可占宽191px，则间距为12px */ width: 191px; } \u003c/style\u003e ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:5","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"分区 grid template-areas 名字很长，但非常好用 \u003cdiv class=\"container\"\u003e \u003cheader\u003eheader\u003c/header\u003e \u003caside\u003easide\u003c/aside\u003e \u003cmain\u003emain\u003c/main\u003e \u003cdiv class=\"ad\"\u003ead\u003c/div\u003e \u003cfooter\u003efooter\u003c/footer\u003e \u003c/div\u003e \u003cstyle\u003e .container { min-height: 100vh; /* 最小高度为占满整个屏幕 */ display: grid; grid-template-rows: 60px auto 60px; /* 行高 */ grid-template-columns: 190px auto 100px; /* 列宽 */ /* 布局：以版块名称直接写出布局、位置 */ grid-template-areas: \"header header header\" \"aside main ad\" \". footer .\"; /* 空格通常会写一个不存在的名称，如【.】点 */ grid-gap: 10px; /* 设置空隙 */ } .container \u003e * { border: 2px solid red } .container \u003e header {grid-area: header;} /* 版块命名 */ .container \u003e aside {grid-area: aside;} .container \u003e aside {grid-area: aside;} .container \u003e main {grid-area: main;} .container \u003e .ad {grid-area: ad;} .container \u003e footer {grid-area: footer;} \u003c/style\u003e grid-gap 设置间距 grid-gap：通用间距 grid-row-gap : 行间距 grid-column-gap： 列间距 .container{ ... grid-gap: 10px; } .container{ ... grid-row-gap: 20px; /* 行间距 */ grid-column-gap: 10px; /* 列间距 */ } ​ ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:6","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"实践 ","date":"2020-07-26","objectID":"/css-layout-2/:4:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"布局 Grid 尤其适合不规则布局 ","date":"2020-07-26","objectID":"/css-layout-2/:4:1","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"经验 等到 Grid 普及了，前端对CSS的要求会进一步降低 目前你简单尝试一下 Grid 就可以了 ","date":"2020-07-26","objectID":"/css-layout-2/:4:2","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"示例 第一步：根据设计图，划分行列需求，给每块区域命名 第二步：书写【容器】样式 \u003cdiv class=\"container\"\u003e \u003cheader\u003eheader\u003c/header\u003e \u003cdiv class=\"image bigImage\"\u003ebig\u003c/div\u003e \u003cdiv class=\"image smallImage\"\u003esmall\u003c/div\u003e \u003cdiv class=\"image smallImage\"\u003esmall\u003c/div\u003e \u003cdiv class=\"image smallImage\"\u003esmall\u003c/div\u003e \u003cdiv class=\"image middleImage\"\u003emiddle\u003c/div\u003e \u003cdiv class=\"image middleImage\"\u003emiddle\u003c/div\u003e \u003cdiv class=\"image middleImage\"\u003emiddle\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e * { margin: 0; padding: 0; box-sizing: border-box; } .container { display: grid; grid-template-rows: 50px 200px repeat(4, 100px); /* 重复4个120px，可以使用repeat()缩写语法 */ grid-template-columns: 240px 240px; grid-template-areas: \"header header\" \"big mid1\" \"big mid2\" \"sm1 mid2\" \"sm2 mid3\" \"sm3 mid3\"; } \u003c/style\u003e 第三步：指定每项的名称（所属） .container \u003e * { border: 2px solid black; } .container \u003e header {grid-area: header;} .container \u003e .image:nth-child(2) {grid-area: big;} .container \u003e .image:nth-child(3) {grid-area: sm2;} .container \u003e .image:nth-child(4) {grid-area: sm3;} .container \u003e .image:nth-child(5) {grid-area: mid1;} .container \u003e .image:nth-child(6) {grid-area: mid2;} .container \u003e .image:nth-child(7) {grid-area: mid3;} ​ ​ ","date":"2020-07-26","objectID":"/css-layout-2/:4:3","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"游戏 https://cssgridgarden.com/#zh-cn 忘记用法时，可以通过游戏来快速回忆 ​ grid-area grid-area属性接受4个由’/‘分开的值：grid-row-start, grid-column-start, grid-row-end, 最后是 grid-column-end。 ​ 起始行 ↑↑ 起始列 ↑↑ 终止行 ↑↑ 终止列 ↑↑ #garden { display: grid; grid-template-columns: 20% 20% 20% 20% 20%; grid-template-rows: 20% 20% 20% 20% 20%; } #water-1 { grid-area: 1 / 4 / 6 / 5; } #water-2 { grid-area: 2 / 3 / 5 / 6; } ​ order 如果网格项不是以grid-area、grid-column、grid-row 等显示的，它们会自动按照它们在源程序中出现的位置摆放。同样我们也可以使用order属性来重写它的顺序，这也是网格布局优于表格布局的好处之一。 默认情况下，所有的网格项的order都是0，但是顺序也可以被任意设置为正数或者负数，就像z-index一样。 ​ fr 与 px 结合 #garden { display: grid; grid-template-columns: 50px 1fr 1fr 1fr 50px; grid-template-rows: 20% 20% 20% 20% 20%; } #water { grid-area: 1 / 1 / 6 / 2; } #poison { grid-area: 1 / 5 / 6 / 6; } #garden { display: grid; grid-template-columns: 20% 20% 20% 20% 20%; grid-template-rows: 1fr 1fr 1fr 1fr calc(100% - 50px); } #water { grid-column: 1 / 6; grid-row: 5 / 6; } ","date":"2020-07-26","objectID":"/css-layout-2/:4:4","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-25","objectID":"/css-layout-1/","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"CSS 布局篇（上）： Float 布局、Flex 布局 。 ​ ​ Float 示例代码 https://jsbin.com/vobenim/edit?html,css,output Flex 示例代码 https://jsbin.com/biluwan/edit?html,css,output Flex 青蛙游戏 https://flexboxfroggy.com/#zh-cn ​ ","date":"2020-07-25","objectID":"/css-layout-1/:0:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局是什么 把页面分成一块一块，按左中右、上中下等排列 ","date":"2020-07-25","objectID":"/css-layout-1/:1:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局分类 两种 固定宽度布局，一般宽度为960/1000/1024px （淘宝pc） 不固定宽度布局，主要靠文档流的原理来布局（常用在移动端、响应式，会跟随设备宽度变化） 还记得吗 文档流本来就是自适应的，不需要加额外的样式 第三种布局 响应式布局 意思就是PC上固定宽度，手机上不固定宽度 也就是一种混合布局 ​ ","date":"2020-07-25","objectID":"/css-layout-1/:1:1","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局的两种思路 从大到小 先定下大局 然后完善每个部分的小布局 从小到大 先完成小布局 然后组合成大布局 两种均可 新人推荐用第二种，因为小的简单 老手一般用第一种，因为熟练有大局观 ​ ","date":"2020-07-25","objectID":"/css-layout-1/:1:2","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局需要用到哪些属性 不多哔哔，直接给你所有套路 以前经常说 DIV+CSS 布局，但是现在已经无意于用 DIV 了，就说用 CSS 布局 main、header、footer、nav、aside … 这些标签的出现，已经可以代替 div 了 需要兼容 IE9 吗 不用，只做手机页面（闲鱼），阿里巴巴在顺应手机时代 很老的手机产品要兼容吗？兼容最新浏览器吗？ ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:1:3","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"Float 布局 float 主要是针对 IE 的，而现在公司基本不需要兼容 IE6789。 ","date":"2020-07-25","objectID":"/css-layout-1/:2:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"步骤 子元素上加 float: left 和 width 在父元素上加 .clearfix（清除浮动的影响） \u003c!-- header中没有文档流元素，子元素都浮动了(脱离文档流) ，所以header的高度为0 --\u003e \u003c!-- 添加 clearfix 后，可以清除浮动的影响 --\u003e \u003cheader class=\"clearfix\"\u003e \u003cdiv class=\"logo\"\u003eXDML\u003c/div\u003e \u003cnav\u003e导航\u003c/nav\u003e \u003c/header\u003e \u003cstyle\u003e .logo{float: left;...} /* 脱离文档流 */ nav{float: left;...} \u003c/style\u003e .clearfix:after{ content: ''; display: block; clear: both; } /* 请背过 clearfix 的写法 */ ","date":"2020-07-25","objectID":"/css-layout-1/:2:1","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"经验 有经验者会留一些空间或者最后一个不设 width （或者可以给个 max-width: xxxpx;） 不需要做响应式，因为手机上没有IE，而这个布局是专门为 IE 准备的 IE6/7 存在双倍 margin bug（给浮动元素设置 margin: 10px 在 IE6/7 中实际距离会变成 margin: 20px 的效果） 解决办法有两个 一是将错就错，针对 IE6/7 把 margin 减半 .logo{ float: left; margin-top: 10px; /* 其他浏览器 只能识别这句，无法识别下面属性 */ _margin-top: 5px; /* IE6/7在属性前加 下划线 或 星号 都能识别 */ } 二是神来一笔，再加一个 display: inline-block .logo{ float: left; margin-top: 10px; display: inline-block; /* 微软说：IE6/7遇到margin乘2的bug，就添加这句 */ } 为什么可以这样？你问我，我问谁… ​ ","date":"2020-07-25","objectID":"/css-layout-1/:2:2","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"实践 不同布局 用 float 做两栏布局（如顶部条） 用 float 做三栏布局（如内容区） 用 float 做四栏布局（如导航） 用 float 做平均布局（如产品列表展示区）—— 负margin 曾经淘宝的前端发明了双飞翼布局，不要学，已过时代码 经验 加上头尾，即可满足所有PC页面需求 手机页面傻子才用float float要程序员自己计算宽度，不灵活 float用来应付IE足以 技术总结 JSbin 演示，总结如下 outline 现象描述：计算宽度时，内部3个元素的宽度和=300，外层容器=300，但是还会把最后一个元素挤下去，说明子元素的宽度超出容器的宽度。 原因可能是，虽然设定容器宽度为 300，但是容器添加了边框 border : 1像素，所以容器的内容区域的宽度实际只有 298 px。(仅限 border-box 情况) 解决： 把容器的边框删了 改用 outline: 1px solid red; outline 是在外侧的，不占内部区域，但是outline 样式上会有点奇怪 改用 背景颜色 标识区域 居中 /* margin: 0 auto; 下面两句的写法更好，这句还覆盖了margin上下的距离，css原则是不要写多余的 */ margin-left: auto; margin-right: auto; 只有==块级元素==，才能使用 margin … auto，实现居中。 float实现平均布局 添加一个 父元素 x ，进行 ==负margin== 操作（这个词基本都是高手才懂） 注意：添加 父元素后，clearfix 的位置也需要相应移动到，浮动元素的直属父级上 \u003cdiv class=\"imageList\"\u003e \u003cdiv class=\"x clearfix\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c!--\u003cdiv class=\"image\"\u003e\u003c/div\u003e--\u003e \u003c!--\u003cdiv class=\"image\"\u003e\u003c/div\u003e--\u003e \u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .imageList { outline: 1px solid green; width: 800px; margin-left: auto; margin-right: auto; margin-top: 10px; } .imageList \u003e .x \u003e .image { width: 191px; height: 191px; background-color: #555; border: 1px solid red; float: left; margin-bottom: 10px; margin-right: 12px; } .imageList \u003e .x { margin-right: -12px; } \u003c/style\u003e ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:2:3","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"缩写 html、css （√） navigator —\u003e nav （√） 不能缩写未经约定、达成统一的单词 content —\u003e cnt （x） container 也可以缩写成 cnt 容易误会，所以不要用 ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:3:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"Flex 布局 教程（来自 CSS Tricks) 把教程过一遍，然后忘掉 完成 Flex青蛙游戏 开始用flex！ ","date":"2020-07-25","objectID":"/css-layout-1/:4:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"容器 container 有哪些属性 container ：表示容器，一般用于做父元素 items ：表示容器里面的、直接的子元素，就称为 items（项） 以下都是 container 的样式 ​ 让一个元素变成 flex 容器 只有下面两种写法： .container{ display: flex; /* 或 display: inline-flex; */ } ​ 改变 items 流动方向（主轴） 默认，所有项都会挤在主轴，主轴占满会平均压缩每项宽度，以保证在主轴存放下所有项 .container{ display: flex; border: 1px solid red; flex-direction: row; /* 【默认值】横向（从左到右） */ flex-direction: column; /* 纵向（从上到下） */ flex-direction: row-reverse; /* 横向反向（从右到左） */ flex-direction: column-reverse; /* 纵向反向（从上到下） */ } ​ 改变折行 .container{ display: flex; border: 1px solid red; flex-direction: row; /* 默认横向 */ flex-wrap: wrap-reverse; /* 反向折行, 效果如下图，基本没用 */ } flex-direction和flex-wrap两个属性经常会一起使用，所以有缩写属性flex-flow。这个缩写属性接受两个属性的值，两个值中间以空格隔开。 举个例子，你可以用flex-flow: row wrap去设置行并自动换行。 ​ ​ 主轴对齐方式 默认主轴是 横轴 除非你改变了 flex-direction 方向 .container { justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly; } space-around： 每项左右两边的空间一样 space-evenly：每项间距一样 space-between：把空间放到中间，元素分布两边 ​ 次轴对齐 默认次轴是 纵轴 .container{ align-items: stretch [默认值] | flex-start | flex-end | center | baseline（不需要） } stretch【默认值】 默认所有 items 的高度 与 高度最高的 item 保持一致 如下图，3个 item 都与 2 号 item 一样高 flex-start flex-end center ​ 多行分布 很少用到 默认平均分 ： align-content: stretch (如图) .container{ display: flex; border: 1px solid red; flex-wrap: wrap; height：400px； align-content: flex-start; /* 全部集中到顶部 */ align-content: flex-end; /* 全部集中到底部 */ align-content: center; /* 全部集中到中间 */ align-content: space-between; align-content: space-around; } ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:4:1","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"flex item 有哪些属性 以下都是 item 的属性 item 上加 order 默认 order 为 0 指定 order 后，item 会按照 order 顺序从小到大排列（可以指定为负数） \u003cdiv class=\"container\"\u003e \u003cdiv class=\"item\"\u003e1\u003c/div\u003e \u003cdiv class=\"item\"\u003e2\u003c/div\u003e \u003cdiv class=\"item\"\u003e3\u003c/div\u003e \u003cdiv class=\"item\"\u003e4\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .container{ display: flex; border: 1px solid red; } .item{ width:50px; height:50px; border: 1px solid green; } .item:first-child{ order: 100; } /* 最后 */ .item:nth-child(2){ order: 2; } .item:nth-child(3){ order: 3; } .item:last-child{ order: 1; } /* 最前 */ \u003c/style\u003e ​ item 上加 flex-grow 用于分配多余的空间（控制变胖） flex-grow： 默认为 0. 就是 item 宽度由内容撑开，没内容的话宽度就是0，不会占用多余的空间 给 item 设置 flex-grow 值为 n （\u003e0），就是将分配多余空间给当前 item 占 n 份。 如果一共有3个item，那就平均分配多余空间，每个 item 占 n/3. 当我们不给 item 设置宽度时，item 的宽度是能有多窄有多窄（宽度由内容撑开） 实现宽度能有多宽有多宽，就给 item 添加 flex-grow .item{ flex-grow: 1; /* 每一个 item 平均分配宽度，来占满多余的空间（不是占满整行空间） */ } 需求：从多余的空间中，给2,3 的宽度占 2 份; 给 1,4 占 1 份 空间 .container{ display: flex; border: 1px solid red; } .item{ height:50px; border: 1px solid green; } .item:first-child{ flex-grow: 1; } .item:nth-child(2){ flex-grow: 2; } .item:nth-child(3){ flex-grow: 2; } .item:last-child{ flex-grow: 1; } 经验 当 3 栏布局，如下 只给【导航】设置 flex-grow: 1（实现导航宽度的响应式），logo、头像固定宽度 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"item\"\u003elogo\u003c/div\u003e \u003cdiv class=\"item\"\u003e导航\u003c/div\u003e \u003cdiv class=\"item\"\u003e头像\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .container{ display: flex; border: 1px solid red; } .item{ height:50px; border: 1px solid green; } .item:nth-child(2){ flex-grow: 1; } \u003c/style\u003e ​ flex-shrink 控制如何变瘦 当界面不断变窄，无法存放每项的给定宽度时，每项都需要变窄，flex-shrink 就控制谁瘦的多，谁瘦的少 默认是1（所有item平均收缩，要缩一起缩） 一般写 flex-shrink: 0; 防止变瘦（被设置为 0 的这一项，就算空间不够时，也不会收缩。要缩别找我） .item{ width: 150px; /* 合计宽度最小450px */ height:50px; border: 1px solid green; flex-grow: 1; /* 每项会均分多余空间 */ } .item:first-child{ flex-shrink: 1; } .item:nth-child(2){ flex-shrink: 50; /* 2 的收缩比例较大 */ } .item:last-child{ flex-shrink: 1; } 当宽度缩小达到450px以内，每项宽度不足，此时每项会开始收缩， flex-shrink 值越大，则收缩的越大，flex-shrink 值越小，越不会受到收缩的影响 如下图，宽度收缩450px以内，【导航】最先开始发生了较大的收缩，因为设定了较大的 flex-shrink 值 【logo】和【头像】版块，基本不收缩 ​ flex-basis 控制基准宽度 用法： 默认是 auto（与 item 的 width 值保持一致） 指定宽度：flex-basis: 100px; 相当于指定了 width 值 这个属性比较迷：不是很重要的属性 可以直接用 width 来代替这个属性 ​ 缩写成 flex flex 相当于 flex-grow flex-shrink flex-basis 习惯上我一般不写缩写，容易记错位置 flex 只有以下 4 种形式的写法 .item:first-child{ flex: 1 1 100px; /* grow-1，shrink-1，宽100px */ } .item:nth-child(2){ flex: 1 100 100px; /* grow-1，shrink-100，宽100px */ } .item:last-child{ flex: 1 1 100px; /* grow-1，shrink-1，宽100px */ } 上述，3个item，宽度为100px grow撑开时每个item平均占满所有多余空间 宽度不足时，2 号主要进行收缩 ​ align-self 定制 align-items 用的很少 默认在垂直方向上，都是顶端对齐的 align-self 可以让某一个 item，在垂直方向上，特例独行的展示（指定一个特别的对齐方式） 实现：单独设置，最后一个 item 底部对齐 ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:4:2","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"重点 记住这些代码 display: flex 开启flex布局 flex-direction: row / column 主轴是横向还是纵向 flex-wrap: wrap 空间不足时是否换行 just-content: center / space-between 主轴方向上的对齐方式：居中/分开 align-items: center 次轴方向上的对齐方式：居中，顶，底 工作中基本只用这些 ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:4:3","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"实践 不同布局 用 flex 做两栏布局 用 flex 做三栏布局 用 flex 做四栏布局 用 flex 做平均布局 —— 负 margin 用 flex 组合使用，做更复杂的布局 JSBin 代码 经验 永远不要把 width 和 height 写死，除非特殊说明 PC端通常可以写死。移动端不能写死，需要适配各种尺寸：平板/手机… 用 min-width / max-width / min-height / max-height flex 可以基本满足所有需求 flex 和 margin-xxx : auto 配合有意外的效果——例：左右布局 ​ 什么叫写死 写死 width:100px 不写死 width: 50% max-width: 100px width: 30vw （屏幕宽度的百分之30） min-width: 80% 特点：不使用 px，或者加 min max 前缀 css 最忌讳把宽高写死 ​ 技术总结 左右布局 表示两栏布局-贴左、贴右：可通过以下两句中的任意一句来实现 margin-xxx: auto 更灵活 \u003cstyle\u003e .header { display: flex; border:1px solid black; /*justify-content: space-between; ---------------二者任选其一----------------------*/ } ul { /* margin-left: auto; -------------------------二者任选其一【推荐】------------------*/ display: flex; border: 1px solid green; } ul \u003e li { border: 1px solid red; } \u003c/style\u003e \u003cheader class=\"header\"\u003e \u003cdiv class=\"logo\"\u003e \u003cimg alt=\"\" src=\"./logo.png\"\u003e \u003c/div\u003e \u003cul\u003e \u003cli\u003e首页\u003c/li\u003e \u003cli\u003e课程\u003c/li\u003e \u003cli\u003e优惠\u003c/li\u003e \u003cli\u003e关于\u003c/li\u003e \u003c/ul\u003e \u003c/header\u003e 产品展示格子布局 失败方案 \u003cdiv class=\"imageList\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c/div\u003e .imageList{ border: 1px solid red; width: 800px; margin-right: auto; margin-left: auto; margin-top: 10px; display: flex; flex-wrap: wrap; justify-content: space-between; /* 会导致产品不足数的行 --\u003e 错位 */ } .image{ width: 191px; height: 191px; background-color: #ccc; margin-bottom: 10px; border: 1px solid green; } ​ 负margin方案 \u003cdiv class=\"imageList\"\u003e \u003c!-- 可以命名为 inner 或者 wrapper --\u003e \u003cdiv class=\"x\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e .imageList { outline: 1px solid red; /* 注意：边框去掉或者放在外面，否则占据宽度 */ width: 800px; margin-right: auto; margin-left: auto; margin-top: 10px; } .imageList \u003e .x { display: flex; flex-wrap: wrap; margin-right: -12px; /* 负margin */ } .image { width: 191px; height: 191px; background-color: #ccc; margin-bottom: 10px; border: 1px solid green; margin-right: 12px; /* 每个的间距 */ } ","date":"2020-07-25","objectID":"/css-layout-1/:4:4","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-25","objectID":"/css-basic/","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"熬夜总结 – CSS 基础篇 。 ","date":"2020-07-25","objectID":"/css-basic/:0:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 的历史 ","date":"2020-07-25","objectID":"/css-basic/:1:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 是谁发明的 李爵士的挪威同事赖先生，首先提出 CSS Håkon Wium Lie （挪威语） ","date":"2020-07-25","objectID":"/css-basic/:1:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"赖先生的生平 生平 1991年获得MIT媒体实验室视觉研究理学硕士学位 1994年提出CSS概念而闻名 1999年任Opera的CTO（首席技术官，不分前端后端、只要是技术就负责） 2005年他写公开信给比尔盖茨问为什么IE不支持Web标准，盖茨说IE 7马上发布，他写了 Acid2 用来验证 2006年通过了博士论文答辩 2006年他倡议 Web 网页应使用通用字体格式 2007年他倡议浏览器可以支持video标签 观点 微软的IE常常成为他的批评对象 他也是Web打印概念的倡导者，用HTML和CSS写书 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 的牛 X 之处在哪？ CSS（Cascading Style Sheets）：==层叠==样式表 样式层叠 可以多次对同一选择器进行样式声明 选择器层叠 可以用不同选择器对同一个元素进行样式声明 文件层叠 可以用多个文件进行层叠 这些特性使得 CSS 极度灵活 这也为 CSS 后来被吐槽留下了隐患 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:3","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 的版本 ⭐目前使用最广泛的css版本：css 2.1 版本 2004-2011年间不断更新，没有具体发布时间 版本 时间 重点 CSS 1 1996年 不用管 CSS 2 1998年 添加定位、z-index、media，不用管 **CSS 2.1 ** 2004~2011年 使用最广泛的版本（IE支持） CSS 3 1999年开始起草 现代版本，分模块（IE 8 部分支持） CSS 4* 分模块升级 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:4","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"浏览器对CSS的支持（兼容性） 怎么知道，哪些浏览器，支持哪些特性？ 方法一：几十种浏览器全部跑一遍 方法二：使用 caniuse.com 红色：不支持flex 黄色：部分支持 绿色：完全支持 caniuse.com 使用方法 请收藏此网站 输入你关心的样式，比如 border-radius 或 filter 查看大部分浏览器的支持情况 如果想看更多，点击 Show All 下方会详细说明兼容 bug 有哪些（翻译成中文） 这个网站是怎么运作的 网站主一开始自己测试了一部分浏览器 社区的前端工程师帮助测试各种各样的浏览器 UC 浏览器和 QQ 浏览器当然主要是中国开发者测试 大家把测试结果提交到 GitHub 上 这就是开发者社区的力量、 什么是社区？ 社区不是一个准确存在的概念，大家你帮我我帮你，互相学习，互相分享，就形成了社区。 是一种弱联系。 社区通过汇集的力量将事情给解决好 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:5","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 是艺术 就像画画、折纸 你需要用感性思维来理解 CSS ","date":"2020-07-25","objectID":"/css-basic/:2:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"不要用理性思维 即不要问「为什么会这样」，而是说「原来是这样」 浏览器说是怎么样，就是怎么样 当然有极少情况是浏览器出错了 ","date":"2020-07-25","objectID":"/css-basic/:2:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"为什么 color: red 能让字变红 不要问「为什么」 要说「原来是这样」 所见即所学 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:2:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"体系化学习 有生之年都不太可能把css所有知识学完，因为它太、多、了。只文档可能就有几百页，目录全看一遍都很累：css标准文档（google 搜 css spec） 不是把所有知识都学完，而是在一个新知识点到来的时候，马上学会它。这才是学习CSS体系化最重要的手段 体系化学习 CSS 和 HTML 的过程完全一致 ","date":"2020-07-25","objectID":"/css-basic/:3:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"学一门语言必须学会什么 语法（怎么写代码） css 语法非常简单 [如何调试](#如何调试 CSS)（怎么知道自己代码写错了） node-w3c-validator -i index.html // 查错 在哪查资料（其实就是为了抄代码） MDN 标准制定者是谁 尝试所有方法仍不能解决问题的话，就必须看标准文档了 ","date":"2020-07-25","objectID":"/css-basic/:3:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"如何学 Copy - 抄文档、抄老师 Run - 放在自己的机器上运行成功 Modify - 加入一点自己的想法，然后重新运行 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"语法 超级简单 语法一：样式语法 选择器 { 属性名: 属性值; /*注释*/ } 注意事项 不学常态，学变态 所有符号都是英文符号，如果写错了，浏览器会警告（样式会被划掉） 区分大小写，a 和 A 是不同的东西（特别是大小写很相似的字母，很容易错） 没有 // 注释，只有 /* 注释 */ 这种形式 最后一个分号可以省略，但建议不要省略 任何地方写错了，都不会报错，浏览器会直接忽略 那我怎么知道自己写没写错呢？一会说 语法二：at 语法 @charset \"UTF-8\"; /* 声明字符编码，必须放在第一行 */ @import url(2.css); /* 导入一个额外的css文件 */ @media (min-width: 100px) and (max-width: 200px) { /* 媒体查询 */ 语法一 } 注意事项 @charset 必须放在第一行 前两个 at 语法必须以分号 ; 结尾 @charset \"UTF-8\"; @import url(2.css); @media 语法会单独教学 charset 是字符集的意思，但 UTF-8 是字符编码 encoding（并不是字符集），这是历史遗留问题 最早只有 ASCII 这一种字符集（英文），这个字符集的编码形式就是它自己 后来中国人发现 ASCII 不能表示中文，所以就发明了 GB2312，由中国国家标准局（国标局）发行，GB 就是国家标准的缩写。 GB2312 是一个支持中文简体汉字的字符集。它对应的编码形式，是它自己 后来日本、韩国的文字，我们的 GB2312 也表示不了。国标局还没开始动作，微软先一步发明 GBK，k表示扩展。GBK 可以同时表示 中文、日文、韩文（CJK） 后来中国发现还需要和更多国家建立联系，国标库根本就搞不定，就有一个叫 Unicode 的组织，给全球制作了一个字符集，叫做 Unicode（万国码）。这个码包含非常多国家，特别长，所以必须采用不同的编码形式。 编码形式包含：UTF8/UTF16/UTF32 （选择任意一个即可） 从 Unicode开始字符集和编码形式就不统一了，之前都是统一的 html 1993年左右发明，css 发明于1996年左右，Unicode在1996年之后发明。 charset 原本后面写一个【字符集的名字】，写 GBK/GB2312 ….这种，对应编码形式也是同名的。但是Unicode发明后，字符集名称和编码形式不统一了，所以我们为了表明自己使用的是 Unicode 的那种编码形式，就只能将Unicode的编码形式，写在表示字符集的 charset 的位置。 ==【这就是这个历史问题的发展经过】== 字符集 编码形式 ASCII ASCII GB2312 GB2312 GBK GBK Unicode UTF8/UTF16/UTF32 问： @charset “UTF-8” 指的是什么？ 回答 ：字符集（charset） 是错误的 “UTF-8”指定的不是字符集 charset，而是指定的【 文件编码 】 虽然charset本身是字符集的意思，但后面的 utf-8 指的是 Unicode字符集的**【编码形式】**的一种。这是一个历史遗留问题 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:3","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"如何调试 CSS 方法 使用 W3C 验证器（在线 / 命令行工具）不用试了 node-w3c-validator -i index.html // 可能需要先安装java环境，才能运行 node-w3c-validator Java环境安装、配置 使用 VSCode 看颜色 使用 WebStorm 看颜色 使用开发者工具看警告 浏览器预览页面，右键检查，查看Element中，一般会给出问题警告。有问题的css会被划删除线 如何使用开发者工具 找到你脑中的标签 看它是否有选择器 看它的样式是否被划掉 看它的样式是否有警告 Border 调试法 步骤 怀疑某个元素有问题 就给这个元素加 border border 展示效果没出现？说明选择器错了或者语法错了 通常是 border 上面的代码有问题（因为上面代码执行遇到问题，就会影响下面样式的输出） border 出现了？看看边界是否符合预期 说明选择器没有错、border以上的代码没有错 可以继续往下测试、查找错误 bug 解决了才可以把 border 删掉 记住 CSS 的 border 调试法 就相当于 JS 的 log 调试法 我会再每节课重复这个调试法 ​ 新人常见错误 低级错误 选择器拼写错误 属性名拼写错误 属性值拼写错误 大小写错误 没写分号 中文冒号 没写反花括号 没加单位 非低级错误 没有非低级错误 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:4","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"在哪查资料 网站推荐 Google 搜索关键词时加 MDN CSS tricks（英文），专门收集 css 小技巧的网站 使用方式：在google 搜 [技术名词] css tricks https://css-tricks.com/snippets/css/a-guide-to-flexbox/ 张鑫旭的博客：可能是中国花时间最多来学css的人 使用方式：搜 [技术名词] 张鑫旭 书籍推荐 不推荐买任何书 CSS 和 HTML 一样，以练为主 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:5","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"在哪搜练习素材 PSD Freepik 搜索 PSD web 英文（下载免费的 psd） 如果下载慢，就把域名加入翻墙插件 中文免费 PSD 网站较少，需要多搜一下 365PSD 里的 UI 套件还行 效果图（不提供下载） dribbble.com 顶级设计师社区 可以用肉眼模仿它 商业网站 直接模仿你常去的网站 ​ ","date":"2020-07-25","objectID":"/css-basic/:3:6","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"不要沉迷临摹 每个类型的临摹一两个即可 PC 网站、手机网站、UI 套件 再多无益 ​ ","date":"2020-07-25","objectID":"/css-basic/:3:7","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"遇到查不到的问题，怎么办 遇到查不到的问题，应该去哪里查文档？ ——找标准制定者 李爵士、赖先生 W3C 搜索 CSS spec 可以找到 CSS 最新标准 没人能看完它 你可以看看 CSS 2.1 标准的中文版 正确学 css ，应该是遇到问题，再查资料 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:8","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"基本概念 ","date":"2020-07-25","objectID":"/css-basic/:4:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"要理解几个重要的概念 文档流 Normal Flow 块、内联、内联块 margin 合并 两种盒模型（border-box 更符合人类思维） ​ ","date":"2020-07-25","objectID":"/css-basic/:4:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"文档流 文档流的英文名称叫做 Normal Flow 文档流方向：默认，内联元素从左到右，块级元素从上到下 emmet: span{第$个span元素}*6 + tab ​ ","date":"2020-07-25","objectID":"/css-basic/:4:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"块、内联、内联块 将元素分为：内联元素、块级元素。是一种已经过时的分法。 在新的 HTML5 标准中，元素不分内联、块级。所有元素都可以是内联元素，所有元素都可以是块级元素。 看样式：如果 display:inline， 就是内联元素。如果 display: block 就是块级元素。 内联块：不会出现如【内联元素首尾可以在不同行】的情况，内联块会同行展示，但是又保有 block 的一个特点：不会跨两行（这就是inline和inline-block在流动方向上相似又稍微不同的点） 流动方向 inline 元素从左到右，到达最右边才会换行 block 元素从上到下，每一个都另起一行 inline-block 也是从左到右 宽度 inline 元素 宽度为 内部 inline 元素的和。 不接受用 width 指定宽度。加了也不变化 不要在 inline元素内部，再写 block 元素。它的计算可能乱套的，出现后果自负 block 元素 默认自动计算宽度，可用 width 指定 width: 200px; （200像素）、width: 20em; （20个字宽） 不指定宽度，宽度默认是 width: auto。不是 width: 100%，是能有多宽就占多宽，最大可以占 100% 如下图，每个div元素都有边框，【div默认宽度】=100%-边框宽度。如果【设置div宽度为100%】，那么相当于，整行宽度= div宽度100%+边框宽度，所以会多出边框宽度的一小块位置 ==经验之谈==：给任何元素都尽量，不要设置 width: 100% 的样式。大部分情况写了就等于 bug。 inline-block 元素 结合前两者特点，可用 width 默认情况，与 inline 一致 但是又可以用 width 指定宽度，这一点又与 block 一致 高度 inline 高度 由 line-height（行高） 间接确定，跟 height 无关 （设置height无效） 如下图，为什么外层的 绿div 没有包住 红span、被撑高呢？ 因为 span 的高度，不是【内容高+padding】决定的。padding 改变的不是 span 的实际高度，只是改变了可视的高度。div 框的高度才是 span 的实际高度。 span 的实际高度，由 行高 间接确定。如下图，虽然span的红框仍然没变，但是 div高度变化了。而div包裹的高度才是 span 的实际高度（只需关注外层div高度即可，红框的高度并不是span实际高度） “间接” 怎么理解？ 即使设置行高100px，span的高度也有可能不是100px高 设置不同的字体，会改变 span 的实际高度。经测试：↓↓ 默认，微软雅黑字体、行高是100px的话，实际高度就是100px。 改成宋体、行高是100px，span 的实际高度变成 101px。 改成 monospace(等宽字体)、行高是100px。 实际高度变成 102px 具体知识点叫做：行盒 （可以看文章，能看懂就看，面试官可能都看不懂，前期可以不用研究这么深） block 高度 默认高度，由内部所有 文档流元素 的高度总和 决定的。（由默认行高间接决定） 内层div是脱离文档流的元素，外层div就无法计算上它的高度 后面会介绍：如何脱离文档流、脱离后去哪里了 同时也可以自定义设置 height 高度。这种情况，就忽略内部元素高度。 如果div中没有任何内容，高度为0。区别于span，span中没有内容，也有高度，由 默认的 line-height 决定。 inline-block 高度 默认高度的计算，跟 block 一样。 也可以自定义设置 height。 ","date":"2020-07-25","objectID":"/css-basic/:4:3","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"overflow 溢出 当内容大于容器 当内容的宽度或高度大于容器的，会溢出 可用 overflow 来设置是否显示滚动条 auto 是灵活设置 scroll 是永远显示（基本不用） hidden 是直接隐藏溢出部分 visible 是直接显示溢出部分（默认值） overflow 可以分为 overflow-x 和 overflow-y，通常只用overflow。x和y可能最终效果会与实际需求有差 示例 \u003cdiv style=\"width: 10em; height: 200px;\"\u003e内容......\u003c/div\u003e overflow: visible; /* 默认 */ overflow: hidden; /* 超出部分隐藏 */ overflow: scroll; /* 超出部分可滚动预览，很少有人用。因为内容没溢出时，仍显示滚动条，非常丑 */ overflow: auto; /* 超出时显示滚动条，不超出不显示 */ 横向滚动条 \u003cdiv style=\"width: 10em; height: 200px;\"\u003e 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 \u003cdiv style=\"width:1000px;\"\u003e 内容 \u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e div{ border: 1px solid green; overflow: auto; } span{ border: 1px solid red; } \u003c/style\u003e 内部文档流元素宽度超出外层父元素，就会出现横向滚动条 同时原本的内容，不会因为宽度被内部元素撑开而平铺显示，仍会只显示在第一屏中 ​ ","date":"2020-07-25","objectID":"/css-basic/:4:4","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"脱离文档流 回忆一下 block 高度由内部文档流元素决定，可以设 height 这句话的意思是不是说，有些元素可以不在文档流中 哪些元素脱离文档流 脱离文档流的元素，那么它所在的容器，就不会把它计算进高度中 脱离文档流，就是从普通文档流中跳出，比普通文档流的层级稍高 float position: absolute / fixed 怎么让元素不脱离文档流 不要用上面属性不就不脱离了 ​ ","date":"2020-07-25","objectID":"/css-basic/:4:5","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"盒模型 content box \u0026 border box css 盒模型分为两种：一种是 content-box ，一种是 border-box 二者的区别是： content-box 的宽度，只包含 content 部分 border-box 的宽度，包含 border、padding 和 content 分别是 content-box 内容盒 - 内容，就是盒子的边界 border-box 边框盒 - 边框，才是盒子的边界 公式 content-box width = 内容宽度 border-box width = 内容宽度 + padding + border 哪个好用 border-box 好用 同时指定 padding、width、border 就知道为什么了 ​ ","date":"2020-07-25","objectID":"/css-basic/:4:6","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"margin合并 哪些情况会合并 兄弟 margin 合并 上方元素的 margin-bottom，会和下方元素的 margin-top 重合 父子 margin 合并 给子元素添加 margin-top，效果会作用在父元素上（bf：嵌套崩塌） 第一个子元素的 margin-top，会和 最后一个子元素的 margin-bottom，效果会作用在父元素的 margin-top/bottom 或 和父元素的 margin-top/bottom 重合 记住：只有上下会重叠，左右从来不重叠 如何阻止合并 不要问为什么，CSS 很多效果是试出来了，无法解释清楚 父子合并用 padding / border 挡住 可以用很小的 padding/border 来挡住，让父子的margin无法穿透并重叠 父子合并用 overflow: hidden 挡住 父子合并用 display: flex，不知道为什么，试出来的 兄弟合并是符合预期的 兄弟合并可以用 display: inline-block 消除 总之要一条一条死记。 而且 CSS 的属性逐年增多，每年都可能有新的 为什么css 难学？ 不正交 因为很多没有道理，需要死记硬背的点。 为什么 display: inline-block 可以消除 margin 合并。 并没有 enable-margin-callapse: false 这种选项，翻译一下就知道它是用来单独控制margin合并的。 无法知道 现在写的这句 css，到底会影响哪些属性 什么叫正交？ 当我们调节显示器的亮度时，显示器的对比度不会改变。 而 css 是不正交的，因为我们在写某一个属性时，可能就会改变其他属性的状态、效果 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:4:7","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"基本单位 长度单位 px 像素 em 相对于自身 font-size 的倍数 百分数 整数 rem：等你把 em 滚瓜烂熟了再问 rem vw 和 vh 其他长度单位都用得很少，不用了解 颜色 十六进制 #FF6600 或者 #F60 #000 也支持最后添加 alpha。 #FF660000 全透明、 #FF6600FF 不透、 #FF660088 半透。但兼容性不确定 RGBA 颜色 rgb(0,0,0) 或者 rgba(0,0,0,1) hsl 颜色 hsl(360,100%,100%)：色相、饱和度、明度 hsla(360,100%,100%, 0.5) ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:4:8","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"实践：做一个彩虹 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eJS Bin\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"rainbow\"\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e * { box-sizing: border-box; margin: 0; padding: 0; } body{ background: white; } .rainbow { height: 200px; overflow: hidden; } .rainbow div { overflow: hidden; } .rainbow \u003e div { width: 400px; height: 400px; background: red; border-radius: 50%; } .rainbow \u003e div\u003e div { background: hsl(60, 80%, 50%); height: 380px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div { background: hsl(120, 80%, 50%); height: 360px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div { background: hsl(180, 80%, 50%); height: 340px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv { background: hsl(240, 80%, 50%); height: 320px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv \u003e div { background: hsl(300, 80%, 50%); height: 300px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv \u003e div \u003e div { background: hsl(330, 80%, 50%); height: 280px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv \u003e div \u003e div \u003e div { background: hsl(330, 80%, 100%); height: 260px; margin: 10px; border-radius: 50%; } ","date":"2020-07-25","objectID":"/css-basic/:5:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["工具"],"content":"最近 Typora 有了更新，终于支持图床功能了 🎉！新增了原生对 PicGo-Core 的调用，可以自动上传 markdown 内的图片，尝鲜一波！","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"​ Typora 是一款简单、高效而且优雅的 Markdown 编辑器，它提供了一种所见即所得的全新的 Markdown 写作体验。它把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时生成预览效果。Typora 的一切都围绕纯粹的生产效率而设计。 Typora一直是我最喜欢的 markdown 编辑器，写博客、记笔记的首选软件。相信大部分朋友也在使用 Typora 这款软件。 但是 Typora 之前是不支持图床功能的，只能通过第三方插件实现图片自动上传的功能。不过最近 Typora 有了更新，终于支持图床功能了，新增了原生对 PicGo-Core 的调用，可以自动上传 markdown 内的图片，赶紧尝鲜一波。 ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:0:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"1. 安装 PicGo-Core 因为Typora已经原生支持PicGo-Core, 所以只需要在软件内下载一下就可以了(PS: 下面这张图就是用的自动上传, 很方便) 首先点击上面红色1的位置，选择 PicGo-Core，再点3（不要问我2去哪儿了….就当他不存在），并等待下载完成。 ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:1:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"2. 安装 smms 插件 直接点击红色5的位置，根据文本内容找到 PicGo-Core 的程序目录 注意，上图中我们只需关心红框中的路径下的 picgo.exe 文件，其他信息都不管 找到目录后，我们在picgo的目录下启动命令行，执行如下命令，并等待安装成功 .\\picgo.exe install smms-user ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:2:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"3. 配置 PicGo-Core 安装完成之后点击红色4的位置（红标顺序不代表点击顺序），打开 PicGo-Core 的配置文件，按照下面的格式无脑全选替换就行 { \"picBed\": { \"current\": \"smms-user\", \"uploader\": \"smms-user\", \"smms-user\": { \"Authorization\": \"这里替换成你自己的\" }, \"transformer\": \"path\" }, \"picgoPlugins\": { \"picgo-plugin-smms-user\": true } } 没有 Authorization 的自己去这里申请一个： https://sm.ms/home/apitoken 申请前需要注册一个账号，这个没啥难度，就不细说了。 ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:3:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"4. 体验效果 保存配置之后，我们直接在 Typora 内粘贴一张图片，就会自动提示上传中 或者在已有的本地图片上面按右键，也可以弹出上传图片的按钮，整个操作非常便捷。 ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:4:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"这里是文章描述，本文用于测试一些 Markdown 语法和样式展现","date":"2019-03-06","objectID":"/tools-test-markdown/","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"本文用于测试一些 Markdown 语法和样式展现 ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:0:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"文章摘要 \u003c!--more--\u003e [more注释]之前的内容，会作为文章摘要显示在主页。尽量不要包含代码块、图片、表格等模块。如果 [more注释] 之前的内容为空，则将自动添加 description 内容为文章摘要，显示在主页中。 ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:1:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"文章置顶 weight: 1 // Front-matter ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:2:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"常用语法 主题文档链接 ​ 反引号 ==高亮== ​ 加粗 ​ 斜体 下划线 这是一个链接哦。 ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:3:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"markdown 支持 emoji 在 config.toml 中开启/关闭 emoji 支持 表情包大全：https://hugoloveit.com/zh-cn/emoji-support/ 冒号joy冒号 冒号jack_o_lantern冒号 冒号heart冒号 😂 🎃 ❤️ ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:4:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"有序列表 有序列表1 无序列表 无序列表 有序列表2 有序列表3 ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:5:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"无序列表 无序列表 无序列表 无序列表 无序列表 在这里添加一个脚注 1 无序列表 无序列表 ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:6:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"复选框 - [x] Write the press release - [x] Update the website - [ ] Contact the media Write the press release Update the website Contact the media ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:7:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"代码块 console.log(\"test\") \u003cdiv class=\"box\" style=\"color:red;\"\u003e\u003c/div\u003e body{ font-size: 20px; } ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:8:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"内置 Shortcodes 语法支持 ","date":"2019-03-06","objectID":"/tools-test-markdown/:9:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"横幅 This is a tip 一个 danger 横幅 This is a tip 一个 note 横幅 This is a tip 一个 tip 横幅 ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:9:1","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"图片 Iceland (figure) ​ 点击图片放大，点击空白缩小↘ Iceland (image)\" Iceland (image) ​ ","date":"2019-03-06","objectID":"/tools-test-markdown/:9:2","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"二级标题 ","date":"2019-03-06","objectID":"/tools-test-markdown/:10:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"三级标题 四级标题 五级标题 六级标题 ​ 这是一段脚注 https://xxx 这是一段脚注 ↩︎ ","date":"2019-03-06","objectID":"/tools-test-markdown/:10:1","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["个人博客的创建之路"],"content":"Valine + LeanCloud","date":"2018-12-30","objectID":"/blog-comments-valine-leancloud/","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"hugo 博客添加评论系统 Valine Valine - 一款快速、简洁且高效的无后端评论系统。 Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho等博客程序在使用Valine。 所以，理论上它也是支持 Hugo 的， 实践证明，确实如此。其特性如下： 快速 安全 Emoji 😉 无后端实现 MarkDown 全语法支持 轻量易用(~15kb gzipped) 文章阅读量统计 v1.2.0-beta1+ 下面就讲一下如何一步步添加 Valine 支持的。 Tips: 整个过程，是以Loveit主题为例的，其它主题操作大同小异。 配置之前应该先阅读Valine快速开始 ​ ","date":"2018-12-30","objectID":"/blog-comments-valine-leancloud/:0:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"Leancloud相关配置 评论系统依赖于 leancloud，所以需要先在leancloud中进行相关的准备工作。 登录 或 注册 LeanCloud（国际版） 必须验证邮箱和手机号 成功后，进入后台点击左上角的创建应用： 创建好应用，进入应用，点击【组件】 左边栏找到【设置】，然后点击【应用Key】，此时记录出现的 App ID 和 App Key，后面配置文件中会用到： 因为评论和文章阅读数统计依赖于存储，所以还需要建立两个新的存储 Class 左边栏找到并点击【存储】，点击【创建Class】 创建两个存储Class，分别命名为: Counter 和 Comment； 仅修改 ACL 的 write 权限 还需要为应用添加安全域名，左边栏点击【设置】，找到【安全中心】，点击后会看到【安全域名】设置框，输入博客使用的域名，点击保存即可： ​ ","date":"2018-12-30","objectID":"/blog-comments-valine-leancloud/:1:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"config.toml 添加参数 添加 Valine 参数项： [params.page.comment.valine] enable = true appId = \"xxxxxxxxxxxxxxxxxxxxxx\" appKey = \"xxxxxxxxxxx\" placeholder = \"说点什么吧...（提醒：填写邮箱，若有人回复您，您将及时收到提醒邮件！）\" avatar = \"mp\" meta= \"\" pageSize = 10 lang = \"\" visitor = false recordIP = true highlight = true enableQQ = false serverURLs = \"\" # LoveIt 新增 | 0.2.6 emoji 数据文件名称, 默认是 \"google.yml\" # (\"apple.yml\", \"google.yml\", \"facebook.yml\", \"twitter.yml\") # 位于 \"themes/LoveIt/assets/data/emoji/\" 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \"assets/data/emoji/\" emoji = \"apple.yml\" 上面几项内容的含义，这里简单一说，具体还是要看 Valine官网中配置相关的内容： 参数 用途 enable 这是用于主题中配置的，不是官方Valine的参数，true时控制开启此评论系统 appId 这是在 leancloud 后台应用中获取的，也就是上面提到的 App ID appKey 这是在 leancloud 后台应用中获取的，也就是上面提到的 App Key notify 用于控制是否开启邮件通知功能，具体参考邮件提醒配置 verify 用于控制是否开启评论验证码功能 avatar 用于配置评论项中用户头像样式，有多种选择：mm, identicon, monsterid, wavatar, retro, hide。详细参考：头像配置 placehoder 评论框的提示符 visitor 控制是否开启文章阅读数的统计功能, 详情阅读文章阅读数统计 ","date":"2018-12-30","objectID":"/blog-comments-valine-leancloud/:2:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"完善评论通知 ⭐️⭐️ Valine 评论邮件提醒功能不太健全，通知邮件中没有文章直达链接，Valine 官网中提供了评论系统第三方功能扩展Valine链接，按照链接中的说明，非常详细的步骤，一步步很容易实现完备的评论系统后台管理以及邮件提醒功能，部分高级配置点我了解。这里简单列举步骤如下： ","date":"2018-12-30","objectID":"/blog-comments-valine-leancloud/:3:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"步骤 进入leancloud，【云引擎】【部署项目】【git】 填写仓库地址： https://github.com/zhaojun1998/Valine-Admin 填写分支： master 此外，你需要设置云引擎的环境变量以提供必要的信息，点击云引擎的设置页，设置如下信息： 必选参数 SITE_NAME : 网站名称。 SITE_URL : 网站地址, 最后不要加 / 。 SMTP_USER : SMTP 服务用户名，一般为邮箱地址。 SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式 SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、\"Yahoo\"、...... ，全部支持请参考 : Nodemailer Supported services。 — 如这里没有你使用的邮件提供商，请查看自定义邮件服务器 SENDER_NAME : 寄件人名称。 （图略） 设置完环境变量，必须重新部署，邮件提醒功能才会生效 云引擎 —— 设置 —— 云引擎域名（如：jackma），保存 然后进入 存储 —— _User 添加一个用户，只需 User，password，email 三个信息即可。（为了安全考虑，此 email 必须为配置中的 SMTP_USER 或 TO_EMAIL， 否则不允许登录） 此时可以使用定义的主机域名登录后台管理系统了，地址为：[云引擎域名jackma].avosapps.us，用户名为刚设置的邮箱。 LeanCloud 休眠策略 首先需要添加环境变量，ADMIN_URL : 云引擎域名，如：https://jackma.avosapps.us（重启生效） 然后点击【云引擎】【定时任务】【创建定时任务】，按照图片上填写：0 0/20 7-23 * * ? 添加后，要记得点击启用 启用成功后，每 20 分钟在【云引擎】的 - 应用【日志】中可以看到提示 登录上面主机域名进入后台瞅一瞅： 我自己沙发了一条评论 日志提示： 进入后台后可以看到： 同时，我也收到了通知邮件： 至此完成了 Valine 评论系统的添加和完善，喝杯咖啡☕️庆祝一下！ ​ ​ ","date":"2018-12-30","objectID":"/blog-comments-valine-leancloud/:3:1","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"解决：自动唤醒失败 免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行： 每天必须休眠 6 个小时 30 分钟内没有外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。 分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。 使用 cron-job 解决 Valine-admin 因流控原因自动唤醒失败的问题 免费的体验版，基本崩了。 评论提醒功能，可能必须经常手动部署。阅读量仍正常记录，不受牵连。 Valine-admin由于Leancloud流控原因，自动唤醒任务可能会失败 所以这里介绍一个使用第三方计划任务网站进行定时唤醒 Valine-admin 的方法。 ","date":"2018-12-30","objectID":"/blog-comments-valine-leancloud/:4:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"注册 cron-job 帐号 注册地址：https://cron-job.org/en/signup/ 注册时的时区请选择 Asia/Shanghai ","date":"2018-12-30","objectID":"/blog-comments-valine-leancloud/:4:1","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"添加一个计划任务 登陆之后依次点击 Members，cronjobs，Create cronjob Title, Address Title 可以随便填一个 Address 填写你的云引擎环境变量的 ADMIN_URL，也就是Leancloud的Web 主机域名。 Schedule 选择 User-defined 进行自定义设置（按住 Ctrl 可多选） Days of month: 全选 Days of week: 全选 Months: 全选 Hours: 你需要在哪个时间段唤醒就选择什么 （每天强制休眠 6 小时，推荐选 7-23-0 唤醒） Minutes: 选择 0 , 20 , 40 Notifications 可以不用修改，也可以根据自己的需要修改 Common 勾选Save responses, 保存唤醒日志 点击Create cronjob ​ ","date":"2018-12-30","objectID":"/blog-comments-valine-leancloud/:4:2","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"参考 Valine Valine-Admin leancloud-休眠策略 hugo博客添加评论系统Valine 将 Valine 切换至 leancloud 国际版 https://juejin.im/post/6844904175298428941 ","date":"2018-12-30","objectID":"/blog-comments-valine-leancloud/:5:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"hugo 搜索功能 Algolia","date":"2018-05-02","objectID":"/blog-search-algolia/","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"hugo 搜索功能 Algolia ","date":"2018-05-02","objectID":"/blog-search-algolia/:0:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"前言 Hugo是由 Steve Francis 大神（http://spf13.com/）基于Go语言开发的静态网站构建工具。没错你现在看到的本博客就是基于Hugo的，使用 Hugo 创建一个网站是非常简单的，基本上没有什么门槛，官方还提供了大量的主题供你选择，你只需要专心写的文章就行。不过有个问题是搜索，我们知道搜索属于动态行为了，如何给静态网站增加搜索功能呢？当然我们可以使用Google的站内搜索功能，Hugo 官方也提供了一些开源的和商业的解决方案，今天我们要介绍的就是一个非常优秀的商业解决方案：Algolia。 ","date":"2018-05-02","objectID":"/blog-search-algolia/:1:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"注册 前往官方网站https://www.algolia.com/ 使用 GitHub 或 Google 帐号登录。 登录完成后根据提示信息填写一些基本的信息即可。 注册完成后前往 Dashboard，我们可以发现 Algolia 会默认给我们生成一个 app。 默认的 app 可以在 settings → Applications 中重命名 选择 Indices，添加一个新的索引，我这里命名为blog，创建成功后，我们可以看到提示中还没有任何记录。 Algolia 为我们提供了三种方式来增加记录：手动添加、上传 json 文件、API。 ","date":"2018-05-02","objectID":"/blog-search-algolia/:2:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"修改 config.toml 配置 以下内容，基于 Loveit 主题测试生效 [params.algolia] appId = \"你的Application ID\" indexName = \"你的索引名字\" searchOnlyKey = \"你的Search-Only API Key\" 执行 hugo，会自动生成 public/index.json 用于索引 ","date":"2018-05-02","objectID":"/blog-search-algolia/:3:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"上传索引文件 生成索引文件之后，我们需要上传到 Algolia 的服务器。 ","date":"2018-05-02","objectID":"/blog-search-algolia/:4:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"手动上传 这一步是可选的，不过还是建议跟着做一下。 点击侧栏 Indices ，点击 Upload record(s) 按钮上传上一步生成的 index.json 文件。 上传成功之后，我们就可以马上尝试搜索了： 可以看到搜索的关键词有相应的匹配结果，说明我们生成的索引文件是正确的。 ","date":"2018-05-02","objectID":"/blog-search-algolia/:4:1","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"自动上传 每次写完博文都手动上传索引文件无疑是痛苦的、无意义的重复劳动。 因此我们需要把上传索引文件的操作自动化，在自动部署的时候顺便完成即可。 这里我们采用npm包 atomic-algolia 来完成上传操作。 安装 atomic-algolia 包 npm install atomic-algolia --save 修改根目录下的 package.json 文件（没有就新建），在 scripts 下添加 \"algolia\": \"atomic-algolia\" { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } 注意 \"test\" 那一行末尾有个英文逗号，不要漏了。 根目录下新建 .env 文件，内容如下： ALGOLIA_APP_ID=你的Application ID ALGOLIA_INDEX_NAME=你的索引名字 ALGOLIA_INDEX_FILE=public/index.json ALGOLIA_ADMIN_KEY=你的Admin API Key 注意替换你自己 Algolia 索引的信息。 另外特别注意 ALGOLIA_ADMIN_KEY 可以用来管理你的索引，所以尽量不要提交到公共仓库。可以添加到 .gitignore 中 上传索引的命令 你可以本地执行 npm run algolia 查看运行效果： 可以看到我们成功添加了记录。 后续，可以把下面的命令加到你的部署脚本中： npm run algolia // 在hugo命令后面执行 ","date":"2018-05-02","objectID":"/blog-search-algolia/:4:2","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"参考资料 Hugo添加Algolia搜索支持 atomic-algolia 插件 Hugo 集成 Algolia 搜索 ","date":"2018-05-02","objectID":"/blog-search-algolia/:5:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["HTML 入门"],"content":"❤️ 🧡 💛 💚 💙 💜","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"记录几个标签的简单用法，然后忘掉 🤪 ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:0:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"a 标签 特别常用，但很多人不会用 😳😳 属性 href target download rel=noopener 面试可能会问 作用 跳转外部页面 跳转内部锚点 跳转到邮箱或电话等 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:1:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"href href 是 Hypertext REFerence 超链接 发音 ：应该读 H-Ref /ˈeit∫.rɛf/ href 的取值 网址 https://google.com http://google.com //google.com 【推荐写这种形式】 network 会先请求 http://google.com → http://www.google.com → https://www.google.com 结束 路径 使用 hs 开启服务的目录，就是 /a/b/c 的根目录 双击打开文件，访问的路径是硬盘的根目录 file /a/b/c 以及 a/b/c index.html 以及 ./index.html \u003ca href=\"/a/b/c.html\"\u003ec.html\u003c/a\u003e \u003ca href=\"./index.html\"\u003eindex.html\u003c/a\u003e 伪协议 javascript:代码; \u003ca href=\"javascript:alert(1);\"\u003e\u003c/a\u003e \u003c!--执行js操作：弹出1--\u003e \u003ca href=\"javascript:;\"\u003e\u003c/a\u003e \u003c!--只有这种是什么都不做--\u003e \u003ca href=\"\"\u003ehref为空，页面会刷新\u003c/a\u003e \u003c!--如果有input会被清空--\u003e \u003ca href=\"#\"\u003e#不刷新，但页面会滚动到顶部\u003c/a\u003e 补充：编译器中 p{$}*30 + tab ，会生成 30 个 p 标签，内容 1-30 mailto:邮箱 移动端，通常会直接呼出发邮件的界面，并自动填写收件人邮箱 \u003ca href=\"mailto:ryuukousen@gmail.com\"\u003e给他发邮件\u003c/a\u003e tel:手机号 移动端，直接呼出拨号盘，并自动填写号码 \u003ca href=\"tel:13912345678\"\u003e\u003c/a\u003e id 锚点 跳转到指定标签 href=#xxx \u003ca href=\"#xxx\"\u003e查看aaa\u003c/a\u003e ... \u003cp id='xxx'\u003eaaa\u003c/p\u003e ... ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:1:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"target 在哪个页面打开窗口 内置名字 _blank ：新窗口 _top ：顶级窗口（结合 iframe） _parent ：父级窗口（结合 iframe） _self ：当前窗口（默认值） 程序员命名 window 的 name \u003ca href=\"//google.com\" target=\"asdf\"\u003egoogle\u003c/a\u003e \u003ca href=\"//baidu.com\" target=\"asdf\"\u003ebaidu\u003c/a\u003e target=asdf，表示如果有这个asdf窗口就在这个窗口打开google，如果没有就创建一个新的窗口命名为asdf 控制台输出 window.name 可知当前窗口的名称 iframe 的 name 可以写一个搜索引擎的集合或切换，goodbai 谷歌已经禁用了在 iframe 中引入 \u003ca href=\"//google.com\" target=\"asd\"\u003egoogle\u003c/a\u003e \u003ca href=\"//baidu.com\" target=\"qwe\"\u003ebaidu\u003c/a\u003e \u003ciframe src=\"\" name=asd\u003e\u003c/iframe\u003e \u003ciframe src=\"\" name=qwe\u003e\u003c/iframe\u003e ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:1:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"download 绝大多数浏览器不支持，chrome 不支持 \u003ca href=\"//google.com\" download\u003e下载页面\u003c/a\u003e 作用 不是打开页面，而是下载页面 问题 不是所有浏览器都支持，尤其是手机浏览器可能不支持 ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:1:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"iframe 内嵌窗口 已经很少使用了，还有些老系统再用。新的方式是通过 ajax 实现 \u003ciframe name=\"a\" src=\"a-target-iframe.html\" frameborder=\"0\"\u003e\u003c/iframe\u003e ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:2:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"table ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:3:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"相关标签 thead、tbody、tfoot，即使开发时换了顺序，浏览器识别时仍会按照 head body foot 的顺序解析渲染 table thead tbody tfoot tr td th 一个表头的表格 \u003ctable\u003e \u003cthead\u003e \u003c!-- tr: table row 行--\u003e \u003ctr\u003e \u003c!-- th: table head 表头--\u003e \u003cth\u003e英语\u003c/th\u003e \u003cth\u003e翻译\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003c!-- td: table data 数据 --\u003e \u003ctd\u003ehyper\u003c/td\u003e \u003ctd\u003e超级\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003etarget\u003c/td\u003e \u003ctd\u003e目标\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003ereference\u003c/td\u003e \u003ctd\u003e引用、链接\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003ctfoot\u003e \u003ctr\u003e \u003ctd\u003e空\u003c/td\u003e \u003ctd\u003e空\u003c/td\u003e \u003c/tr\u003e \u003c/tfoot\u003e \u003c/table\u003e 两个表头的表格 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003e小红\u003c/th\u003e \u003cth\u003e小明\u003c/th\u003e \u003cth\u003e小颖\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003cth\u003e数学\u003c/th\u003e \u003ctd\u003e61\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e92\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e语文\u003c/th\u003e \u003ctd\u003e61\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e92\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e英语\u003c/th\u003e \u003ctd\u003e61\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e92\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003ctfoot\u003e \u003ctr\u003e \u003cth\u003e总分\u003c/th\u003e \u003ctd\u003e200\u003c/td\u003e \u003ctd\u003e200\u003c/td\u003e \u003ctd\u003e200\u003c/td\u003e \u003c/tr\u003e \u003c/tfoot\u003e \u003c/table\u003e ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:3:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"相关样式 table-layout auto【默认】：根据单元格中的内容数量，计算单元格宽度 fixed：单元格宽度尽量平均 inherit initial unset border-spacing 设定每个单元格的间隙 \u003cstyle\u003e table{ width: 600px; table-layout: auto; border-spaceing: 10px; } td,th{ border: 1px solid blue; } \u003c/style\u003e border-collapse 通常用于 去掉单元格间隙 \u003cstyle\u003e table{ width: 600px; table-layout: auto; border-collapse: collapse; /* 去掉单元格间隙 */ border-spaceing: 0; /* 去掉单元格间隙 */ } td,th{ border: 1px solid blue; } \u003c/style\u003e 下面这两句常被写进 reset.css 中 border-collapse: collapse; /* 去掉单元格间隙 */ border-spaceing: 0; /* 去掉单元格间隙 */ ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:3:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"img 标签 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"作用 发出 get 请求，展示一张图片 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"属性 alt：全称是可替换的，当图片加载失败，会显示 alt 的值 height：只设置 height ，宽度自适应 width：只设置 width ，高度自适应 同时设定，height 和 width，图片可能变形 永远不要让图片变形 src：全称 source ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"事件 onload/onerror \u003cimg id=\"xxx\" width=\"400\" src=\"dog.jpg\" alt=\"一只狗子\"\u003e \u003cscript\u003e xxx.onload = function(){ console.log(\"图片加载成功\"); } xxx.onerror=function(){ console.log(\"图片加载失败\"); xxx.src = \"/404.jpg\"; // 挽救：图片加载失败，展示404图，放在项目中 } \u003c/script\u003e ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"响应式 max-width:100% \u003cstyle\u003e *{ margin:0; padding:0; box-sizing: border-box; } img{ max-width: 100%; /* 图片是响应式的，尺寸永远满足各种窗口大小 */ } \u003c/style\u003e ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:4","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"可替换元素 https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element 考试可能会问，被问概率30% ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:5","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"form 标签 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:5:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"作用 发 get 或 post 请求，然后刷新页面 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:5:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"属性 \u003cform action=\"/xxx\" method=\"POST\"\u003e \u003cinput type=text /\u003e \u003cinput type=submit /\u003e \u003c/form\u003e action 默认需要给一个 action ，就是发送请求的目标地址（HTTP相关）、请求某一个页面的页面地址 需要有后台给我们提供这个地址 method method 属性控制用 GET 还是 POST 来发送请求 autocomplete 自动填写 autocomplete: on / off target 提交到哪个页面：新开页面、当前页面、iframe 与 a 标签写法一致 _blank top ：顶级窗口（结合 iframe） _parent ：父级窗口（结合 iframe） _self ：当前窗口（默认值） window.name \u003ciframe name=xxx\u003e\u003c/iframe\u003e \u003cform action=\"/xxx\" method=\"POST\" autocomplete=\"off\" target=\"a\"\u003e \u003cinput type=text /\u003e \u003cinput type=submit /\u003e \u003c/form\u003e \u003ciframe name=\"a\" src=\"a-target-iframe.html\" frameborder=\"0\"\u003e\u003c/iframe\u003e ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:5:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"事件 onsubmit：用户点击提交会触发这个事件 ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:5:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"type=submit form 中的 button 如果没有指定 type 类型，默认是 type=submit 的，点击 button 就会提交 form 表单。如果指定了其他类型，例如 type=button，按钮就不能提交表单。 一个 form 表单中，必须要有一个 type=submit 的 input 或 button ，才能提交表单。 ​ 修改submit按钮文字 \u003cinput type=\"submit\" /\u003e \u003cinput type=\"submit\" value=\"搞起\" /\u003e ​ submit 按钮的 input 和 button 的区别 \u003cinput type=\"submit\" value=\"搞起\" /\u003e \u003cbutton type=\"submit\"\u003e搞起\u003cbutton\u003e 区别是： input按钮中，不能再添加内容 button按钮中还可以再添加标签内容 \u003cbutton\u003e \u003cstrong\u003e搞起\u003c/strong\u003e \u003cimg src=\"dog.jpg\" alt=\"狗子\"\u003e \u003c/button\u003e ​ ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:5:4","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"input 标签 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:6:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"作用 让用户输入内容 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:6:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"属性 类型 type: button/checkbox/email/file/hidden/ number/password/radio/ search/submit/tel/text \u003cinput type=\"text\" /\u003e \u003cinput type=\"color\" /\u003e \u003cinput type=\"password\" /\u003e \u003cinput type=\"radio\" name=\"gender\" /\u003e男 \u003c!--同一组，取相同的name--\u003e \u003cinput type=\"radio\" name=\"gender\" /\u003e女 \u003cinput type=\"checkbox\" name=\"hobby\" /\u003e唱 \u003c!--同一组，取相同的name--\u003e \u003cinput type=\"checkbox\" name=\"hobby\" /\u003e跳 \u003cinput type=\"checkbox\" name=\"hobby\" /\u003erap \u003cinput type=\"checkbox\" name=\"hobby\" /\u003e篮球 \u003cinput type=\"file\" multiple/\u003e 看不见我吧：\u003cinput type=\"hidden\"\u003e \u003c!-- 通常用于js自动获取并填入 --\u003e \u003ctextarea style=\"resize: none;width:50%;height:50px\"\u003e\u003c/textarea\u003e \u003c!--禁止改变大小--\u003e \u003cselect name=\"\" id=\"\"\u003e \u003coption value=\"\"\u003e-请选择-\u003c/option\u003e \u003coption value=\"1\"\u003e星期一\u003c/option\u003e \u003coption value=\"2\"\u003e星期二\u003c/option\u003e \u003c/select\u003e 其他 （js内容） name/autofocus/checked/disabled/ maxlength/pattern/value/placeholder ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:6:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"事件 （js内容） onchange ：用户改变内容触发 onfocus：用户聚焦时触发 onblur ：用户失焦时触发 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:6:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"验证器 （js内容） HTML5新增功能：自带验证 例： \u003cinput type=\"text\" require/\u003e \u003cinput type=\"password\" require/\u003e ​ ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:6:4","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"其他输入标签 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:7:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"标签 （js内容） select + option textarea label ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:7:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"注意事项 一般不监听 input 的 click 事件 form 里面的 input 都要有 name form 里要放一个 type=submit 才能触发 submit 事件 ​ ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:7:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"补充工具：开启 http 服务 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:8:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"http-server 安装 yarn global add http-server 使用 http-server . -c-1 http-server -c-1 hs -c-1 -c 缓存，-c-1 不要缓存 . 可以省略 http-server 可缩写成 hs 按住ctrl + 点击打开任意链接。地址栏追加 html 文件名，即可浏览 ctrl + C 中断服务器 ​ ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:8:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"parcel 操作更简便 好像有bug ：ctrl + c 无法中断 yarn global add parcel // 安装 parcel a-href.html // 使用 ","date":"2017-07-16","objectID":"/html-a-simple-record-of-html-tags/:8:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"😎💋","date":"2017-07-16","objectID":"/html-introduction/","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"HTML (HyperText Markup Language) 不是一门编程语言，而是一种用来告知浏览器如何组织页面的标记语言。😎💋 HTML 可复杂、可简单，一切取决于开发者。 它由一系列的元素（elements）组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 一对标签（ tags）可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。 ​ ","date":"2017-07-16","objectID":"/html-introduction/:0:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"HTML 是谁发明的 HTML 之父 ","date":"2017-07-16","objectID":"/html-introduction/:1:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"1990年左右诞生 Tim Berners-Lee，称之为李爵士 2004年，英女皇他颁发大英帝国爵级司令勋章 2017年，被颁发图灵奖 ","date":"2017-07-16","objectID":"/html-introduction/:1:1","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"李爵士做了啥？ 自己写了第一个浏览器 自己写了第一个服务器 用自己写的浏览器访问了自己写的服务器 发明了WWW，同时发明了HTML、HTTP和URL ​ ","date":"2017-07-16","objectID":"/html-introduction/:1:2","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"HTML 起手式怎么写 快捷键：感叹号 ! + tab \u003c!DOCTYPE html\u003e ← 文档类型 \u003chtml lang=\"en\"\u003e ← 页面根标签 \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e ← 文件的字符编码 \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e ← 防止页面缩放 \u003cmeta http-equiv\"X-UA-Compatible\" content=\"ie=edge\"\u003e ← 如果在IE打开，告诉IE使用最新内核（IE11） \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e DOCTYPE：文档类型 浏览器支持很多种文档类型（HTML、XHTML…）。 \u003c!DOCTYPE html\u003e 表示告诉浏览器开始写HTML了。 html 标签是根标签 必须要写（如果没写也会自动加上） 可以把 lang 的属性值改为 zh-CN head 和 body 标签，虽然是 html 的子元素，但一般格式上不缩进 head 标签里面存放看不见的元素 viewport 视口、视窗 ​ ","date":"2017-07-16","objectID":"/html-introduction/:2:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"章节标签 章节标签，通常用于表示文章、书的层级（就是内容框架） 标题 h1~h6 章节 section 文章 article 段落 p 头部 header 脚部 footer 主要内容 main 旁支内容 aside 划分 div \u003cbody\u003e \u003cheader\u003e顶部广告\u003c/header\u003e \u003cdiv\u003e \u003cmain\u003e \u003ch1\u003e文章标题\u003c/h1\u003e \u003csection\u003e \u003ch2\u003e第一章\u003c/h2\u003e \u003cp\u003e 一段话一段话一段话一段话一段话一段话一段话一段话一段话一段话一段话 \u003c/p\u003e \u003csection\u003e \u003ch3\u003e1.1 节\u003c/h3\u003e \u003cp\u003e一段话\u003c/p\u003e \u003c/section\u003e \u003csection\u003e \u003ch3\u003e1.2 节\u003c/h3\u003e \u003cp\u003e一段话\u003c/p\u003e \u003c/section\u003e \u003c/section\u003e \u003c/main\u003e \u003caside\u003e 参考资料 1 2 3 \u003c/aside\u003e \u003c/div\u003e \u003cfooter\u003e\u0026copy; xxx版权所有\u003c/footer\u003e \u003c/body\u003e ​ ​ ","date":"2017-07-16","objectID":"/html-introduction/:3:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"全局属性 任何标签都可以有的属性 ​ ","date":"2017-07-16","objectID":"/html-introduction/:4:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"class ： 类名 \u003cstyle\u003e ← style标签也有contenteditable 属性，可以被编辑 [class=middle]{ /* 早期写法--缺点：当一个标签存在多个类名，就无法通过匹配单个类名来找到这个标签 */ background: black; color: white; } .middle{ /* 简写 */ background: black; color: white; } \u003c/style\u003e ​ ","date":"2017-07-16","objectID":"/html-introduction/:4:1","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"contenteditable ：让标签可以被编辑 style标签，也有 contenteditable 属性，可以被编辑 可以将 style 标签放到 body里面，然后添加 style { display : block; } ，style 标签中的样式内容就会显示在浏览器中，然后给style标签添加contenteditable 属性，就可以在浏览器总直接修改样式，并实时刷新 \u003cbody\u003e \u003cstyle contenteditable\u003e style{ display: block; } .xxx{ border: 10px solid orange; } \u003c/style\u003e \u003cp class=\"xxx\" contenteditable\u003e这段话可以直接在浏览器中编辑修改内容\u003c/p\u003e \u003c/body\u003e contenteditable\" contenteditable ​ ","date":"2017-07-16","objectID":"/html-introduction/:4:2","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"hidden ：让标签隐藏 \u003ch1 class=\"title\" hidden\u003e\u003c/h1\u003e .title{ display: block /* 直接添加属性hidden而隐藏的元素，可以通过设置样式 display: block，再显示回来 */ } ​ ","date":"2017-07-16","objectID":"/html-introduction/:4:3","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"id ：全局唯一 id 用来表示【全局唯一的标签】 id 的全局唯一性没有保障，就算有两个重复的 id，HTML 也不会提示我写错了 class足够了，不到万不得已不要用 id ，因为 id 重复使用也不会报错，可能误导开发者 \u003cheader id=\"xxx\"\u003e\u003c/header\u003e \u003cdiv id=\"xxx\"\u003e\u003c/div\u003e #xxx{ /* 此时设置的样式会同时对两个id=xxx元素生效，id被重复使用不会报错，那id的唯一性就毫无意义了 */ } id 中有很多不能使用的词：parent、self、top … 控制台输入 window. 弹出属性列表中所有的词都不能用，因为这些词是 window 已经有的全局属性 \u003cheader id=\"top\"\u003e\u003c/header\u003e \u003cscript\u003e top.style.border=\"10px solid red\" // 直接调用不能获取到top元素，与window对象中的全局属性重名 var ele = document.getElementById(\"top\") // 通过这种方式可以获取到 top 元素，但单词略复杂 \u003c/script\u003e ​ ","date":"2017-07-16","objectID":"/html-introduction/:4:4","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"style ：行内样式 \u003cdiv style=\"border: 10px solid red\" id=\"a\"\u003e\u003c/div\u003e js 中写 a.style.border = \"100px solid green\" 会覆盖 div元素中的行内样式 ​ ","date":"2017-07-16","objectID":"/html-introduction/:4:5","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"tabindex ：顺序 在浏览页面时，网页中按钮都只通过键盘 tab 控制切换选中。而这里的 tabindex 属性就是控制，切换的顺序 被选中的会有一圈不明显的蓝色边框 \u003ca tabindex=1\u003e首页\u003c/a\u003e \u003cp tabindex=3\u003e一段话\u003c/p\u003e \u003cfooter tabindex=2\u003e\u0026copy;版权所有\u003c/footer\u003e tabindex 可以是正数，不必是连续的 tabindex 可以是 0，表示最后才被 tab 访问 tabindex 可以是 -1，表示不可被 tab 访问 ​ ","date":"2017-07-16","objectID":"/html-introduction/:4:6","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"title ：鼠标指向时显示的内容 单行文字溢出，使用省略号 将鼠标移动到这段文字上时，应该能展示出全部文字内容，包括溢出隐藏的部分 \u003cp class=\"xxx\" title=\"显示一段超长的话\"\u003e一段超长的话\u003c/p\u003e \u003cstyle\u003e .xxx { text-overflow: ellipsis; /* 超出部分用省略号 */ overflow: hidden; /* 超出隐藏 */ white-space: nowrap; /* 不换行 */ } \u003c/style\u003e ​ ​ ","date":"2017-07-16","objectID":"/html-introduction/:4:7","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"内容标签 ","date":"2017-07-16","objectID":"/html-introduction/:5:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"ol+li ordered list + list item ol ：有序列表 ol 不能含有 li 之外的任何元素、字符 ","date":"2017-07-16","objectID":"/html-introduction/:5:1","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"ul+li unordered list + list item ul ：无序列表 ","date":"2017-07-16","objectID":"/html-introduction/:5:2","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"dl+dt+dd description list + term + data dl ：description list —— 描述列表 dt ：description term —— 描述项 dd ：猜测是 description data —— 描述信息 ","date":"2017-07-16","objectID":"/html-introduction/:5:3","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"pre preview 的缩写 用的较少 html 特点：HTML 代码里的多处空格、回车、tab 等内容，默认会被转化为一个空格 pre 的作用是，可以保留开发者键入的空白位置（pre 有默认样式，很丑，如下） pre\" pre ","date":"2017-07-16","objectID":"/html-introduction/:5:4","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"code 等宽字体 用 code 标签包裹的内容，字符是等宽的。但默认内容在同行展示，无法换行 使用 pre 可以让 code 的内容换行 code \u0026 pre+code\" code \u0026 pre+code ","date":"2017-07-16","objectID":"/html-introduction/:5:5","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"hr 水平分割线 horizontal ","date":"2017-07-16","objectID":"/html-introduction/:5:6","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"br break 的缩写 换行 ​ ","date":"2017-07-16","objectID":"/html-introduction/:5:7","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"a anchor 的缩写 超链接 href target 国内开发习惯使用 _blank 在新标签打开链接。 国外开发通常不写 target，他们觉得会让浏览器网页越开越多（他们习惯：通过鼠标中间点击打开新标签页，默认左键点击同屏跳转） ","date":"2017-07-16","objectID":"/html-introduction/:5:8","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"em emphasis 的缩写 emphasis 意为强调，效果字体斜体 ​ ","date":"2017-07-16","objectID":"/html-introduction/:5:9","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"strong 字体加粗 表示重要 ​ ","date":"2017-07-16","objectID":"/html-introduction/:5:10","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"q quote 的缩写 quote 意为引用 quote标签：内联，行内，不换行 ​ ","date":"2017-07-16","objectID":"/html-introduction/:5:11","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"blockquote 引用 块级，换行 quote \u0026 blockquote\" quote \u0026 blockquote ","date":"2017-07-16","objectID":"/html-introduction/:5:12","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["个人博客的创建之路"],"content":"个人博客绑定域名","date":"2017-07-15","objectID":"/blog-buy-setup-a-domain/","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"买个域名玩玩！ ","date":"2017-07-15","objectID":"/blog-buy-setup-a-domain/:0:0","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"个人博客绑定域名 ","date":"2017-07-15","objectID":"/blog-buy-setup-a-domain/:1:0","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"购买域名 namesilo （方便、无需填写个人真实信息）和阿里云（中文、可能需要实名填写详细信息） namesilo 进入官网，搜索并选中需求的域名（domain），进行注册 支付，使用支付宝，需设置支付宝邮箱 购买成功后，等待跳转。邮箱也会收到购买成功的邮件。 每年需要续费，不续费，会有一个保护期，保护期过了，域名就重新开放购买 点击 Manage my Domains 【管理我的域名】。 初次进入可能需要填写基本信息。点击 create my new account。只要保证当前账户邮箱是真实的即可 在域名管理页面，点击蓝色圆形按钮，可以进入 【Manage DNS】 管理DNS页面 ​ 阿里云 进入官网，注册一个账户，国内账户通常需要提供真实的手机号/姓名/身份证等。 在【域名与网站】选项卡中，选择【域名注册】；或者直接在搜索框进入【域名 控制台】选择【域名注册】 搜索域名，加入清单，结算 个人 or 企业 填写 [个人] 信息 支付 ​ ","date":"2017-07-15","objectID":"/blog-buy-setup-a-domain/:1:1","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"配置 GitHub Pages 添加域名 找到 github pages 中的 custom domain ，添加域名，SAVE 保存 仓库会多出一个 CNAME 文件，记录配置的域名 注意：不勾选 Enforce HTTPS。现在不用开启 HTTPS（不开启比较方便测试） 勾选后，所有与当前仓库相关的页面，可能都需要变成 https，可能还需要申请免费证书之类的，hin麻烦 ​ ","date":"2017-07-15","objectID":"/blog-buy-setup-a-domain/:1:2","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"配置 DNS 最终效果是，让 4个A记录出现在域名的DNS管理页面中，就搞定了 配置四条 A 记录 找到 github pages 中的 custom domain ，点击 Learn more ，找到【配置 apex 域】 找到 4 个IP，配置到域名中 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 namesilo 配置 A 记录 （点击蓝色圆形按钮）进入某个域名的管理页面，点击选择 A 会生成一个配置，然后依次将4个IP 多填入提交，生成4条配置。只保留这4条配置，将其他默认存在的配置删除即可，默认提供的配置都是没用的 阿里云 配置 A 记录 基本同 namesilo 在域名DNS解析中，添加 4 条 A 记录 IP 下拉框选择 @ ​ 测试DNS是否配置成功 打开命令行，运行nslookup liubingxuan.xyz 命令行能打印出4条A记录的IP，就说明配置的DNS生效了 刚配置完可能没法立即生效，需要等待（可能半小时、一天或更久，只能等，听天由命😢 ） Windows 用户：nslookup 域名 Mac 用户：dig + noall + answer 域名 A 记录可能要很久才会生效，等就好了 ​ ","date":"2017-07-15","objectID":"/blog-buy-setup-a-domain/:1:3","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"tip 如果要放弃域名方案 😭 把仓库中的 CNAME文件（自定义域名） 删掉。settings 中 custom domain 也删掉。 ","date":"2017-07-15","objectID":"/blog-buy-setup-a-domain/:1:4","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"如何用 hugo 搭建个人博客","date":"2017-07-14","objectID":"/blog-start-a-hugo/","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"第一篇正式博文，我想给大家分享下我的博客的创建过程吧！🥇 ​ Hugo 是由 Go 语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 ​ ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:0:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"安装 Hugo 官方教程 英文 Mac 安装方式 brew install hugo hugo version Windows 安装方式 去 Hugo releases 页面 下载 hugo_xxx_Windows- 64bit.zip 解压，把 hugo.exe 放到 D:\\Software\\hugo\\hugo.exe 把 D:\\Software\\hugo\\ 加到 PATH 重启终端，运行 hugo version 查看版本 ​ ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:1:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"快速搭建博客 官方文档教程，必看！ ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:2:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"准备、提交 新建 blog 目录，运行 hugo new site xxx.github.io-generator ， xxx 为 github 用户名 。会在当前目录中创建 xxx.github.io-generator 文件夹（博客生成器） 进入博客生成器目录，git init 选择并下载主题 ，放到 themes 目录下 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 遇到报错 ↘ fatal: unable to access 'https://github.com/dillonzq/LoveIt.git/': error setting certificate verify locations: CAfile: D:/Software/Git/mingw64/ssl/certs/ca-bundle.crt CApath: none 解决办法：使用 git clone 出现 fatal: unable to access 'https://github.com/...' ，执行代码 ​↓ git config --system http.sslverify false // 把证书校验禁用 然后，将主题添加到站点配置中：echo 'theme = \"LoveIt\"' \u003e\u003e config.toml // 主题目录的名称 创建新文章：hugo new posts/first_post.md D:\\blog\\xxx.github.io-generator\\content\\posts\\first_post.md created 编辑文章后，修改 draft: false。draft : true 表示处于草稿状态，此时Hugo不会真正发布它 初次创建博客或修改主题，需将主题文档中给出的配置，粘贴到 config.toml 文件中。 baseURL 配置成 http://[用户名].github.io/ hugo server -D 建立本地访问 https://localhost:1313 预览博客 hugo 创建一个新的目录 public/，这就是需要提交到 github，最终生成线上博客的目录 根目录下，新建 .gitignore 文件，添加 /public/。使得 /public 可以自成一个仓库 进入public cd public，git init git add . git commit ​ ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:2:1","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"第一次部署 登录 github，创建博客专用仓库，仓库名必须为 ： [用户名].github.io 。 进入 public 目录，git remote add origin xxx git push -u origin master 进入 github 博客仓库的 Settings，找到 GitHub Pages ，选择 master ，保存 通过 http://[用户名].github.io 就能访问博客 ​ ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:2:2","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"以后的部署 在 xxx.github.io-creator 目录（注意确保自己不在 public 目录）里运行 hugo new posts/第二篇博客.md 运行 code posts/第二篇博客.md 对文件进行编辑，注意不要把文件原本的内容 front matter 给删了，直接在后面另起一行写新内容。 hugo server -D 建立本地访问 https://localhost:1313 预览博客 运行 hugo -D，得到新的 public 目录 进入 public 目录 cd public，执行一下操作 git add . 注意有一个点 git commit -m update git push -f 其中 -f 是强制上传的意思 等待几分钟后，你的博客就会出现第二篇文章了！ 通过 http://[用户名].github.io 访问博客 ​ ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:2:3","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"备份博客生成器 generator 程序员永远都会留备份 新建仓库 xxx.github.io-generator 将本地 xxx.github.io-generator 目录，git init，git add . ，git commit -m backup，git remote add origin xxx，git push -u origin master 即可 如果在执行 add 时，提示我们需要执行 rm 操作，可能是因为主题目录下已经存在 .git 文件，主题目录本身就是一个本地仓库了，那和 generator 目录会形成一个嵌套子目录的关系，that’s not good . 我们需要把主题目录下的 .git 文件删除 如果嵌套了，可以创建 .gitignore 文件。把【嵌套的子目录】添加到【.gitignore】中，忽略不上传 ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:3:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"网站基础配置 ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:4:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"网站 ico 图标配置 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在根目录下的 /static 目录中。利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件。 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color 。 ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:4:1","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"域名配置 博客根目录下的 /static 目录中，新建文件 CNAME 无后缀，填入域名 touch CNAME echo \"[你的域名]\" \u003e\u003e CNAME 执行 hugo ，会在 public 目录下生成 CNAME 文件。 push 到 github 后，会自动识别 CNAME 文件中的域名，填入 Github pages 的 custom domain 中，就无需手动配置域名啦！👍 ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:4:2","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"头像配置 博客根目录下的 /assets/images 目录中，存放名为 avatar.png 的图片。 执行 hugo，会在 public/images 目录下生成 avatar.png。push 到 github 后，网站会自动识别 avatar.png 作为网站头像 ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:4:3","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"文章 Front-matter 配置 title: \"主标题\" subtitle: \"这里是副标题\" draft: false #是否为草稿 weight: 1 #表示置顶。数字越小，文章越靠前 toc: auto: false # true自动收放，false全部展开不能收缩 author: \"Sam\" authorLink: \"https://liubingxuan.xyz/\" #设置作者名的链接 description: \"这里是文章描述。可在鼠标悬停文章封面图时显示此处内容\" license: \"转载请注明出处\" images: [] # 页面图片, 用于 Open Graph 和 Twitter Cards. tags: [\"标签1\",\"标签2\"] categories: [\"文章所处的大分类\"] #featuredImagePreview: \"https://i.loli.net/2020/07/15/QY8Ac1ojVqtl9XB.png\" 指定封面图网络地址 #featuredImage: \"https://i.loli.net/2020/07/15/QY8Ac1ojVqtl9XB.png\" resources: - name: \"featured-image\" # 指定文章内顶部封面图 src: \"featured-image.jpg\" - name: \"featured-image-preview\" # 指定文章在首页显示的封面图。可省略并默认使用featured-image src: \"featured-image-preview.jpg\" hiddenFromHomePage: false # 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: false # 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: false #如果设为 true, 这篇文章会使用 twemoji. lightgallery: true # 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: true # 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: true # 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: true # 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: true #如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: false #如果设为 true, 在 RSS 中将会显示全文内容. # ...... 更多配置，详见 Hugo 文档、Front Matter ","date":"2017-07-14","objectID":"/blog-start-a-hugo/:4:4","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":null,"content":"Every Day is A New Beginning. Stay Simple, Stay Young 🎉","date":"2017-07-13","objectID":"/celebration/","tags":["开博纪念"],"title":"【置顶】开博纪念🥰","uri":"/celebration/"},{"categories":null,"content":"Come on, G！🎉🎉 💪 Life is simply about getting hit over and over :) Never put off till tomorrow what you can do today :) You can make IT :) ","date":"2017-07-13","objectID":"/celebration/:1:0","tags":["开博纪念"],"title":"【置顶】开博纪念🥰","uri":"/celebration/"}]