[{"categories":["JS编程接口"],"content":"jQuery API 汇总","date":"2020-10-25","objectID":"/dom-jquery-api/","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:0:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"如何获取和使用 jQuery jQuery 的官方网址是：http://jQuery.com/，从这里可以获取 jQuery 的最新版本。 使用的话，就是导入这份 js 文件。 导入方式是在页面，通过\u003cscript\u003e标签导入 \u003cscript type=\"text/javascript\" src=\"jQuery.js\"\u003e\u003c/script\u003e 导入之后，就可以使用 jQuery 的语法了。 ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:1:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"jQuery 版本 1.x：兼容IE678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日) 2.x：不兼容IE678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日) 3.x：不兼容IE678，只支持最新的浏览器。需要注意的是很多老的 jQuery 插件不支持3.x版。目前该版本是官方主要更新维护的版本。 维护IE678是一件让人头疼的事情，一般我们都会额外加载一个CSS和JS单独处理。值得庆幸的是使用这些浏览器的人也逐步减少，PC端用户已经逐步被移动端用户所取代，如果没有特殊要求的话，一般都会选择放弃对678的支持。 ","date":"2020-10-25","objectID":"/dom-jquery-api/:2:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"jQuery 对象 jQuery 对象就是通过 jQuery 包装DOM对象后产生的对象。 jQuery 对象是 jQuery 独有的。 如果一个对象是 jQuery 对象，那么它就可以使用 jQuery 里的方法：例如 $('#i1').html() 。 $(\"#i1\").html() // 意思是: 获取id值为 i1 的元素的 html 代码。其中 html() 是 jQuery 里的方法。 // 相当于： document.getElementById(\"i1\").innerHTML; 虽然 jQuery 对象是包装 DOM 对象后产生的，但是 jQuery 对象无法使用 DOM 对象的任何方法，同理 DOM对象也没不能使用 jQuery 里的方法。 一个约定，我们在声明一个 jQuery 对象变量的时候在变量名前面加上$： let $variable = jQuery 对像 let variable = DOM对象 $variable[0] // jQuery 对象转成DOM对象 拿上面那个例子举例， jQuery 对象和 DOM 对象的使用： $(\"#i1\").html(); // jQuery 对象可以使用 jQuery 的方法 $(\"#i1\")[0].innerHTML // DOM对象使用DOM的方法 ​ ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:3:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"一、选择网页元素 jQuery 的基本设计思想和主要用法，就是\"选择某个网页元素，然后对其进行某种操作”。这是它区别于其他Javascript库的根本特点。 使用 jQuery 的第一步，往往就是将一个选择表达式，放进构造函数 jQuery ()（简写为$），然后得到被选中的元素。 选择表达式可以是CSS选择器： $(document) //选择整个文档对象 $('#myId') //选择ID为myId的网页元素 $('div.myClass') // 选择class为myClass的div元素 $('input[name=first]') // 选择name属性等于first的input元素 ​ 也可以是 jQuery 特有的表达式： $('a:first') //选择网页中第一个a元素 $('tr:odd') //选择表格的奇数行 $('#myForm :input') // 选择表单中的input元素 $('div:visible') //选择可见的div元素 $('div:gt(2)') // 选择所有的div元素，除了前三个 $('div:animated') // 选择当前处于动画状态的div元素 ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:4:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"二、改变结果集 jQuery 设计思想之二，就是提供各种强大的过滤器，对结果集进行筛选，缩小选择结果。 $('div').has('p'); // 选择包含p元素的div元素 $('div').not('.myClass'); //选择class不等于myClass的div元素 $('div').filter('.myClass'); //选择class等于myClass的div元素 $('div').first(); //选择第1个div元素 $('div').eq(5); //选择第6个div元素 ​ 有时候，我们需要从结果集出发，移动到附近的相关元素， jQuery 也提供了在DOM树上的移动方法： $('div').next('p'); //选择div元素后面的第一个p元素 $('div').parent(); //选择div元素的父元素 $('div').closest('form'); //选择离div最近的那个form父元素 $('div').children(); //选择div的所有子元素 $('div').siblings(); //选择div的同级元素 ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:5:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"三、链式操作 jQuery 设计思想之三，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如： $('div').find('h3').eq(2).html('Hello'); ​ 分解开来，就是下面这样： $('div') //找到div元素 .find('h3') //选择其中的h3元素 .eq(2) //选择第3个h3元素 .html('Hello'); //将它的内容改为Hello 这是 jQuery 最令人称道、最方便的特点。它的原理在于每一步的 jQuery 操作，返回的都是一个 jQuery 对象，所以不同操作可以连在一起。 jQuery 还提供了.end()方法，使得结果集可以后退一步： $('div') .find('h3') .eq(2) .html('Hello') .end() //退回到选中所有的h3元素的那一步 .eq(0) //选中第一个h3元素 .html('World'); //将它的内容改为World ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:6:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"四、元素的操作：取值和赋值 操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。 jQuery 设计思想之四，就是使用同一个函数，来完成取值（getter）和赋值（setter），即\"取值器\"与\"赋值器\"合一。到底是取值还是赋值，由函数的参数决定。 $('h1').html(); //html()没有参数，表示取出h1的值 $('h1').html('Hello'); //html()有参数Hello，表示对h1进行赋值 ​ 常见的取值和赋值函数如下： .html() // 取出或设置html内容 .text() // 取出或设置text内容 .attr() // 取出或设置某个属性的值 .width() // 取出或设置某个元素的宽度 .height() // 取出或设置某个元素的高度 .val() // 取出某个表单元素的值 需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）。 ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:7:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"五、元素的操作：移动 jQuery 设计思想之五，就是提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。 假定我们选中了一个div元素，需要把它移动到p元素后面。 第一种方法是使用 .insertAfter()，把div元素移动p元素后面： $('div').insertAfter($('p')); 第二种方法是使用.after()，把p元素加到div元素前面： $('p').after($('div')); ​ 表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。你可以根据需要，选择到底使用哪一种方法。 使用这种模式的操作方法，一共有四对： .insertAfter() 和 .after() ：在现存元素的外部，从后面插入元素 .insertBefore() 和 .before() ：在现存元素的外部，从前面插入元素 .appendTo() 和 .append() ：在现存元素的内部，从后面插入元素 .prependTo() 和 .prepend() ：在现存元素的内部，从前面插入元素 ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:8:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"六、元素的操作：复制、删除和创建 除了元素的位置移动之外， jQuery 还提供其他几种操作元素的重要方法。 复制元素使用 .clone()。 删除元素使用.remove()和.detach()。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。 清空元素内容（但是不删除该元素）使用.empty()。 创建新元素的方法非常简单，只要把新元素直接传入 jQuery 的构造函数就行了： $('\u003cp\u003eHello\u003c/p\u003e'); $('\u003cli class=\"new\"\u003enew list item\u003c/li\u003e'); $('ul').append('\u003cli\u003elist item\u003c/li\u003e'); ​ ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:9:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"汇总 ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:0","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"jQuery 选择器 ——— 选择器通过标签名、属性名或内容对DOM元素进行快速、准确的定位。根据所获取页面中元素的不同，可以将选择器分为：基本选择器、层次选择器、过滤选择器和表单选择器。 ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:1","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"1、基本选择器 使用最频繁的选择器，包括元素 ID、Class 名、元素名等。 id选择器： $('#element-id') class选择器： $('.class-name') 元素选择器： $('element-name') ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:2","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"2、层次选择器 通过DOM元素间的层次关系获取元素，主要层次关系包括后代、父子、相邻、兄弟关系等。 根据祖先元素匹配所有后代元素： $('ancestor descendant') 根据父元素匹配所有的子元素： $('parent \u003e child') 匹配所有紧接在prev元素后的相邻元素： $('prev + next') 匹配prev元素之后的所有兄弟元素： $('prev ~ siblings') ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:3","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"3、过滤选择器 过滤选择器根据某类过滤规则进行元素的匹配，以:开头。过滤选择器又分为：简单过滤选择器、内容过滤选择器、可见性过滤选择器、属性过滤选择器、子元素过滤选择器和表单对象属性过滤选择器。 3.1 简单过滤选择器 获取页面第一个和最后一个X元素： $('element:first') $('element:last') 获取所有索引值为偶数和奇数的元素，索引值从0开始： $('element:even') $('element:odd') 获取等于、大于和小于索引值的元素： $('element:eq(index)') $('element:gt(index)') $('element:lt(index)') 获取除给定的选择器外的元素： $('element:not(selector)') 3.2 内容过滤选择器 获取包含给定文本的元素： $('element:contains(text)') 获取所有不包含子元素或者文本的空元素： $('element:empty') 获取含有选择器所匹配的元素的元素： $('element:has(selector)') 获取含有子元素或文本的元素： $('element:parent') 3.3 可见性过滤选择器 获取所有不可见的元素，或者type为hidden的元素： $('element:hidden') 获取所有可见的元素： $('element:visible') 3.4 属性过滤选择器 获取包含给定属性的元素： $('element[attribute]') 获取属性是给定值的元素： $('element[attribute=value]') 获取属性不是给定值的元素： $('element[attribute!=value]') 获取属性是以给定值开始的元素： $('element[attribute^=value]') 获取属性是以给定值结束的元素： $('element[attribute$=value]') 获取属性是包含给定值的元素： $('element[attribute*=value]') 3.5 子元素过滤选择器 获取父元素下的第一个、最后一个、唯一一个子元素： $('parent:first-child') $('parent:last-child') $('parent:only-child') 获取父元素下的特定位置的元素，索引值从1开始： $('parent:nth-child(eq|even|odd|index)') 3.6 表单对象属性过滤选择器 获取表单中所有属性为可用的元素： $('element:enabled') 获取表单中所有属性为不可用的元素： $('element:disabled') 获取表单中所有被选中的元素： $('element:checked') 获取表单中所有被选中option的元素： $('element:selected') ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:4","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"4、表单选择器 通过它可以在页面中快速定位某表单对象。 获取所有input、textarea、select等input元素： $('form:input') 获取所有单行文本框： $('form:text') 获取所有密码框： $('form:password') 获取所有单项按钮： $('form:radio') 获取所有复选框： $('form:checkbox') 获取所有提交按钮： $('form:submit') 获取所有图像域： $('form:image') 获取所有重置按钮： $('form:reset') 获取所有按钮： $('form:button') 获取所有文件域： $('form:file') ​ ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:5","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"DOM 操作 ——— 在与页面中的元素进行交互式的操作中，主要包括对元素属性、内容、值、CSS等的操作。同时，还有对页面节点的操作，包括节点元素的创建、插入、复制、替换、删除等操作。 ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:6","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"1、元素属性操作 在 jQuery 中，可以对元素属性进行获取、设置、删除等操作。 获取指定属性名的元素属性： $(selector).attr(name) 设置元素属性值，key为属性名称，value为属性值： $(selector).attr(key, value) 设置多个属性值： $(selector).attr({keyN:valueN}) 删除指定属性名的元素属性： $(selector).removeAttr(name) ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:7","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"2、元素内容操作 在 jQuery 中，可以获取和设置元素的HTML或文本内容。 获取元素的HTML/文本内容： $(selector).html() $(selector).text() 设置元素的HTML/文本内容： $(selector).html(value) $(selector).text(value) 两者的区别是，html() 方法仅支持 HTML 类型的文档，不支持 XML。而 text() 方法不仅支持 HTML 类型，也支持 XML 类型。 ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:8","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"3、元素值操作 在 jQuery 中，可以获取和设置元素的值。 获取元素的值： $(selector).val() 设置元素的值： $(selector).val(value) Tips：通过 val().join(”,\") 获取 select 标签中的多个选项值。 ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:9","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"4、元素样式操作 在 jQuery 中，可以直接设置样式、增加CSS类别、类别切换、删除类别等操作。 为指定name的样式设置值： $(selector).css(name, value) 为元素增加样式类： $(selector).addClass(class) 切换不同的样式类： $(selector).toggleClass(class) 删除元素的样式类： $(selector).removeClass(class) ​ ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:10","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"5、创建节点元素 如果要在页面中添加某个元素，需要先通过构造函数创建节点元素： $(html) ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:11","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"6、插入节点元素 按照插入元素的位置区分，可以分为内部和外部两种插入方法。 6.1 内部插入节点 向所选择的元素内部追加/前置内容： $(selector).append(content) $(selector).prepend(content) 向所选择的元素内部追加/前置function方法所返回的内容： $(selector).append(function()) $(selector).prepend(function()) 把所选择的元素追加/前置到另一个指定的元素集合中： $(selector).appendTo(content) $(selector).prependTo(content) 6.2 外部插入节点 向所选择的元素外部追加/前置内容： $(selector).after(content) $(selector).before(content) 向所选择的元素外部追加/前置function方法所返回的内容： $(selector).after(function()) $(selector).before(function()) 把所选择的元素追加/前置到另一个指定的元素： $(selector).insertAfter(content) $(selector).insertBefore(content) ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:12","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"7、复制节点元素 将某个元素节点复制到另一个节点之后。 复制匹配的DOM元素并且选中复制成功的元素： $(selector).clone() 在复制时将该元素的所有行为也进行复制： $(selector).clone(true) ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:13","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"8、替换节点元素 将所有选择的元素替换成指定的HTML或DOM元素： $(selector).replaceWith(content) 将所有选择的元素替换成指定selector的元素： $(selector).replaceAll(selector) 一旦完成替换，被替换元素中的全部事件将会消失。 ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:14","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"9、删除节点元素 删除指定的元素： $(selector).remove() 删除指定的元素，但保留被移除元素的事件： $(selector).detach() 清空所选择的页面元素的内容，但不移除该元素： $(selector).empty() ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:15","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"10、通用操作 这类操作不需要选择元素就可以直接使用。 $.trim() // 去除字符串两端的空格。 $.each() // 遍历一个数组或对象。 $.inArray() // 返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。 $.grep() // 返回数组中符合某种标准的元素。 $.extend() // 将多个对象，合并到第一个对象。 $.makeArray() // 将对象转化为数组。 $.type() // 判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。 $.isArray() // 判断某个参数是否为数组。 $.isEmptyObject() // 判断某个对象是否为空（不含有任何属性）。 $.isFunction() // 判断某个参数是否为函数。 $.isPlainObject() // 判断某个参数是否为用\"{}\"或\"new Object\"建立的对象。 $.support() // 判断浏览器是否支持某个特性。 ","date":"2020-10-25","objectID":"/dom-jquery-api/:10:16","tags":[" jQuery ","API"],"title":" jQuery 快速上手","uri":"/dom-jquery-api/"},{"categories":["JS编程接口"],"content":"命名风格、jQuery.prototype、设计模式","date":"2020-10-25","objectID":"/dom-jquery-prototype/","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"​ ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:0:0","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"命名风格 命名风格：我们在写代码时都会有一些风格，这些风格可能是业界共识、也可能是自己的小技巧 下面介绍一个命名风格（以前可能是业界共识，但现在已经不太常用了，因为 jQuery 很少人用了） ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:1:0","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"下面的代码令人误解 const div1 = document.querySelector('.test') const div2 = $('.test') // div2 到底是 DOM 对象，还是 jQuery 对象? 「DOM 对象」只能使用 DOM API，如 querySelector、appendChild … 「jQuery 对象」只能使用 jQuery 的 API，如 find、 addClass … const div = $('div#test') 我们会误以为 div 是一个 DOM 实际上 div 是 jQuery 构造的 api 对象 怎么避免这种误解呢？ ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:1:1","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"改成这样 const elDiv1 = document.querySelector('.test') const $div2 = $('.test') 声明变量用来表示 DOM 对象，可以变量名可以前置： el （可选） 声明变量用来表示 jQuery 产生的 api 对象，变量名前 + $ const $div = $('div#test') $div.appendChild 不存在，因为它不是 DOM 对象 $div.find 存在，因为它是 jQuery 对象 代码中，所有 $ 开头的变量，都是 jQuery 对象 这是约定，除非特殊说明 ​ ​ ​ ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:1:2","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"jQuery 代码 当前已经实现的代码 window.$ = window.jQuery = function (selectorOrArray) { /* * elements 表示通过选择器找到的目标元素组成的伪数组 * */ let elements if (typeof selectorOrArray === \"string\") { // 重载 elements = document.querySelectorAll(selectorOrArray) } else if (selectorOrArray instanceof Array) { elements = selectorOrArray } // ↓ api 可以操作 elements（this 就是 jQuery 返回的 api） return { addClass(className) { for (let i = 0; i \u003c elements.length; i++) { elements[i].classList.add(className) } return this }, find(selector) { console.log(`elements`, elements) let array = [] for (let i = 0; i \u003c elements.length; i++) { array = array.concat(Array.from(elements[i].querySelectorAll(selector))) } console.log(`array`, array) array.oldApi = this return jQuery(array) }, oldApi: selectorOrArray.oldApi, // 在 find 中，通过 array 保存下来的旧的 api end() { return this.oldApi }, each(fn) { for (let i = 0; i \u003c elements.length; i++) { fn.call(null, elements[i], i, elements) } return this // this 就是 api !!! }, print() { console.log(elements) return this }, parent() { const array = [] // 遍历父元素 ↓ this.each(node =\u003e { if (array.indexOf(node.parentNode) === -1) { // 去重 array.push(node.parentNode) } }) array.oldApi = this return jQuery(array) }, children() { const array = [] this.each(node =\u003e { if (node.children) { array.push(...node.children) } }) array.oldApi = this return jQuery(array) } /******************************************/ } } ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:2:0","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"调用 const api1 = $('.red') // api1 用来操作 red 元素 const api2 = $('.blue') // api2 用来操作 blue 元素 /* * 由上，可以发现 api1 和 api2 重复了 （?!! 什么意思） * */ ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:2:1","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"发现问题 🎃 api1 和 api2 重复了 ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:3:0","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"分析 🎃 api1 和 api2 重复了 （?!! 什么意思） api1 对应一块内存 #101 在 #101 中，有 find （#201）、each（#209） 内存 #201 对应一个find函数、内存 #209 对应一个each函数 api2 对应内存 #409 在 #409 中，有 find （#509）、each（#519） 内存 #509 对应一个find函数、内存 #519 对应一个each函数 可以比较清楚的发现： 两个 find 、两个 each 实际上应该是同一个函数的实现 但 jQuery 每创建一个 api ，这些函数也都被再次创建了一遍 201和509（209和519）是完全一样的两块内存 这就是前面提到的「 api1 和 api2 重复了」 ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:3:1","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"解决方法 🎃 find 和 each 应该作为「共用属性」 那为什么不把共用的属性写到一个对象上去呢？ 用一个 __proto__ 属性保存下共有属性的地址，即可 把这个包含共有属性的对象，放到 jQuery 上，让 jQuery.prototype 等于这个对象 套用原型公式 对象.__proto__ === 其构造函数.prototype const api1 = $('.red') api1.__proto__ === jQuery.prototype // 原型公式 const api2 = $('.blue') api2.__proto__ === jQuery.prototype ​ ​ ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:3:2","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"使用原型 改造 jQuery ⭕️ ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:4:0","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"第一版 jQuery 代码 先看看之前的版本 window.$ = window.jQuery = function (selectorOrArray) { let elements if (typeof selectorOrArray === \"string\") { // 重载 elements = document.querySelectorAll(selectorOrArray) } else if (selectorOrArray instanceof Array) { elements = selectorOrArray } // ↓ api 可以操作 elements（this 就是 jQuery 返回的 api） return { jquery: true, oldApi: selectorOrArray.oldApi, // 通过 array 保存下上一次的api // 下面是各种功能函数 addClass(className) {...}, find() {...}, each(fn) {...}, appendTo() {...}, ... } } ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:4:1","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"使用原型进行改造 ⭕️ ① 共有属性（函数）转移到原型上 把所有共有属性，都移到 jQuery 的原型 prototype 上 别忘了 constructor 这里是直接给 jQuery.prototype 赋新值，这样写很方便，但是会导致原本原型上的 constructor 被覆盖丢失，所以要手动加回去 constructor jQuery.prototype = { constructor: jQuery, jquery: true, // 下面是各种功能函数 addClass(className) {...}, find() {...}, each(fn) {...}, appendTo() {...}, ... } ② 把 prototype 赋予 jQuery 创建的对象 Object.create() ：创建对象，并给对象指定原型 __proto__ window.$ = window.jQuery = function (selectorOrArray) { let elements // ... const api = Object.create(jQuery.prototype) // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c // 创建 api对象，并指定其原型是 jQuery.prototype // 相当于 const api = {__proto__: jQuery.prototype} ... return api } ③ 往 api 上添加 elements 、oldApi 问题分析： 当我们把所有功能函数都从 api（独立函数） 上拿走，放到原型（独立对象）上之后 原型上的函数就获取不到 jQuery 里的 elements ，elements 仅作用在在 window.jQuery 函数中 window.jQuery = function(p1){ let elements = document.querySelectorAll(p1) return api }; jQuery.prototype = { get(index){ return elements[index] }, // 这里的elements获取不到上面的 elements end(){return this.oldApi}, find(){ }, // ... }; 那 find、get … 怎么操作 elements 呢？ 每生成新的 elements，都会创建、返回新的 api（api 的原型上就是这些功能函数） 需要找到它们之间的联系 $('.test').addClass('red') // addClass 函数中的 this 指向函数调用者 $('.test') // 而 $('.test') === api ，所以函数中的 this 指向的就是 api 所以要想在函数内部，获取到 elements，可以把 elements 放到 api 上 那就在 api 上添加一个属性 elements，用来保存 jQuery 创建的 elements 在原型里的函数中，通过 this.elements，就可以访问到这个【目标元素的数组】，加以操作 综上： 在原型里的函数，要获取到 jQuery 里的变量。必须通过桥梁【 api 、this 】 桥梁：只要 api 上有 jQuery 里的变量，函数就能通过 this 关键字获取到这个变量 注：oldApi 代码如下 end(){ return this.oldApi // end 原本就是要操作【调用者api】中的 oldApi // 所以 this(api) 上必须有 oldApi，end才能操作到，所以同样也需要往 api 上添加 oldApi } 完整代码 Object.assign：把后面对象的属性，复制到前面的对象上（注意是浅复制，JS 本身没有深复制） window.$ = window.jQuery = function (selectorOrArray) { let elements // ... elements = document.querySelectorAll(selectorOrArray) const api = Object.create(jQuery.prototype) // 把所需变量放到 api 上（两种方式） // （方式一 👇） // api.elements = elements // api.oldApi = selectorOrArray.oldApi // 等同于 ↓ // （方式二 👇） Object.assign(api, { // Object.assign（两个参数）把后面对象的属性，复制到前面的对象上 elements: elements, oldApi: selectorOrArray.oldApi }) return api } jQuery.prototype = { // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 函数在这里 constructor: jQuery, jquery: true, // 所有对 elements 的调用，都改成 this.elements get(index) { return this.elements[index] }, addClass(className) { for (let i = 0; i \u003c this.elements.length; i++) { const element = this.elements[i] element.classList.add(className) } return this }, end() { return this.oldApi // this 就是新 api } find(selector) { let array = [] for (let i = 0; i \u003c this.elements.length; i++) { const elements2 = Array.from(this.elements[i].querySelectorAll(selector)) array = array.concat(this.elements2) } array.oldApi = this // find 返回值会覆盖原本的 api，所以提取保存下旧的 api（this） return jQuery(array) }, each(fn) {...}, appendTo() {...}, ... } 完整代码 ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:4:2","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"补充： jQuery.fn jQuery.fn = jQuery.prototype = {...} 在 jQuery 的源码中，你会发现还多赋值了一个 jQuery.fn （如上）。用 fn 来表示 prototype 原型 可能是嫌弃 prototype 这个单词太长了，所以想用 fn 来表示 也可能是想兼容一些不太理解 prototype 的开发者，所以干脆换一个更短的单词 fn 总之，就是 jQuery 的源码中，对 jQuery 的 prototype 原型取了一个别名叫： fn ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:4:3","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"总结 $ 指代 jQuery 把共用属性（函数）全都放到 $.prototype $.fn = $.prototype // 名字太长不爽，再起个别名 fn 然后让 api.__proto__ 指向 $.fn （也就是让 api.__proto__ 指向了 $.prototype） ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:4:4","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"完整代码 window.$ = window.jQuery = function (selectorOrArrayOrTemplate) { let elements if (typeof selectorOrArrayOrTemplate === \"string\") { if (selectorOrArrayOrTemplate[0] === \"\u003c\") { // 创建 div elements = [createElement(selectorOrArrayOrTemplate)] } else { // 查找 div elements = document.querySelectorAll(selectorOrArrayOrTemplate) } } else if (selectorOrArrayOrTemplate instanceof Array) { elements = selectorOrArrayOrTemplate } function createElement(string) { const container = document.createElement(\"template\") container.innerHTML = string.trim() return container.content.firstChild } // api 可以操作elements const api = Object.create(jQuery.prototype) // 创建一个对象，这个对象的 __proto__ 为括号里面的东西 // const api = {__proto__: jQuery.prototype} Object.assign(api, { elements: elements, oldApi: selectorOrArrayOrTemplate.oldApi }) // api.elements = elements // api.oldApi = selectorOrArrayOrTemplate.oldApi return api } 原型 jQuery.fn = jQuery.prototype = { constructor: jQuery, jquery: true, get(index) { return this.elements[index] }, appendTo(node) { if (node instanceof Element) { this.each(el =\u003e node.appendChild(el)) } else if (node.jquery === true) { this.each(el =\u003e node.get(0).appendChild(el)) } }, append(children) { if (children instanceof Element) { this.get(0).appendChild(children) } else if (children instanceof HTMLCollection) { for (let i = 0; i \u003c children.length; i++) { this.get(0).appendChild(children[i]) } } else if (children.jquery === true) { children.each(node =\u003e this.get(0).appendChild(node)) } }, find(selector) { let array = [] for (let i = 0; i \u003c this.elements.length; i++) { const elements2 = Array.from(this.elements[i].querySelectorAll(selector)) array = array.concat(this.elements2) } array.oldApi = this // this 就是 旧 api return jQuery(array) }, each(fn) { for (let i = 0; i \u003c this.elements.length; i++) { fn.call(null, this.elements[i], i) } return this }, parent() { const array = [] this.each(node =\u003e { if (array.indexOf(node.parentNode) === -1) { array.push(node.parentNode) } }) return jQuery(array) }, children() { const array = [] this.each(node =\u003e { if (array.indexOf(node.parentNode) === -1) { array.push(...node.children) } }) return jQuery(array) }, print() { console.log(this.elements) }, // 闭包：函数访问外部的变量 addClass(className) { for (let i = 0; i \u003c this.elements.length; i++) { const element = this.elements[i] element.classList.add(className) } return this }, end() { return this.oldApi // this 就是新 api } } ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:4:5","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"库封装完成 可以把代码公开了 发布到 GitHub 添加文档，告诉别人怎么用 获得称赞 ❤️ 🧡 💛 💚 💙 💜 🖤 🤍 🤎 实现一个封装的库，提供给别人使用，好用的话，别人就会给你点赞 jQuery 就是早期一个程序员写的库，并提供给所有开发者使用 👍👍 这就是程序员的社区。人人为我，我为人人 当然现在的水平，肯定不够指导别人。 就先把代码写完整，自己用成功一次即可 以后会学习「如何做单元测试」（当然「单元测试」可能比「封装jQuery」的代码还难） 现在需要做的就是：自己能动手写成至少 10% 的这么一个轮子 只要你能完成，那代码水平肯定会显著提高 ​ ​ ​ ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:5:0","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"jQuery 有多牛 X 它是目前前端最长寿的库，2006年发布 （已经14岁了） vue 、react 也才四五岁 在前端历史上，有数以万计的库，最终能够活下来并一直被使用的库，很少很少。 jQuery 是目前最长寿的一个 它是世界上使用最广泛的库，全球80%的网站在用 可能现在新的科技公司不会再用 jQuery 但是老牌大公司，像是阿里巴巴、淘宝，一直都在用 jQuery ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:6:0","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"设计模式？ 为什么 jQuery 这么牛 X ？ 因为 jquery 的代码设计，做的 特 ~ 别 ~ 的 好。 好到没办法改进 我们今天学习的、很多写代码的套路，都是从 jQuery 的源码中学来的（工作个四五年再去看 jQuery 源码学习，小白直接看无异于自杀） ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:6:1","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"jQuery 用到了哪些设计模式 不用 new 的构造函数（jQuery做到了），这个模式没有专门的名字 const api = new JQuery('.test') =\u003e const api = $('.test') //在jQuery之前没人想到可以这样 $(支持多种参数)，这个模式叫做重载 可以传选择器、传数组、传 html 结构 用闭包隐藏细节，这个模式没有专门的名字 闭包：在一个函数中，调用了函数外部的变量 用户永远无法直接操作 elements （隐藏细节），必须通过 api 中的函数才能操作到 elements jQuery 每次生成 elements 后，这个 elements 可以一直存活。因为 jQuery 函数返回的 api 、api 中的函数里仍然在获取 elements 且函数返回值是 api。细想，这就导致 elements 一直在被访问，不断在函数的返回值中被调用。直到 api 消失，elements 才会消失 $div.text() 即可读也可写，这个模式叫 getter/setter getText() setText('newValue') // 以前都是两个函数来实现读、写 // 而jQuery中只用一个函数，根据参数个数，区分读写 $.fn 是 $.prototype 的别名，这叫别名 这的确是设计模式，因为在 jQuery 前并没有人这么干过 jQuery 针对不同环境使用不同代码，这叫适配器 电源适配器：你在日本，就调整成 110v，在中国，就调整成220v if(){ }else if(){ } ​ ​ ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:6:2","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"设计模式到底是啥 老子这个代码写得太漂亮了，别人肯定也用得到（去掉 new、重载、闭包、getter/setter、别名、适配器…） 那就给这种写法取个名字吧，比如：适配器模式（if else） 设计模式，就是对通用代码取个名字而已 实际上就是程序员的黑话、行话 ​ 适配器：就是针对不同环境使用不同代码 别名：让一个名字等于另外一个名字、 getter/setter：一个函数，既可以get 、也可以 set （可读可写） 闭包隐藏细节：生成一个变量（elements），一个函数（addClass）去读这个变量 重载：一个函数支持多种形式的参数 不用 new 的构造函数：要知道是怎么一回事 const api = new JQuery('.test') =\u003e const api = $('.test') ​ ​ ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:6:3","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"我应该学习设计模式吗？ 设计模式不是用来学的 你看了这些代码 但你并不知道这代码用来解决什么问题 看了白看 设计模式是用来总结的 你只管去写代码 把你的代码尽量写好，不断重写 总结你的代码，把写得好的地方抽象出来 看看符合哪个设计模式 （并不是知道设计模式才这么写的，而是写完后发现，居然用到了设计模式） 你就可以告诉别人你用到了这几个设计模式 显得你特别高端 ​ ​ ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:6:4","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"有人说不用学 jQuery 真相 jQuery 这么简单、经典的库，为什么不学？ 通过 jQuery 可以学会很多封装技巧，为什么不学？ 把一个变量放到函数里面、暴露出 api，api 可以操作变量，这就是 封装 连 jQuery 都理解不了，Vue / React 肯定学不好 推荐文章 《jQuery都过时了，那我还学它干嘛？》 ","date":"2020-10-25","objectID":"/dom-jquery-prototype/:6:5","tags":["jQuery","设计思想"],"title":"jQuery 的设计思想（下）","uri":"/dom-jquery-prototype/"},{"categories":["JS编程接口"],"content":"重新封装DOM、链式风格、增删改查","date":"2020-10-24","objectID":"/dom-jquery-handwritten/","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:0:0","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"前言 本节内容，把上节封装的 dom 代码，改用 jQuery 风格再次重新封装 jQuery 非常简单 ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:1:0","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"用 jQuery 风格重新封装 这节课你可能经常对自己说：我怎么没想到？！ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:2:0","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"准备工作 每节的准备工作都差不多，溜溜的用起来 新建项目目录 dom-2 \u003e src \u003e index.html 、 main.js 、 jquery.js ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:3:0","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003e手写jQuery\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e 你好 \u003cscript src=\"jquery.js\"\u003e\u003c/script\u003e \u003cscript src=\"main.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:3:1","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"jquery.js // 第一步，声明 window.jQuery 是一个函数（？！先不用管为什么是函数） window.jQuery = function () { console.log(`我是jQuery`) } ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:3:2","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"main.js jQuery() // window.jQuery() // output：我是jQuery ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:3:3","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"开启本地服务 yarn global add parcel parcel src/index.html ​ ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:3:4","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"链式风格 ❤️ 看一下我们就要实现一个什么的代码 👇 ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:4:0","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"也叫 jQuery 风格 window.jQuery() 是我们提供的全局函数 ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:4:1","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"特殊函数 jQuery jQuery(选择器) 用于获取对应的元素 但它却不返回这些元素 相反，它返回一个对象，称为 jQuery 构造出来的对象 （ 也就是最初代码中的那个 api ） 这个对象可以操作对应的元素 听不懂？直接写代码！ 本地项目dom-2 ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:4:2","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"代码 ⭕️ index.html \u003cbody\u003e \u003cdiv class=\"test\"\u003e你好1\u003c/div\u003e \u003cdiv class=\"test\"\u003e你好2\u003c/div\u003e \u003cdiv class=\"test\"\u003e你好3\u003c/div\u003e \u003cscript src=\"jquery.js\"\u003e\u003c/script\u003e \u003cscript src=\"main.js\"\u003e\u003c/script\u003e \u003c/body\u003e jquery.js // 第一步，声明 window.jQuery 是一个函数（？！）（先不用管为什么是函数） window.jQuery = function (selector) { const elements = document.querySelectorAll(selector) // 获取 selector 的全部元素（得到一个数组） // return elements // 常规操作：就直接返回这个通过选择器找到的元素。 // 但jQuery做了反常规的操作：获取到元素后，没有返回这个元素，而是返回了可以操作这个元素的 api // 如下： // api 可以操作 elements // api 是个对象，里面包含各种可以操作 elements 的函数。 // 如，addClass 就是给 elements 添加类名的函数 const api = { // 函数内访问了函数外部的变量，这就是「闭包」 addClass(className) { // elements 是 addClass 这个函数外部的变量 for (let i = 0; i \u003c elements.length; i++) { // 遍历所有获取到的元素，添加类名 elements[i].classList.add(className) } // return null return api // 返回值是 api，而 api 里有很多方法，所以可以通过返回值继续调用.addClass 形成一个链条 } } return api } main.js const api = jQuery(\".test\") // 通过选择器获取到元素，但不返回该元素，返回 api 对象 (api对象里有很多方法) // console.log(api.addClass) // 遍历所有获取到的元素，添加 .red 类名 api.addClass(\"red\").addClass('blue') // api.addClass 返回值是 api，而 api 里有很多方法，所以可以通过返回值继续调用.addClass 形成一个链条 ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:4:3","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"jQuery 代码变型 1️⃣ 下面的 return 的变化，必须理解 return 的骚操作 1️⃣ 用 this 代替 api window.jQuery = function (selector) { const elements = document.querySelectorAll(selector) // 获取 selector 的全部元素（得到一个数组） const api = { addClass(className) { for (let i = 0; i \u003c elements.length; i++) { elements[i].classList.add(className) } // return api return this /* * 如果用一个对象来调用函数，那么这个函数中的this，就是前面的对象 * obj.fn(p1) 等价于 ↓ * obj.fn.call(obj, p1) // 在fn中，this就是obj * 调用时 api.addClass(\"red\") =\u003e 同理，在 addClass 中 this 就是 api，二者等价 * 那 addClass 函数中，原本是 return api，就可以换成 return this * 注：this 的值，与调用时前面写了什么有关，只在函数被调用时才能确定this指代什么 * */ } } return api } return 的骚操作 2️⃣ 完全去掉 jQuery 中的 api 既然先创建了 api 对象，然后返回 api 对象，那是不是可以直接返回对象，省略 api 的赋值环节 呢？ 岂不是「多此一举」 window.jQuery = function (selector) { const elements = document.querySelectorAll(selector) const api = { // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c addClass(className) { for (let i = 0; i \u003c elements.length; i++) { elements[i].classList.add(className) } return this } } return api // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c } // 省略 api 的赋值环节 👇 window.jQuery = function (selector) { const elements = document.querySelectorAll(selector) // 获取 selector 的全部元素（得到一个数组） // const api = { return { addClass(className) { for (let i = 0; i \u003c elements.length; i++) { elements[i].classList.add(className) } return this } } // return api } ​ ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:4:4","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"jQuery 的核心思想 第一个核心点：闭包 jQuery 函数，接收一个 css 选择器 通过选择器，获取到这个元素 elements（但不会返回这个元素），它会返回一个对象 返回的对象中，包含很多函数。这些函数都可以操作这个元素 elements 原理： 用「闭包」去维持这个 elements 因为 addClass 函数在访问 elements。被访问的变量，是不会随便就被浏览器回收掉的 这就是 jQuery 的核心思想之一 第二个核心点：链式操作 addClass 函数，肯定能猜到：用户在调用 addClass 时，肯定是通过 jQuery(选择器) 得到的 api 来调用的 所以才会大胆的 return this。 addClass 函数，希望把 「点 . 」前面的东西，作为 addClass 的返回值 api.addClass(\"red\") 这样就相当于，api 从 addClass 函数前面，传递到了函数后面，这样就可以接着调用 addClass 👇api.addClass(\"red\")👇.addClass(\"blue\") 这就是 「链式操作」 ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:4:5","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"jQuery 代码变型 2️⃣ main.js 简化调用 去掉变量 x const x = jQuery(\".test\") // 声明出来 x ，接着直接使用。那赋值操作，显得多此一举 x.addClass(\"red\").addClass('blue').addClass('green') // 👇 最终写成 👇 jQuery(\".test\").addClass(\"red\").addClass('blue').addClass('green') ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:4:6","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"小总结 所谓高级的前端代码，就是把中间过程全部省掉了 把所有多次一举、无关紧要的东西，都尽量删掉。 最后只留下一个最少信息的、最精炼的代码。 虽然代码特别简洁、优雅，但对于学习者来说，就是看不懂。（说明「源码」真的不适合学习者） ​ ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:4:7","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"jQuery 是构造函数吗？ 讲到这里可能会有这个疑问 👆 构造函数的特点：① 前面有 new ② 构造出对象 结合这两个特点，可以认为 jQuery 是构造函数，也可以认为不是构造函数 ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:5:0","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"是 因为 jQuery 函数确实构造出了一个对象 ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:5:1","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"不是 因为不需要写 new jQuery() 就能构造一个对象 以前讲的构造函数都要结合 new 才行 ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:5:2","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"结论 jQuery 是一个不需要加 new （就可以构造出对象）的构造函数 jQuery 不是常规意义（严格意义）上的构造函数 这是因为 jQuery 用了一些技巧（目前没必要讲，讲了新手就更迷惑了） ​ ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:5:3","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"术语 ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:6:0","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"口头约定 👄 [前面](# 特殊函数 jQuery)提到：jQuery 函数，返回一个对象，称为 **jQuery 构造出来的对象 ** （ 也就是最初代码中的那个 api ） 口头约定： 以后说到 jQuery对象 就代指 jQuery函数 构造出来的对象 （为了省事，少说几个字） 不是说 「 jQuery 这个对象 」 一定要记清楚 ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:6:1","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"其他举例 Object 是个函数 Object 对象，表示 Object 这个构造函数 构造出来的对象（不是 Object 本身是对象） Array 是个函数 Array 对象/数组对象，表示 Array 构造出来的对象（不是 Array 本身是对象） Function 是个函数 Function 对象 / 函数对象，表示 Function 构造出来的对象（不是 Function 本身是对象） ​ ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:6:2","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"更多功能的封装 ⭕️ 链式风格 📌📌📌📌📌📌📌📌更多代码实现、解析、注释，请查看本地项目dom-2 📌📌📌📌📌📌📌📌 ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:7:0","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"查 jQuery('#xxx') // 返回值并不是元素，而是一个api对象 jQuery('#xxx').find('.red') // 查找#xxx里的.red元素 jQuery('#xxx').parent() // 获取爸爸 jQuery('#xxx').children() // 获取儿子 jQuery('#xxx').siblings() // 获取兄弟 jQuery('#xxx').index() // 获取排行老几（从0开始） jQuery('#xxx').next() // 获取弟弟 jQuery('#xxx').prev() // 获取哥哥 jQuery('.red').each(fn) // 遍历并对每个元素执行fn 代码 本地项目dom-2 window.jQuery = function (selectorOrArray) { /* * elements 永远表示选择器的目标元素的集合（伪数组） * */ let elements if (typeof selectorOrArray === \"string\") { // 重载 elements = document.querySelectorAll(selectorOrArray) } else if (selectorOrArray instanceof Array) { elements = selectorOrArray } // 👇 返回 jQuery函数 构造的对象 api（this就是这个api、api可以操作elements） return { addClass(className) { for (let i = 0; i \u003c elements.length; i++) { elements[i].classList.add(className) } return this }, find(selector) { let array = [] for (let i = 0; i \u003c elements.length; i++) { array = array.concat(Array.from(elements[i].querySelectorAll(selector))) } return jQuery(array) // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 重点理解这句 【代码分析，见本地项目dom-2的注释】 }, oldApi: selectorOrArray.oldApi, end() { return this.oldApi }, each(fn) { for (let i = 0; i \u003c elements.length; i++) { fn.call(null, elements[i], i, elements) // 遍历每项，对每一项都执行某个方法 } return this }, print() { console.log(elements) return this }, parent() { const array = [] this.each(node =\u003e { if (array.indexOf(node.parentNode) === -1) { // 去重 array.push(node.parentNode) } }) array.oldApi = this return jQuery(array) }, children() { const array = [] this.each(node =\u003e { if (node.children) { array.push(...node.children) // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c } }) array.oldApi = this return jQuery(array) }, /********************* 下面的课上未讲 *********************/ /* siblings() index() next() prev() */ } } ​ 练习 /* \u003cdiv id=\"test\"\u003e \u003cdiv class=\"child\"\u003e1\u003c/div\u003e \u003cdiv class=\"child\"\u003e2\u003c/div\u003e \u003cdiv class=\"child\"\u003e3\u003c/div\u003e \u003c/div\u003e */ window.jQuery = function(selectorOrArray){ let elements if(typeof selectorOrArray === 'string'){ elements = document.querySelectorAll(selectorOrArray) }else if(selectorOrArray instanceof Array){ elements = selectorOrArray } return { addClass(className){ this.each(n=\u003en.classList.add(className)) }, find(selector){ let array = [] this.each(n=\u003e{ array.push(...n.querySelectorAll(selector)) }) return jQuery(array) }, each(fn){ for(let i=0;i\u003celements.length;i++){ fn.call(null, elements[i], i) } } } } window.$ = window.jQuery $('#test').find('.child').addClass('red') // 请确保这句话成功执行 ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:7:1","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"增 只捋一捋思路，最终代码 代码 // 先简单回顾 dom 创建节点 👇（两种方式） const div = document.createElement('div') // ①传入标签名 template.innerHTML = '\u003cdiv\u003e\u003c/div\u003e' // ②传入html结构，最后返回 template.content.firstChild window.$ = window.jQuery = function(selectorOrArrayOrTemplate) { let elements; if (typeof selectorOrArrayOrTemplate === \"string\") { if (selectorOrArrayOrTemplate[0] === \"\u003c\") { // 创建 div elements = [createElement(selectorOrArrayOrTemplate)]; } else { // 查找 div elements = document.querySelectorAll(selectorOrArrayOrTemplate); } } else if (selectorOrArrayOrTemplate instanceof Array) { elements = selectorOrArrayOrTemplate; } function createElement(string) { const container = document.createElement(\"template\"); container.innerHTML = string.trim(); return container.content.firstChild; } // 返回jQuery创建的api return{ appendTo(node) { if (node instanceof Element) { this.each(el =\u003e node.appendChild(el)); } else if (node.jquery === true) { this.each(el =\u003e node.get(0).appendChild(el)); } }, // ... } } // 创建 div，插入到 body 中 $('\u003cdiv\u003e\u003cspan\u003e1\u003c/span\u003e\u003c/div\u003e').appendTo(document.body) ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:7:2","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"删 和dom实现逻辑一样 $div.remove() $div.empty() ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:7:3","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"改 和dom实现逻辑一样 $div.text(?) // 读写文本内容 // 传了参数就是「写」，不传参数就是「读」 $div.html(?) // 读写HTML内容 // 传了参数就是「写」，不传参数就是「读」 $div.attr('title', ?） // 读写属性 $div.css({color: 'red'}) // 读写style // 注意方法名是css $div.addClass('blue') $div.on('click', fn) $div.off('click', fn) · 注意 $div 大部分时候，对应了多个 div 元素 一定要默认 $div 是一个数组，然后遍历它 （每个操作都要遍历） ​ ​ ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:7:4","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"window.$ = window.jQuery jQuery('#test') // 每次使用都要这么写，很麻烦 什么？你嫌 jQuery 太长 你是对的 jQuery 这个单词，确实不好拼写（还要大小写区分） 怎么让 jQuery 变得更短呢？ 还记得 bash alias 吗，添加一个别名即可 // 一定在代码最后添加 window.jQuery = function (selectorOrArray){...} window.$ = window.jQuery 之后在任何地方使用 $ 就相当于使用 jQuery 还可以再省事 👇 window.$ = window.jQuery = function (selectorOrArray){...} // 写在一行上，顺序是从右向左执行 // 先执行 window.jQuery = function(){} // 然后再把 window.jQuery 的结果，赋值给 window.$ 这就是很多高级程序员会使用的写法 ","date":"2020-10-24","objectID":"/dom-jquery-handwritten/:8:0","tags":["jQuery","增删改查","封装"],"title":"jQuery 的设计思想（上）","uri":"/dom-jquery-handwritten/"},{"categories":["JS编程接口"],"content":"什么叫封装、库的初始化、封装增删改查","date":"2020-10-22","objectID":"/dom-dom-handwritten/","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"​ ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:0:0","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"前言 本节代码地址 ​ ​ ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:1:0","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"什么叫封装 可以理解成「把一些复杂的东西，打包成盒」，通过简单的命令就可使用 ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:2:0","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"举例 电脑笔记本就是 CPU、内存、硬盘、主板、显卡 的封装 用户只需要接触显示器、键盘、鼠标、触控板等设备 即可操作复杂的计算机 ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:2:1","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"接口 被封装的东西需要暴露一些功能给外部 这些功能就是接口，如 USB 接口、HDMI 接口 接口都是需要有规范的文档来说明的 全世界厂商都可以根据 USB 接口文档，来生产具有 USB 接口的硬件 深圳华强北就是根据各种文档，很快的复制生产出苹果数据线 … （功能差不多、价格更便宜） 这就是接口的好处，只要知道它的功能和实现细节，所有厂商都能做 设备只要支持这些接口，即可与被封装的东西通讯 比如在键盘上打字，计算机就能接收到我们敲了哪个键 比如键盘、鼠标支持 USB 接口 显示器支持 HDMI 接口 全世界所有显示器厂商的产品，都可以连接到任何一台电脑，就是因为有接口的统一标准存在 旧的有：VGA 接口（体积大、传输慢） 最新的有：雷电接口、HDMI 接口 （都有新的标准） （示意图） 本节的实现的《我的库》里面就封装了 DOM 的各种奇葩操作 document.getElementById 单词太长，封装后就叫 get 或者 find 封装成一个 create 就可以实现创建元素，不需要写 document.createElement … 这么复杂的单词 封装出来的 get、find、create 这些函数，就是接口 所有的页面中，都可以调用这些接口 ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:2:2","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"术语 ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:3:0","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"库 我们把提供给其他人用的工具代码，叫做「库」 就是把一些好用的函数统一放到一个地方，这个地方就是「库」 比如 jQuery、Underscore 它们就是库（提供了很多函数，供用户调用） ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:3:1","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"API 「库」暴露出来的函数或属性（功能）叫做 API（应用编程接口） API： Application Programming Interface ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:3:2","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"框架 当你的库变得很大，并且需要学习才能看懂 那么这个库就叫「框架」，比如 Vue / React ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:3:3","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"注意 编程界的术语大部分都很随便，没有固定的解释 可能程序员写了套东西，涵盖很多内容，作者本人也搞不清楚应该怎么定性，就随意的称为「库」 如果遇到有人反驳，那就慢慢讨论、定性 所以意会即可 我们就把「小的功能」叫库，「大的功能」叫框架 ​ ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:3:4","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"封装技术 下面我们开始学习封装技术 会用两种不同的风格，封装 DOM 操作 对象风格（命名空间风格） 链式风格（ jQuery 风格） ​ ​ ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:4:0","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"DOM 库的初始化 ⭕️ 创建 dom-1 项目目录 \u003e src 目录 \u003e index.html、main.js、dom.js ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:5:0","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"index.html \u003cbody\u003e 示例 \u003c!-- 注意：要先引入 dom.js； 否则 main 中先引用了dom.js的 API 就会报错：dom is not defined --\u003e \u003cscript src=\"dom.js\"\u003e\u003c/script\u003e \u003cscript src=\"main.js\"\u003e\u003c/script\u003e \u003c/body\u003e ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:5:1","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"dom.js dom 库（对象） 和 封装的函数（create），有两种呈现关系的形式 1 window.dom = {} dom.create = function () {} // window.dom.create 省略前缀 window 2 window.dom = { create: function () {} } // 👆可进一步简化：省略 function // ES6 window.dom = { create() {} } ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:5:2","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"举例：封装 create 代码 更多代码，请直接查看地址 create 创建节点 写法 1 调用时填入要创建的标签名 window.dom = {} dom.create = function (tagName) { return document.createElement(tagName) } 写法 2 初版有 bug 调用时直接填入标签结构 但填入 td / tr / tbody … 这种表格内的标签，就会返回 undefined。 这些标签不能直接放入 div 中，通常需要外层有 table 标签包裹才行 dom.create = function (html) { // const container = document.createElement('div') const container = document.createElement('template') // 如果容器是 div ，不能容纳 td ... 等 // 使用 \u003ctemplate\u003e\u003c/template\u003e 作为容器，可以容纳任意元素。 container.innerHTML = html return container.children[0] } 正确代码 dom.create = function (html) { const container = document.createElement(\"template\") container.innerHTML = html.trim() // trim 去掉字符串的两端空格 // 因为使用firstChild获取元素，如果传入的html前面有空格，就会只获取到空格(文本元素)，而不是标签元素。 // 所以必须提前trim()一下 return container.content.firstChild } ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:5:3","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"main.js 写法 1 的调用 const div = dom.create(\"div\") console.log(div) // (标签) \u003cdiv\u003e\u003c/div\u003e 写法 2 的调用 const div = dom.create(\"\u003cdiv\u003e\u003cspan\u003e123\u003c/span\u003e\u003c/div\u003e\") console.log(div) // (标签) \u003cdiv\u003e\u003cspan\u003e123\u003c/span\u003e\u003c/div\u003e ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:5:4","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"对象风格 ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:6:0","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"也叫 命名空间风格 window.dom 是我们提供的全局对象 下面从增删改查 4 个方面，来说明 window.dom 是干什么的（代码量很大哦）、 本节代码地址 ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:6:1","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"增 after()：2020刚出的 insertBefore 语法：父节点.insertBefore(要插入的子节点，插入到哪个子节点的前面) dom.create（'\u003cdiv\u003ehi\u003c/div\u003e') // 用于创建节点 dom.after(node,node2) // 用于新增弟弟 dom.before(node,node2) // 用于新增哥哥 dom.append(parent,child) // 用于新增儿子 dom.wrap(`\u003cdiv\u003e\u003c/div\u003e`) // 用于新增爸爸 代码 window.dom = { create(string){ // 创建节点 const container = document.createElement(\"template\") container.innerHTML = string.trim() return container.content.firstChild }, after(node, node2){ // 新增兄弟节点 node.parentNode.insertBefore(node2, node.nextSibling) }, before(node, node2){ // 新增兄弟节点 node.parentNode.insertBefore(node2, node) }, append(parent, node){ // 新增子节点 parent.appendChild(node) }, wrap(node, parent){ // 新增父节点 dom.before(node, parent) dom.append(parent, node) } }； ​ ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:6:2","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"删 dom.remove(node)用于删除节点 dom.empty(parent)用于删除后代 代码 window.dom = { remove(node){ node.parentNode.removeChild(node) return node }, empty(node){ let array = [] let x = node.firstChild // 这块是讲数据结构时最常用的思路，类似用循环实现的递归（不停找下一个，直到全删完了） while (x) { array.push(dom.remove(x)) x = node.firstChild } return array } } ​ ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:6:3","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"改 用到了【重载】和【适配】 重载：传不同个数的参数，执行不同的代码 适配：做很多判断（js 数据类型），什么情况下执行这句、什么情况下执行那句 dom.attr(node, 'title', ?) // 用于读写属性 dom.text(node, ?) // 用于读写文本内容 dom.html(node, ?) // 用于读写HTML内容 dom.style(node, {color: 'red'}) // 用于修改 dom.class.add(node, 'blue') // 用于添加 dom.class.remove(node, 'blue') // 用于删除 dom.on(node, 'click', fn) // 用于添加事件监听 dom.off(node, 'click', fn) // 用于删除事件监听 代码 dom.attr = function (node, name, value) { if (arguments.length === 3) { node.setAttribute(name, value) } else if (arguments.length === 2) { return node.getAttribute(name) } } dom.text = function (node, string) { if (arguments.length === 2) { if (\"innerText\" in node) { node.innerText = string } else { node.textContent = string } } else if (arguments.length === 1) { if (\"innerText\" in node) { return node.innerText } else { return node.textContent } } } dom.html = function (node, string) { if (arguments.length === 2) { node.innerHTML = string } else if (arguments.length === 1) { return node.innerHTML } } dom.style = function (node, name, value) { // 3种调用形式 if (arguments.length === 3) { node.style[name] = value } else if (arguments.length === 2) { if (typeof name === \"string\") { return node.style[name] } else if (name instanceof Object) { const object = name for (let key in object) { node.style[key] = object[key] } } } } dom.class = { add(node, className) { node.classList.add(className) }, remove(node, className) { node.classList.remove(className) }, has(node, className) { return node.classList.contains(className) } } dom.on = function (node, eventName, fn) { node.addEventListener(eventName, fn) } dom.off = function (node, eventName, fn) { node.removeEventListener(eventName, fn) } ​ ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:6:4","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"查 dom.find('选择器') // 用于获取标签或标签们 dom.parent(node) // 用于获取父元素 dom.children(node) // 用于获取子元素 dom.siblings(node) // 用于获取兄弟姐妹元素 dom.next(node) // 用于获取弟弟 dom.previous(node) // 用于获取哥哥 dom.each(nodes, fn) // 用于遍历所有节点 dom.index(node) // 用于获取排行老几 代码 dom.find = function (selector, scope) { return (scope || document).querySelectorAll(selector) } dom.parent = function (node) { return node.parentNode } dom.children = function (node) { return node.children } dom.siblings = function (node) { return Array.from(node.parentNode.children).filter(n =\u003e n !== node) } dom.next = function (node) { let x = node.nextSibling while (x \u0026\u0026 x.nodeType === 3) { x = x.nextSibling } return x } dom.previous = function (node) { let x = node.previousSibling while (x \u0026\u0026 x.nodeType === 3) { x = x.previousSibling } return x } dom.each = function (nodeList, fn) { for (let i = 0; i \u003c nodeList.length; i++) { fn.call(null, nodeList[i]) } } dom.index = function (node) { const list = node.parentNode.children let i for (i = 0; i \u003c list.length; i++) { if (list[i] === node) { break } } return i } ​ ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:6:5","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"总结1 上面代码，除了「创建节点，用了 template」，其他方法基本都是使用 DOM 的原生 API 来实现 不管是多么高深的库，最后都是用 if-else、for循环、while循环 就搞定了 不论什么语言，实现逻辑只需要三种表达形式：顺序执行、if/else、循环 ​ ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:7:0","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"总结2 最好的学习方法，就是去看作者的思路，照着他的思路实现一下。比如，vue的作者，就把所有思路写在 vue 文档里，就去看文档就好了。 ​ 这是许多程序员多年摸索出来的经典代码。 你只需要站在巨人的肩膀上，继续向上探索 ​ ","date":"2020-10-22","objectID":"/dom-dom-handwritten/:8:0","tags":["DOM","增删改查"],"title":"手写 DOM 库","uri":"/dom-dom-handwritten/"},{"categories":["JS编程接口"],"content":"获取元素、元素的原型链、nodeType、增删改查、DOM跨线程操作——慢？、生命周期","date":"2020-10-21","objectID":"/dom-dom-manipulate/","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:0:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"前言 本节是 DOM 最基础的部分 ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:1:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"前置知识 需要什么知识 理解简单的 JS 语法，如 变量、if else、循环 会背 JS 的七种数据类型（四基两空一对象、bigInt） 会背 JS 的五个 falsy 值 （0，NaN，null，undefined，空字符串） 知道函数是对象，数组也是对象 会用 div 和 span 标签 会简单的 CSS 布局（flex） ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:2:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"网页其实是一棵树 第一个知识点 画成「树」 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:3:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"JS 如何操作这棵树 JS 只能操作 JS，是操作不了网页的 **浏览器提供了功能，往 window 上添加了一个 document ** 只要有 document 这个对象， JS 就可以操作这棵树了 示例 用chrome打开任意网站 在控制台键入： window.document 得到一个 #document 鼠标放在 `#document` 上会发现整个网页被选中了，说明document包含整个网页 通过 window.document 得到网页的根节点 根节点下有 head 、 body … ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:3:1","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"JS 用 document 操作网页 这就是 Document Object Model 文档对象模型 「用一个 document 对象来操作整个网页」这种思想(模型)，全称叫做 「Document Object Model」 简称 DOM ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:3:2","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"DOM 很难用 请记住这个事实 之前讲过「JS 的原创之处并不优秀，优秀之处并非原创」 DOM 可能比 JS 还要难用 难用到「都没人愿意使用 DOM」 下面会想办法，解决这个难题 ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:3:3","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"如果你觉得 DOM 很智障 不要怀疑自己，你觉得的是对的 DOM 的接口设计的非常反人类 导致前端人员，不得不使用 jQuery 来操作 DOM 后来 jQuery 又被 Vue 代替了，于是大多数人就用 Vue 来操作 DOM 后来又有 React 了，就用 React 来操作 DOM 从来不会用 DOM 自带的功能来操作 DOM，自带的功能实在是非常反人类 ​ 图片来自 ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:3:4","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"获取元素的 API 获取元素，也叫标签 什么是 API —— 没有准确定义，听多了你自然就知道什么是 API 了 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:4:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"有很多 API 通过 id window.id名 id名 document.getElementById('id名') 举例 👇 \u003cinput id=\"kw\"\u003e window.kw // \u003cinput id=\"kw\"\u003e （直接获取到这个标签） kw // \u003cinput id=\"kw\"\u003e document.getElementById('kw') // \u003cinput id=\"kw\"\u003e （已经有上面两个特别简单的写法，谁还用这个） 特例 👇 当 id 名为 JS 关键字/属性时，就不能通过前面两个简单的写法来获取到元素 // 如下图所示 window.parent // parent 在这里是【获取 window 的上一层窗口】的意思 document.getElementById('parent') // 此时，只能通过此写法 所以，只要 id 不与全局属性冲突，就可以最简单的直接用这个 id 如果不小心冲突了，就只能退而求其次，用这个很长的 API ​ 通过 标签名 /* * 找到所有标签名为 div 的元素。 * 拿到的是一个数组（伪数组） * 要获取到具体某一个 div，需要用下标（也可以遍历） */ document.getElementsByTagName('div')[0] ​ 通过 class 获取元素 /* * 找到所有 class 为 red 的元素。 * 拿到的是一个数组（伪数组） * 要获取到具体某一个 red 元素，需要用下标（也可以遍历） */ document.getElementsByClassName('red')[0] ​ 最新的 API ：query 虽然是 query 开头，但并不是 jQuery 提供的 API，而是 JS 原生的 querySelector 和 getElement(s)ByXxx 方法的区别 querySelector()，接收一个CSS选择符，返回与该模式匹配的第一个元素 querySelectorAll()，用于选择匹配到的所有元素 document.querySelector('#id名') // 借用了css语法，css怎么找到这个标签，括号中就怎么写 document.querySelectorAll('.red')[0] ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:4:1","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"用哪一个 ⭕️ 工作中用最新的， querySelector 和 querySelectorAll 做 demo 直接用 idxxx，千万别让人发现 要兼容 IE 的可怜虫才用 getElement(s)ByXxx ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:4:2","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"获取特定元素的 API 获取 html 元素 document.documentElement 获取 head 元素 document.head 获取 body 元素 document.body 获取窗口（窗口不是元素） window 获取所有元素 document.all 这个 document.all 是个奇葩，第 6 个falsy值 ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:4:3","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"获取到的元素是个啥 显然是一个对象，我们需要搞清它的原型 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:5:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"抓一只 div 对象来看看 （图示见[下一P](# div 完整原型链)） let div = document.getElementsByTagName('div')[0] // www.baidu.com console.dir(div) // 用 dir 可以打印出结构。 （ 如下图，会有很多属性，都是构造函数添加的 ） // 重点关注【原型链】 注意：这里写的 HTMLDivElment 不是真正的原型 div.__proto__ === HTMLDivElment // false div.__proto__ === HTMLDivElment.prototype // true // JS 经典公式 对象.__proto__ === 其构造函数.prototype console.dir(div) 开始查看原型链 点开最外层 div#wrapper.wrapper_new，最先看到的是这个 div 自身的属性 第一层原型 HTMLDivElement.prototype 点开，这里面也是有很多属性，是所有 div 共有的属性，不用细看 第二层原型 HTMLElement.prototype 这里面是所有 HTML 标签共有的属性，不用细看 第三层原型 Element.prototype 这里面是所有 XML、HTML 标签的共有属性，你不会以为浏览器只能展示 HTML 吧 AJAX 的 X 指的就是 XML。在没有发明 json 之前，全部处理的都是 XML（XML 里也有标签） 具体这里包含 XML、HTML、SVG、… 各种不同标签都共有的属性，所以叫 Element 在 Element 各种元素之上，我们还有👇节点node的属性 第四层原型 Node.prototype 这里面是所有节点共有的属性，节点包括 XML 标签文本注释、HTML 标签文本注释等等 第五层原型 EventTarget.prototype 只有 3 个共有属性：addEventListener、dispatchEvent、removeEventListener 最重要的函数属性是 addEventListener 最后一层原型就是 Object.prototype（根对象）了 再往上就是 null 了 综上，div 是个非常复杂的对象 ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:5:1","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"div 完整原型链 自身属性和共有属性，点击查看 本地查看 let div = document.querySelectorAll('.red')[0] 由于 div 是由 HTMLDivElement 构造的 HTMLDivElement 构造函数往 this 上添加了一些属性 （this 指代 div） div 也继承了 Element，所以 Element 也往 this 上添加了一些属性 还继承了 node 构造函数，添加了一些属性 综上，每一层构造函数，都会往 div 身上添加了属性 ​ 例 👇 requestFullScreen() // 请求全屏（是所有Element的共有属性） head.requestFullScreen() // head元素全屏显示 // 这个 API 兼容性一般不是很好，通常不会使用 // 每一个元素都可以要求自己跟屏幕一样大 // head 能调用到这个 API , 就是因为顺着【原型链】继承而来 ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:5:2","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"总结 这样我们就可以清楚的知道，获取到的 div 是个啥了 就是个对象，且有 6 层原型 ​ ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:5:3","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"节点类型 nodeType 节点？元素？傻傻分不清 一个网页里面，节点包括很多种。最常见的就是元素、也叫标签 节点 Node 包括以下几种 1 表示元素 Element，也叫标签 Tag （最常见） 3 表示文本 Text 8 表示注释 Comment 9 表示文档 Document 11 表示文档片段 DocumentFragment （记住 1 和 3 即可） MDN 有完整描述，通过 **x.nodeType ** 得到一个数字 // 在任何一个元素上通过 .nodeType 就可以获取到这个元素的类型 div.nodeType // 1 表示标签 示例 // www.baidu.com let div = document.getElementsByTagName('div')[0] div.nodeType // 1 div.childNodes // 查看div的所有子节点 // 得到 Nodelist(5) 伪数组。 0: text 第一个子节点就是文本 div.firstChild // #text 获取到文本节点 div.firstChild.textContext // 获取文本里面的内容 \" \" 是个空格 div.firstChild.nodeType // 3 获取到div的第一个子节点的节点类型就是 3 文本 ​ ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:6:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"节点的增删改查 程序员的宿命就是增删改查 后端，对【数据库】进行增删改查 前端，对【页面元素】进行增删改查 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:7:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"增 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:8:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"创建一个标签节点 let div1 = document.createElement('div') // “DOM反人类”再次得到验证：创建一个元素居然写这么长的单词 document.createElement('style') document.createElement('script') document.createElement('li') // \u003cdiv\u003e\u003c/div\u003e 、 \u003cstyle\u003e\u003c/style\u003e 、 \u003cscript\u003e\u003c/script\u003e 、 \u003cli\u003e\u003c/li\u003e ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:8:1","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"创建一个文本节点 text1 = document.createTextNode('你好'） // 为什么不能直接写成 text1='你好' // 因为 '你好' 是一个字符串；而文本节点是一个【对象】（包含很多原型、函数什么的） ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:8:2","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"标签里面插入文本 两种形式、3 种写法 div1.appendChild(text1) div1.innerText = '你好' 或者 div1.textContent = '你好' // 但是不能用 div1.appendChild('你好'） appendChild 是 Node 构造函数 添加的 textContent 也是 Node 构造函数 添加的 innerText 是 HTMLElement 构造函数 添加的 喜欢 Node 就用 Node 提供的接口 喜欢 HTMLElement 就用 HTMLElement 提供的接口 但是不能混着用 示例如下图，会报错：appendChild 只能接收一个 node 节点 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:8:3","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"综上 \u003cdiv\u003e你好\u003c/div\u003e // 通过 DOM 创建上面这个html标签 👆 // 需要下面 3 行代码，才能实现 let div1 = document.createElement('div') let text1 = document.createTextNode('你好'） div1.appendChild(text1) 此时的 div1 并不会显示在页面中，只是在 JS 内存中存活 只有插入页面中，这个 div1 才能生效（显示） ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:8:4","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"插入页面中 创建的标签，默认处于 JS 线程中 不会显示在页面中，只是在 JS 内存中存活 你必须把它插到 head 或者 body 里面，它才会生效、显示在页面中 创建的是 style 或 link 元素 … 就需要传入到 head 里才能生效 appendChild 会把元素插入到目标容器的末尾 document.body.appendChild(div) document.head.appendChild(div) // 或者 已在页面中的元素.appendChild(div) 例 let div1 = document.createElement('div') // 创建div元素 let text1 = document.createTextNode('你好'）// 创建文本节点 div1.appendChild(text1) // 通过appendChild把文本节点添加到div元素中。此时div仍在内存中，不在页面显示 document.body.appendChild(div1) // \u003cbody\u003e\u003cdiv\u003e你好\u003c/div\u003e\u003c/body\u003e 此时 div 显示在页面中 ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:8:5","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"appendChild 疑问 一个元素，只能插入一处 页面中有 div#test1 和 div#test2 let div = document.createElement('div') test1.appendChild(div) test2.appendChild(div) // 创建一个 div 元素，先后插入到另外两个div中 // 请问新创建的这一个 div 元素，最终会出现在哪里？ 请问最终 div 出现在哪里？ 选项1、test1 里面 选项2、test2 里面 选项3、test1 里面 和 test2 里面 答案：（鼠标选中显示答案）👉 最终 div 出现在 test2 里面 因为一个元素不能出现在两个地方，除非复制一份 同理：送子观音，把一个孩子送到第一户人家，又把他送到第二户人家，那最后在哪降生？ 答：第二户人家 因为一个孩子只会有一个亲生家庭 ​ 示例 尝试用 appendChild，把创建好的元素，先后添加到两个地方（无法实现一个元素插入多处） let div1 = document.createElement('div') let text1 = document.createTextNode('你好') div1.appendChild(text1) div1.style.backgroundColor = 'white' div1.style.fontSize = '100px' // 此时内存中有一个 \u003cdiv\u003e你好\u003c/div\u003e 元素。 背景白色，字体100像素 // 把这个 div1 元素，先后插入到 head 和 body 中 document.head.appendChild(div1) document.body.appendChild(div1) // 最终div1元素只会出现在body中 ​ ​ 复制元素，使插入多处 用「克隆节点」 cloneNode MDN let div2 = div1.cloneNode(true) // true 深拷贝：该节点的所有后代节点也都会被克隆 // false 浅拷贝：只克隆该节点本身 document.head.appendChild(div1) document.body.appendChild(div2) ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:8:6","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"删 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:9:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"两种方法 // 旧方法 👇 parentNode.removeChild(childNode) // 必须找到父节点，来删除子节点 （反人类） // 新方法 👇 childNode.remove() // IE不支持（兼容性有问题） 临时探讨：为什么 IE 总搞独立？ 实际上在最初，IE 确实是最厉害的浏览器。其他各家浏览器公司为了反制 IE 才搞出「标准」 所以不是 IE 搞独立，而是标准出的太晚了 IE 一家独大的时候，标准还没有出台。IE 也不会提前知道标准的内容。 而且标准中某些内容还会故意跟 IE 反着写 比如 IE 发明了 innerText，标准出台表示不用 innerText 而用 textContent（就导致开发者两个写法都要记😭） 所以并不一定是 IE 故意搞独立，会不会是「标准」在故意使坏呢 ?! （🤔盲生你发现了华点） ​ 旧方法 // 先创建出 div1，再克隆出 div2 let div1 = document.createElement('div') let text1 = document.createTextNode('你好') div1.appendChild(text1) let div2 = div1.cloneNode(true) // 把 div1/div2 元素，分别插入到 head/body 中 document.head.appendChild(div1) document.body.appendChild(div2) // 再删除节点 div1.parentNode.removeChild(div1) div2.parentNode.removeChild(div2) // 删除后还能再添加回来吗 ？ // 可以的。因为删除节点后，节点还在内存里面，所以还可以添加回来 document.body.appendChild(div2) 新方法 // 先创建出 div1，再克隆出 div2 // 把 div1/div2 元素，分别插入到 head/body 中 // 再删除节点 div1.remove() div2.remove() // 删除后还能再添加回来吗 ？ // 可以的。因为删除节点后，节点还在内存里面，所以还可以添加回来 // 跟旧方法的效果一模一样 document.body.appendChild(div2) 由于【 ele.remove() 】是后发明的，所以不兼容 IE ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:9:1","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"思考 如果一个 node 被移出页面（DOM 树） 那么它还可以再次回到页面中吗？ 答案：可以。（示例参考上面） 只是被移出来，并没有被彻底干掉，所以还可以存在在 JS 内存中 ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:9:2","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"如何彻底干掉元素 即元素被删除后，就彻底消失、不存在在内存中、也无法重新添加回页面 // 彻底干掉元素，先把元素移出页面 div1.remove() div2.remove() // 这时 div1/div2 都在内存中 div1 = null div2 = null // 等于空，div1/div2 就与内存断开联系了，就会被【垃圾回收】掉 ​ ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:9:3","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"改 💡 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:10:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"改属性 写标准属性 改 class 科普：早期 JS 对象是不能拥有一个「保留字」作为 key 的 div1.if // JS引擎的解析器看到 if 会认为是不是 if 语句，而实际上 if 是 对象 div1 的 一个key // 这就会导致歧义 // 所以 JS 不接受「保留字(JS关键字...)」作为 key div1.class = \"red\" // 修改失败 // 因为 class 也是JS关键字，所以不能使用 // 于是就起了新的名字，用 className 表示标签の类名 class 正确写法 👇 注意：每次用 className 修改类名，都会把之前的类名 直接覆盖掉 // 如果只是想【追加】类名 div.className = 'red blue' // 用 className 就把所有类名都写上 div.classList.add('red') // 或者通过👈方式追加类名 div.classList // 可以查看div元素当前已有的class类名组成的数组 ​ 改 style div.style = 'width:100px;color:blue;' // 全覆盖 【不推荐】 div.style.width = '200px' // 改一部分【推荐】 div.style.backgroundColor = 'white' // 注意「驼峰命名」的大小写 JS 不支持有「中划线 - 」的 key 值 div.style.background-color // ❌ 中划线会被理解成：减号 div.style['background-color'] // ⭕ 就是某些情况支持 key 包含中划线，也只能用[]中括号的形式 div.style.backgroundColor // ✅ ​ 改 data-* 属性 以前有段时间，需要往元素上添加自定义属性。现在基本没人用了（库开发者可能会用到） // 添加自定义属性 div.setAttribute('data-x', 'test') // \u003cdiv data-x=\"test\"\u003e\u003c/div\u003e div.dataset.xx = 'sam' // \u003cdiv data-xx=\"sam\"\u003e\u003c/div\u003e // 获取自定义属性的属性值 div.getAttribute('data-x') // test div.dataset.xx // sam // 修改自定义属性的值 div.dataset.xx = 'jack' ​ ​ 读标准属性 div.id div.classList a.href // 👆 大多是属性都是一一对应，直接读就可以 获取原本的属性值 不想被浏览器加工 div.getAttribute('class') div.classList a.getAttribute('href') a.href 两种方法都可以，但值可能稍微有些不同（大多情况两种方法获取的结果是一样的） 一种是简单的书写方式，「xxx.属性名」，但值可能被加工 一种是较长的书写方式，「xxx.getAttribute(‘属性名’)」，虽然长，但可确保结果更准确，更保险一点 举例：a 标签的特殊情况 👇 \u003ca id=test href='/xxx'\u003e\u003c/a\u003e console.log(test.href) // https://null.jsbin.com/xxx 浏览器把域名给补全了 如果直接用 js 的属性，读出值。得出的结果，有可能会被浏览器加工 ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:10:1","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"改事件处理函数 div.onclick 默认为 null 代码在线编译 \u003cdiv id=\"test\"\u003etest\u003c/div\u003e console.log(test.onclick) // null test.onclick = () =\u003e { console.log('hi') } test.onclick = function(x){ console.log(this) // this: test console.log(x) // x: event } // 调用原理：test.onclick.call(test, event) // 所以 this 和 event ，实际上是浏览器在用户点击时，用 call 传进来的 每一个元素都有 onclick 属性，该属性的默认值为 null 默认点击 div 不会有任何事情发生 但是如果你把 div.onclick 改为一个函数 fn 那么点击 div 的时候，浏览器就会调用这个函数 并且是这样调用的 fn.call(div, event) div 会被当做 this （如果要用到 this 就不能用箭头函数、必须用 function） event 则包含了点击事件的所有信息，如坐标 ​ div.addEventListener 是 div.onclick 的升级版，之后的课程单独讲 DOM Event div.onclick 只能写一个函数（点击时，执行的所有操作，都必须写在一个函数中） div.addEventListener 可以写无数个函数（点击时，执行的所有操作，可以写作不同的函数，对于复杂的操作情况非常友好） ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:10:2","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"改内容 改文本内容 div.innerText = 'xxx' // 早期 IE 发明的 div.textContent = 'xxx' // 出台「标准」中规定的 两者几乎没有区别 现在所有浏览器基本都是同时支持这两种写法的 ​ 改HTML内容 代码在线编译 div.innerHTML = '\u003cstrong\u003e重要内容\u003c/strong\u003e' innerText ：所有内容都会被识别为 文本 innerHTML ： 会解析内容、识别标签… （内容需要注意长度，超过一定限度，如20000个字符，可能会导致浏览器卡爆） ​ 改标签 div.innerHTML = '' // 先清空 div.appendChild(div2) // 再加内容 ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:10:3","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"改爸爸 想要找一个新爸爸 newParent.appendChild(div) // 直接把div添加到新的父节点内，以前父节点中的div就自动消失了 直接这样就可以了，直接从原来的地方消失 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:10:4","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"查 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:11:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"查爸爸 node.parentNode // 或者 node.parentElement ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:11:1","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"查爷爷 node.parentNode.parentNode ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:11:2","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"查子代 node.childNodes // 包含文本节点 // 或者 node.children // 【优先使用】不包含文本节点 查看在线代码 childNodes 例1 \u003cul id=test\u003e \u003cli\u003e1\u003c/li\u003e \u003cli\u003e2\u003c/li\u003e \u003cli\u003e3\u003c/li\u003e \u003c/ul\u003e console.log(test.childNodes.length) // 7 第 1 个子节点是：回车 + 空格，最终缩成一个**空格 **（最开始讲 html 时就讲过，不论几个回车空格，都会缩成一个空格） 第 2 个子节点是：li 第 3 个子节点是：回车 + 空格，最终缩成一个**空格 ** 第 4 个子节点是：li 第 5 个子节点是：回车 + 空格，最终缩成一个**空格 ** 第 6 个子节点是：li 第 7 个子节点是：回车 + 空格，最终缩成一个**空格 ** 例2 \u003cul id=test2\u003e\u003cli\u003e1\u003c/li\u003e\u003cli\u003e2\u003c/li\u003e\u003cli\u003e3\u003c/li\u003e\u003c/ul\u003e console.log(test2.childNodes.length) // 3 // 因为没有回车和空格 ​ children \u003cul id=test\u003e \u003cli\u003e1\u003c/li\u003e \u003cli\u003e2\u003c/li\u003e \u003cli\u003e3\u003c/li\u003e \u003c/ul\u003e console.log(test.children.length) // 3 // 即使有回车空格，子元素也是 3 个 所以「查子代」优先使用 children ​ 思考：元素节点的变化 当子代变化时，childNodes 和 children 也会实时变化吗？ 在线代码：children / childNodes 答：如果子元素变化，children / childNodes 的长度**也会变化 ** 在线代码：querySelectorAll 答：通过 document.querySelectorAll 获取子元素集合。如果子元素变化，集合的长度**不会变化 ** querySelectorAll 不会实时根据元素变化，去改变自己。获取过一次之后，就不再变化 ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:11:3","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"查兄弟姐妹 没有 API 可以直接获取到「任一元素的兄弟元素」，只能通过「先获取到父元素，再获取父元素的子元素」的方式 node.parentNode.childNodes // parentNode 可以和 parentElement 互换 node.parentNode.children // 同上 // 发现问题：上面获取到的数组，都包含了自己，而需求是只要兄弟元素，过滤掉自己 // 只能遍历 // children 遍历排除自己 // childNodes 遍历排除自己和所有文本节点（更麻烦） 例 let div2 = document.getElementsByTagName('div')[1] // div2 有多少个兄弟姐妹 let siblings = [] let c = div2.parentElement.children // 先获取到父亲的所有子代，再遍历从中排除自己 for(let i = 0; i \u003e c.length; i++){ if(c[i] !== div2){ silblins.push(c[i]) } } ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:11:4","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"查看第一个子代 node.firstChild // node.parentNode.children[0] ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:11:5","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"查看最后一个子代 node.lastChild ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:11:6","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"查看上一个兄弟 距离自己最近的上一个兄弟节点（哥哥） node.previousSibling // 如果上一个节点是文本节点(空格、回车...)，就会获取到文本节点 node.proviousElementSibling // 会避开文本节点，只找元素节点 补充：[节点类型](# 节点类型 nodeType) ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:11:7","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"查看下一个兄弟 距离自己最近的下一个兄弟节点（弟弟） node.nextSibling // 下一个兄弟节点 （包含文本节点） node.nextElementSibling // 下一个元素兄弟节点 （只包含元素节点） ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:11:8","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"遍历一个 div 里面的所有元素 与前面的「数据结构——遍历树」逻辑相同 DOM 就是一棵树。数据结构中「树」的所有算法都可以用到 DOM 中 travel = (node, fn) =\u003e { // 与遍历树节点的代码逻辑一致 fn(node) if(node.children){ for(1et i = 0；i \u003c node.children.length; i++){ travel(node.children[i], fn) } } } travel(div1, (node) =\u003e console.log(node) ) 看，数据结构多么有用 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:11:9","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"DOM 操作是跨线程的（详解）📌 面接常问：为什么 DOM 操作比较慢？ 因为 DOM 操作和 JS 是两个不同的东西。 下面就详细解释：什么叫「DOM 操作是跨线程的」 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:12:0","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"浏览器功能划分 在《JS世界》那一节里，讲过浏览器功能划分 浏览器有两个重要功能：「渲染引擎」和「JS 引擎」 渲染引擎：专门用来渲染 html 和 css JS 引擎：专门用来执行 JS 这两个引擎在不同的线程中，互不相干 ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:12:1","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"跨线程操作 这两个线程-各司其职 JS 引擎，不能操作页面，只能操作 JS （window对象、object 对象、document对象…之类的） 虽然存在 document 对象，但不能通过它操作任何事情，它只能操作document对象本身 —— 只能操作 JS 渲染引擎，不能操作 JS，只能操作页面 这就是【各司其职】 document.body.appendChild(div1) // 但是执行这句JS的调用语句，却使页面发生了改变。这不就违背了【各司其职】的原则 ❓❓ 既然是各司其职：JS 引擎 只能操作 JS，渲染引擎 只能操作 页面 怎么让 div 出现在屏幕中的 ？ 理论上，它只能出现在 body 的内存里面 这句 JS 的调用语句到底是如何操作、改变页面的 ❓❓ —— [跨线程通信](# 跨线程通信) ​ 跨线程通信 当浏览器发现 JS 要在 body 里添加一个 div1 对象 浏览器就会通知渲染引擎： 在页面里也新增一个 div 元素 新增的 div 元素的所有属性，都照抄 div1 对象 所以不是 JS 去渲染、改变了页面，而是浏览器去渲染、改变了页面 ​ 图示跨线程操作 左【JS 执行线程】、中【浏览器】、右【渲染线程】 各自独立的 let div = doc.createElement('div') // 不会影响页面，只改变了JS 执行线程的内存 div.textContent = 'hi' // 也不会影响页面（第1次改变文本内容） document.body.appendChild(div) // 浏览器发现JS往body里添加了div节点，浏览器就通知了渲染引擎【慢】。 // 渲染引擎接到通知，就往body里添加了div元素（div元素的属性照搬div节点的属性） ... div.textContent = 'sam' // 浏览器发现div节点中的文本内容改变了，于是通知渲染引擎【慢】，照搬操作（第2次改变文本内容） 大量的时间花费在【中间过程】，也就是「浏览器通知渲染引擎」的过程中 这就使得： div 的操作，会比其他几行单线程操作，都慢很多 「第 2 次改变文本内容」需通知渲染引擎。所以「第 2 次改变文本内容」的操作，肯定比「第 1 次」慢 [思考](# DOM 操作慢？)：执行速度变慢，这是模块化的缺点吗 ？ ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:12:2","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"DOM 操作慢 ❓❗️ 网上都说 DOM 操作慢，实际上只是比 JS 操作慢，DOM 操作比网络请求还是快很多的。 关于这一部分内容，大家可以延伸阅读一些文章： 为什么说DOM操作很慢 为什么经过10年的努力DOM操作还是这么慢 注意，网上的文章说的不一定都是对的，作为参考了解一下即可。 「跨线程操作，使得执行速度变慢」，这是模块化的缺点吗？ 答 👇 虽然变慢了，但是可以实现各线程内部单独的优化。 比如，在渲染引擎中可以单独优化渲染，不需要理会 JS 的各种变量的问题 … 因为根本就看不见它们，所以也就无需考虑 总结 「模块化」可以让划分的每一块，都比较简单、容易优化、容易代替 虽然损失了时间，但「模块化的优点」却是更显著的 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:12:3","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"插入新标签的完整过程（生命周期） 这个 div 经历了 3 个过程（vue 也有生命周期：之前、之时、之后） 在 div1 放入页面之前 你对 div1 所有的操作都属于 JS 线程内的操作 把 div1 放入页面之时 浏览器会发现 JS 的意图 就会通知渲染线程在页面中渲染 div1 对应的元素 把 div1 放入页面之后 为什么要说「可能会 ~，也可能不会」这种看似无意义的话 因为不同的浏览器，有不同的逻辑 以下 4 点均以 Chrome 为例 你对 div1 的操作都有可能会触发重新渲染 div1.id='newId' 可能会重新渲染，也可能不会 比如，改的这个 id 有 css 样式，那就会触发重新渲染 div1.title = 'new' ，即使改 title**也可能会重新渲染**，也可能不会 貌似看起来改 title 不应该影响页面。实际上 title 有时也会渲染在页面里 举例 👇 \u003cdiv title='titleHi'\u003e\u003c/div\u003e \u003cstyle\u003e div::after{ content: attr(title); } /* 页面中显示出了 `titleHi` */ \u003c/style\u003e \u003c!-- div 的伪元素内容，就是获取了 div 的 title 属性。 这种情况如果改了 div 的 title，页面一定会重新渲染 --\u003e 如果你连续对 div1 多次操作，浏览器可能会合并成一次操作，也可能不会（之前在动画里提到过） 需求动画效果：让 test 元素的宽度从 100 px 渐变成 200 px 代码见链接。这样写为什么不会发生动画 ？ 在短时间内，对这个元素的 classList 进行了两次操作（两次添加类名） JS 认为 执行两次、渲染两次是浪费时间，何不合并、渲染一次，更节约渲染时间 由于合并 ，导致动画效果出不来。 怎么才能不合并、展示出动效 test.classList.add('start') // 中间多执行一步 test.clientWidth // 获取test的客户端宽度。看似这句代码人畜无害的，但事实并非如此 // 因为这里要获取宽度，使得上面添加class的操作，必须立即渲染 // 所以就不会合并操作（从而展示出动效） test.classList.add('end') 在中间读取宽度，导致 JS 必须先渲染出 start，然后告诉你宽度，最后渲染 end（强行拆分） 又因为中间存在 css 的过渡效果 transition，所以就会展示动画啦 这其实是非常高深的一点 ，很少有人能这么清晰的分析出原因 ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:12:4","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"提问 let div = doc.createElement('div') div.textContent = 'hi' // 不触发重新渲染 document.body.appendChild(div) // div插入页面之时 ... div.textContent = 'sam' // 在div插入页面之后，修改 div 的文本内容，一定会触发重新渲染 在 div 插入页面之后 修改 div 的文本内容，一定会触发重新渲染 那是否「修改 div 的所有属性，都会触发重新渲染」呢？ 示例代码 html 中，div 元素有三个不同的属性：id、x、data-x，属性值都是 test JS 中，获取到这个 div 元素为 div1，再分别修改这三个属性的值为 frank 那最终页面中的这个 div 元素，是否会三个属性都修改成功了呢 ？ id 修改成功、x 修改失败、data-x 修改成功 可修改的属性，存在什么规律吗？ 如果这个属性是在「标准属性」中、或在「data 属性」中 那么浏览器会自动同步这个修改结果到渲染的页面中 id 属于标准属性、data-x 属于 data 属性， 而 x 属于非标准属性，修改它就不会影响（渲染）到页面 总结「属性同步」的标准，[见下](# 属性同步) ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:12:5","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"属性同步 标准属性 对 div1 的标准属性的修改，会被浏览器自动同步到页面中 比如 id、className、title 等（你改了就会直接变） data-* 属性 同上 非标准属性 对非标准属性的修改，则只会停留在 JS 线程中 不会同步到页面里 比如 x 属性，示例代码 启示 如果你想自定义属性，又想被同步到页面中，请使用 data- 作为前缀（data 属性） 不要使用类似 x 这种属性 图示 div 的【标准属性】，自动同步 div 的【data 属性】，自动同步 【data 属性】中的【x 属性】，自动同步 div 的 x 属性，什么东西，滚 补充： JS 线程中的属性叫「properties」，渲染线程中的属性叫「attributes」 （[对比](# Property vs Attribute)） 所以 Element.getAttribute() 这个 API 获取的是页面中的属性 ​ ​ ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:12:6","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["JS编程接口"],"content":"Property vs Attribute property 属性 JS 线程中 div1 的所有属性，叫做 div1 的 property div1.style div1.id div1.className attribute 也是属性 渲染引擎中 div1 对应标签的属性，叫做 attribute \u003cdiv id=\"test\" class=\"test\" data-x=\"test\"\u003e\u003c/div\u003e ​ 区别 大部分时候，同名的 property 和 attribute ，值相等 但如果不是标准属性，那么它俩只会在一开始时相等 非标准属性 x，一开始左右相等。后来 JS 线程中修改了 x 的值，但是渲染线程并不知道，导致不等 但注意 attribute 只支持字符串 页面中的标签属性的值，只能是字符串，\u003cdiv id=1\u003e \u003c/div\u003e 中的 id=1 也只是省略了引号的字符串 1 而 property 支持字符串、布尔等类型 ","date":"2020-10-21","objectID":"/dom-dom-manipulate/:12:7","tags":["DOM","增删改查"],"title":"DOM 编程 ","uri":"/dom-dom-manipulate/"},{"categories":["算法与数据结构"],"content":"队列 Queue、栈 Stack、链表 Linked List、哈希表 Key-Value Pairs、树 Tree","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:0:0","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"目前用过的数据结构 数组 数组可以分为队列、栈等 哈希表 用来存储 key - value 对 ​ ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:1:0","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"队列 Queue 队列，是一种特殊的数组 ——**「先进先出 FIFO」的数组 ** FIFO : first in , first out ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:2:0","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"题目 请实现一个「餐厅叫号」网页 点击「取号」按钮，生成一个号码 点击「叫号」按钮，显示「请 X 号就餐] ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:2:1","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"分析 首先，应该选择「队列 queue」作为数据结构 因为「叫号」遵循的应该是「先到先得」的原则，这点与「队列」的「先进先出」是一致的 队列的两个重要的 API ：入队、出队 在 JS 中，「入队」相当于 queue.push （在叫号数组的最后，添加一个人） 在 JS 中，「出队」相当于 queue.shift （把叫号数组中第一个人踢走，结束排队、可以去吃饭了） 记得练习一下 call 的用法 其他的事情就顺其自然了，见完整代码 （codesandbox在线编译器） 本地编译器中，开启项目，运行 parcel +（文件路径，如 src/index.html ） 就可以开启本地服务，实时监听 yarn global add parcel ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:2:2","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"代码 \u003cbody\u003e \u003cdiv id=\"screen\"\u003e\u003c/div\u003e \u003cdiv class=\"actions\"\u003e \u003cbutton class=\"createNumber\"\u003e取号\u003c/button\u003e \u003cbutton class=\"callNumber\"\u003e叫号\u003c/button\u003e \u003c/div\u003e \u003cdiv\u003e 当前号码： \u003cspan id=\"newNumber\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e 当前队列： \u003cspan id=\"queue\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cscript src=\"./main.js\"\u003e\u003c/script\u003e \u003c/body\u003e // 获取到所有页面元素 const divScreen = document.querySelector(\"#screen\") const btnCreateNumber = document.querySelector(\".createNumber\") const btnCallNumber = document.querySelector(\".callNumber\") const spanNewNumber = document.querySelector(\"#newNumber\") const spanQueue = document.querySelector(\"#queue\") // 取号 // 取号号码n默认从0开始，每次点击后自增1 // 需要把所有取过的号都记下来，才能实现叫号 let n = 0 let queue = [] btnCreateNumber.onclick = () =\u003e { n += 1 queue.push(n) // 入队 spanNewNumber.innerText = n spanQueue.innerText = JSON.stringify(queue) /* innerText 只能显示字符串， * 可以用 queue.toString() 显示效果：1,2,3,4 * 用 JSON.stringify(..) 会把JS对象转换成外观完全一样的字符串, [1,2,3,4] * */ } // 叫号 btnCallNumber.onclick = () =\u003e { if (queue.length === 0) { // 当队列为空，就不再执行叫号操作 return spanQueue.innerText = `无需排队` } const m = queue.shift() // 出队 divScreen.innerText = `请 ${m}号就餐` spanQueue.innerText = JSON.stringify(queue) } ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:2:3","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"问 如果不知道「队列」这个知识点，你会怎么做？ 懂得「队列」，看到这种实现逻辑（先到先得），能立马知道这符合「队列：入队/出队」（先进先出） 科班生只需要了解：「入队、出队」在 JS 中对应的 API 形式即可 没有「数据结构」相关知识的辅助，只能一步一步推导这种逻辑的实现方法（相对薄弱） 所以「数据结构」很重要 ​ ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:2:4","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"栈 Stack 「后进先出 LIFO」的数组 LIFO : last in , first out ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:3:0","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"举例 可以以一个不严谨的「坐电梯」的情景来理解 ： 1层直达88层的电梯，先进电梯的人，会站到电梯最后。而后进电梯的人站在电梯最前，会先出电梯 现实生活的运行机制中，这种不公平的例子很少 所以下面就是以一个**「JS 函数调用」**的例子来展开。JS 的「调用栈」就是「栈」的数据结构 JS 函数的调用栈 call stack 就是一个栈 假设 f1 调用了 f2，f2 有调用了 f3 那么 f3 结束后应该回到 f2，f2 结束后应该回到 f1 ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:3:1","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"代码 function f1(){ let a = 1; returb a+f2() } function f2(){ let b = 2; return b+f3() } function f3(){ let c = 3; return c } f1() // 问：上述代码是 如何压栈和弹栈的 ？ 画一下压栈、出栈过程，便知这是「后入先出」的栈 首先，栈就是数组 压栈就是 push（添加到最后） 弹栈就是 pop（把最前面先弹出来） ​ ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:3:2","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"留一个悬念 内存图里的栈内存和这个调用栈 它们是什么关系？—— 关系很大 是同一块内存吗？—— （可以说是同一块内存，因为）有很大的地方是重叠的 这块和 JS 关系不大。【内存图 2.0】 ​ ​ ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:3:3","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"链表 Linked List 只要满足「一个链一个」这样的数据结构，就是「链表」 ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:4:0","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"实际使用 举例：**「JS 的原型链」**中的「链」，实际上就是指「链表」 let array = [1,2,3] array.__proto__ === Array.prototype Array.prototype.__proto__ === Object.prototype 从这个角度看，JS 中任何一个普通对象，都是一个链表（因为有原型的概念） 链表，是一种对数据结构的抽象。这种抽象，是一种很松散的链接关系 let array = [1,2,3] array.push // array本身没有push，就去数组原型上找 array.hasOwnProperty // array本身没有，数组原型上没有，只能从对象原型上找到 这是非常简洁的、实现继承的一种机制 ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:4:1","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"链表的好处 可以随时把中间的链条给断掉 例 任意一个数组 array，要去掉链条中的数组原型 实现方式：让 array 的 _proto_ 直接指向对象原型（那么这个 array 就不再具备 push 这些方法了） let array = [1,2,3] array.__proto__ // 得到数组原型 array.__proto__.__proto__ // 得到对象原型 array.__proto__.__proto__.__proto__ // null // 让 array 的 __proto__ 直接指向对象原型 array.__proto__ = Object.prototype array.push // undefined ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:4:2","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"链表的简单操作 ✅ 怎么创建链表、怎么在链表上进行增删改查 —— 代码见本地【linked_list】项目 要在大脑中，能构建出这样的模型 添加节点 第一次尝试：失败 ❌ BUG分析 运行下面代码的【appendList 方法】只能实现一种情况：就是在第1个节点后面，添加第2个节点。 当你想添加多个节点，多次运行【appendList 方法】会发现链表中始终只有两个节点 多次运行的结果，就是第二个节点在不断的被替换，而不会将每次运行时用户写的节点添加到已有节点的后面 /* * 如何创建一个链表 ↓ * 最简单的链表，就是只有一个节点的链表 * 一个节点，用对象表示。需要包含两个属性：数据、下一个节点(默认是空) * */ const createList = (value) =\u003e { return { data: value, next: null // 默认下一个节点是空 } } /* 添加其他节点 */ const appendList = (list, value) =\u003e { const node = { data: value, next: null } list.next = node return node // 往list上添加node节点，并把这个node节点作为函数返回值 } const list = createList(10) // 创建list链条(只有一个节点) const node = appendList(list, 20) // 往list链条上，添加node节点。 console.log(`node`, node) console.log(`list`, list) 代码简化 { data: value, // 形参value next: null // 默认是单节点链表，下一个节点为空 } 上述部分被多次引用。可以提取出来，单独成一个函数 createNode ，来多次调用 // 提取公共部分，独立成一个函数 createNode const createNode = (value) =\u003e { return { data: value, next: null } } -------------------------------------------------------------------------- const createList = (value) =\u003e { return createNode(value) // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 多次调用 } const appendList = (list, value) =\u003e { const node = createNode(value) // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 多次调用 list.next = node return node } 第二次尝试：成功 ✔️ 我们说「添加节点」实际上是要在当前链条的**最后一个节点的后面，再添加新的节点 **。**而不是在第一个节点的后面，添加新的节点 ** 👆 上述这点逻辑，必须清晰认识到，这样代码才有可能写对 const appendList = (list, value) =\u003e { const node = createNode(value) // 先生成我们要新添加的节点的内容 // 添加节点：我们需要在当前链条的最后一个节点的后面，添加新的节点。 // 所以必须找到 list 的最后一个节点 let x = list // 重新赋值给变量x，更保险。直接用list原值，可能会导致问题 // 开局假设：链表只有一个节点，声明变量 x，作为链表的这一个节点（也是最后一个节点） // 循环遍历 // 如果 x 后面还有节点存在，说明 x 不是最后一个节点，需要给 x 重新赋值为下一个节点 while (x.next) { x = x.next } // x.next === null // 遍历结束，x.next如果是null了，说明 x 是最后一个节点 // 此时只需要，把需要添加的节点，赋值给 x.next 即可 x.next = node return node // 把需要添加的节点 node 作为函数返回值 } ​ ​ 删除节点 现 list 链条上有 3 个节点，每个节点的 data 分别是 10/20/30。需求：从链条中删除 20 的节点 示例分析 这个实现的思路和[前面的例子](# 链表的好处)类似。 「从链条中删除 20 节点」，实际上就是让 10 节点的 next 不再指向 20，而是直接指向 30 删掉 10 和 20 之间的联系后，10 和 20 的 next 仍然分别指向 30。 但是并没有任何对象指向 20 ，20 就相当于没人用的内存垃圾，浏览器会自动把它回收掉 所以最终 10 - 20 - 30，就变成了 10 - 30 （图解 ↘） 问题：怎么找到 20 节点的上一个节点（我们只能通过 next 找到当前节点的下一个节点，并没有属性保存当前节点的上一个节点？？） ​ 思路 通过上图可知，**「删除 X 节点」**可以转嫁成另一个需求 👇 **「让 X 的上一个节点的 next，直接指向 X 的下一个节点」 ** 跳过了 X 节点，相当于从链条中删除了 X 节点（浏览器还会自动回收） ​ 第一次尝试：找规律 ⚠️ 常规逻辑书写 /* * 删除节点 * 参数1：从哪个链条删除 * 参数2：删除哪个节点 * */ const removeFromList_Demo = (list, node) =\u003e { // 注意：链条的名称 === 第一个节点的名称 // 如果要删除的(node传入的)是第1个节点（那node.next就表示第2个节点） if (node === list) { list = node.next // 就将第1个节点list重新赋值为第2个节点（相当于第1节点就不存在了） } else { // 如果要删除的(node传入的)是第2个节点（那node.next就表示第3个节点） if (node === list.next) { list.next = node.next // 就将第1个节点的next，直接指向第3个节点（跳过第2节点，相当于删除） } else { // 如果要删除的(node传入的)是第3个节点（那node.next就表示第4个节点） if (node === list.next.next) { list.next.next = node.next // 就将第2个节点的next，直接指向第四个节点（跳过第3节点，相当于删除） } else { // 如果要删除的是第4个节点 =\u003e 让第3个节点.next，直点接指向第5个节（跳过4） if (node === list.next.next.next) { (list.next.next).next = node.next } else { // 找到规律了吗？ // 这是一个循环（递归）呀 } } } } } 根据需求，写出上述常规代码：非常冗余，全是近似代码、不断重复。【是否说明这其实是有规律可循的】 猜想：是否可以用「循环」来解决代码的重复调用、实现规律 ​ 第二次尝试：有 bug ⭕️ 利用循环，实现规律 删除X节点：就是让【 X 的上一个节点】的 next，直接指向【 X 的下一个节点】（X.next） 所以**关键在于： X 的上一个节点怎么找到 ** 要知道 X 的上一个节点，这就与 X 节点联系紧密 /* * 删除节点 * 参数1：从哪个链条删除 * 参数2：删除哪个节点 * （链条名===第一个节点） * */ const removeFromList = (list, node) =\u003e { let x = list // x 默认为第一个节点 let p = null // p 始终表示 x 的上一个节点，默认为空 // 传入的 node 表示是要删除的节点。 // 要遍历链条中的每一个节点，用 x 表示当前遍历的节点 // 将 x 与 node 比对，如果当前节点 x 不等于 node 节点，就给 x 重新赋值下一个节点，再次判断是否相等 // 不断循环查找下一个，最终 x 就会找到要删除的那个节点 // 因为【x的上一个节点】是关键，所以循环每轮都要把【当前x的上一个节点】记录下来 while (node !== x) { p = x // 每轮先用 p 把当前 x 记下来 x = x.next // 然后再把 x 重新赋值为下一个节点 //（此时x成为x的下一个节点，p就成为x的上一个节点） } // while 遍历完，得出当前要删除的节点。如果找不到，说明用户传入的 node 不存在 (╯□╰) // 综上，遍历完后，x 和 p 的取值各有两种情况 👇 // console.log(x === node || x === null) // x 要么找到传入的要删除的节点；要么就是null // console.log(p === x的上一个节点 || p === null) // p 要么是 x 的上一个节点；要么就是null（说明要删除的就是第1个节点，所以 p 是 null） /* * 最后，删除节点，相当于跳过这个节点。 * x是要删除的节点，那么跳过x这个节点，就应该是x的上一个节点的next ，直接指向 x 的下一个节点 （跳过x） * x的上一个节点的","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:4:3","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"链表的变形 这块比较超纲，就只提出个概念，感兴趣可以自己了解一下 双向链表 每个节点有一个 previous ，指向上一个节点 循环链表 最后一个节点的 next ，指向头节点 ​ ​ ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:4:4","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"哈希表 key-value pairs 链表比较复杂，哈希表没有链表复杂 有人说：哈希表看起来就是 JS 对象的简化版，有什么难点吗？ 哈希表的难点，不在于「表」这个字 难点在于**「哈希」**二字 这里有一篇文章（停车场案例），帮助你理解什么是 hash ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:5:0","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"哈希表 key-value 的组合 就是存 key-value 这种形式的数据 并没有限制存储容量的上限。但是存的越多，读取就越难 难点就是如何读取hash表更快 ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:5:1","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"哈希表的难点 场景 假设哈希表 hashTable 里有10000对 key-value （N=10000） 如何使得读取任意一个 hashTable[‘yyy’] 速度都很快呢 ？ 可以看一篇文章（与停车场案例，同理） hashTable = { aaa: value1 aab: value2 aba: value3 abb: value4 ... zzz: value10000 // 假设共有 10000 对 key-value } // 找到 hashTable[`yyy`] 的最快方式 解决办法 四种读取 hashTable[‘yyy’] 的方式，如下 不作任何优化，hash[‘xxx’] 需要遍历所有 key，复杂度为 O(N) （N表示key的总个数10000）【速度慢】 一万个需要1秒，十万个10秒 … 对 key 排序，使用二分法查找，复杂度就是 O(log(2)N) =\u003e 可简写成（ln N）【速度较快】 用字符串对应的 ASCII 数字做索引，复杂度 O(1) 【速度最快，占空间巨大】 aaa =\u003e 979797 (a: 97) yyy =\u003e 121121121 (y: 121) // 虽然一次就可以直接找到 yyy, 但是就像停车场的案例，这样导致占用的空间太大了（每一个指都对应一个空间） 对索引做除法，取余数，O(1) 【速度最快，节省大部分空间】 假设要获取的key的ASCII为 979797，准备一个长度为 1000 的容器 那就用 979797 / 1000 余数肯定在 0~999 之间 这个数组只需要 0~999 项 { 0：aaa,aab,aba,abb,... 1: bbb,bba,bab,baa,... 2: ccc,... ... 998: yyy,... 999: zzz,... } （同一个号码有两个）冲突了怎么办，冲突了就顺延 998 满了就存 999，999 满了就存到 0，0 满了就存到 1 … 反正只有 1000 个位置 通过哈希表实现更快的读取到数据 哈希表解决的就是这个问题（存的很容易，读也得快） ​ ​ ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:5:2","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"树 Tree 一个链多个 是对链表的升级 children 是个**数组 ** data1 节点有两个子节点（数组元素） data2 / data3 ，共同组成一个「树」结构（可以有无限长） 两个子节点 data2 / data3 可以再向下链接其他的子节点 data4 / 5 / 6 … ，也可不再有其他子节点 如果子节点不再（分枝杈）有 children，就称这个子节点为「叶子」 链到头了，最后一个节点 所以 data1 有两个叶子 看起来不像树，像金字塔，倒过来就像树了 ​ ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:6:0","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"实际使用 实际生活中，到处都是「树」结构 中国的省市区，可以看成一棵树 公司的层级结构，可以看成一棵树 网页中的节点，可以看成一棵树 html \u003e head、body，body \u003e div、span、a、p …，head \u003e link、title、meta ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:6:1","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"对「树」进行增删改查 let tree = createTree(value) // 创建树 let node = createNode(value) // 创建节点 addChild(tree,node) // 添加节点 removeChild(node1,node2) // 删除节点 travel(tree) // 遍历树 ​ 创建树（根节点） const createTree = (value) =\u003e { return { data: value, children: null, // 子节点 parent: null // 父节点 } } ​ 添加子节点 /* * 添加子节点 * 参数1：往哪个节点下添加子节点 * 参数2：要添加的子节点数据是什么 * */ const addChild = (node, value) =\u003e { const newNode = { data: value, children: null, parent: node } node.children = node.children || [] // 必须保证node.children是数组，才能用push方法 node.children.push(newNode) return newNode } ​ 遍历节点 /* * 遍历节点 * 先fn操作根节点，然后遍历根节点上的所有子节点，分别用fn操作子节点（不断循环） * 这种先打印根节点，后处理子节点的遍历方法，称为「先根遍历」法，是比较简单的遍历方法 * 当然还有其他遍历方法 * */ const travel = (tree, fn) =\u003e { fn(tree) if (tree.children) { for (let i = 0; i \u003c tree.children.length; i++) { travel(tree.children[i], fn) } } } ​ 删除节点 /* * 删除节点 * 数组只能通过下标删除元素（splice） * 所以必须先找到node的兄弟姐妹，遍历兄弟姐妹，看node排行第几（获取下标） * */ const removeNode = (tree, node/*要删除的节点*/) =\u003e { const siblings = node.parent.children let index = 0 for (let i = 0; i \u003c siblings.length; i++) { if (siblings[i] === node) { index = i } } siblings.splice(index, 1) } 查找节点 /* * 查找节点 * */ const findNode = (tree, node) =\u003e { if (tree === node) { // 要查找的就是根节点 return tree } else if (tree !== node \u0026\u0026 tree.children) { // 非根节点、且存在子节点的情况 for (let i = 0; i \u003c tree.children.length; i++) { // 遍历所有子节点，找到目标node const result = findNode(tree.children[i], node) // 递归 if (result) { return result } } return undefined } return undefined } ​ ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:6:2","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"数据结构就这么简单 ？ 对，数据结构就是这些代码 难在，看着代码简单，但是写起来非常难（逻辑绕） 甚至大脑里面想都想不清楚，必须写出来、log、再慢慢推导 其实，数据结构必须是**简单的 ** 所有数据结构都可以通过一句话就概况出来 队列是什么：先进先出 栈是什么：先进后出 哈希表是什么： key-value的组合 链表是什么：一个对象链着另一个对象 树是什么：一个对象链着多个对象 它不可以复杂，即使复杂了，也会被程序员重新划分成几个简单问题 因为👇程序员崇尚简洁优雅 程序员崇尚简洁优雅 如果你觉得某个编程概念真的很难 那么请相信一定是你哪里理解错了 请试着重新理解一下 把细节自己动手敲一敲，才找到错误点。 这个过程中可能会突然意识到「噢！！原来是这样，我之前大脑想的是错的」 ​ ​ 「二叉树」 可能是前端中最难的 ","date":"2020-10-19","objectID":"/algorithm-data-structures-part.1/:7:0","tags":["数据结构","入门"],"title":"数据结构（上）","uri":"/algorithm-data-structures-part.1/"},{"categories":["算法与数据结构"],"content":"递归、循环、选择排序、快速排序、归并排序、计数排序、推算时间复杂度","date":"2020-10-16","objectID":"/algorithm-sort/","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"​ ","date":"2020-10-16","objectID":"/algorithm-sort/:0:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"前言 算法中最简单的就是排序算法 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:1:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"复习代码 let sort = (numbers) =\u003e { if(numbers.length \u003e 2){ let index = minIndex(numbers) let min = numbers[index] numbers.splice(index, 1) return [min].concat( sort(numbers) ) }else{ return numbers[0] \u003c numbers[1] ? numbers : numbers.reverse() } } 一句话总结： 每次找到最小的数放前面，然后对后面的数做同样的事情 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:2:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"minIndex 用于找出数组中最小数字的下标 ","date":"2020-10-16","objectID":"/algorithm-sort/:3:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"你永远都有两种写法 「递归」和「循环」 ","date":"2020-10-16","objectID":"/algorithm-sort/:3:1","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"目前的 minIndex （递归算法） 通过 min 函数的「递归」算法，来获取到最小值，从而找到下标 let minIndex= (numbers) =\u003e numbers.indexOf(min(numbers)) let min = (numbers) =\u003e { if(numbers.length \u003e 2){ return min( [numbers[0], min( numbers.slice(1) ) ] ) // 递归 }else{ return numbers[0] \u003c numbers[1] ? numbers[0] : numbers[1] } } 缺点 看着就繁琐（递归中用了很多括号、还引用了额外的帮助函数min ） 重写吧 ","date":"2020-10-16","objectID":"/algorithm-sort/:3:2","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"重写 minIndex 🔔 （循环算法） 用循环 思路：【 index 】作为一个标志，始终代表着「数组 numbers」中的「最小值」的【下标】 第一步，假设下标为 0 的元素，是 numbers 中的最小值，也就是 index = 0 把下标 1 的元素与下标 0 的元素进行比较，如果下标 1 的元素，比下标 0 的元素还小，也就是下标 1 是最小值。而 index 始终表示最小值的下标，所以 index 需重新赋值为 1 👆这种方法叫【贪婪法】：只要判断是比自己小的值，就认为是最小的值 （俗称「渣男法」：只要看到一个女生比现在的女朋友漂亮，就要换女朋友） 逐步分析 👇 minIndex([9,6,8,13,5,4]) =\u003e (假设9[0]最小) index = 0 =\u003e (9遇到6[1] - 9\u003e6) index = 1 =\u003e (6遇到8[2] - 8\u003e6) index = 1 =\u003e (6遇到13[3] - 13\u003e6) index = 1 =\u003e (6遇到5[4] - 5\u003c6) index = 4 =\u003e (5遇到4[5] - 4\u003c5) index = 5 =\u003e index 变化过程 0→1→4→5 源代码（循环实现minIndex） 👇 1et minIndex = (numbers) =\u003e { let index = 0 for(let i=1; i \u003c numbers.length; i++){ if( numbers[i] \u003c numbers[index] ){ index = i } } return index } minIndex([9,6,8,13,5,4]) index 表示当前最小值下标，已经为 0，所以循环体中，应该是从下标为 1 的元素开始，和下标为 0 的元素进行比较大小 全部遍历完，返回最小值下标 ​ 分析 一目了然，一听就会，一写就错 写错，就记得多测试几次 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:3:3","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"启发 💡 是不是所有的「递归」都可以写成「循环」 ？？ 答：是的 所有的递归，都可以改写成循环 这是已经被证明的事情 如果觉得递归不好理解，都可以改写成循环，一般来说循环会更好理解，但循环写起来会更麻烦、代码量更大 ","date":"2020-10-16","objectID":"/algorithm-sort/:4:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"选择排序 select sort ⭕️ 选择排序两种思路 递归 循环 改写 sort ","date":"2020-10-16","objectID":"/algorithm-sort/:5:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"递归写法 复习一下 | 递归思路： 长度大于2，就找最小值放到前面 + 并对后面所有值再次 sort 长度等于2，就直接判断大小 / 交换两个元素位置，然后返回数组（中止条件） let minIndex= (numbers) =\u003e numbers.indexOf(min(numbers)) let min = (numbers) =\u003e { console.log(`numbers: ${numbers}`) return min( [ numbers[0], min( numbers.slice(1) ) ] ) // 递归 } let sort = (numbers) =\u003e { if(numbers.length \u003e 2){ let index = minIndex(numbers) let min = numbers[index] numbers.splice(index,1) return [min].concat( sort(numbers) ) // 递归 }else{ return numbers[0] \u003c numbers[1] ? numbers : numbers.reverse() } } ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:5:1","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"循环实现分析 思路不变： 每次找到最小的数放前面，然后对后面的数做同样的事情 然后 i++ 「循环的每次找到最小的数，放前面 —— 选择排序」这个思路比较容易想到，但是代码写起来却比较困难 尝试写循环代码 👇 1et minIndex = (numbers) =\u003e { let index = 0 for(let i=1; i \u003c numbers.length; i++){ if( numbers[i] \u003c numbers[index] ){ index = i } } return index } let sort = (numbers) =\u003e { for(let i=0; i\u003c???; i++){ let index = minIndex(numbers) // index 是当前最小数的下标，i 表示当前下标 // index 对应的数应该放到 i 处（交换 index 和 i 的元素，这就是👇swap需要实现的） swap(numbers, index, i) // swap 还没实现 // index、i 都是 index 的意思，建议 i 改名 } } 分析 怎么知道 i \u003c ??? 处应该写什么（结束条件是什么） 提前写好 minIndex 能有效简化问题 用 swap 占位能有效简化问题（虽然还不知道swap应该实现的代码，但是先写个占位符，有助于分析思路） ​ 一、实现 swap 实现交换 index 和 i 的元素 1、常规方法 let swap = (array, i, j) =\u003e { let temp = array[i] array[i] = array[j] array[j] = temp } swap(numbers, 1, 2) 2、JS 解构赋值（析构赋值） let a = 1; let b = 2; [a,b] = [b,a] // a =\u003e 2 // b =\u003e 1 ​ 错误的实现 swap let swap = (a,b) =\u003e { let temp = a a = b b = temp } let numbers = [100,200,300] // 能否实现交换元素位置呢 ？？ swap(numbers[1], numbers[2]) console.log(numbers) // [100,200,300] 未实现交换位置 你会发现，上述 numbers[1] 和 numbers[2] 的值原封不动 分析： 如果 a / b 是简单类型，传参的时候就会复制值 numbers[1] 传给 a，相当于 a 复制了 200 这个值，a 与 numbers 并没有连带关系。 b 同理 相当于只是把 a(200) 和 b(300) 交换了值，但这一切与 numbers 并没有关系 而前面常规方法中 numbers 是(数组)对象，传参时是复制地址 let swap = (array, i, j) =\u003e {...} 这里的 array 形参是接收一个数组实参，也就是接收一个对象，对象传递时只是复制了地址，所以 array 形参始终代表了传递进来的实参数组 numbers 所以 array[i] 和 array[j] 交换位置，也就等同于控制 numbers 中对应元素交换了位置 这就是【传值 V.S. 传址】的区别 内存图相关知识：所有放在 stack 中的都是直接复制值，放在 heap 里面只能复制地址 ​ 二、分析 i \u003c ??? 应该写什么 怎么知道 i \u003c ??? 处应该写什么 暴力分析（逐步拆解） let sort = (numbers) =\u003e { for(let i=0; i\u003c???; i++){ let index = minIndex(numbers) swap(number，index,i) } } 假设 numbers 的长度为 n = 4 👇 第一次循环 i = 0，当前遍历的元素下标为 0 ，需要进行比较的元素、其下标 index 的取值范围只能是 1\\2\\3 第二次循环 i = 1，当前遍历的元素下标为 1 ，需要进行比较的元素、其下标 index 的取值范围只能是 2\\3 第三次循环 i = 2，当前遍历的元素下标为 2 ，需要进行比较的元素、其下标 index 的取值范围只能是 3 第四次循环 i = 3，当前遍历的元素下标为 3 ，需要进行比较的元素、其下标 index 无法取值，所以 i 不能等于 3，一定要 i = 3 和 一个空数组进行比较也可以，但多此一举 结论：i 的取值为 0\\1\\2 【 i 能取到的最大值小于 3 ，也就是 i \u003c numbers 的长度减 1 】 for(let i=0; i\u003cnumbers.length-1; i++ ){...} ​ ​ 发现 2 个问题 1、minIndex 查找范围有问题 let index = minIndex(numbers) 这句话有问题，如果上次循环已经找到了第一个最小的数字，那么之后找最小数字的时候，就可以忽略第一个 let index = minIndex( numbers.slice(i) ) + i 👆分析 下标 i 、下标 index 对应元素的交换经过 [20,40,30,10] =\u003e 当前i=0 , minIndex([20,40,30,10])=\u003e最小值下标index=3 , 0与3交换位置=\u003e[10,40,30,20] , 10位置钉住 =\u003e 当前i=1 , minIndex([xx,40,30,20])=\u003e最小值下标index=3 , 1与3交换位置=\u003e[10,20,30,40] , 10/20位置钉住 =\u003e 当前i=2 , minIndex([xx,xx,30,40])=\u003e最小值下标index=2 就是当前元素 i，无需交换位置 =\u003e （结束）i不需要再取3，因为上一步已经将最后两个元素进行比较 所以说，每一轮 minIndex 的元素，都需要忽略前一个元素，也就是👇 当 i = 0，需要从 [20, 40, 30, 10] 中找出最小值，忽略 0 个 👉 [10, 40, 30, 20] 当 i = 1，需要从 [xx, 40, 30, 20] 中找出最小值，忽略 1 个 👉 [10, 20, 30, 40] 当 i = 2，需要从 [xx, xx, 30, 40] 中找出最小值，忽略 2 个 👉 [10, 20, 30, 40] 综上，发现规律：i 等于 N，就需要忽略前面 N 个元素 所以 =\u003e minIndex( numbers.slice(i) ) 2、为什么要 +i 如果不加 i ， 那么 index 的取值计算，每次都是从 0 开始 因为每轮都切掉前面一个元素，导致下标数值发生变化 当 i=0，忽略0个，从 [20,40,30,10] 中找出最小值10/下标为【3】，实际在[20,40,30,10]对应下标仍为【3】 👉 [10, 40, 30, 20] 当 i=1，忽略1个(下标为0的元素)，从[40,30,20]中找出最小值20/下标为【2】实际在[10,40,30,20]对应下标应为【3】 👉[10, 20, 30, 40] 当 i=2，忽略2个(下标为0/1的元素)，从[30,40]中找出最小值30/下标为【0】实际在[10,20,30,40]对应下标应为【2】 👉不交换 得出规律 i=0时，minIndex =\u003e 3，index =\u003e 3 👉 相当于 minIndex(3) + i(0) = index(3) i=1时，minIndex =\u003e 2，index =\u003e 3 👉 相当于 minIndex(2) + i(1) = index(3) i=2时，minIndex =\u003e 0，index =\u003e 2 👉 相当于 minIndex(0) + i(2) = index(2) index = minIndex(…) + i // 最终得出 let index = minIndex( numbers.slice(i) ) + i ​ 再次分析 i\u003c ??? let sort = (numbers) =\u003e { for(let i=0; i\u003c???; i++){ let index = minIndex( numbers.slice(i) ) + i swap(number, index, i) } } 假设 numbers 的长度 n = 4 i 等于 3 时，在 minIndex(numbers.slice(3))中， numbers 只剩 numbers[3] 也就是 numbers[i] 本身，只剩一个元素，无法再和其他元素进行比较大小了，也就不需要 minIndex 操作了，所以 i = 3 是无意义的 所以 i 的取值从 0 开始，最大就到 2 为止 结论：i 的取值范围是 i \u003c 3 ，也就是 i \u003c n-1 ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:5:2","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"循环代码（注释版） let sort = (numbers) =\u003e { for(let i = 0; i \u003c numbers.length - 1; i++){ console.log(`----`) // 这个log很精髓 console.log(`i: ${i}`) // 打印i，知道这是第几次比较 let index = minIndex(numbers.slice(i)) + i // 找到最小值下标 console.log(`index: ${index}`) console.log(`min: ${numbers[index]}`) if(index !== i){ // 如果最小值下标index 与 i 不等，就交换二者位置，相等就什么也不做 swap(numbers, index, i) console.log(`swap ${index}: ${i}`) // 打印出调换的 index 和 i console.log(`numbers: ${numbers}`) } } return numbers } // 下面是sort中引用的两个帮助函数： swap / minIndex let swap = (array, i, j) =\u003e { // 用于交换位置 // let temp = array[i] // array[i] = array[j] // array[j] = temp [array[i], array[j]] = [array[j],array[i]] // 也可以用解构赋值法，交换元素位置 } let minIndex = (numbers) =\u003e { // 用于找出最小值下标 let index = 0 for(let i = 0; i \u003c numbers.length; i++){ if(numbers[i] \u003c numbers[index]){ index = i } } return index } ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:5:3","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"汇总 ✅ 循环代码（纯净版） 思路：循环的每轮，找到未排序数组中的最小值的下标，用于交换位置，把最小值放到最前面 循环的每轮，都假设 i 为当前轮次的最小值下标，并且 i 还可以表示当前未排序数组的第一位元素。 通过 minIndex 找到未排序数组中的最小值下标 如果最小值下标与假设不符，就通过 swap 交换位置 三部分组成：sort（循环排序）、swap（实现交换位置）、minIndex（找最小值下标） let sort = (numbers) =\u003e { for(let i = 0; i \u003c numbers.length - 1; i++){ // 👈 重点理解！！（边界：为什么-1） let index = minIndex(numbers.slice(i)) + i // 👈 重点理解！！（最小值下标：为什么+i） if(index !== i){ swap(numbers,index,i) } } return numbers } let swap = (array, i ,j) =\u003e { [array[i], array[j]] = [array[j],array[i]] } let minIndex = (numbers) =\u003e { let index = 0 for(let i = 0; i \u003c numbers.length; i++){ if(numbers[i] \u003c numbers[index]){ index = i } } return index } 补充：双层 for 循环写法 特点：代码量少，只需一个函数。但思路、算法过程不易理解 思路同上：每轮找未排序数组中的最小值的下标，用于交换位置，把最小值放到最前面 外层循环：每轮开局，都假设当前遍历元素 j（同时也是未排序数组的第一个元素）为最小值 minIndex 内层循环：当前未排序数组中的第一个元素 j 和 后面元素依次比较大小，确定当前最小值下标 如果当前最小值下标与假设不符，就交换二者位置 let selectSort = arr =\u003e{ for (let j = 0; j \u003c arr.length - 1; j++) { // j表示每轮遍历的元素的下标；i表示下一位元素的下标 let minIndex = j // 每轮都假设当前元素是最小值，当前元素下标 j 是最小值下标 for (let i = j + 1; i \u003c arr.length; i++) { if (arr[i] \u003c arr[minIndex]) { // 当前元素与下一个元素，进行两两比较，找出最小值下标 minIndex = i } } if (minIndex !== j) { // 若最小值不是当前元素 j ，那就把最小元素与当前元素交换位置 [arr[minIndex], arr[j]] = [arr[j], arr[minIndex]] } // 每一轮都从未排序数组中找出最小值，并放到未排序数组的最前面(第一位) // 注：每一轮遍历的当前元素 j 所在位置，就是当前未排序数组的第一位 } return arr } 对比：递归写法 特点：思路更简明、但需要帮助函数 【边界处理 ( 中止条件 ) 是关键！！】 递归思路： 长度大于2，就找最小值放到前面 + 并对后面所有值再次 sort 长度等于2，就直接判断大小 / 交换两个元素位置，然后返回数组。【👈中止条件（边界处理）】 let minIndex = arr =\u003e arr.indexOf(min(arr)) let min = arr =\u003e { if(arr.length \u003e 2){ return min( [arr[0], min( arr.slice(1) ) ] ) // 递归 }else{ return arr[0] \u003c arr[1] ? arr[0] : arr[1] // 👈 边界处理很关键！！ } } let sort = arr =\u003e { if(arr.length \u003e 2){ let index = minIndex(arr) let minNum = arr[index] arr.splice(index,1) return [minNum].concat(sort(arr)) // 递归 }else{ return arr[0] \u003c arr[1] ? arr : arr.reverse() // 👈 边界处理很关键！！ } } ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:5:4","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"总结 选择排序的两种实现方式：递归、循环 思路：每次选择最小 / 大的，放在最前面 / 最后面。选到最后没得选了，就排完了 假设有 10 个元素，就需要选择 8 次、对比 8 次。 第 1 个元素不用选，默认第 1 个直接和第 2 个对比 第 10 个也不用选，选第 9 个时，就已经和第 10 个对比了 所以只需要对比 8 次 每次对比，需要进行一次搜索（找到最小值） 所以时间复杂度、大概是「 n 的平方 」 ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:5:5","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"总结 👆 ","date":"2020-10-16","objectID":"/algorithm-sort/:6:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"1. 所有递归都能改成循环 ","date":"2020-10-16","objectID":"/algorithm-sort/:6:1","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"2. 循环的时候有很多细节 循环时特别容易被细节干扰，这些细节很难想清楚 要动手列出表格，找规律 尤其是边界条件很难确定 我们没有处理长度为 0 和 1 的数组（if length === 0 | 1 直接 return 即可） ","date":"2020-10-16","objectID":"/algorithm-sort/:6:2","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"3. 如果 debug 学会看控制台 学会打 log 打 log 的时候，注意加标记 ​ ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:6:3","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"快速排序 quick sort ⭕️ 特点就是「快」 只讲递归思路，不讲循环思路。通过上面的学习，已经知道递归更简单、循环非常复杂（细节很多） ","date":"2020-10-16","objectID":"/algorithm-sort/:7:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"递归思路 以某某为基准 想象你是一个体育委员 你面对的同学为 [12，3，7，21，5，9，4，6] **「以某某为基准，小的去前面，大的去后面」 ** （不会规定「你」需要站在哪里） 你只需要重复说上面这句话，就能让他们完成排序 神奇不神奇？ 用图说明一下 =\u003e [12，3，7，21，5，9，4，6] 👆 =\u003e 假设站在靠中间的 21 上 =\u003e 喊话「以21为基准，比21小的，站到21前面，大的站到后面」 =\u003e [12，3，7，5，9，4，6，21] 经过这一次排序，21 的位置就钉住了 👆 =\u003e 再次随机找一个数（从中间找），喊话「以5为基准，比它小的站到前面，比它大的站到后面」 =\u003e [12，3，7，5，9，4，6，21] 👆 =\u003e [3，4， (5)，12，7，9，6，(21)] // [3,4]是比5小的，[12,7,9,6]是比5大的，5的位置就钉住了 =\u003e 接下来在[3,4]中间任选一个（假设选4吧），喊话「比4大的去前面，比4小的去后面」 =\u003e [3]、(4)、(5)、[12,7,9,6]、(21) // 此时 4 的位置就钉住了。3固定了吗？不行，每次指向谁，谁才能固定 =\u003e 此时指向3，发现3就一个元素自身，那无需比较，3可以固定了 =\u003e 下面跑到右边一组去，指向 7 吧，喊话「比7大的去前面，比7小的去后面」 =\u003e (3)、(4)、(5)、[6,(7),12,9]、(21) // 假设下面指向6，就一个可以直接固定了 =\u003e (3)、(4)、(5)、(6),(7),[12,9]、(21) // 下面指向 9 吧，所以9就钉住了，喊话「比9大的往后面去...」 =\u003e (3)、(4)、(5)、(6)、(7)、(9)、[12]、(21) // 就剩12一个元素了，此时指向 12，就一个所以直接固定位置 =\u003e (3)、(4)、(5)、(6)、(7)、(9)、(12)、(21) =\u003e [3,4,5,6,7,9,12,21] 思路 一共 8 个元素，每指向一个元素，就会固定一个元素的位置 所以只需要指 8 次，就完成排序了 【这就是快速排序的思路】 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:7:1","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"快排源码（递归） 下面是在阮一峰写的版本基础上、加工成 ES6 因为使用递归思想，所以必须考虑中止条件、对各种情况进行相应处理 逐步分析 👇 如果发现数组只有一个元素，就无需排序，直接放行（中止条件） 注意：这里条件必须写 arr.length \u003c= 1 ，不能只有arr.lenght === 1 这会导致递归无法结束 pivot /ˈpɪvət/ —— 基准、中心点、轴 取地板（舍去小数部分）：Math.floor(3.5) → 3 pivot ，这里的 splice 用于删除数组中的某个元素，并把它。（splice 会修改原数组） 因为 JS 中 splice 提取后返回的是一个数组，必须通过 [0] 的方式才能拿到数字本身。并赋值给变量 pivot 拿到基准数，并将基准数从 arr 中删除 既然已经拿到基准数的下标，为什么不直接通过 let pivot = arr[pivotIndex] 来获取到基准数，而是还要通过 splice 的返回值来获取基准数、这么麻烦的方式？？ 因为这里实际上是完成两个操作：第一目的是获取基准数、第二目的是还需要将基准数从 arr 中删除，所以使用 splice 正好可以同时完成这两个操作 let quickSort = arr =\u003e { if(arr.length \u003c= 1) { return arr } // 最基本的情况：发现指向的数组只剩下一个元素 let pivotIndex = Math.floor(arr.length / 2) // 获取基准的索引、找到靠中间的数字（取地板） let pivot = arr.splice(pivotIndex, 1)[0] // 拿到基准数，并将基准数从 arr 中删除 let left = [] let right = [] for(let i=0; i \u003c arr.length; i++){ // 遍历被删掉基准数后的数组 （执行喊话操作） if(arr[i] \u003c pivot){ left.push(arr[i]) // 如果当前遍历元素小于基准数，就放到left数组中 }else{ right.push(arr[i]) // 由此得到了三部分：左边数组、基准数、右边数组 } } return quickSort(left).concat( [pivot], quickSort(right) ) // 👈 代码的核心就是这句 // 不断对左边数组快排、右边数组快排、连接两边数组和基准数 // 停止条件是 数组只剩下一个元素，直接返回数组 } 思路： 对数组「找基准数、然后左右分半」 … 不断递归（循环）这个操作 直到数组只剩一个元素，就不再执行直接返回 所有算法的思路都很简单，难再代码实现 代码（纯净版） 思路： 每次找一个中间基准数。将数组对半，大于基准数，放到左边数组，小于基准数放到右边数组。 然后再次分别对左边/右边数组排序（层层递归、压栈） 中止（边界）条件：数组\u003c=1个元素，就可以直接返回这个具体值（开始弹栈） let quickSort = arr =\u003e { if(arr.length \u003c= 1){ return arr } let pivotIndex = Math.floor(arr.length / 2) let pivot = arr.splice(pivotIndex,1)[0] let left = [] let right = [] for(let i=0; i\u003carr.length; i++){ if(arr[i] \u003c pivot){ left.push(arr[i]) } else{ right.push(arr[i]) } } return quickSort(left).concat([pivot], quickSort(right)) } ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:7:2","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"补充说明 例：let pivot = arr.splice(pivotIndex, 1)[0] 因为 splice 的特性，导致必须用 [0] 来拿到基准数本身 let arr = [16,32,45] let a = arr.splice(1,1) a // [32] ------------------------------ let arr = [16,32,45] let a = arr.splice(1,1)[0] a // 32 算法如果涉及到某个语言的细节，这是非常不好的。 最好的算法写法是用「伪代码」来写。自己发明语法，就不用纠结 API 的问题了。 面试时，可以尝试鸡贼的写法，询问面试官可否使用「伪代码」来写 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:7:3","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"思路一句话 以某个元素为基准，小的往前放，大的往后放 ​ ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:7:4","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"归并排序 merge sort ⭕️ 是当前三种排序算法中最难理解的一个 ","date":"2020-10-16","objectID":"/algorithm-sort/:8:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"「不」以某某为基准 想象你是一个体育委员 你面对的同学为 [12，3，7，21，5，9，4，6] 左边一半排好序，右边一半排好序 **然后把左右两边合并（merge）起来 ** 神奇不神奇？ 用图说明一下 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:8:1","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"思路分析 [12，3，7，21，5，9，4，6] =\u003e [12,3,7,21]，[5,9,4,6] // 【每次都把数组看作左边和右边，并让左右边自己排序】 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ =\u003e [3,7,12,21]，[4,5,6,9] // 左右排序完成（先忽略排序细节） =\u003e 现在只需要把左右两部分【结合】起来，怎么结合？ // 【合并】 =\u003e [3, 7, 12, 21]，[4, 5, 6, 9] 👆 👆 // 左手指向左边第一个，右手指向右边第一个。比较两个值大小，把较小的放到容器中。 ✅✅ // 此时左边的 3 更小，所以先把 3 放到下面容器中。然后左手指向下一个元素 7 =\u003e [3, ] =\u003e [3, 7, 12, 21]，[4, 5, 6, 9] 👆 👆 // 此时比较 7 和 4。把较小值 右边的 4 放到容器中。右手指向下一元素 [3, 4, ] =\u003e [3, 7, 12, 21]，[4, 5, 6, 9] 👆 👆 // 此时比较 7 和 5。把较小值 右边的 5 放到容器中。右手指向下一元素 [3, 4, 5, ] =\u003e [3, 7, 12, 21]，[4, 5, 6, 9] 👆 👆 // 此时比较 7 和 6。把较小值 右边的 6 放到容器中。右手指向下一元素 [3, 4, 5, 6, ] =\u003e [3, 7, 12, 21]，[4, 5, 6, 9] 👆 👆 // 此时比较 7 和 9。把较小值 左边的 7 放到容器中。左手指向下一元素 [3, 4, 5, 6, 7, ] =\u003e [3, 7, 12, 21]，[4, 5, 6, 9] 👆 👆 // 此时比较 12 和 9。把较小值 右边的 9 放到容器中。右边元素排完了. [3, 4, 5, 6, 7, 9 ] 当某一边元素全部排完，另一边元素就可以全部照抄了 （左边还剩12,21直接放进容器中）✅✅ 大功告成 =\u003e [3, 4, 5, 6, 7, 9, 12, 21] 综上可知：【合并】的算法其实很简单：左右两边 index 同时遍历，把较小值 push 到容器中 问题是：怎么让左右两边自己先完成排序？ （递归思想 👇） 数组 [12,3,7,21,5,9,4,6] 分成左右两边 [12,3,7,21]，[5,9,4,6] 之后 将左边 [12,3,7,21] 再次划分为两部分 [12,3]、 [7,21] 将左边 [12,3] 再次划分为两部分 [12]、 [3] 当拆分到只有两个元素时，就可以直接比较大小排序了（如果不会，还可以再进行前面的【合并】操作） =\u003e [12]、 [3] =\u003e 👆 👆 // 左手指向左边第一个，右手指向右边第一个。将较小值放到容器中 =\u003e [3, ] // 此时右边全部排完。那么左边直接照抄落到容器后面即可 // 大功告成 =\u003e [3, 12]，同理得到 [7, 21] 上面 从 [12]、 [3] 得到 [3, 12] 这一步是最关键的一步。 将数组 [12,3]，[7,21] 拆分为 [12] [3]，[7] [21] … **「使得所有数组，变成了排好序的数组」**怎么理解这句？ 被拆分后，数组中只有一个元素，一个元素也就无需排序。 变相的理解成 **「此时所有的数组，都是无需排序的数组（排好序的数组）」 ** 归并排序的算法：默认只能，对两个排好序的数组，进行排序 这个算法可能乍一看，很不可思议，好像什么都没做，就排好序了。 一定要拆解步骤，才能发现这里面的神奇之处。 // 再合并（左手指左一、右手指右一，较小值放到容器中）✅✅ =\u003e [3, 12]，[7, 21] 👆 👆 // 比较 3 和 7。把较小值 左边的 3 放到容器中。左手指向下一元素 12 [3, ] =\u003e [3, 12]，[7, 21] 👆 👆 // 比较 12 和 7。把较小值 右边的 7 放到容器中。右手指向下一元素 21 [3, 7, ] =\u003e [3, 12]，[7, 21] 👆 👆 // 比较 12 和 21。把较小值 左边的 12 放到容器中。左边全部排完。右边剩下[21]直接落到后面 [3, 7, 12 ] // 大功告成 =\u003e [3, 7, 12, 21] ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:8:2","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"源码分析 let mergeSort = arr =\u003e { if (arr.length === 1) { return arr } let left = arr.slice(0, Math.floor(arr.length / 2)) let right = arr.slice(Math.floor(arr.length / 2)) return merge(mergeSort(left), mergeSort(right)) // 👈关键 } let merge = (a, b) =\u003e { // 👈 核心 if (a.length === 0) return b if (b.length === 0) return a return a[0] \u003e b[0] ? [b[0]].concat(merge(a, b.slice(1))) : [a[0]].concat(merge(a.slice(1), b)) // 关键 👆 } 详细注释 👇 let mergeSort = arr =\u003e { if (arr.length === 1) { // 长度为1的数组，无需排序，所以默认它是已经排好序的数组【这点非常关键】 return arr } // arr.slice(begin,end) 截取数组下标从begin到end的部分，返回新数组（包括begin，不包括end） // 原数组 arr 不改变 // 省略 end，则 slice 会一直提取到原数组末尾 let left = arr.slice(0, Math.floor(arr.length / 2)) // left是从下标0截取到一半的位置（不包括end） let right = arr.slice(Math.floor(arr.length / 2)) // right是从一半的位置，截取到末尾（包括begin） return merge(mergeSort(left), mergeSort(right)) // 左右再次进行拆分操作。拆到数组只有1个元素，认为所有数组已经排好序。 // 对排好序的数组进行 merge 合并（这才是归并算法的核心👇见下） } let merge = (a, b) =\u003e { // 【前提条件：merge 接收的a、b两个数组，必须是已经排好序的两个数组】！！！ if (a.length === 0) return b // 一个空数组a和一个已经排好序的数组b，那就直接返回排好序的数组b if (b.length === 0) return a // 同理 return a[0] \u003e b[0] ? [b[0]].concat(merge(a, b.slice(1))) : [a[0]].concat(merge(a.slice(1), b)) // 👆这里就是递归的难理解之处，需要拆解步骤 ⚠️⚠️见下 } 拆解 merge⚠️⚠️ 【前提条件：merge 接收的 a、b 两个数组，必须是已经排好序的两个数组】！！！ merge([1,5,10], [2,4,9]) =\u003e a[0] \u003e b[0] ? [b[0]].concat(merge(a, b.slice(1))) : [a[0]].concat(merge(a.slice(1), b)) ---------------------------------------------拆解 👇----------------------------------------- // 第一步：指向两个数组的第一位，比较大小 =\u003e [1,5,10], [2,4,9] ↑ ↑ 1 \u003e 2 否，执行 [a[0]].concat( merge( a.slice(1), b ) ) // 相当于把较小值摘出，再次merge剩余部分 =\u003e [1, merge( [5,10], [2,4,9] )] ↑ ↑ 5 \u003e 2 是，执行 [b[0]].concat( merge( a, b.slice(1) ) ) // 把较小值摘出，再次merge剩余部分 =\u003e [1, 2, merge([5,10], [4,9]) ] ↑ ↑ 5 \u003e 4 是，执行 [b[0]].concat( merge( a, b.slice(1) ) ) // 把较小值摘出，再次merge剩余部分 =\u003e [1, 2, 4, merge([5,10], [9]) ] ↑ ↑ 5 \u003e 9 否，执行 [a[0]].concat( merge( a.slice(1), b ) ) // 把较小值摘出，再次merge剩余部分 =\u003e [1, 2, 4, 5, merge([10], [9]) ] ↑ ↑ 10 \u003e 9 是，执行 [b[0]].concat( merge( a, b.slice(1) ) ) // 把较小值摘出，再次merge剩余部分 =\u003e [1, 2, 4, 5, 9, merge([10], []) ] ↑ ↑ // 满足中止条件：一个空数组、一个已经排好序的数组 ，那就直接返回排好序的数组b =\u003e [1, 2, 4, 5, 9, 10] 补充：slice 用法 arr.slice(begin, end) 截取数组下标从 begin 到 end 的部分，返回一个新数组（包括begin，不包括end） **原始数组不改变 ** begin （可省略） 提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。 **如果省略 begin，则 slice 从索引 0 开始。 ** 如果 begin 大于原数组的长度，则会返回空数组。 end（可省略） 提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。 slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。 如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 **如果 end 被省略，则 slice 会一直提取到原数组末尾。 ** 如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。 // 省略两个参数，可以实现深拷贝效果 ？！ let arr = [1,2,3,4,5] let newArr = arr.slice() console.log(`newArr: ${newArr}`) // 6,2,3,4,5 newArr[0] = 6 console.log(`修改后，newArr: ${newArr}，arr: ${arr}`) // 6,2,3,4,5 1,2,3,4,5 原数组不改变 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:8:3","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"代码（纯净版） let mergeSort = arr =\u003e { if (arr.length === 1) { return arr } let left = arr.slice(0, Math.floor(arr.length / 2)) let right = arr.slice(Math.floor(arr.length / 2)) return merge(mergeSort(left), mergeSort(right)) } let merge = (a, b) =\u003e { if (a.length === 0) return b if (b.length === 0) return a return a[0] \u003e b[0] ? [b[0]].concat(merge(a, b.slice(1))) : [a[0]].concat(merge(a.slice(1), b)) } ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:8:4","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"总结 归并排序的思路 mergeSort 拿到一个乱序的数组，会把数组分成左右两部分。然后对左右两边继续调用 mergeSort 再拆分 … 拆分到所有元素独自成一个数组，达到中止条件。 merge 接收两个数组作为参数（只接收排好序的数组） **每次都比较两个数组的首项，并提取出较小的值，放在最前面 ** 因为两个数组都是顺序排列，所以首项一定代表其所在数组的最小值。 两个最小值对比得出的较小值，一定是所有元素中的最小值，所以摘出放在最前面 对剩余数组，继续重复上一步操作 ​ 代码 let mergeSort = arr =\u003e { if(arr.length === 1){ return arr } let left = arr.slice(0, Math.floor(arr.length/2)) let right = arr.slice(Math.floor(arr.length/2)) return merge(mergeSort(left), mergeSort(right)) } let merge = (a,b) =\u003e { if(a.length === 0) return b if(b.length === 0) return a return a[0] \u003c b[0] ? [a[0]].concat(merge(a.slice(1),b)) : [b[0]].concat(merge(a, b.slice(1))) } ​ 图示 1 merge( a , b ) merge( [1,5,10] , [2,4,9] ) 2 mergeSort([12,3,7,21, 5,9,4,6]) 3 mergeSort([6,3,2,7,1,5,8,4]) merge( mergeSort([6,3,2,7]), mergeSort([1,5,8,4]) ) merge( merge( mergeSort([6,3]), mS([2,7]) ), merge( mergeSort([1,5]), mergeSort([8,4]) ) ) m(m(m(mS([6]),mS([3])), m(mS([2]),mS([7])) ) , m(m(mS([1]),mS([5])), m(mS([8]),mS([4])))) // 达到 mergeSort 中止条件 👆 m( m( m([6],[3]), m([2],[7]) ) , m( m([1],[5]), m([8],[4]) ) ) // 开始 merge 👇 m( m( [3].concat( m([6],[]) ) , [2].concat( m([7],[]) ) ) ... ) ) m( m( [3].concat([6]), [2].concat([7]) ) , m( [1].concat([5]), [4].concat([8]) ) ) m( m( [3,6] , [2,7] ), m( [1,5], [4,8] ) ) m( [2].concat( m([3,6], [7]) ) , [1].concat( m([5], [4,8]) ) ) m( [2].concat( [3].concat(m([6], [7])) ) , [1].concat( [4].concat(m([5], [8])) ) ) m( [2].concat( [3].concat([6].concat(m([], [7]))) ),[1].concat( [4].concat( [5].concat(m([], [8])) ) ) ) ... m( [2,3,6,7],[1,4,5,8] ) ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:8:5","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"思路一句话 每次都分两部分，默认是排好序的，如果没有排好序就先排序。然后对排好序的两个数组，进行合并 怎么把无序的数组排好序？ 很简单，（变相理解）不断拆分数组，直到每个数组中只有一个元素，这样每个数组都是排好序的 然后两个一组，开始进行合并 ​ 归并的思路确实很抽象，是上述三种算法种最难理解的（很哲学） 如果实在无法理解归并排序，那就学到快速排序就不要再学了 ​ ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:8:6","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"总结 ","date":"2020-10-16","objectID":"/algorithm-sort/:9:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"目前理清了三种排序 选择排序（递归、循环） 每次选择最小的，放在最前面。选到最后没得选了，就排完了 快速排序（递归） 以某个元素为基准，小的往前放，大的往后放 归并排序（递归） 每次都分两部分，默认是排好序的，如果没有排好序就先排序。然后对排好序的两个数组，进行合并 是上述三种算法种最难理解的（很哲学） ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:9:1","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"接下来 **计数排序 **（循环） 比上面的排序算法都要**快 ** ​ ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:9:2","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"计数排序 counting sort ⭕️ 特性：速度非常快 注：本节如果提到哈希，实际说的是哈希表（因为我们并没有接触过哈希函数 … ） ","date":"2020-10-16","objectID":"/algorithm-sort/:10:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"思路 用一个新的数据结构 —— 哈希表，来作记录 哈希表：一种 key: value 的形式。 JS 的对象可以算是哈希表的一种形式，但不是纯粹的哈希表。 因为 JS 对象具有隐藏属性、函数，而真正的哈希表里没有隐藏属性，只有数据。 所以 JS 对象不能算是一个完全的哈希表 发现数字 N 就记 N：1，如果再次发现 N 就加 1 最后把哈希表的 key 全部打出来，假设 N：m，那么 N 需要打印 m 次 画图演示 ​ 扑克牌 「一副扑克牌，（不算大小王）共 52 张，乱序 」 怎么对这副扑克牌排序 ，实现 【 AAAA , 2222 , 3333 , 4444 , … , JJJJ , QQQQ , KKKK 】 的排序结果 ？？ [1,2,1,3,4,1,K,K,J,J,5, ...... ] // 52张牌乱序 // 👇 哈希表：每碰到一个数，就对应位置记上一笔。（类似计数器） { A：0 2：0 3：0 J：0 Q：0 K：0 } 人类天生就会排序，只不过可能不会用代码表示出来 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:10:1","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"示例分析 [12,3,9,4,2,8,5,7] =\u003e 发现数字 N 就记 N：1，再次发现 N 就加 1。 同时记录最大值 max：假设第一个元素就是最大值，max = 0。遇到3 \u003c12，max不变；9\u003c12，max不变 ... 后面的数都比 12 小，所以 max 就是 12 =\u003e { 12:1 (max) 3:1 9:1 4:1 2:1 8:1 5:1 7:1 } 现在完成两件事： 1、x最大值为12 2、所有数据次数记录完毕。 接下来，开始循环 =\u003e 设定 i = 0 ~ 12(max)，如果发现哈希表里存在 i 值，就把 i 值打印到一个数组里面 i = 0, 哈希表中没有 0 =\u003e [] i = 1, 哈希表中没有 1 =\u003e [] i = 2, 哈希表中有 2 =\u003e [2, ] i = 3, 哈希表中有 3 =\u003e [2,3, ] 4 =\u003e [2,3,4, ] 5 =\u003e [2,3,4,5, ] 6 =\u003e [2,3,4,5, ] 7 =\u003e [2,3,4,5,7, ] 8 =\u003e [2,3,4,5,7,8, ] 9 =\u003e [2,3,4,5,7,8,9, ] 10 =\u003e [2,3,4,5,7,8,9, ] 11 =\u003e [2,3,4,5,7,8,9, ] 12 =\u003e [2,3,4,5,7,8,9,12 ] // 👈 排序完成 // 当 i 从 0 ~ 12 走完，排好序的数组也就得出了 // 需要两个条件姐就可以实现排序：哈希表、最大值max ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:10:2","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"初步代码 补充： in 操作符用法 let countSort = arr =\u003e { let hashTable = {}, max = 0, result = [] for(let i = 0; i \u003c arr.length; i++){ // 遍历数组，得到【哈希表】和【max】 if(!(arr[i] in hashTable)){ // 发现数字 N 就记 N：1，再次发现 N 就加 1 hashTable[arr[i]] = 1 }else{ hashTable[arr[i]] += 1 } if(arr[i] \u003e max) { // max：谁比我大，我就等于谁 max = arr[i] } } for(let j = 0; j \u003c= max; j++){ // 遍历哈希表 if(j in hashTable){ result.push(j) // 如果发现这个值在hash表中，就push到数组 } } return result } 上述代码有bug 遍历哈希表时，没有考虑「一个值在 hash 表中出现多个」的情况 举例验证 bug [4,2,2,5,2] // 得到 hash表 👇 { 4: 1, 2: 3, 5: 1 } // 遍历哈希表 for(let j = 0; j \u003c= max; j++){ if(j in hashTable){ // 如果发现 j 在 hash表 中，就 push 到数组 result.push(j) } } // j 取 0~5 （如果发现 j 在hash表中，就把 j 添加到数组） // j=0 =\u003e [] // j=1 =\u003e [] // j=2 =\u003e [2, ] // j=3 =\u003e [2, ] // j=4 =\u003e [2,4, ] // j=5 =\u003e [2,4,5 ] 遍历完成，结果数组中少了两个元素 2 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:10:3","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"完整代码 ✅ let countSort = arr =\u003e { let hashTable = {}, max = 0, result = [] for(let i = 0; i \u003c arr.length; i++){ if(arr[i] in hashTable){ hashTable[arr[i]] += 1 }else{ hashTable[arr[i]] = 1 } if(arr[i] \u003e max){ max = arr[i] } } for(let j = 0; j \u003c= max; j++){ if(j in hashTable){ for(let i = 0; i \u003c hashTable[j]; i++){ // 假设 j 出现了 3 次，就需循环 3 次(添加 j)的操作。 // i 可以取几个值，循环就执行几次，所以 i 应该取 3 个值 （从0开始就取 i = 0，1，2） result.push(j) } } } return result } ","date":"2020-10-16","objectID":"/algorithm-sort/:10:4","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"思路总结 ✅ 遍历数组，得到一个 hashTable（记录出现过的元素 key，以及出现次数 value）。 同时，在这次遍历数组的过程中，找到数组最大值 （开局假设第一个元素就是最大值max，依次比较，大于 max 的元素，就重新赋值给 max） 此时，已知 hashTable 和 max。 已知最大值 max，所以全部元素的取值都在 0 ~ max 这个范围之间 遍历 0 ~ max 这个范围之间的所有元素，如果与哈希表的 key 一致，就之间把这个元素 push 到数组中 如果当前 key(元素) 的 value(出现次数) 不是 1，说明原数组中有 N 个该元素，那就需要把 N 个该元素都在此时 push 到数组中。所以 push 操作需要循环执行 N 次 获取这个 value 次数，作为 for 循环执行次数 i 的依据，来控制 push 的执行轮次 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:10:5","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"计数排序的特点 ✅ 数据结构不同 使用了额外的 hashTable （数据结构） 计数排序中使用的数据结构升级了 算法也就直接升级了，非常快 只遍历数组一遍（不过还要遍历一次 hashTable ） 之前的排序算法，都会多次遍历数组 选择排序：找第一个最小值，需遍历一遍数组。找第二个最小值，需再把余下元素遍历 …（重复遍历） 为什么计数排序，可以这么厉害，就遍历一遍数组呢？ 答：就是因为有 hashTable，这叫做「用空间换时间」 hashTable 就是存储在内存中的一块空间。 用多余的空间就可以节省多余的时间。 通常空间、时间只能二选一：「用空间换时间」或「用时间换空间」 （除非你智商碾压，二者都能实现） ​ 时间复杂度对比 选择排序 O(n^2） 快速排序 O(n log2n) 归并排序 O(n log2n) 计数排序 O(n + max) 时间最少、速度最快，但空间占的多 先遍历一个长度为 n 的数组，再遍历一个长度为 max 的数组 时间复杂度，到底是怎么计算出来的呢？ 其实有特别简单的方法，几乎不需要太复杂的数学知识 👇 [详见下](# 时间复杂度) ​ ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:10:6","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"题外话：字母出现次数 前面讲过案例「如何统计一段文字中字母出现的次数，并打印结果」 其实就是借鉴了【计数排序】的思维 let count = str =\u003e { let result = {} let newStr = str.replace(/[^a-zA-Z]/g, '') // `HiImSam` console.log(newStr) for(let i=0; i\u003cnewStr.length; i++){ if(newStr[i] in result){ result[newStr[i]] += 1 }else{ result[newStr[i]] = 1 } } return result } let str = `Hi, I'm Sam` let newStr = str.match(/a-zA-Z/g) count(str) -------------------------------------------------- { H: 1 I: 1 S: 1 a: 1 i: 1 m: 2 } 补充正则 提取数字....value.replace(/[^\\d]/g, '') 提取中文....value.replace(/[^\\u4E00-\\u9FA5]/g, '') 提取英文....value.replace(/[^a-zA-Z]/g, '') 例 let str = `Hi, I'm Sam` let newStr = str.match(/[a-zA-Z]/g) // [\"H\", \"i\", \"I\", \"m\", \"S\", \"a\", \"m\"] // match 返回数组 let newStr = str.replace(/[^a-zA-Z]/g, '') // `HiImSam` （把字符串中所有非字母字符，替换为空） // replace 返回字符串 （替换思想） ​ ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:10:7","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"时间复杂度 其实就是举一个比较大的数组，看一下当前算法的规模 ","date":"2020-10-16","objectID":"/algorithm-sort/:11:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"以「选择排序」为例 // 假设数组长度为 1000 （且处于最坏情况，每次都需要对比，没有任何一次是不需要对比的） 第1次遍历，要从 [0,...,999] 找到最小值 min1（放到首位），需要对比999次 第2次遍历，要从 [1,...,999] 找到最小值 min2（放到首位），需要对比998次 第3次遍历，要从 [2,...,999] 找到最小值 min3（放到首位），需要对比997次 ... 第999次遍历，要从 [998,999] 找到最小值 min999（放到首位），需要对比1次 长度为 1000 的数组，最坏情况下（每次都需要对比） 1+2+3+4+…+998+999 =\u003e 1 + 2 + 3 + 4 + … + 998 + 999 =\u003e 1≈1000 + 2≈1000 + 3≈1000 + 4≈1000 + ... + 555≈1000 + ... + 998≈1000 + 999≈1000 =\u003e 大概1000个1000，也就是 1000^2 =\u003e n^2 综上： 选择排序：每次找最小的 时间复杂度，是 n 的平方 （这是最坏情况） ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:11:1","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"以「快速排序」为例 找一个基准数，然后左右分两队 // 假设数组长度为 1000 [0,...,500,...,999] ↑ ↙ ↘ // 以500为基准，依次和 500 进行比较 [0,...,500) , [500,...,999] // 左边全是比500小的，比较了 500 次。右边全是比500大的，比较了 500 次 // 然后 [0,...,500) 中再找一个基准数 250 [0,...,250,...,500) ↑ ↙ ↘ 250 250 // 左边是比250小的，比较了250次。右边是比250大的，比较了250次，以此类推 // 得出图示 👇 [0,...,250,...,500) [500,...,999] | =\u003e 500 * 2 = 1000 次 ↑ ↑ | ↙ ↘ ↙ ↘ | 250 250 250 250 | =\u003e 250 * 4 = 1000 次 ↙ ↘ ↙ ↘ ↙ ↘ ↙ ↘ | 125 125 125 125 125 125 125 125 | =\u003e 125 * 8 = 1000 次 ... ... ... /* 虽然每一排比较次数都是 1000 次，但是减少的速度特别快（每次折半） 看 1000 能除以多少次 2，就知道这个树形图，能分裂出多少个 1000 次 1000 ≈ 1024 = 2^10，1000大概是2的10次方，所以最多除以10次。 如果把树形图比喻成塔，塔最高10层，每层1000次】 */ 复杂度： =\u003e 1000 * 10层 // log(2)1000 ≈ 10层 (2^10=1024) =\u003e N * log(2)N 【快速排序】的时间复杂度，是 N * log(2)N ​ 基本上画出 4 步的图示，就能找到规律，无需花费更多精力来记忆 ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:11:2","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"以「归并排序」为例 思路：每次对半分。对排好序的两个数组，进行合并 // 假设数组长度为 1000 [0,...,999] ↙ ↘ // 拆分成左右两部分，各操作 1 次（共2次） merge([0,...,500], [500,...,999]) // merge合并：分别用左边500个数和右边500个数做对比（共1000次操作） ↙ ↘ ↙ ↘ // 拆分成左右两部分，各操作 1 次（共4次） 250 250 250 250 // merge：拆分成两部分，每部分250个数，逐个对比（共1000次操作） ↙↘ ↙↘ ↙↘ ↙↘ 125 125 125 125 125 125 125 125 // merge：拆分，每部分125个数，逐个对比（共1000次操作） ... // 拆分到，每个数组只有一个元素，就停止：[0]，[1]，[2]...[998]，[999] // 问题就转换为：1000个数对半拆分，需要多少次就能拆分成1个1个的。 2^10 = 1024 // 所以拆分10次就会停止，得到每个数组只有一个元素 // 所以，需要10次拆分，每次拆分需要执行1000次合并操作 复杂度： =\u003e 1000次合并 * 10次拆分 // log(2)1000 ≈ 10次拆分 (2^10=1024) =\u003e 1000 * log(2)1000 =\u003e N * log(2)N 例 merge([1,4,7],[2,5,9]) =\u003e [1,4,7], [2,5,9] =\u003e [1,2,4,5,7,9] // 6个元素需要对比5次 / 1000个元素需要对比999次 =\u003e 四舍五入就是 n 个元素需要对比 n 次 ​ 「归并排序」的 时间复杂度：与快速排序一致 N * log(2)N ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:11:3","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"以「计数排序」为例 思路：每次对半分。对排好序的两个数组，进行合并 // 假设数组长度为 1000 [0,...,999] =\u003e 对数组进行一次遍历：得出 计数的【哈希表】hashTable ，并找出最大值（假设max是100） （1000次操作） =\u003e hashTable 里就添加了1000个数据 =\u003e 遍历 min(0) ~ max（100），对应哈希表，发现相同值，就push输出 （100次操作） 复杂度： =\u003e 1000 + 100 // 元素在0~100之间 =\u003e n + max // 如果哈希表有最小值、最大值，如元素在50~100之间，则应该再减去min（只需比较 50 次） =\u003e n + max - min (默认min是0) 「计数排序」的 时间复杂度： n + max - min (默认min是0) ​ 基本上画出 4 步的图示，就能找到规律，无需花费更多精力来记忆 不需要做特别精细的分析，只需要看衰减的规律即可 ​ ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:11:4","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"算法学习总结 ","date":"2020-10-16","objectID":"/algorithm-sort/:12:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"心法 战略上藐视敌人：思想上暗示自己算法是特别简单的东西 战术上重视敌人：在真正写代码时，要非常重视每一个细节 +1 -1 \u003c \u003c= … （细节难以确定时，写写画画逐步分析） ","date":"2020-10-16","objectID":"/algorithm-sort/:12:1","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"特点 思路都很简单 细节都很多 不需要多强的智力，需要的是耐心、细心 **多画表，多画图，多 log ** 如果实在不想陷入 JS 的细节，可以用「伪代码」 ​ ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:12:2","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"还有哪些排序算法 ⁉️ 冒泡排序 https://visualgo.net/zh/sorting 点击 BUB （visualgo只提供伪代码思路参考） 插入排序 https://visualgo.net/zh/sorting 点击 INS 希尔排序 http://sorting.at/ 自己选择 Shell Sort 基数排序 https://visualgo.net/zh/sorting 点击 RAD ","date":"2020-10-16","objectID":"/algorithm-sort/:13:0","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"冒泡排序 bubble sort 最 low 的排序。思路 https://visualgo.net/zh/sorting （查看图示 + 伪代码） 两两对比，较大的往后接着对比。 每一轮找出一个最大值，冒泡到最后 let bubbleSort = arr =\u003e { for(let i = 0; i \u003c arr.length - 1; i++){ // i 代表轮次（两两比较） for(let j = 0; j \u003c arr.length - i; j++){ // j 代表当前轮选中元素的下标 if(arr[j] \u003e arr[j+1]){ [arr[j], arr[j+1]] = [arr[j+1], arr[j]] // 交换元素 } } } return arr } ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:13:1","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"插入排序 Insertion Sort 参考扑克牌思路，很好理解。 思路 扑克牌思路：大部分人抓完牌，手上拿着的牌就已经都是排好序的。 https://visualgo.net/zh/sorting 点击 INS （查看图示 + 伪代码） 拿起一张牌，依次和前面的牌对比（所以起始值从下标为 1 的元素开始，才能保证前面有值可对比） 比前面的小，就插入到前面去 思路 **从第一个元素开始，该元素可以认为已经被排序 ** 取出下一个元素，**在已经排序的元素序列中从后向前扫描 ** 把取出的元素放到已排序的元素中间的合适位置 重复步骤2~3 就像排队一样，依次每次挑一个同学，把该同学“插入”到已经排好的部分队伍里。 ​ 代码 开局默认第一个元素（前面元素）是已经排好序的。 取出下一个待排序元素，与前面已排好序的元素进行比较 如果后面的元素小于前面已排好序的某个元素，就把后面元素插入到前面已排好序的元素的**相应位置 ** // 插入法JS版 function insertionSort(arr) { // 开局默认下标0的元素已排序，所以待排序数组的下标取值从1开始 for(let i = 1; i \u003c arr.length; i++) { // i 表示当前待排序数组元素的下标 // j 表示当前已排序数组元素的下标（默认下标0的元素已排序,所以 j 初始值一定为0） // 已排序元素始终在待排序元素的前面，所以 j 的取值一定小于 i // 综上 j = [0,i) for(let j = 0; j \u003c i; j++) { // 当前取出的待排序元素arr[i]，依次和前面已排序元素进行比较 if(arr[i] \u003c arr[j]) { arr.splice(j, 0, arr[i]) // 在 arr[j] 前面插入 arr[i]，然后把原本的 arr[i] 删除 arr.splice(i+1, 1) // 因为上一步已经在前面插入一个元素，导致后面元素下标后移一位，原本需要被删除 i 位置上的元素，现在的下标变成了 i+1 break // 跳出内层循环，i++ } } } } let arr = [10, 34, 21, 47, 3, 28] insertionSort(arr) console.log(arr) 插入法普通版 for function insertionSort(arr) { for(var i = 1; i \u003c arr.length; i++) { var temp = arr[i] for(var j = i; j \u003e 0 \u0026\u0026 arr[j-1] \u003e temp; j--) { arr[j] = arr[j-1] } arr[j] = temp } } ----------------------------------------------------- function insertionSort(arr) { for (var i = 1; i \u003c arr.length; i++) { var temp = arr[i]; for (var j = i - 1; j \u003e= 0; j--) { if (arr[j] \u003e temp) { arr[j + 1] = arr[j]; } else { break; } } arr[j + 1] = temp; } return arr; } ------------------------------------------------------- let arr = [10, 34, 21, 47, 3, 28] insertionSort(arr) console.log(arr) 插入法普通版 while function insertionSort(arr) { for (var i = 1; i \u003c arr.length; i++) { var temp = arr[i]; var j = i - 1; while (j \u003e= 0 \u0026\u0026 arr[j] \u003e temp) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = temp; } return arr; } let arr = [10, 34, 21, 47, 3, 28] insertionSort(arr) console.log(arr) ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:13:2","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"希尔排序 Shell Sort 极其少见 算法应该是比较复杂的，是生想出来的。现实生活中没有可参考的例子、数学中也没有例子 1959年，一个叫 Shell 的人发明的 貌似是间隔着排，先大间隔、然后中间间隔 … 可能会节省一些中间的步骤 ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:13:3","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"基数排序 Radix Sort 特别适合用于**多位数排序 ** 指未排序数组中的元素，有一位数得、也有两位数、三位数、四位数、五位数的 … （形式多样的数组） 死记硬背，顺序非常重要，记错了就完了（但是可以理解这个算法的精神 👇 ） 先根据个位数排序，个位是 0 的从下往上叠在一起，个位是 1 的从下往上叠在一起 … 然后按照个位 0-9 堆叠的从下往上的顺序（这个顺序非常重要）展开所有元素，成一个数组 对这个新数组，根据十位数进行排序，十位数 0-9 从下往上堆叠。 然后再按0-9从下往上的顺序展开成数组 … 所有位数都重复上述操作 最后展开的数组，就是排完序的数组 ​ ​ ","date":"2020-10-16","objectID":"/algorithm-sort/:13:4","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"堆排序 Heap Sort 堆排序应该是排序的终点了，因为没有比堆排序更复杂的排序了 其他复杂的排序，基本都是在堆排序的基础上进行改进而已 搞定了堆排序，就搞定了**「树」**这个数据结构，就搞定了排序的最难的一部分 ","date":"2020-10-16","objectID":"/algorithm-sort/:13:5","tags":["算法","排序算法","数据结构","递归"],"title":"排序算法","uri":"/algorithm-sort/"},{"categories":["算法与数据结构"],"content":"递归、求任意长度数组的最小值、对任意长度数组进行排序","date":"2020-10-11","objectID":"/algorithm-introduction/","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:0:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"前言 前面学习的伪代码和流程图，是用来帮助我们思考的 本节是特别简单的算法入门。 —— 对于没学过算法的人可能觉得算法有点难，但当你学完后再来回顾，也许就会有上述的同感了 算法比你想象中简单 「什么是算法」「算法需要满足什么条件」… 等理论，这里就不讲了 直接开始写代码 —— 代码可以是 JS 也可以不是，主要是靠大脑在思考 ​ ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:1:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"⭕️小试牛刀：找 2 个数中的较小值 minOf2 首先应该想：如何表示两个数 二元组？！ 可以的 但 JS 中没有二元组，退而求其次，可以使用【长度为 2 的数组】来表示这两个数 如果能想到这一点，就说明已经知道【什么是数据结构】了 👆 约定用 [a,b] 表示这两个数 必备知识 👇 ","date":"2020-10-11","objectID":"/algorithm-introduction/:2:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"数据结构 用数组 [a,b] 表示两个数字 你能想到这一点，就说明你在使用数据结构 ","date":"2020-10-11","objectID":"/algorithm-introduction/:2:1","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"编程知识 问号冒号表达式 ? : 或 if … else … 怎么从 [a,b] 中找出较小的呢（逻辑） a \u003c b 成立，就返回 a。否则返回 b （比较大小，并返回较小值） ","date":"2020-10-11","objectID":"/algorithm-introduction/:2:2","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"代码 minOf2 的实现 numbers 是数组。 判断中直接获取 numbers[0] 、 numbers[1] 相当于约定数组长度只能为 2 虽然约定是长度为 2 的数组，但如果调用时传了长度为 1 的数组，怎么办 （暂时不考虑这种情况） let minOf2 = (numbers) =\u003e { if(numbers[0] \u003c numbers[1]){ return numbers[0] }else{ return numbers[1] } } ","date":"2020-10-11","objectID":"/algorithm-introduction/:2:3","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"优化代码 let minOf2 = numbers =\u003e numbers[0] \u003c numbers[1] ? numbers[0] : numbers[1] ","date":"2020-10-11","objectID":"/algorithm-introduction/:2:4","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"再优化代码 let minOf2 = ([a,b]) =\u003e a \u003c b ? a : b // 最简洁写法 这种写法叫做**「析构赋值」**，之后的课程会反复使用（解构） ","date":"2020-10-11","objectID":"/algorithm-introduction/:2:5","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"调用 minOf2([1,2]) // 1 这是小白调用法 minOf2.call(null, [1,2]) // 1 这是高手调用法 【推荐使用】（不使用this所以赋空值null） ​ 算法，就是把解决问题的思路，用代码表示出来，不论问题多么的简单（如两个数取最小） 什么是算法，就是用代码来解决问题 只不过编程界，有很多固定的问题，只有把这些固定问题都搞清楚，才可以说是会算法。只会一点是不够的 ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:2:6","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"现成 API JS内置了 Math.min Math.min 的核心，实际上就是上面我们写的 minOf2 的代码（比较大小，并返回较小值） Math.min(1,2） // 1 小白调用法 Math.min.call(null, 1,2) // 高手调用法，不需要this，所以取null Math.min.apply(null, [1,2]) // 高手调用法，区别于call，apply方法的第二个参数是【数组】形式 关于 Math 看起来 Math 像 Object 一样，都是首字母大写，难道 Math 也是构造函数 ？？ 实际上 Math 只是一个（首字母大写的）**普通对象 ** Math.__proto__ === Object.prototype // Math不是函数，不具有函数的共有属性。打开 Math 的原型，就是【根对象】 以前接触过的所有对象，都是首字母小写，甚至全局对象 window 都是首字母小写 JS 中只有 Math 是唯一一个首字母大写的对象 ⭕️⚡️🚩 这是唯一的特例：首字母大写是构造函数 ​ ​ ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:2:7","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"⭕️举一反三：找 3 个数中的最小值 minOf3 思路：先求前两个数中的较小值，然后拿这个较小值和第三个数进行比较，再得出一个较小值，它就是三个数中的最小值 ","date":"2020-10-11","objectID":"/algorithm-introduction/:3:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"代码 minOf3 的实现 let minOf3 = ([a,b,c]) =\u003e { return minOf2([minOf2([a,b]), c]) // 先求 a、b 最小值 } 或者 let minOf3 = ([a,b,c]) =\u003e { return minOf2([a, minOf2([b,c])]) // 先求 b、c 的最小值 【推荐写法：形式上更好看😝】 } 注意： minOf3 调用了两次 minOf2 ，这并不是「递归」 如果 minOf3 调用了 minOf3 ，这才是「递归」 ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:3:1","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"⭕️逐步推理：找 4 个数中的最小值 minOf4 minOf4 的实现 let minOf4 = ([a,b,c,d]) =\u003e { return minOf2([a, minOf3([b,c,d])]) // 用 minOf2 求 a 和 后面三个数中的最小值 } 得出推论：任意长度数组 求最小值，都可以基于 minOf2 并最终实现 提问：可否把「求最小值」写作一个函数 min 呢 👇 ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:4:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"⭕️推广：求任意长度数组の最小值 min min 的实现 ","date":"2020-10-11","objectID":"/algorithm-introduction/:5:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"细品 把 minOf? 全部用 min 替换 思路：先依次求后面所有元素的最小值 … 最后和第一位元素进行比较，最终得出所有元素的最小值 （不断拆分第1个元素和后面所有元素） 代码👇 let min = (numbers) =\u003e { return min( [ numbers[0], min( numbers.slice(1) ) ] // 截取数组中下标为1及1之后的所有元素，组成新数组（也就是去掉数组中下标为0的元素） ) } 这个代码会死循环不停调用自己，直到报错为止，所有需要添加一个中止条件 ","date":"2020-10-11","objectID":"/algorithm-introduction/:5:1","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"完整代码：添加中止条件 跳出递归的条件：当 numbers 中只有两个元素时，不再拆分，直接判断两个元素大小，返回较小值 let min = (numbers) =\u003e { if(numbers.length \u003e 2){ // 停止条件 return min( [ numbers[0], min( numbers.slice(1) ) ] // 递归（拆分出第1个元素和后面所有元素） ) }else{ // return numbers[0] \u003c numbers[1] ? numbers[0] : numbers[1] // 👈👇两种写法均可 return Math.min.apply(null, numbers) // 必须用 apply。 // 因为min方法接收的参数必须是一个一个的数字，不接受数组，如果用call就是把整个数组传给min。所以必须用 apply 会把数组给展开成一个一个的数字 } } min([2,4,3,1]) // 代入法：获取这个数组[2,4,3,1]中的最小值 这就是[递归](# 递归) 👆 ","date":"2020-10-11","objectID":"/algorithm-introduction/:5:2","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"递归 先递进，再回归 一定要用代入法来理解，只靠看是看不懂的，眼睛只会欺骗你、 ","date":"2020-10-11","objectID":"/algorithm-introduction/:6:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"特点 函数不停调用自己，每次调用的参数略有不同 当满足某个简单条件时，则实现一个简单的调用（获取到一个基本值） 然后将基本值层层代入、回归 算出最终结果 ","date":"2020-10-11","objectID":"/algorithm-introduction/:6:1","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"理解 可以用 代入法 快速理解递归 层层剖开 可以用 **调用栈 **快速理解递归 什么时候 压栈、弹栈 每次进入下一行代码，就是压栈；开始回归后，就是弹栈 ​ ​ ​ ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:6:2","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"排序算法 将一个正整数数组，从小到大排序 思路：递归思路、循环思路 ","date":"2020-10-11","objectID":"/algorithm-introduction/:7:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"用递归实现 代码简单，但不易理解。推荐使用代入法，层层剖开理解 ","date":"2020-10-11","objectID":"/algorithm-introduction/:7:1","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"用循环实现 代码多，但易于理解 ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:7:2","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"选择排序 思路：每次选择最小的放到前面，对后面的进行排序（递归） ","date":"2020-10-11","objectID":"/algorithm-introduction/:8:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"🔴长度为 2 的数组排序 sort2 ","date":"2020-10-11","objectID":"/algorithm-introduction/:9:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"代码 析构赋值 let sort2 = ([a,b]) =\u003e { if(a \u003c b){ return [a,b] // 注意：return的数组[a,b]是新数组，与原数组[a,b]是不同的内存空间。新数组只是复制了原数组ab的值 }else{ return [b,a] } } 内存图原理——复制 变量是对象，就是把对象存的地址复制 变量是普通值，就是把值复制 ","date":"2020-10-11","objectID":"/algorithm-introduction/:9:1","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"优化代码 let sort2 = ([a,b]) =\u003e a \u003c b ? [a,b] : [b,a] ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:9:2","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"🔴长度为 3 的数组排序 sort3 ","date":"2020-10-11","objectID":"/algorithm-introduction/:10:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"代码 思路： 先求三个数的最小值，作为返回数组的第一项 然后后面两个数字进行 sort2 操作（长度为 2 的数组排序） let sort3 = ([a,b,c]) =\u003e { return [ min([a,b,c]), sort2([???]) ] } 但，**我们发现无法将最小值从数组里删掉 ** 来单独进行sort2其余两个数字的排序 ","date":"2020-10-11","objectID":"/algorithm-introduction/:10:1","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"改进代码 思路：如果知道最小数字的下标，就可以把它从数组里删掉 补充：splice 方法易错点 numbers.splice(index, 1) // 直接修改原数组 numbers，从中删除下标为 index 的元素 let rest = numbers.splice(index, 1) // splice的返回值rest是被删除的元素组成的新数组 // 注意：上面两点经常被混淆，注意区别 代码 👇 let sort3 = (numbers) =\u003e { let index = minIndex(numbers) return [ numbers[index] ].concat( sort2( numbers.splice(index, 1) ) ) } 上面代码可忽略，比较复杂 :） 优化 👇 let sort3 = (numbers) =\u003e { let index = minIndex(numbers) // 假设有👇minIndex函数，与min相似，只不过返回的是最小值的下标 let min = numbers[index] // 根据最小值下标index，获取到最小值本身min numbers.splice(index, 1) // 从numbers数组的index处删掉1个数字，也就是从numbers中删掉最小值 return [min].concat( sort2(numbers) ) // 返回一个从小到大排序后的数组 } 因为我们需要返回的结果是一个数组 而这个数组是需要两个部分拼接：最小值、sort2返回排序后的数组 JS 中使用 concat 可以实现两个数组的拼接（ruby语法中可用+直接相加两个数组） 所以把最小值放在一个数组中，这样就可以和 sort2 返回的数组，通过 concat 方法进行拼接 （自己写写这段代码） ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:10:2","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"获取最小值下标 minIndex let minIndex = (numbers) =\u003e { return numbers.indexOf( min(numbers) ) // 先用min获取最小值，再用indexOf获取数组中当前元素的下标 } 有小 bug：如果最小值有两个（相同值），indexOf 只会返回第一个值得下标（） 这是一个取巧的办法，以后会教更好的 ","date":"2020-10-11","objectID":"/algorithm-introduction/:10:3","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"完整代码 // min 函数：获取任意数组中最小值 let min = (numbers) =\u003e { if(numbers.length \u003e 2){ // 停止条件 return min( [ numbers[0], min( numbers.slice(1) ) ] // 递归 ) }else{ return Math.min.apply(null, numbers) // 必须用apply，call会传递整个数组。Math.min仅接收单个数字 } } // minIndex 函数：获取任意数组中最小值的下标 let minIndex = (numbers) =\u003e { return numbers.indexOf( min(numbers) ) } // sort3 函数：对长度为3的数组从小到大排序 let sort3 = (numbers) =\u003e { let index = minIndex(numbers) let min = numbers[index] numbers.splice(index, 1) // numbers中仅保存最小值以外的两个元素，就可以使用sort2对numbers进行排序 return [min].concat( sort2(numbers) ) // 返回一个从小到大排序后的数组 } ","date":"2020-10-11","objectID":"/algorithm-introduction/:10:4","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"🔴长度为 4 的数组排序 sort4 let sort4 = (numbers) =\u003e { let index = minIndex(numbers) let min = numbers[index] numbers.splice(index,1) return [min].concat( sort3(numbers) ) } ","date":"2020-10-11","objectID":"/algorithm-introduction/:11:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"🔴推广：任意长度的数组排序 sort 递归 回顾：先获取最小值，然后从数组中排除最小值 … 进行大小比较 … let sort = (numbers) =\u003e { let index = minIndex(numbers) let min = numbers[index] numbers.splice(index, 1) return [min].concat( sort(numbers) ) // 死循环 } ","date":"2020-10-11","objectID":"/algorithm-introduction/:12:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"思路一 中止条件 当 numbers 中只有 2 个值时 直接通过 三元运算符（问好冒号表达式）比较大小 并返回从小到大排序后的数组 let sort = (numbers) =\u003e { if(numbers.length \u003e 2){ let index = minIndex(numbers) let min = numbers[index] numbers.splice(index, 1) return [min].concat( sort(numbers) ) }else{ return numbers[0] \u003c numbers[1] ? numbers : numbers.reverse() } } // 用代入法看看 sort[12,5,8,7,9] 代入法 👇 sort[12,5,8,7,9] = [5] + sort[12,8,7,9] = [5] + ( [7] + sort[12,8,9] ) = [5] + ( [7] + ( [8] + sort[12,9] )) // 👇 sort([12,9]) 进入停止条件 👇 = [5] + ( [7] + ( [8] + ( 12 \u003c 9 ? [12,9] : [9,12] ))) = [5] + ( [7] + ( [8] + ( [9,12] ))) = [5] + ( [7] + ( [8,9,12] )) = [5] + ( [7,8,9,12] ) = [5,7,8,9,12] ","date":"2020-10-11","objectID":"/algorithm-introduction/:12:1","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"思路二 开始「递进」，不断提取最小值。进入「回归」，将 每轮提取的最小值 进行逐个拼接 中止条件：不断提取最小值，直到 numbers 长度为 1，也就是只有一个元素时，直接返回 numbers let sort = (numbers) =\u003e { if(numbers.length \u003e= 2){ let index = minIndex(numbers) let min = numbers[index] numbers.splice(index, 1) return [min].concat( sort(numbers) ) }else{ return numbers } } 或 let sort = (numbers) =\u003e { if(numbers.length === 1){ return numbers }else{ let index = minIndex(numbers) let min = numbers[index] numbers.splice(index, 1) return [min].concat( sort(numbers) ) } } 代入法 👇 sort[12,5,8,7,9] = [5] + sort[12,8,7,9] = [5] + ( [7] + sort[12,8,9] ) = [5] + ( [7] + ( [8] + sort[12,9] )) = [5] + ( [7] + ( [8] + ( [9] + sort[12] ))) // sort[12] =\u003e [12] = [5] + ( [7] + ( [8] + ( [9] + [12] ))) // 递进中止，开始回归 = [5] + ( [7] + ( [8] + [9,12] )) = [5] + ( [7] + [8,9,12] ) = [5] + [7,8,9,12] = [5,7,8,9,12] ​ ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:12:2","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"代码调试 如果代码报错，如何调试 ","date":"2020-10-11","objectID":"/algorithm-introduction/:13:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"举例：splice易错点 [splice易错点](# 补充：splice 方法易错点) let sort = (numbers) =\u003e { if(numbers.length \u003e 2){ let index = minIndex(numbers) let min = numbers[index] let rest = numbers.splice(index, 1) // splice的返回值与原数组，经常被搞混淆 return [min].concat( sort(rest) ) }else{ return numbers[0] \u003c numbers[1] ? numbers : numbers.reverse() } } ","date":"2020-10-11","objectID":"/algorithm-introduction/:13:1","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"console.log 调试 let min = (numbers) =\u003e { if(numbers.length \u003e 2){ return min( [ numbers[0], min( numbers.slice(1) ) ] ) }else{ return Math.min.apply(null, numbers) } } let minIndex = (numbers) =\u003e { return numbers.indexOf( min(numbers) ) } let sort = (numbers) =\u003e { if(numbers.length \u003e 2){ let index = minIndex(numbers) console.log(`index: ${index}`) // console调试大法 let min = numbers[index] console.log(`min: ${min}`) // console调试大法 let rest = numbers.splice(index, 1) console.log(`rest: ${rest}`) // console调试大法 return [min].concat( sort(rest) ) }else{ return numbers[0] \u003c numbers[1] ? numbers : numbers.reverse() } } 打印结果，发现 rest 值有问题（正确的值应该是 rest =\u003e [12,8,7,9] ） 这时候就可以 mdn 查查 splice 写法是否正确（得知 splice 返回值为被删元素的数组，而非其余元素） 找到问题，得出正确写法：**无需获取返回值，numbers调用splice方法就会直接删除numbers中的指定元素 ** 修改代码，如下 👇 let sort = (numbers) =\u003e { if(numbers.length \u003e 2){ let index = minIndex(numbers) let min = numbers[index] console.log(`min: ${min}`) numbers.splice(index, 1) // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c console.log(`numbers: ${numbers}`) return [min].concat( sort(numbers) ) }else{ return numbers[0] \u003c numbers[1] ? numbers : numbers.reverse() } } 总结：新人一定要不停的 log 调试，当你把所有可能的问题都发现了，就成长了 ","date":"2020-10-11","objectID":"/algorithm-introduction/:13:2","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"举例：调用 min 报错 let min = (numbers) =\u003e { if(numbers.length \u003e 2){ return min( [numbers[0], min( numbers.slice(1) ) ] ) }else{ return numbers[0] \u003c numbers[1] ? numbers[0] : numbers[1] } } let sort = (numbers) =\u003e { if(numbers.length \u003e 2){ let index = numbers.indexOf( min(numbers) ) // 报错 Cannot access 'min' before initialization let min = numbers[index] numbers.splice(index, 1) return [min].concat( sort(numbers) ) }else{ return numbers[0] \u003c numbers[1] ? numbers : numbers.reverse() } } sort([2,5,1,4,3]) 原因： let index = numbers.indexOf( min(numbers) ) 目的是获取到最小值的坐标，需要先调用 min函数 获取最小值 但是因为当前作用域中定义了同名的 min JS 优先认为 ①min(numbers) 中的 min 是 ②let min = numbers[index] 中的 min 而执行 代码① 时，代码②还未执行，所以报错：不能在 min 初始化前访问 解决 给 min 变量改名 ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:13:3","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"完整代码 sort // min 函数：获取任意数组中最小值 let min = (numbers) =\u003e { if(numbers.length \u003e 2){ return min( [ numbers[0], min( numbers.slice(1) ) ] ) }else{ // return Math.min.apply(null, numbers) return numbers[0] \u003c numbers[1] ? numbers[0] : numbers[1] } } // minIndex 函数：获取任意数组中最小值的下标 let minIndex = (numbers) =\u003e { return numbers.indexOf( min(numbers) ) } // sort 函数：从小到大排序 ------------------------------------------------ let sort = (numbers) =\u003e { if(numbers.length \u003e 2){ let index = minIndex(numbers) let min = numbers[index] numbers.splice(index, 1) return [min].concat( sort(numbers) ) }else{ return numbers[0] \u003c numbers[1] ? numbers : numbers.reverse() } } 或 let min = (numbers) =\u003e { if(numbers.length \u003e 2){ return min( [numbers[0], min( numbers.slice(1) ) ] ) }else{ return numbers[0] \u003c numbers[1] ? numbers[0] : numbers[1] } } let sort = (numbers) =\u003e { if(numbers.length \u003e 2){ let index = numbers.indexOf( min(numbers) ) // （省略了 minIndex 函数） let minNum = numbers[index] numbers.splice(index, 1) return [minNum].concat( sort(numbers) ) }else{ return numbers[0] \u003c numbers[1] ? numbers : numbers.reverse() } } sort([2,5,1,4,3]) ​ ​ ​ ","date":"2020-10-11","objectID":"/algorithm-introduction/:14:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"总结 求最小值 2个数 3个数 N个数 排序 2个数 3个数 N个数 用到的东西 本节只用到一个数据结构 —— 【数组】，提供了三个方法 slice（截取）、concat（连接）、splice（删除） 递归 ","date":"2020-10-11","objectID":"/algorithm-introduction/:15:0","tags":["算法","入门","递归","排序"],"title":"算法入门","uri":"/algorithm-introduction/"},{"categories":["算法与数据结构"],"content":"帮助提高应对复杂情况时的逻辑分析能力","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:0:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"前言 正式学算法之前，有一个铺垫 ——「伪代码与流程图」 铺垫，看似不重要，实际上可能会影响非常深远 我们作为前端，一般学习的第一门编程语言是 Javascript 根据之前的学习，我们可以看到 JavaScript 这门语言有很多的问题 这些问题，都会导致学习者的思维上的一些缺陷 由于你学的第一门语言是一门有问题的语言，所以导致你的编程的一些基础知识是有缺陷的。 通过「伪代码和流程图」可以很好的弥补这些缺陷 ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:1:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"JS 语法不难，难的是抽象概念 有没有发现 JS 语法不难，难的是抽象概念 比如，你经常发现每句都懂，加在一起就不懂（就像学英语，每个单词都懂，拼成句子就懵了） ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:2:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"举个栗子 function t(fn,delay){ let fn2 = () =\u003e { if(fn2.timer){return} fn() fn2.timer = setTimeout(() =\u003e { fn2.timer = null }, delay) } return fn2 } let f = t(() =\u003e {console.log('火球术')}, 5000) // 这个函数在做什么？（防抖节流 ?!） 看不懂，是因为对「抽象概念」不了解 ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:2:1","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"抽象能力 越高级的程序员，抽象能力越强 ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:3:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"编程语言也能抽象 懂得抽象后，JS、Python、Java、PHP 根本就没区别。 这就是高级程序员，能掌握多种语言的原因 这些语言都有👇这些共同点 声明 if..else… while 循环、for 循环 函数 对象 这意味着 你没有必要过分关注语言的细节 你应该首先理解这些语言的[不变之处](# 不变之处) 然后以不变应万变 对于肤浅的程序员，所有新知识都是全新的。 而对于理解抽象的程序员，所有新东西只是原本基础知识上的抽象组合而已 ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:3:1","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"不变之处 从第一位程序员诞生至今，有什么东西是不变的（也就是，所有程序员都认为这是有用的东西） [对编程的热爱](# 一、对编程的热爱) [逻辑](# 二、逻辑 ⭐️) [数据结构](# 三、数据结构) （详见👇） ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:4:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"一、对编程的热爱 怎么会有人爱这么枯燥的玩意 1 《Just For Fun》 Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program. 大多数程序员愿意写代码，不是因为他们获得高额的薪水或者他人的赞誉，而是因为写代码很有意思。 —— Linus Torvalds （Linux之父、Git之父） 2 I'm not a great programmer; I'm just a good programmer with great habits. 我不是一个牛X的程序员； 我只是一个拥有牛X的习惯的还凑活的程序员。 —— Kent Beck（极限编程创始人） 我想让你知道的是： 不是所有人都只为工资编程，虽然一开始是为了工资 （但最后一直坚持下去的人，都是真正热爱编程的人） ​ 人们喜欢编程的原因 简洁之美 新人可能无法特别好的理解这种「简洁之美」 随着工作经验的积累，可能几年之后，你会发现，层次越高，代码越简洁。 代码越少，解决的越多，这就是编程的魅力 中国可能大部分公司不考虑简洁，只考虑时间、能否解决问题，不行就 996。 永远处在这种模式下，你会感觉不到任何美，就是单纯堆时间的体力活 真正的简洁美，是程序员用大脑想到一个方法，来解决一个较为复杂的问题，同时还能带来收益回报 要有追求 追求简洁的代码 追求不加班的编程，而不是靠时间堆砌的体力活 ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:5:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"二、逻辑 ⭐️ 所有的编程，都在使用逻辑 我们写代码，实际上就是在写逻辑 JS 用 JS 的语言来表达逻辑 Java 用 Java 的语音来表达逻辑 PHP 用 PHP 的语音来表达逻辑 … ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"逻辑是什么 三段论逻辑 - 1 命题一：JS 有 7 种数据类型：string、number、bool、symbol、undefined、null、object 命题二：JS 的函数不属于前六种类型 如果命题一、二为真，那么我们可以得到 推论：JS 的函数属于 object 类型 给出命题一、二，能发现它们之间的逻辑关系，并得出推论 —— 这就说明你是懂逻辑的 三段论逻辑 - 2 命题一：JS 中所有函数都是由 Function 构造的 命题二：Function、Object、Array 是函数 推论：Function、Object、Array 是由 Function 构造的 逻辑是需要学习的 中国人比外国人缺乏「逻辑」 中国人更愿意持有混沌的思维方式，比如，二元对立、辩证统一 …中国人共容易接受这些思维方式 「逻辑」反而是一个外来的词语 「逻辑」有时候是「符合直觉」的，但又有的时候「反直觉」 ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:1","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"逻辑 V.S. 直觉 直觉的好处 直觉能让你快速学会一些东西 比如数字、字符串、数组、对象都可以靠直觉学会 直觉的坏处 直觉却又能阻止你学会另一些东西 这时你就只能依靠「逻辑」来说服自己 比如，虽然不知道 Function 是如何构造 Function 的，但是逻辑告诉我们，确实如此（尽管这并不符合直觉） ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:2","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"如何用代码表示逻辑 例1 输出两个数中较大的一个数 如果第1个数大于第2个数，就输出第1个数 否则输出第2个数 👇 这里只是用代码来表示出上述逻辑，**不限定语言/语法 ** —— [伪代码](# 伪代码) a = [12,32] if a.get(0) \u003e a.get(1) print a.get(0) else print a.get(1) 可以得出一个结论 用 if … else … 可以表示某些逻辑 （发现规律） ​ 例2 输出 N 个数中最大的一个数 找到第 1、2 个数字中较大的那一个，存入 max 找到 max 和第 3 个数字中较大的那个，存入 max 找到 max 和第 … 个，存入 max max 就是最大的数 代码 a = [12, 32, 9, 1, 23, 6] max = a[0] for i from 1 to a.length() - 1 if a.get(i) \u003e max then max = a.get(i) print max 依次两两比较，找出最大 ​ 可以得出一个结论 用 for 循环，也可以表示某些逻辑 （又发现规律） 引出问题 👇 ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:3","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"表示逻辑需要多少种语句 如果要表达所有的逻辑，应该用哪些语句 ？（表示逻辑需要多少种语句） 掌握了这些语句就能表达所有逻辑 ？！ 上世纪60-70年代，科学家发明了一种理论 —— 「结构化编程」理论 他们说，所有逻辑，只需要 [3 种语句](# 三种语句搞定所有逻辑)就可以表达 注： 结构化编程，在某些情况下，会变得麻烦 比如，错误处理（这时候可能需要第4种语句：go to ） ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:4","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"三种语句搞定所有逻辑 ⭐️ 所有的复杂算法，都能用这三种语句描述 —— 多么简洁啊 顺序执行语句 语句1 语句2 条件判断语句 if ... then ... else ... if ... else if ... else 伪代码 👇 if x \u003e 10 语句1 else 语句2 循环语句 while ... do ... for i from 1 to n ... 伪代码 👇 when i \u003c 10 语句1 i+=1 语句2 JS 的变量提升就是个 BUG （ 所有编程语言只有 JS 支持变量提升，JS 宛如智障🤪） 所以[前面](# 前言)说，第一门语言学习 JS 是很不友好的、可能导致学习者思维上的缺陷 现在要学习另外一种叫「伪代码」的东西，来弥补这块缺陷 ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:5","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"伪代码 有没有发现，尽管没有讲解这种语法，我们依旧可以通过「这种代码」来理解这些[例子](# 例1)的逻辑/目的 这种代码就叫 「伪代码」 伪代码，不属于任何一种标准语言，只是为方便程序员自己理清逻辑 所以只要便于自己理解，**「伪代码」可以是任意写法 ** 作用：可以锻炼我们的大脑、思维，而不是总需要依靠浏览器去判断正确性 ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:6","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"流程图 流程图是一种语言，一种标准语言/标准画法 不同的语法逻辑，需使用相对应的某种形状来表达，是具有一定标准的。 **形状不可乱用，「流程图」不可乱画，必须遵循标准 ** ​ 注：「流程图」「伪代码」，只是两种表达形式，用来阐明逻辑，看个人喜好使用一种即可 流程图，可以看到整个逻辑的脉络（可能更适合较为复杂的逻辑 ?! 🤔） 并不绝对 ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:7","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"推荐使用 Mindjet 画流程图 也可以用 XMind、百度脑图 等工具代替 ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:8","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"流程图、伪代码的好处 锻炼你的大脑 你必须自己画出来 不能运行在计算机里 整理你的思路 思路乱，则图乱 伪代码都写不好，则真代码更写不好 帮助提高 应对复杂情况时的分析能力 ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:9","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"用流程图找到最大数 两个数中找最大数 N个数中找最大数 ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:10","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"总结 逻辑很重要 理解三段论 逻辑有时符合直觉，有时违反直觉。不论怎样，一定要相信逻辑 可以用三种语句表达所有逻辑 顺序执行语句 条件判断语句 循环语句 可以用「图 \u0026 伪代码」表示上述**三种语句 ** 推论：用「图 \u0026 伪代码」，可以表达所有逻辑 ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:6:11","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"三、数据结构 「数据结构」 **表示数据与数据之间的关系和结构 **。 是比算法更抽象的东西，**非常抽象 **。 抽象到甚至无法举出很具体的示例来表示「什么是数据结构」，只能尽量阐述、举例 ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:7:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"如何表示两个数据 两个人之间能有什么关系？基友，师生，父子 … 这就是他们之间的数据结构 他们之间的关系，就是他们的结构 两个整数之间能有什么关系？比如，1是2的前一个，2是1的后一个（1和2是前后关系） 虽然很抽象，但确实是种关系 如果顺序有意义 可以用下面方法👇来表示 [x, y] 表示第一个是 x，第二个是 y [y, x] 表示第一个是 y，第二个是 x 这就是最简单的数据结构 ——【有序的二元组】 比如，坐标 就是这样的数据结构 前一个数据表示 x 轴位置、后一个数据表示 y 轴位置。 如果反过来，就是另一个坐标数据了 对于这样的数据结构，**需要提供 first 和 last 操作 ** （一共两个数据）first 返回第一个数据、last 返回第二个数据 ​ 如果顺序无意义 (x, y) 和 (y, x) 一样 —— 【无序二元组】 比如，血压值 (120, 80) 和 (80, 120) 没区别。（书写顺序任意，默认较大值是高压、较小值是低压） 不需要提供 first 和 last 操作 因为顺序无意义，所以无需区别第一个还是最后一个 注： 上面提到的【xxx二元组】这种数据结构跟 JS 没有任何关系，只是随机一种写法来表示两个数据的关系而已 目前，在 JS 中只需知道【数组和对象】这两种数据结构 上述就是「两个数据能组成的数据结构」的举例 ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:7:1","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"如何表示 N 个数据 N个数据，能组成什么样的数据结构 比如：一串数字，组成全部同学的分数 如果顺序有意义 可以用一个经典的数据结构 —— 数组 来表示 [ a1, a2, … , aN ] 数组需要提供索引操作 get(i)：给定一个数字 i，返回对应的某项数据 还要提供 add / indexOf / delete 操作（增删改查的接口） // indexOf 在数组中找到一个给定元素的第一个索引，如果不存在，则返回-1 const beasts = ['ant', 'bison', 'camel', 'duck', 'bison']; beasts.indexOf('bison'); // 1 ​ 如果顺序没有意义 实际中，很少有数据顺序是无意义的情况 集合 表示 { a1, a2, … , aN } 要提供 add / delete / has 操作 注意：当前md中的所有代码，与 JS 无关 ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:7:2","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"如何表示 N 对 N 数据 也就是 2*N 个数据 比如，学号对应名字 用「哈希表」表示 哈希表，是一种抽象的数据结构，有 key 和 value key 可以是字符串、数字、布尔、甚至对象 … （因为「哈希表」是一种抽象的数据结构） hash = { 1001 =\u003e '小芳', 1002 =\u003e '小红'} 学号1001的同学，名字叫小芳；学号1002的同学，名字叫小红 这种 key 对应 value 的结构，叫做「哈希表」 ​ JS 对象，区别于「哈希表」 「哈希表」的 key 可以是字符串、数字、布尔、甚至对象 … 因为「哈希表」是一种抽象的数据结构 **JS 对象的 key 只能是字符串 **。 可以认为，JS 对象，只是一种对哈希的部分实现而已。 而且 **JS 对象永远有一个隐藏属性 _proto_，而「哈希表」里没有原型 ** ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:7:3","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"数据结构 = 数据形式 + 操作 不同形式的数据暴露不同的操作 数据形式 就是逻辑形式 操作 数组必须提供 add / indexOf / delete 增删改查 的接口 如果是集合，就不需要提供 indexOF，需要 add / delete / has 操作 这些接口，都属于操作 ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:7:4","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"有没有觉得很抽象 数据结构都是抽象的 数据结构的全名，就叫做「抽象数据结构」 前面都属于非常抽象的描述 下面举一些具体的例子，讲讲为什么数据结构这么重要（什么是数据结构，懂数据结构的人有多🐮B） ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:8:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"面试题 有一段英文对白，里面只会出现 a-z A-Z、标点符号和空格，请告诉我**每个字符出现的次数 **\r 例如 Hi, I’m Sam 需求：输出 a 出现 1 次，H 出现 1 次 … 懂「数据结构」的程序员一看完问题，就能抽象的发现，这与「哈希表」的结构形式一样 key : value 伪代码 str = `Hi, I'm Sam` hash = {} for i from 0 to str.length-1 key = str.get(i) value = hash.get(key,0) + 1 // value是上一次key值加1，如果上一次没有值就默认是0 hash.set(key, value) for key,value from hash print `${key} 出现了 ${value} 次` JS 代码 function times(str) { let obj = {}; for (let i = 0; i \u003c str.length; i++) { if (!obj[str[i]]) { obj[str[i]] = 1; } else { obj[str[i]] += 1; } } for(let key in obj){ console.log(`${key}出现了 ${obj[key]}次`) } } times(`Hi, I'm Sam`); ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:9:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"数据结构的作用 ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:10:0","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"提前记住一些结构 如果能提前就记住一些数据结构，这是最好的（如，数组、hash … ） 这些结构很常见 这些结构，能让你很快理清思路 这些结构，面试经常问 ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:10:1","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"锻炼你的抽象能力 一种数据结构往往能解决很多类似的问题 如果选错了数据结构，那基本玩完，算法再厉害也没用。因为在错误的数据结构下，压根就得不到正确的思路 牛逼的程序员更重视数据结构，而不是算法 能分析出数据是怎样的结构，这是最重要的 再根据数据结构去想算法 想快速有效的理解数据结构，快速入门算法和数据结构 只推荐一种方式：**搞懂 8 种排序算法 ** 每一种排序算法，都对应不同的数据结构。搞懂8个排序算法，基本学会了 5-6 个数据结构 后面会总结： 「归并排序」 「快速排序」 「计数排序」 「选择排序 」 以及「对应的数据结构」 搞定这 4 种排序算法，基本上也就会了 3-4 个数据结构，可以应付めんせつ了 数据结构在工作中用的多吗？ 这其实是主观上的 举个例子，在武侠世界里，有内功的人打出的拳肯定比普通人打出的拳更扎实。 别人打了一拳，很难说他用没用内功。但如果你没有内功，那就只能干打拳。 所以说，对于程序员来说，懂数据结构的人写的代码，质量上一定更高 但是如果具体问别人：写代码时，有没有回忆起10年前学的数据结构呢？当事人自己可能也不知道 所以要**把「数据结构」融会到自己的思想中，内化 **（ hash、二元组 … ） ​ ​ ​ ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:10:2","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["算法与数据结构"],"content":"补充：一些走❤️的东西 写代码会有种创造世界的成就感（就像 Minecraft） 写代码的控制感会比玩游戏的控制感更强烈一些，所以有些人可能代码写多了反而不爱玩游戏了 数据结构和伪代码，就是让你通过自己的方式和逻辑来解决问题，不要依赖浏览器等工具的调试，而是依靠自己的大脑，看它能不能想出一些东西 学习编程、写代码，一定是先定一个目的 「我要学好编程」这种不是目的 「今天我要写出一个时钟」这种才是目的 ","date":"2020-09-25","objectID":"/algorithm-pseudocode-flowchart/:10:3","tags":["算法与数据结构","入门"],"title":"伪代码与流程图","uri":"/algorithm-pseudocode-flowchart/"},{"categories":["JavaScript"],"content":"知识点概述、难点、重要知识点、拨乱反正（误区）、再画JS世界","date":"2020-09-24","objectID":"/javascript-summary/","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"​ ","date":"2020-09-24","objectID":"/javascript-summary/:0:0","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"知识点 ","date":"2020-09-24","objectID":"/javascript-summary/:1:0","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"基本概念 内存：内存图 变量：如何声明、哪些类型 数据类型：哪7种 对象：是什么、有什么属性、如何构造的 ","date":"2020-09-24","objectID":"/javascript-summary/:1:1","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"控制语句 if…else… for… ","date":"2020-09-24","objectID":"/javascript-summary/:1:2","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"对象 原型、原型链 对象分类：数 组是什么对象、函数是什么对象 如何 new 一个新对象：new 做了哪 4 件事情 构造函数：是什么 this 的隐式传递和显式传递：普通调用就是隐式传递、推荐用 call 显式传递 ​ ​ ","date":"2020-09-24","objectID":"/javascript-summary/:1:3","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"难点 ","date":"2020-09-24","objectID":"/javascript-summary/:2:0","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"JS 三座大山 原型 this AJAX ","date":"2020-09-24","objectID":"/javascript-summary/:2:1","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"已经遇到了前两座 前端门槛 反复学反复理解 ​ ​ ","date":"2020-09-24","objectID":"/javascript-summary/:2:2","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"最重要的知识 ⭐️ ","date":"2020-09-24","objectID":"/javascript-summary/:3:0","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"第一个重要知识：JS 公式 对象.__proto__ === 其构造函数.prototype JS 唯一公式 ​ ","date":"2020-09-24","objectID":"/javascript-summary/:3:1","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"第二个重要知识：根公理 Object.prototype 是根对象 Object.prototype 是所有对象的原型 Object.prototype 是所有对象的直接或间接的原型 加了一个直接或间接，所谓公理就是 JS 规定好的 例 {name:'frank'} 的原型: Object.prototype（直接原型） [1,2,3] 的原型是: Array.prototype（直接原型） 的原型是 =\u003e Object.prototype（间接原型） Object 的原型是: Function.prototype（直接原型） 的原型是 =\u003e Object.prototype（间接原型） ​ ","date":"2020-09-24","objectID":"/javascript-summary/:3:2","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"第三个重要知识：函数公理 所有函数都是由 Function 构造的 推出 👇 任何函数.__proto__ === Function.prototype 任意函数有 Object / Array / Function 例 let f1 = () =\u003e console.log('hi') f1.__proto__ === Function.prototype // true ​ ​ ","date":"2020-09-24","objectID":"/javascript-summary/:3:3","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"总结 JS 公式、根公理、函数公理 基于这三个知识和基础知识，可以推出 JS 世界 （细品） ​ ​ ","date":"2020-09-24","objectID":"/javascript-summary/:4:0","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"拨乱反正（误区） ","date":"2020-09-24","objectID":"/javascript-summary/:5:0","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"乱一：「的原型」 XXX 的原型 提到 「xxx 的原型」，到底指的是 __proto__ 还是 prototype - {name:'frank'} 的原型 - [1,2,3] 的原型 - Object 的原型 解读 - Object 的原型是 Object.__proto__：对 - Object 的原型是 Object.prototype ：错 分析 - 约定只要提到「xxx的原型」就是指「xxx.__proto__」 - 中文的「原型」无法区分 __proto__ 和 prototype，可以同时代指这俩 - 所以我们只能约定，「原型」默认表示 __proto__ - 只不过 __proto__ 正好等于某个函数的 prototype ​ ","date":"2020-09-24","objectID":"/javascript-summary/:5:1","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"乱二：直接/间接原型 矛盾了吗？ 说 [1,2,3] 的原型是 Array.prototype 又说 Object.prototype 是所有对象的原型 那为什么 Object.prototype 不是 [1,2,3] 的原型 怎么理解 原型分两种：直接原型 和 间接原型 对于普通对象来说，Object.prototype 是直接原型 对于数组、函数来说，Object.prototype 是间接原型 - {name:'frank'} 的原型: Object.prototype（直接原型） - [1,2,3] 的原型是: Array.prototype（直接原型） 的原型是 =\u003e Object.prototype（间接原型） - Object 的原型是: Function.prototype（直接原型） 的原型是 =\u003e Object.prototype（间接原型） 其实，只要在浏览器中输出一下 [1,2,3] 看看 proto 就能理解 直接原型 和 间接原型 比较好理解 ​ ","date":"2020-09-24","objectID":"/javascript-summary/:5:2","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"乱三：Object.prototype 有人认为 Object.prototype 不是根对象 （质疑公理 😏） 理由如下 Object.prototype 是所有对象的原型 Object 是 Function 构造出来的 所以，Function 构造了 Object.prototype 推论，Function 才是万物之源啊！ （看似无懈可击的推理，实际上是对更基础的知识没有理解好） 反驳 要理解 Object.prototype 和 Object.prototype 对象 的区别 实际上，Object.prototype 的值，本身是一个内存地址，指向的内存空间是 Object.prototype 对象 只是我们日常习惯口头上称 Object.prototype 为原型对象（实际上只是个地址） “Function 构造了 Object.prototype” 是构造出了 Object 上存根地址的属性 prototype: #202，而不是构造出原型对象本身 （结合内存图理解） 对象里面从来都不会包含另一个对象，只会包含另一个对象的地址 接下来我们要把 JS 世界的建造顺序理清楚 ​ ","date":"2020-09-24","objectID":"/javascript-summary/:5:3","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"再画 JS 世界 ","date":"2020-09-24","objectID":"/javascript-summary/:6:0","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"JS 世界的构造顺序 创建根对象 #101 (toString)，根对象没有名字 创建函数的原型 #208 (call /apply)，原型 __p 为 #101 创建数组的原型 #404 (push/pop)，原型 __p 为 #101 创建 Function #342，原型 __p 为 #208 用 Function.prototype 存储函数的原型，等于 #208 此时发现 Function 的 _proto_ 和 prototype 都是 #208 用 Function 创建 Object #909 用 Object.prototype 存储对象的原型，等于 #101 用 Function 创建 Array 用 Array.prototype 存储数组的原型，等于 #404 创建 window 对象 用 window 的 ‘Object’ ‘Array’ 属性将 7 和 9 中的函数命名 记住一点，JS 创建一个对象时，不会给这个对象名字的 ","date":"2020-09-24","objectID":"/javascript-summary/:6:1","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"构造一个新对象的过程 用 new Object() 创建 obj1 new 会将 obj1 的原型 __p 设置为 Object.prototype，也就是 #101 因为创建 JS 世界时，把原型的地址存到了 Object.prototype 上 用 new Array() 创建 arr1 new 会将 arr1 的原型 __p 设置为 Array.prototype，也就是 #404 用 new Function 创建 f1 new 会将 f1 的原型 __p 设置为 Function.prototype，也就是 #208 总结 new XXX， 就把 new 出来的实例的原型 __p 设为 XXX.prototype ​ ","date":"2020-09-24","objectID":"/javascript-summary/:6:2","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"自定义构造函数创建过程 自己定义构造函数 Person，函数里给 this 加属性 Person 自动创建 prototype 属性和对应的对象 #502 在 Person.prototype #502 上面加属性 用 new Person() 创建对象 p new 会将 p 的原型 __p 设为 #502 ​ ​ ","date":"2020-09-24","objectID":"/javascript-summary/:6:3","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"漂亮的图示 ⭐️ 需求：清晰的理解下图的每一条线 Array、Object、Function 三个都是函数，所以他们本身的原型 __p 都指向「函数的原型」 而每一个函数都存了其构造出的「(孩子) 新对象」的原型（共有属性） prototype ​ ","date":"2020-09-24","objectID":"/javascript-summary/:6:4","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"prototype 和 _proto_ 区别 细品 都存着原型的地址 只不过 prototype 挂在函数上 Object 是个构造函数，Object.prototype 就存储了 Object构造的新对象 的共有属性 Array 是个构造函数，Array.prototype 就存储了 Array构造的新对象 的共有属性 __proto__ 挂在每个新生成的对象上 Object构造的新对象 obj1 的共有属性在 obj1.__proto__ 上 Array构造的新对象 arr1 的共有属性在 arr1.__proto__ 上 函数上的 prototype 指向这个函数构造出来的孩子的共有属性 孩子上的 _proto_ 指向其父构造函数赋予这个孩子的共有属性 每个函数都有 prototype、每个对象都有__proto__ ，而函数也属于对象，所以函数同时有 prototype 和 __proto__ var obj = {} 等价于 var obj = new Object() // Object 上有 prototype // obj 上有 __proto__ obj.__proto__ === Object.prototype // true ​ ​ ","date":"2020-09-24","objectID":"/javascript-summary/:6:5","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"总结 ⭐️ 必须非常清晰的理解 不管怎么绕，都要清楚的理解 函数的构造函数 Function ，构造出了函数 f1 对象的构造函数 Object，构造出了对象 obj1 数组的构造函数 Array ，构造出了数组 array1 (window.)Function 的构造函数是 Function array1 的构造函数是 Array obj 的构造函数是 Object Object 的构造函数是 Function … ","date":"2020-09-24","objectID":"/javascript-summary/:7:0","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"构造函数 是用来构造对象的 会预先存好对象的原型，原型的原型是根 new 的时候将对象的 __p 指向原型 ","date":"2020-09-24","objectID":"/javascript-summary/:7:1","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"对象 所有对象都直接或间接指向根对象 如果对象想要分类，就在原型链上加一环 用构造函数可以加这一环 ","date":"2020-09-24","objectID":"/javascript-summary/:7:2","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"思考 如果加了一环之后，想再加一环怎么办 （加两环，要用继承的方式） 以后会在「继承」里讲 ​ ​ ","date":"2020-09-24","objectID":"/javascript-summary/:7:3","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"例 ⚡️ 把其他知识都忘掉，就记住以下 JS 公式：对象.__proto__ === 其构造函数.prototype 根公理：Object.prototype 是所有对象的直接或间接的原型 函数公理：所有函数都是由 Function 构造的 Object.prototype 的原型是什么 // 1.约定只要提到「xxx的原型」就是指「xxx.__proto__」 // 2.Object.prototype 是所有对象的原型（是根，根就不再往上有原型了） Object.prototype.__proto__ === null Function.prototype 的原型是什么 //（JS公式）等于问 Function.prototype 的「构造函数」.prototype // 重点在 Function.prototype 的构造函数 是 ？？ Function.prototype.__proto__ == Object.prototype var f = () =\u003e {} // 箭头函数的原型是什么 // 所有函数都是由 Function 构造的 f.__proto__ === Function.prototype Function 的原型是什么 // 所有函数都是由 Function 构造的 Function.__proto__ === Function.prototype Array.prototype.toString 的原型是什么 // toString 是个函数 // 所有函数都是由 Function 构造的 Array.prototype.toString.__proto__ === Function.prototype Object 的原型是什么 Object.__proto__ === Function.prototype Array.prototype 是谁的原型 // 把公式一反过来用 // 是用 Array 构造的实例的原型 Array.prototype === [].__proto__ ","date":"2020-09-24","objectID":"/javascript-summary/:8:0","tags":["JavaScript","阶段总结"],"title":"JS 阶段总结","uri":"/javascript-summary/"},{"categories":["JavaScript"],"content":"👿🤪🙄来一套~~~~~~~~题","date":"2020-09-18","objectID":"/javascript-operators/","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"​ ","date":"2020-09-18","objectID":"/javascript-operators/:0:0","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"前言 JavaScript 网道：运算符 ​ ","date":"2020-09-18","objectID":"/javascript-operators/:1:0","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"算数运算符 数学运算 ","date":"2020-09-18","objectID":"/javascript-operators/:2:0","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"number 运算 加减乘除 1+1 // 2 9-4 // 5 5*3 // 15 9/4 // 2.25 9/0 // Infinity 正无穷大 -9/-0 // Infinity 正无穷大 9/-0 // -Infinity 负无穷大 -9/0 // -Infinity 负无穷大 ​ 余数 x % 7 10 % 7 // 3 7 % 7 // 0 表示没有余数 -1 % 7 // -1 把负号提出来，用1%7=\u003e1，然后合起两部分 =\u003e -1 1 % -7 // 1 数学逻辑原理上： 两个数相隔 x ，再分别和 x 取余，其结果应该是相等的 // 10 和 17 相隔 7，分别和 7 取余，结果应该是等价的 10 % 7 === 17 % 7 // true -1 % 7 === 6 % 7 // false // JS 中负数取余有BUG 变态面试题：负数取余 JS 犯错了，在 JS 中 如果是负数取余 -x % y ，执行的逻辑是，先把负号提出来，两个正数取余，其结果再加上负号 -x % y =\u003e -(x % y) -x % -y =\u003e -(x % y) x % -y =\u003e x % y -1 % 7 // -1 -7 % 8 // -7 -4 % 3 // -1 -4 % 2 // -0 -4 % 8 // -4 ---------------------------------- -1 % -7 // -1 -7 % -8 // -7 -4 % -3 // -1 -4 % -2 // -0 -4 % -8 // -4 ---------------------------------- 1 % -7 // 1 7 % -8 // 7 4 % -3 // 1 4 % -2 // 0 4 % -8 // 4 ​ 指数 x ** 3 x 的 3次方 这是最新的语法，但是 IE6 不支持（谁管它~🙄） 7 ** 2 // 49 8 ** 2 // 64 2 ** 3 // 8 ​ 自增自减 👿 x++ / ++x / x– / –x 面试常考 var a = 1 a++ // 1 --- 表达式的值 a // 2 a-- // 2 --- 表达式的值 a // 1 var a = 1 ++a // 2 --- 表达式的值 a // 2 --a // 1 --- 表达式的值 a // 1 规则： a 在前，表达式的值就是 ++ 前的值 a 在后，表达式的值就是 ++ 后的值 a 在前，表达式的值就是 – 前的值 a 在后，表达式的值就是 – 后的值 var a = 10 var b = a++ // 先赋值，后自增 b // 10 a // 11 ​ 求值运算符 +x 就是单纯的获取一下值，不对值做任何改变 var a = 8 +a // 8 ---------------------- var a = -8 +a // -8 ​ 负数运算符 -x 求负运算：正数变负数、负数变正数 var a = 8 -a // -8 ---------------------- var a = -8 -a // 8 ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:2:1","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"string 运算 字符串仅支持一种符号运算 ： + （效果是连接两个字符串） 连接运算 + '123' + '456' // \"123456\" 字符串的 相减、相乘、相除，都会转换成 number 运算。但本质上是错误的计算 '2' - '1' // 1 ​ 变态 1 + '2' // \"12\" \"1\" + \"2\" // \"12\" 本质上：一个数字为什么要和一个字符串相加 ？！ 这从类型上讲就不对。其他语言都不允许不同类型进行相加，会报错 JS 中 数字与字符串相加：JS 默认先把「数字」转为「字符串」，然后拼接字符串 数字与字符串相减：因为字符串不支持减号，JS 默认先把「字符串」转为「数字」，然后进行减法运算 1 + '2' // \"12\" \"5\" - 5 // 0 ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:2:2","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"尽量少用自增自减 因为容易你和别人都记错 总有人会分不清 a++ / ++a ，所以你要兼容处理这种可能的情况，想办法避免 解决办法，就是不用自增自减 a++ =\u003e a += 1 什么情况用 a++ 呢？ 只在 for 循环用：因为这是一种「约定俗成」的写法 for(let i=0; i\u003c10; i++){} // 所有程序员都这么写 for(let i=0; i\u003c10; i+=1){} // 这么写没问题，但是看着就有点野路子、不正规 for(let i=0; i\u003c10; ++i){} // 还有处女座程序员喜欢这么写，不管他怎么解释，你听听就好，不必当真 可能 20 年前， ++i 更快。但是现在，无脑写 i++ 就可以了，完全没问题 🤪 ​ ","date":"2020-09-18","objectID":"/javascript-operators/:2:3","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"不同类型不要加起来 把 1 和 ‘2’ 加起来是几个意思 苹果 + 橘子 是什么？ 苹橘？ ​ ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:2:4","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"比较运算符 \u003e \u003c = \u003c= == // 模糊相等 != // 不模糊相等 === // 全等 !== // 不全等 == 是 JS 的 BUG 为什么推荐使用 === 不推荐 == 假设要计算 x == y， 计算的过程很冗长，但是每个步骤都很简单 ","date":"2020-09-18","objectID":"/javascript-operators/:3:0","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"JS 的三位一体 0 == [] // true 0 == '0' // true 0 == '\\t' // true (\\t: tab) // 上面等式，还可以理解，但是等式右边的三个却互不相等 [] == '0' // false [] == '\\t' // false '0' == '\\t' // false ","date":"2020-09-18","objectID":"/javascript-operators/:3:1","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"忠告： 永远不要使用 ==，而是使用 === == 的问题在于，它总是自作聪明（自动类型转换） ​ ","date":"2020-09-18","objectID":"/javascript-operators/:3:2","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"x == y // 令人难以理解 [] == false但不是 falsy [] == false但{}却不是 [[]] == false 真值表 黄色块，表示两个值是真的相等 JS 的自相矛盾 逻辑 BUG 问：下述代码 if 判断为真吗 ？ var a = [] if(a) {} // a是true，可以通过 if ，真 只有 5 个 falsy 值是假，其他都是真 0 NaN null undefined \"\" 但是 var a = [] if(a) { console.log(\"判断为真\") }else{ console.log(\"判断为假\") } [] == true // false [] == false // true 打印结果：【判断为真】，但 [ ] == true 却为假。 if(a==true) { console.log(\"判断为真\") }else{ console.log(\"判断为假\") } 打印结果：【判断为假】。 总结： if(a)为真，if(a==true)为假。 a 是真的 ，但是却不等于 true 那 a 到底是真的假的 ？！ —— JS 自身矛盾 解决办法：🤬 永远不要用 == ​ 空数组 == false、空对象 != true 对照 [== 真值表](# 真值表) [] == true // false [] == false // true [[]] == true // false // 如果空数组里有一个空元素，仍是false [{}] == true // false -------------------------------------------------------------------------------- {} == true // false // chrome 输出要加小括号 ({}) == true {} == false // false // chrome 输出要加小括号 ({}) == false 空对象 != false 、空对象 != true ​ ","date":"2020-09-18","objectID":"/javascript-operators/:3:3","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"x === y 没有任何费解（仅两个规则） **基本类型看值是否相等 ** **对象看地址是否相等 ** [] !== [] // 地址不同 {} !== {} // 地址不同 真值表 重点 0 === [] // false 0 === 1 // false true === false // false true === true // true ... ------------------------------------------ [] === [] // false 空数组 和 空数组，不相等。 如果会画「内存图」就很清晰了。 地址不同 [] /* #101 */ === [] /* #108 */ false 数组属于对象类型，只能比较地址，不能比较内容 ​ ","date":"2020-09-18","objectID":"/javascript-operators/:3:4","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"NaN !== NaN 唯一特例，强行记忆一下 ​ ","date":"2020-09-18","objectID":"/javascript-operators/:3:5","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"总结 空数组模糊相等 false、空对象模糊相等 true 空数组不全等于空数组 空对象不全等于空对象 NaN 不全等于 NaN ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:3:6","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"布尔运算符 ","date":"2020-09-18","objectID":"/javascript-operators/:4:0","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"或、且、非 || \u0026\u0026 ! 取反 ","date":"2020-09-18","objectID":"/javascript-operators/:4:1","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"短路逻辑 常用 例1. if(console){ if(console.log){ console.log('hi') } } // 简化为 👇 console \u0026\u0026 console.log \u0026\u0026 console.log('hi') IE 中就没有 console 以防 console 不存在报错 这种编码方式，叫做**「防御性编程」** 最新版 JS 还新增了更简单的写法 ——「可选链语法」 // 简化为 👇 console?.log?.('hi') // 如果console存在，就获取上面的log方法，如果也存在执行、打印 'hi' ​ 例2. if(!a){ a = 100 }else{ a = a } // 简化为 👇 a = a || 100 a 的保底值 如果 a 是真值，a 就不变。如果 a 是假值，a 就等于 100 但上述方法其实存在一点 bug ：如果 a 是空字符串呢 ?！ 5个falsy值都会使得 a 为假值，赋值为100 于是，JS 又发 明了新的语法 —— 直接在函数参数上写 ✅ function add(n){ if(!n){ n=0 } // n = n || 0 return n+1 } // 新语法 👇 function add(n=0){ return n+1 } add(null) // 1 add(undefined) // 1 add('') // \"1\" ​ ","date":"2020-09-18","objectID":"/javascript-operators/:4:2","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"尽量都是用最新的 JS 语法 ⭐️ ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:4:3","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"二进制位运算符 这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，**好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。 ** 有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。 注：可以使用十进制数进行运算，会先自动转化成二进制，然后再计算 ","date":"2020-09-18","objectID":"/javascript-operators/:5:0","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"或、与、否运算符 或 0b（零b）开头，表示后面写的是二进制数 0b11 // 3 0b01 // 1 0b10 // 2 或 | 只有两位都为 0，结果才为 0 否则为 1 运算过程： 0b1111 |||| 0b1010 |||| 0b1111 // 垂直比较对应位置，只要上下两个二进制数中有一位显示的是 1 那么最终结果的当前位置为 1。 // 都是 0 时，才得出 0 例 0b1111 | 0b1010 // 15 // 因为没用二进制显示结果，所以默认被转换为了10进制 （8421） // 正确写法 👇 (0b1111 | 0b1010).toString(2) // \"1111\" JS变态之处，只能用字符串形式表示二进制数，不能用数字 ​ 与 与 \u0026 两位都为 1 才是 1 有一位是 0 ，结果就是 0 例 (0b1111 \u0026 0b1010).toString(2) // \"1010\" 0b1111 \u0026\u0026\u0026\u0026 0b1010 |||| 0b1010 ​ 否 否 ~ 1变成0，0变成1 它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。 详解查看 JavaScript 网道 (~0b1111).toString(2) // \"-10000\" ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:5:1","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"异或运算符 异或运算（^）在两个二进制位不同时返回1，相同时返回0。 两位相同，则返回 0 两位不同，则返回 1 (0b1111 ^ 0b1010).toString(2) // 0101 省略最前面的 0，结果为 =\u003e \"101\" ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:5:2","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"左移、右移运算符 \u003c\u003c 和 \u003e\u003e 左移运算符（«）表示将一个数的二进制值向左移动指定的位数，尾部补 0 右移运算符（»）表示将一个数的二进制值向右移动指定的位数。 如果是正数，头部全部补0；如果是负数，头部全部补1。 0b0010 // 0010（二进制） =\u003e 2（十进制） 左移一位 👇 0b0010 \u003e\u003e 1 // 0001（二进制） =\u003e 1（十进制） 右移一位 👇 0b0010 \u003c\u003c 1 // 0100（二进制） =\u003e 4（十进制） 注意：结果仍会自动转换为十进制数，调用 .toString(2) 可以得到二进制（会省略开头0） (0b0010 \u003e\u003e 1).toString(2) // 0010 =\u003e 0001 =\u003e \"1\" （二进制） 会省略开头0 (0b0010 \u003c\u003c 1).toString(2) // 0010 =\u003e 0100 =\u003e \"100\"（二进制） 会省略开头0 右移得负数情况 如果不懂二进制，这块也不太好理解是怎么转换的 😶 -4 \u003e\u003e 1 // -2 /* // 因为-4的二进制形式为 11111111111111111111111111111100， // 右移一位，头部补1，得到 11111111111111111111111111111110, // 即为十进制的 -2 */ ​ 如果有多个 1 (0b0011 \u003e\u003e 1).toString(2) // 0011 =\u003e 0001 =\u003e \"1\" （二进制） 会省略开头0 （吃掉最右边的1） (0b0011 \u003c\u003c 1).toString(2) // 0011 =\u003e 0110 =\u003e \"110\"（二进制） 会省略开头0 ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:5:3","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"头部补零的右移运算符 \u003e\u003e\u003e 在正数的情况下，\u003e\u003e 和 \u003e\u003e\u003e 基本没有区别 头部补零的右移运算符（»\u003e）与右移运算符（»）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（»）完全一致，区别主要在于负数。 (0b1111 \u003e\u003e\u003e 1).toString(2) // 0111 =\u003e \"111\"（二进制） 会省略开头0 ​ 上面的运算符，看过一遍然后就忘记好了，因为这辈子可能都用不上 ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:5:4","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"面试题 🙄 平时工作很少用。只有一种情况可能遇上，就是「面试题」中 文章：位运算符在JS中的妙用 （仅做参考） ","date":"2020-09-18","objectID":"/javascript-operators/:6:0","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"使用与运算符\u0026判断奇偶 先给出结果： // 方法1.与2取余（最方便的方法、也好理解） 7 % 2 === 1 // true 奇数 // 方法2.二进制与运算符：两位都为1才是1 任意数 \u0026 1 // =\u003e 0 说明是偶数 任意数 \u0026 1 // =\u003e 1 说明是奇数 测试 (7).toString(2) // 把其转换为2进制 =\u003e \"111\" 最后一位是 1 7 \u0026 0b001 // 7和二进制的1进行与运算，规则是二进制中对应的两位都是1结果就是1 =\u003e 1 (7 \u0026 0b001).toString(2) // 0001 =\u003e \"1\" 二进制 原理 偶数的二进制位最后一位都是 0 ，而奇数二进制位的最后一位都是 1，所以可以根据二进制判断奇偶 问题转化：**如何获取任意数的二进制数的最后一位值 ** 解决办法：跟二进制的 1 进行**与运算 ** 与运算的规则：两个二进制数的对应位进行两两比较，**只要有一个是 0，结果就是 0 **，只有对应位都是 1 结果才得 1 因为二进制 1 的前五位都是 0，所以任意数与二进制 1 进行与运算，必然导致最终结果的前 5 为都是 0 因为前 5 位都是 0，自然就获取到最后一位，根据最后一位的结果 0 或 1 来判断出「偶 或 奇」 如果最后一位是 0 ，则二进制数为 000000 简写为 0 =\u003e 偶数 如果最后一位是 1 ，则二进制数为 000001 简写为 1 =\u003e 奇数 例 123 \u0026 1 // 1 奇数 124 \u0026 1 // 0 偶数 125 \u0026 1 // 1 奇数 注：可以使用十进制数进行二进制与运算，会先自动转化成二进制，然后再计算 虽然位运算 速度极快，但是模运算速度也不慢 “模”是“Mod”的音译，模运算多应用于程序编写中。 Mod的含义为**求余 **。 ​ ","date":"2020-09-18","objectID":"/javascript-operators/:6:1","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"使用 ~, », «, »\u003e, | 来取整 下列方法都是基于该原理： 位运算符只对整数起作用，不支持小数，会自动转为整数后再执行 （直接抹掉小数位，不是四舍五入） 正数、负数同理 window.parseInt(6.83) // 6 (JS有直接提供取整的 api 呀~~) ------------------------------------------------------------- // 面试逼得必须会的方式👇 位运算 console.log(~~ 6.83) // 6 console.log(6.83 \u003e\u003e 0) // 6 console.log(6.83 \u003c\u003c 0) // 6 console.log(6.83 | 0) // 6 console.log(6.83 \u003e\u003e\u003e 0) // 6 ​ 1. 两次取反 ~~ 注意，这是二进制的取反：把 1 变成 0，把 0 变成 1 console.log(~~ 6.83) // 两次取反，相当于负负得正，还是取的原值，但把小数部分抹去了 // 6 ​ 2. 右移 0 位 » 0 console.log(6.83 \u003e\u003e 0) // 右移零位，就是原地不动，但位运算符会自动取整，所以这番运算会抹掉小数 // 6 console.log(-6.83 \u003e\u003e 0) // -6 运算过程： 因为是位运算，第一步先转换为整数 6.83 =\u003e 6 因为 6 的二进制形式是 “0110” =\u003e 右移 0 位 “0110” =\u003e 转换成10进制输出 6 左移 0 位 « 0， 同理可得 头部补零的右移 »\u003e 0 ，同理可得 ​ 3. 与 0 进行或运算 | 0 或运算 | ：只有两位都为 0，结果才为 0，否则是 1 （位运算符自动转换为整数） console.log(6.83 | 0) // 与0进行或运算的本质：还是不改变原二进制数的 （细品） 运算过程： 因为是位运算，第一步先转换为整数 6.83 =\u003e 6 6 的二进制数与 0 的二进制数进行或运算： “110” | “000” =\u003e “110” ​ ","date":"2020-09-18","objectID":"/javascript-operators/:6:2","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"使用 ^ 来交换 a b 的值 let a=1; let b=2; [a,b] = [b,a] // JS 最新的语法——交换两个值 a // 2 b // 1 位运算 —— 异或 ^ 两位相同，则返回 0 两位不同，则返回 1 var a = 5 var b = 8 a ^= b // 是 a = a ^ b 的简写 b ^= a a ^= b console.log(a) // 8 console.log(b) // 5 ","date":"2020-09-18","objectID":"/javascript-operators/:6:3","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"总结 关于位运算，只要记住下面 3 个问题的解法： 判断奇偶 取整 交换值 位运算用得很少容易忘，面试之前重新看看即可 ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:6:4","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"其他运算符 奇葩运算符，一个比一个奇葩 很多「搞不清楚为什么 JS 可以这样写的」用法，其实是程序员自己发现的 ","date":"2020-09-18","objectID":"/javascript-operators/:7:0","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"点运算符 点运算符，只能用在对象上。如果遇到其他类型，会有一个特殊逻辑 ，👇 语法 对象.属性名 = 属性值 作用 读取/设置 对象的属性值 let a = {name:'sam'} a.name // \"sam\" 读取属性值 a.name = \"jack\" // 设置属性值 有个疑问 问：不是对象，为什么也可以用点 . 还能获取到属性？ 'a-b-c'.split('-') JS 有特殊逻辑，点前面不是对象，就把它封装成对象 var a = 1 a.toString() （内存图） JS 发现 a 没有 toString，就把 a 封装成对象 a’ 然后调用 封装对象 a‘ 的 toString 方法 抹掉封装对象 a’ = null ​ 每次使用 . 点运算符，都会①创建封装对象②调用封装对象上的方法③抹掉封装对象**(滚) ** var a = 1 a.xxx = 'sam' // 这一行背后过程：创建 a'，然后把 xxx 放到 a'上，值为sam，最后 a’ 被抹掉 a.xxx // undefined // 这一行背后过程：创建a''，获取a'‘上的xxx属性，找不到xxx，返回 undefined **每次点运算符，都会创建一个新的对象 **，用来容纳你操作的属性信息 （翻脸就不认人🙄） ​ JS 封装对象 number 会变成 Number 对象 string 会变成 String 对象 bool 会变成 Boolean 对象 程序员从来不用这三种对象👇，只用简单类型 new Number() new String() new Boolean() 提醒一下，「永远不要用」的有 👇 == ++ （for循环用一下) new Number() 、 new String() 、 new Boolean() （number/string/布尔的构造函数） ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:7:1","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"void 运算符 语法 void 表达式或语句 void console.log('hi') void 1 ​ 作用 求表达式的值，或执行语句 **void 的值总是为 undefined ** ​ 需求/用法 需求：a 标签不跳转，而是点击 a 就执行 f 方法 // 假设👇是 f 方法 function f(){ console.log('hi') } 方法一 return 假值可以阻止默认动作（阻止 a 标签跳转） \u003ca href=\"http://example.com\" onclick=\"f(); return false;\"\u003e点击\u003c/a\u003e 方法二 点击 a 执行 js 语句 （改用 void 可以炫技） \u003ca href=\"javascript: void(f())\"\u003e文字\u003c/a\u003e 方法三 即使不用 void ，也可以实现同样效果，👇 \u003ca href=\"javascript:;\" onclick=\"f();\"\u003e文字\u003c/a\u003e ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:7:2","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"逗号运算符 语法 表达式1, 表达式2, ..., 表达式 n 作用 将表达式 n 的值作为整体的值 也就是将最后一个表达式 ，作为 return 的内容 使用 例 1 let a = (1,2,3,4,5) 那么 a 的值就是 5，奇葩吧？ 例 2 箭头函数，不用 { } 和 return，也能写多个语句 👇 ：用 () 和 , let f = (x) =\u003e (console.log('平方值为'), x*x) 注意上面的括号不能省 ​ ​ ","date":"2020-09-18","objectID":"/javascript-operators/:7:3","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"运算符的优先级 先算什么，后算什么 ","date":"2020-09-18","objectID":"/javascript-operators/:8:0","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"优先级是什么 优先级处理的就是，当一个语句中有多个操作，到底先算哪个 不同运算符 1 + 2 * 3 是 (1 + 2) * 3 还是 1 + (2 * 3) // 小学生都知道先算乘法 ! a === 1 是 (! a) === 1 还是 ! (a === 1) // 先求a的反，再与1进行布尔运算 new Person().sayHi() 先new还是先.sayHi() 相同运算符 从左到右 a + b + c 从右到左 a = b = c = d 优先级就是先算什么后算什么 具体规则想知道吗？ 你：想。 不，你不想！看看这里就知道为什么。—— JS 操作符的优先级，你可能这辈子都记不下来（丧😨） MDN 总结的非常好 将所有运算符按照优先级的不同从高（20）到低（1）排列 ","date":"2020-09-18","objectID":"/javascript-operators/:8:1","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"学习建议 运算符优先级很难记全，所以直接 放弃，不要记 如果遇到运算符优先级的题，直接猜 ​ ","date":"2020-09-18","objectID":"/javascript-operators/:8:2","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"优先级汇总 ####汇总表位于 MDN 一共有20个运算符 怎么记忆呢 技巧 只记「圆括号优先级最高」 会用圆括号就行 其他一律不记 面试官：问为什么不知道 / 没有记 JS 的优先级？ 满分回答： 因为 JS 的优先级太多了，没有一个人能确保把 JS 的优先级记得很清楚 就算我记清楚了，也不能确保我的同事记得清楚。所以我就记了「优先级最高的是圆括号」 我会在写代码时，非常清楚的用「圆括号」表明我的优先级，这样别人也可以很好的理解我的代码 （从为了让同事能更好的理解代码的角度，来反驳面试官/领导） ","date":"2020-09-18","objectID":"/javascript-operators/:8:3","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"例 💋 不同运算符 if(!a===1){} // 先算谁呢？ if( (!a) === 1) // 圆括号优先级最高 // 查一下MDN可知，!高于=== 相同运算符 a + b + c // 从左到右顺序 a = b = c = d // 从右到左倒序 例 let a,b,c,d a = b = c = d = 2 相当于👇 a = (b = (c = (d = 2))) // (d=2)表达式的值就是2，赋给c，c=2表达式的值是2，再赋给 b... ","date":"2020-09-18","objectID":"/javascript-operators/:8:4","tags":["JavaScript","运算符"],"title":"JS 运算符 ","uri":"/javascript-operators/"},{"categories":["JavaScript"],"content":"执行时机，又称调用时机，是 JS 函数的重要要素之一。","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:0:0","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"JS 函数的执行时机 执行时机，或说调用时机，是 JS 函数的要素之一 先抛出结论：JS 函数的执行时机不同，结果不同 下面逐例分析：函数调用执行的时机，是如何影响结果的 ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:0","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例1 let a = 1 function fn(){ console.log(a) } 输出：[未知] 分析：函数只有被调用才会执行。上述代码中的函数 fn 并未被调用，输出更无从说起。 ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:1","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例2 let a = 1 function fn(){ console.log(a) } fn() 输出：1 ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:2","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例3 let a = 1 function fn(){ console.log(a) // 看到这可能会认为是打印 1 // 但此时函数未被调用，可以忽略整个函数。不要提前把 a=1 带入到函数中做记号 } a = 2 // a变成2 fn() 输出：2 ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:3","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例4 let a = 1 function fn(){ console.log(a) } fn() // 看时机：函数被调用，此时 a=1 a = 2 输出：1 ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:4","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例5 let a = 1 function fn(){ setTimeout(() =\u003e { console.log(a) },0) } fn() a = 2 输出：2 分析： setTimeout 口语化理解相当于“过一会”、“尽快”（意思是忙完当前手头事，就立马执行里面的语句） 举个栗子： 你在打游戏（运行这段代码） 别人叫你去吃饭（fn()被调用） 你说马上去”（遇到 setTimeout ） “马上去” 的潜台词，是要先把这局游戏打完才去😜（继续向下执行 a=2） 现在打完了（其他代码全部走完） 可以去吃饭了 （console.log(a)） ​ ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:5","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例6 💡 let i = 0 for(i = 0; i\u003c6; i++){ setTimeout(() =\u003e { console.log(i) },0) } 输出：6 6 6 6 6 6 分析： 首先，let 声明一个 i 。 let i 写在 for 循环外，所以 let i（声明 i）不会参与到循环中。始终只有一个 i 开始 for 循环，逐步拆分 ↓ i=0 （i\u003c6） 遇到 setTimeout（执行完其他代码，再执行这里 setTimeout 中的语句）—— stand by ① i++ =\u003e i=1 （i\u003c6） 遇到 setTimeout —— stand by ② i++ =\u003e i=2 （i\u003c6） 遇到 setTimeout —— stand by ③ i++ =\u003e i=3 （i\u003c6） 遇到 setTimeout —— stand by ④ i++ =\u003e i=4 （i\u003c6） 遇到 setTimeout —— stand by ⑤ i++ =\u003e i=5 （i\u003c6） 遇到 setTimeout —— stand by ⑥ i++ =\u003e i=6 不符合条件 i\u003c6。 循环结束。 stand by 完毕，开始依次执行 ①②③④⑤⑥，此时 i=6 console.log(i) // 6 console.log(i) // 6 console.log(i) // 6 console.log(i) // 6 console.log(i) // 6 console.log(i) // 6 ​ 变形 for(var i = 0; i\u003c6; i++){ // 相当于只有一个 i setTimeout(()=\u003e{ console.log(i) },0) } // 6 6 6 6 6 6 ​ ​ ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:6","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"例7 💡 for(let i = 0; i\u003c6; i++){ // 相当于在每一次循环的代码块中各声明了一个i。一共声明了6个i setTimeout(()=\u003e{ console.log(i) },0) } 输出： 0 1 2 3 4 5 分析： for 和 let 连用，可以近似的理解为：每轮循环创建了一个作用域 { } let 特性，仅在当前作用域有效 { let i = 0， 满足 i \u003c 6 setTimeout(() =\u003e console.log(i), 0) // stand by ① } { let i = 1， 满足 i \u003c 6 setTimeout(() =\u003e console.log(i), 0) // stand by ② } ... { let i = 5， 满足 i \u003c 6 setTimeout(() =\u003e console.log(i), 0) // stand by ⑥ } { let i = 6， 不满足 i\u003c6 ，循环结束 } // 此时 stand by 完毕，开始依次执行 ①②③④⑤⑥ // 因为 let 存在作用域限制，所以每个 log 打印的都是其所在作用域的 i { console.log(i) // 0 } { console.log(i) // 1 } ... { console.log(i) // 5 } ​ 变形1 for (var i=0; i\u003c6; i++){ ! function(j){ setTimeout(function(){ console.log(j) }, 0) }(i) } 输出：0 1 2 3 4 5 分析：利用「立即执行函数」的参数，保存下 i 值 ​ 变形2 for (var i=0; i\u003c6; i++) { setTimeout((j) =\u003e { console.log(j) }, 0, i) } 输出：0 1 2 3 4 5 分析：利用 setTimeout 的第 3 个参数，保存下 i 值。一旦定时器到期，会作为参数传递给 function ","date":"2020-09-16","objectID":"/javascript-timing-of-call-a-function/:1:7","tags":["JavaScript","函数"],"title":"JS 函数的执行时机 🚀⌚","uri":"/javascript-timing-of-call-a-function/"},{"categories":["JavaScript"],"content":"JS 函数的基本介绍","date":"2020-09-14","objectID":"/javascript-function/","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"定义函数、call / apply / bind、大师调用法、调用时机、作用域、闭包、形参、调用栈、函数提升、arguments、this、箭头函数、立即执行函数。 ​ ","date":"2020-09-14","objectID":"/javascript-function/:0:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数是对象 函数怎么会是对象……看起来不一样啊 解释起来非常抽象，请直接接受这个结论 函数是一种特殊的对象 ","date":"2020-09-14","objectID":"/javascript-function/:1:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"定义一个函数 ","date":"2020-09-14","objectID":"/javascript-function/:2:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"1️⃣ 具名函数 function 函数名(形式参数1, 形式参数2){ 语句 return 返回值 } ","date":"2020-09-14","objectID":"/javascript-function/:2:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"2️⃣ 匿名函数 上面的具名函数，去掉函数名就是匿名函数 匿名函数，通常要声明一个变量进行赋值，不然函数就消失了 let a = function(x, y){ return x+y } 也叫函数表达式 ps：等号左边是声明变量 a 并赋值。等号右边部分，才是函数表达式 ","date":"2020-09-14","objectID":"/javascript-function/:2:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"例 function fn(x,y){ return x+y } ------------------------------- 上面是具名函数，函数名为fn； ------------------------------- 下面是匿名函数，函数没有名字，但是声明一个变量a来容纳这个函数的地址 let a = function(x,y){ return x+y } 变态 let a = function fn(x,y){return x+y} // fn(1,2) // 报错 fn 不存在：fn is not defined // 为什么？ a(1,2) // 3 解： 如果 fn 函数式的声明是在等号右边，那么这个 fn 的作用域就只能在等号右边、这块高亮的范围 出了这块高亮范围，fn 就不存在 其他地方要用这个函数，只能用 a 来调用 ​ function fn(x,y){return x+y} fn(1,2) // 3 如果没有左边赋值的操作，那么 fn 在哪里都可以用 ​ ","date":"2020-09-14","objectID":"/javascript-function/:2:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"3️⃣ 箭头函数 写法 let f1 = x =\u003e x*x let f2 = (x,y) =\u003e x+y // 多个形参，则圆括号不能省 let f3 = (x,y) =\u003e { return x+y } // 写了return，则花括号不能省 let f4 = (x,y) =\u003e {console.log('x+y='); return x+y } // 多语句时，花括号不能省，return不能省 变态：函数返回值是一个对象 // let f5 = (x,y) =\u003e {name:x, age: y} // JS 中 {} 被优先当做【代码块(label语法)】的起始，而不是对象 let f5 = (x,y) =\u003e ({name:x, age: y}) 函数返回值是一个对象，需要加个圆括号，表示里面是一个整体，不是一个代码块 可以看出 JS 这门语言每次添加新的语法时，可能都多少会有点小bug，大概是因为它要兼容以前得版本，所以有些错误它也解决不了（不是门很严谨的语言） ​ ","date":"2020-09-14","objectID":"/javascript-function/:2:4","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"4️⃣ 用构造函数 // 单语句 let f = new Function('x', 'y', 'return x+y') // 多语句 let f = new Function('x', 'y', 'console.log(\\'hi\\'); return x+y') f(1,2) // hi // 3 基本没人用，但是能让你知道函数是谁构造的 所有函数都是 Function 构造出来的 包括 Object、Array、Function 也是 （这里都省略了 window. ） Function 本身也是由自己构造出来的（在对象原型的笔记中解释过） ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:2:5","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数自身 vs. 函数调用（区别） fn V.S. fn() ","date":"2020-09-14","objectID":"/javascript-function/:3:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数自身 let fn = () =\u003e console.log('hi') fn 结果 不会有任何结果 因为 fn 没有执行（执行就是调用，调用就是执行） ","date":"2020-09-14","objectID":"/javascript-function/:3:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数调用 let fn = () =\u003e console.log('hi') fn() 结果 打印出 hi 有圆括号才是调用 ","date":"2020-09-14","objectID":"/javascript-function/:3:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"再进一步 let fn = () =\u003e console.log('hi') // 很多人认为fn就是函数，实际上这里的fn只是保存了函数的地址 let fn2 = fn // 把fn保存的地址复制给fn2 fn2() 结果 fn 保存了匿名函数的地址 这个地址被复制给了 fn2 fn2() 调用了匿名函数 实际上 fn 和 fn2 都是对匿名函数的引用而已 真正的函数既不是 fn 也不是 fn2 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:3:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数的要素（9 个）🤩 9个概念需要知道，其他函数的教程，都没这里讲的细 ","date":"2020-09-14","objectID":"/javascript-function/:4:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"每个函数都有这些东西 调用时机 作用域 闭包 形式参数 返回值 调用栈 函数提升 arguments（除了箭头函数） this（除了箭头函数） JS 的三座大山 原型、原型链 this AJAX 搞懂这三座大山，vue、react、angular … 就都可以去学了。 但如果三个有任何一个没搞清楚，那就还是 JS 没入门的水平。你会感觉一直在 JS 的屏障/瓶颈中 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"1️⃣ 调用时机 🧐 JS 函数的执行时机 —— 时机不同，结果不同 例1 let a = 1 function fn(){ console.log(a) } 问打印出多少？答：不知，因为没有调用（函数只有被调用才会执行） 例2 let a = 1 function fn(){ console.log(a) } fn() 问打印出多少？答：1 例3 let a = 1 function fn(){ console.log(a) // 很多人看到这，会认为是打印 1。 // 但此时函数根本没执行过，可以完全忽略整个函数，不要提前就把 a=1 带入到函数中做记号 } a = 2 // 到这里，a变成2了 fn() 问打印出多少？答：2 例4 let a = 1 function fn(){ console.log(a) } fn() // 看时机：函数被调用，此时a=1 a = 2 问打印出多少？答：1 例5 let a = 1 function fn(){ setTimeout(()=\u003e{ // setTimeout 相当于过一会、尽快（意思是当前手头事忙完，就立马执行里面的语句） console.log(a) },0) } fn() a = 2 举个栗子：你在打游戏（运行这段js），你妈叫你去吃饭（fn()被调用） ，你说马上去（执行setTimeout）。说了马上去，意思是要先把这局游戏打完才去（继续向下执行a=2）。现在打完了(js全部走完)，可以吃饭 console.log(a) 问打印出多少？答：2 例6 💡 let i = 0 // 注意：let i 写在for外面，相当于 i 只声明了一个。let i（声明i）的过程不会参加到循环中 for(i = 0; i\u003c6; i++){ setTimeout(()=\u003e{ // 忙完手头事（for循环）立马执行里面的语句 console.log // 【异步】 console.log(i) // 6 6 6 6 6 6 },0) } 上面代码块打印出多少？答：不是 0、1、2、3、4、5，而是 6 个 6 变形： for(i = 0; i\u003c6; i++){ // 相当于只有一个 i setTimeout(()=\u003e{ console.log(i) // 6 6 6 6 6 6 },0) } ------------------------------------------------- for(let i = 0; i\u003c6; i++){ // 这样相当于在每一次循环体的代码块中各声明了一个i，一共声明了6个i setTimeout(()=\u003e{ console.log(i) // 0 1 2 3 4 5 },0) } 例7 💡 for(let i = 0; i\u003c6; i++){ // 这样相当于在每一次循环体的代码块中各声明了一个i，一共声明了6个i // 每次循环都会创建一个i 进行赋值，然后留在这个空间中。6次循环创建6个新的i在各自的{}中，互不干涉 // 细品：类似于刻舟求剑，每次刻一下，剑的位置竟随着舟的移动也发生了变化 setTimeout(()=\u003e{ console.log(i) },0) } 问打印出多少？答：是 0、1、2、3、4、5。 因为 JS 在 for 和 let 一起用的时候会加东西，每次循环会多创建一个 i（我服了 JS） ​ 总结 setTimeout 就是尽快、等一会，但是不是现在。相当于先干完手头的，然后去做 setTimeout 里面的 JS 函数的「调用时机」，由于变量的值可能会发生改变，所以每次求值的时候都要想一想所有代码执行的顺序是怎样的。如果不能确定代码执行的顺序，那么最终结果可能就是不对的。 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"2️⃣ 作用域 每个函数都会默认创建一个作用域 作用域特别简单，就是画圈圈 例1 function fn(){ let a = 1 // let声明的变量的作用域仅在当前这个 {...} 中 } console.log(a) // 报错 a is not defined // a不存在 问：是不是因为 fn 没执行，导致 a 不存在 ？？ 例2 function fn(){ let a = 1 } fn() console.log(a) // 即使 fn 执行了，a 还是不存在，仍旧报错 答：就算 fn 执行了，也访问不到作用域里面的 a 跟执不执行没有关系。 let 声明的变量的作用域非常好找。 在 let 声明语句的前面找到一个 { ，在 let 语句后面找到一个 } ，这俩半个花括号组成的作用域{ } ，就是 let 变量的作用域 ​ 全局变量 vs. 局部变量 在顶级作用域声明的变量是【全局变量】 挂载到 window 上的属性是【全局变量】 其他都是【局部变量】 function fn(){ let a = 1 // let 声明的变量 a，仅在fn函数的{}内生效，所以是局部变量 } let b = 2 // let声明的变量b，是在顶级作用域声明的，所以是全局变量，全局可访问 window.c = 3 // 在window上声明变量c，c就是全局变量，全局可访问 function f1(){ window.d = 4 console.log(c) } function f2(){ console.log(d) } f1() // 3 // 函数里也可以访问到 window 上的 c f2() // 4 // f2函数中能访问到f1函数中，声明在window 上的变量d 只要是挂载在window上的变量，不论在哪个作用域声明/挂载的，都是全局变量，全局可访问 为什么有些方法可以直接使用，因为是挂在 window 上的 例如： Object / window.Object 、parseInt / window.parseInt … 函数可嵌套 作用域也可嵌套 就近原则 function f1(){ let a = 1 function f2(){ // 在f1函数中声明了一个f2函数 let a = 2 console.log(a) } console.log(a) a = 3 f2() } f1() // 1 // 2 作用域规则 如果多个作用域有同名变量 a （如上） 那么查找 a 的声明时，就向上取最近的作用域 简称「就近原则」 查找 a（分清作用域）的过程与函数执行无关 函数的作用域与函数执行无关 —— 静态作用域（又叫 词法作用域，属于编译原理的知识） 函数的作用域与函数执行有关 —— 动态作用域，但 JS 里没有动态作用域，只有静态 但 a 的值与函数执行有关 例4 ⭐️ 看懂这个例子，作用域就没什么问题了 function f1(){ let a = 1 function f2(){ let a = 2 function f3(){ console.log(a) } a = 22 f3() } console.log(a) a = 100 f2() } f1() // 1 // 22 作用域总结：==「就近原则」== ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"3️⃣ 闭包 闭包上面讲过了 —— 讲过了吗？！ 重看例4 function f1(){ let a = 1 function f2(){ --------------------------- let a = 2 function f3(){ console.log(a) // f3里面用到了外层函数f2的变量 a ，那么 a 和 f3 就是闭包 } --------------------------- a = 22 f3() } console.log(a) a = 100 f2() } f1() 闭包 如果一个函数用到了外部的变量 那么这个函数加这个变量 就叫做闭包 左边的 a 和 f3 组成了闭包 闭包的用途以后讲，这里先把【闭包】的形式记下来即可 你也可以先搜一下 “ 闭包这么简单吗？怎么看到网上讲的各种花里胡哨… ” frank：在 JS 基础知识这方面，我很有自信，我比其他所有在网上教你的人都懂。网上教的乱七八糟的 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:4","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"4️⃣ 形式参数 形式参数的意思就是非实际参数 function add(x, y){ return x+y } // 其中 x 和 y 就是【形参】，因为并不是实际的参数，x/y并【不代表任何实际的值】，仅代表参数的【顺序】 add(1,2) // 调用 add 时，1 和 2 是实际参数【实参】，会被赋值给 x 和 y 其他 JS 教程可能会说： JS 传参时分为「值传递」和「地址传递」。 上面记法太复杂，如果你搞懂了内存图，就知道没那么麻烦。 实际上，传参就是把 stack 里记的内容拷贝给形参（不要区分什么值和地址，太麻烦了） function add(x, y){ return x+y } add(1,2) // 3 // x接收到的 1，和 add(1,2) 这里的1，不是同一个1，只是复制了一份给 x function addObject(x,y){ return x.value + y.value } addObject({value:1},{value:2}) // 3 // 怎么知道调用时，赋给x的{value:1}和 addObject(x,y)中x接收到的{value:1}是不是同一个 // 测试一下 let a = {value:1} let b = {value:2} function addObject(x,y){ // 执行函数不仅把value加起来，还偷偷把x的内容改掉，看看是否影响到外面定义的x x.name = 'xxx' return x.value + y.value } addObject(a,b) // 3 a // {value: 1, name: \"xxx\"} // 诶! a被改了 如果搞懂内存图，就会知道，当我们在赋值时，只是把 a 存的 stack 内容，拷贝给形参 实际上，传参就是把 stack 里记的内容拷贝给形参（不要区分什么值和地址，太麻烦了） 而形参 x / y ，应该会存储在「不知道什么区」（代指任何应该出现的区） ​ 形参可认为是变量声明 其实，形参的本质就是变量声明 「形参」并不特殊，就是个语法糖 // 上面代码近似等价于下面代码 function add(){ var x = arguments[0] // 为什么用 var ? 答：历史原因，当时发明形参时 就只有var声明 var y = arguments[1] return x+y } ​ 形参可多可少 形参只是给参数取名字而已 function add(x){ // 只声明一个形参，如果传了两个参数，怎么拿到第2个形参呢？ return x + arguments[1] } add(1,2) // 3 arguments 就是所有形参组成的数组 所以我们没有必要，把形参全部声明出来。通过 arguments 就可以全部获取到 function add(x,y,z){ return x+y // z 怎么办？无所谓，声明着玩 } add(3,4) // 7 JS 代码就是这么随意，形参爱多就多，爱少就少，没有规则约束 后来这种特性造成一些问题，比如 TypeScript 兴起，TS 要求形参必须按照严格的类型和顺序 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:5","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"5️⃣ 返回值 每个函数都有返回值 不存在没有返回值的函数 function hi(){ console.log('hi') } hi() 没写 return，会默认返回值是 undefined function hi(){ return console.log('hi') } hi() // hi // 会照常执行语句的打印效果，并不表示这是语句的返回值 // undefined // 返回值 return console.log('hi') 也就是说返回值为 console.log(‘hi’) 的值，也就是 log 函数 的返回值，因为 log 函数没有 return，所以最终的值就是 undefined return 的结果，还是比较严谨的 ​ 函数执行完了后才会返回 如果不执行，就不会有返回值 执行了，才会有返回值 ​ 只有函数有返回值 1+2 的返回值为 3 ❌ （这是我们常见的一种口误，没有 return 哪来的返回值） 1+2 的值为 3 ✅ ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:6","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"6️⃣ 调用栈 ⭐️ MDN：Call stack 很抽象。是函数非常重要的要素。 什么是调用栈 JS 引擎在调用一个函数前 需要把函数所在的环境 push 到一个数组里 这个数组叫做调用栈 等函数执行完了，就会把环境弹(pop)出来 然后 return 到之前的环境，继续执行后续代码 举例 console.log(1) console.log('1+2的结果为' + add(1,2)) console.log(2) 调用栈的作用（抽象） 计算机是健忘的，每次进到一个函数，都要记下来等会要回到哪。把记录写到「调用栈」中 所以要把这个回到的地址，写到这个调用栈里面 ——「压栈」 在进入一个函数后，还要再进入另一个函数（嵌套的），那也要把这个子函数的地址放到栈里 等当前子函数执行完毕，就**「弹栈」**—— 告诉计算机函数执行完要回到哪了。当前父函数执行完，再弹栈… 弹栈，会立刻删除调用栈列表中压栈时存下的对应信息。 MDN 调用栈 这个模型还是比较重要的。 JS 每次进入一个函数之前，先存档，执行完毕，没什么问题就读档，消掉前面的档 类似玩游戏打boss之前要存档，dead了后，就能自动读档到打boss之前的游戏进度 —— 与 JS 的流程不是非常一致，就是大概意思. 主要理解上面的流程图 「栈」会不会满呢？ 如果使用递归函数，就有可能把栈压满。 因为递归函数，可能会一直不停的在压栈。 递归函数 阶乘 当 n 不等于 1，就执行 n × f(n-1) 当 n 等于 1，就返回 1 function f(n){ return n !== 1 ? n* f(n-1) : 1 } ​ 理解递归 层层递进↘，再层层回归↙ —— 递归 f(4) = 4 * f(3) = 4 * (3 * f(2)) = 4 * (3 * (2 * f(1))) = 4 * (3 * (2 * (1))) = 4 * (3 * (2)) = 4 * (6) 24 先递进↘，再回归↙ 很多教程中，说递归就是不停的调用自己，实际上是不正确的理解 调用自己 !== 递归。调用自己有时候会死循环的，死循环就不是递归。递归——先递进，再回归、 递归的尽头，就在 f(1) === 1 这个关键点。 ​ 递归函数的调用栈 递归函数的调用栈很长 请画出阶乘 (4) 的调用栈 阶乘 4 ，会压 4 次栈 阶乘 10000 ，会压 10000 次栈 （数值太大，Chrome 计算不了） 试试「阶加」10000，压 10000 次栈 function sum(n){ return n !== 1 ? n+ sum(n-1) : 1 } sum(10000) // 50005000 sum(20000) // Maximum call stack size exceeded 【爆栈】 爆栈 如果调用栈中压入的帧过多，程序就会崩溃 —— 爆栈 function sum(n){ return n !== 1 ? n+ sum(n-1) : 1 } sum(10000) // 要压10000次栈 // 50005000 sum(20000) // 要压20000次栈 // 已经报错。Maximum call stack size exceeded 可以用二分法，试试 Chrome 最多能压多少次栈 sum(15000) // 爆栈 sum(12500) // 爆栈 sum(11431) // 爆栈 sum(11430) // 65328165 Chrome 的调用栈的长度，大概 11000 ~ 12000 左右，不是固定值（因为里面可能已经放了一些别的东西） ​ 调用栈最长有多少 使用下面代码，可以测试一个浏览器的调用栈的长度 function computeMaxCallStackSize() { try { return 1 + computeMaxCallStackSize(); } catch (e) { // 报错说明 stack overflow 了 return 1; } } Chrome 12578 Firefox 26773 Node 12536 Chrome 和 Node 的用的是同一个 JS 引擎，所以测出来差不多。 Firefox 用的是自己的 JS 引擎，所以可能大一些 ​ 总结————————————— 什么是调用栈 就是我们进入一个函数时，要先把这个环境存下来，然后再进去，不然函数执行完就不知道怎么回去了。 要存的东西很多，就需要一个数组来保存。这个保存函数所在环境的数组，就叫「调用栈」 调用栈的长度大概是在一万到两万左右，超过这个值程序就会崩溃 —— 爆栈 ​ ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:7","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"7️⃣ 函数提升 什么是函数提升 不管你把具名函数声明在哪里，它都会跑到第一行 function fn(){} 示例 add(1,2) function add(x,y){ return x+y } // 3 有一种代码规范就是，把所有声明的函数，都集中放到最后面，这样代码阅读起来就更简洁 拓展 如果同时声明 变量 add 和 函数 add，那 add 到底是谁呢？ let add = 1 function add(){} 报错：add 已经被声明了。 输出 add，结果为 函数 add。（函数会提升，自动变成 ↓↓ 这样） function add(){} let add = 1 let 特性：如果这个变量已经存在，就不允许再次重复声明，会直接报错 但是用 var 声明，就不会报错 var add = 1 function add(){} var add function add(){} 由上，用 var 可能有很多问题，搞不清到底表示函数还是什么。（押题再讲 var） 如果只用 let ，那世界就清净了。因为只要 let 重复声明，就会报错，避免上述搞不清变量到底是谁的 bug 学习方法：难得东西着重去学；简单的东西，可以放到面试准备阶段背 就比如：var 很复杂，但又没什么用，只是面试会考到。所以我们只在面试准备阶段，讲一下 ​ 什么不是函数提升 let fn = function(){} 这是赋值，右边的匿名函数声明不会提升，你在什么时候写，它就什么时候声明 例 add(1,2) // 报错 let add = function(x,y){return x+y} // 这个函数的声明并没有提升，导致声明前先调用，所以会报错 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:8","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"8️⃣ arguments ","date":"2020-09-14","objectID":"/javascript-function/:4:9","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"9️⃣ this ⚡️ arguments 和 this，是除了箭头函数，每个函数都有的。 箭头函数，是新出的语法，故意摒弃了这两个特性。 可见，新的语法并不认为这俩是好东西 正如 JS 之父说的：JS 的原创之处并不优秀、优秀之处并非原创 arguments 和 this 就是 JS 原创的，使得 JS 语法特别独特，也特别不好用 ​ ","date":"2020-09-14","objectID":"/javascript-function/:4:10","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"理解 arguments 译为：参数 注意 arguments 是所有参数组成的伪数组 每次调用函数时，都会对应产生一个 arguments 我们应该尽量不对 arguments 内的元素进行修改，修改 arguments 会让代码变得令人疑惑 function fn(){ console.log(arguments) } fn() fn(1) fn(1,'a') 发现：打印 arguments，结果类似数组 实际上， arguments 是包含所有参数的伪数组。 arguments 数组的原型是「根对象」——包含对象的共有属性。没有 push、shift、join … 这些数组共有方法 没有数组共有方法的数组，就是「伪数组」 「伪数组」怎么变真数组 ？ 通过 Array.from(array) 可以把任何不是数组的东西，转换为真数组（具有数组的共有属性） ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:5:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"理解 this ⚡️ this 可以说是 JS 的 “ 千古奇案 ” —— 各种取值，眼花缭乱 ","date":"2020-09-14","objectID":"/javascript-function/:6:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"情况一 如果不给任何条件，那么 this 默认指向 window（包含所有全局变量） 这种情况，通常用不上。因为如果要获取 window 上的某变量，直接写就行 window.xxx ，不需要用 this 来指代 function fn(){ console.log(this) } ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"如何指定 this 目前只能用 fn.call(…) 情况一 如果传的 this 不是对象，JS 会尽量封装成对象 function fn(){ console.log(this) } fn.call(1) // → 对象1 fn.call(undefined) // → window 什么叫「封装成对象」？ 就是 new Number(1) // 具有 number 的共有属性 —— 但基本没人用 怎么禁用这个自动封装的特性 ？ 例：传数字 1，最终 this 就是指向【数字 1】，而不被自动封装成【对象 1】 // 很简单，在声明函数的时候，【使用严格模式】，相当于告诉 JS 不要随便添加东西 function fn(){ 'use strict' console.log(this) } fn.call(1) fn.call(undefined) ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"同时指定 this 和 arguments 目前可以用 fn.call(xxx, 1,2,3) 传 this 和 arguments 第1个参数是 this，后面所有参数是 arguments xxx 作为 this，会被自动转化成对象（JS 的糟粕） function fn(){ console.log(this) console.log(arguments) } fn.call(1,2,3,4) ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"“ this 是隐藏参数、arguments 是普通参数 ” this 是参数（此结论是 frank 个人的） ↑↑ 是什么意思呢 ？ —— 我们需要花很多例子，来理解这句话 要理解 this，先从 JS 中把 this 排除出去。就是看看不用 this，能不能达到跟 this 一样的功能 ！ ","date":"2020-09-14","objectID":"/javascript-function/:6:4","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"假设没有 this let person = { name: 'frank', sayHi(){ console.log(`你好，我叫` + person.name) // 以前是使用 this.name，改成 person.name } } 为什么这里可以用 person.name，应该还没完成 person 的声明吧 ？ 因为这是一个函数，函数等会儿才会执行，等到执行时，person 不是已经完成了声明吗 ！！所以这是可以的 我们在 person 对象中声明一个函数的时候，在函数中可以用变量 person 得到这个对象的引用 在不准用 this 的前提下，这段代码是合法的，也符合我们的预期 我们可以用直接保存了对象地址的变量获取 ‘name’ 我们把这种办法简称为引用 （ 一个变量保存了一个对象的地址，就叫引用） 问题一 如果先声明了这个函数，后声明对象 let sayHi = function(){ console.log(`你好，我叫` + person.name) // 函数声明时怎么知道会有 person 变量呢，person 还没声明 ？ // 虽然执行上没问题，但先后逻辑上确实略有不通之处 } let person = { name: 'frank', 'sayHi': sayHi // 引用sayHi函数 } person sayHi() 分析 person 如果改名，sayHi 中引用 person 的地方也必须跟着修改，否则 sayHi 函数就挂了 甚至有可能有 2 个单独 JS 文件，一个放着 person，而 sayHi 函数在另一个文件里面。 这样就显得更加奇怪：一个文件居然需要知道另一个文件中有什么变量 所以我们可能不是很希望 sayHi 函数里出现 person 引用 （感觉上这个代码有点不好，但也不是那么不好，较尴尬令人不爽 🙃 ） ​ 问题二 ⚡️⚡️ 对象还好，如果用 类 class 的话，问题就更大了。 class Person{ constructor(name){ this.name = name // this 指临时的新对象，这里的 this 是 new 强制指定的。我们就不讨论了 😅 } sayHi(){ console.log(???) // 问题在这，怎么打印出name呢？声明类时，还没有new出任何实例对象，没法引用 } } 我们想在 sayHi 中获取到当前对象的 name，但此时根本就没有当前对象，那怎么获取 ？ 我们就需要一种机制，来获取到未来的对象的 name 的引用 分析 这里只有类，还没创建对象，故不可能获取对象的引用 那么如何拿到对象的 name 属性？ 🤔 ​ 需要一种办法拿到未来的对象 复述问题：我们需要在函数中，获取一个对象的引用，但这个对象还未创建，那要怎么获取 ？ 怎样才能获取的未来对象的引用，以便拿到对象的 name 属性？ → 怎样在不知道对象名字的情况下，拿到对象的引用 ？ 一种土办法，用参数（传参） 对象 let person = { name: 'frank', sayHi(p){ console.log(`你好，我叫` + p.name) } } person.sayHi(person) // 用参数的形式，把你要得到的对象，传给了你 // 这种方法，看起来很冗余、很挫 类 class Person{ constructor(name){ this.name = name } sayHi(p){ console.log(`你好，我叫` + p.name) } } ​ 谁会用这种办法 —— Python Python 在每一个函数中加了一个参数，并且约定这个参数就是后面创建的新对象 class Person: def __init__(self, name): # 构造函数 self.name = name def sayHi(self): print('Hi, I am ' + self.name) person = Person('frank') person.sayHi() # Python 默认会把 sayHi 前面的 person 作为参数传到 sayHi 中，所以 self 就是这个参数 特点 每个函数都接受一个额外的 self 这个 self 就是后面会创建并传进来的对象 只不过 Python 会偷偷帮你传对象 person.sayHi() 等价于 person.sayHi(person) person 就被传给 self 了（得到了一个未来的对象的引用） 这其实是任何语言都要解决的问题 —— 在写代码的时候，不知道后面要创建的对象叫什么 ​ JS 没有模仿 Python 的思路 JS 走了另一条路 —— 更难理解的路 —— 这就是 JS 的第二座大山 this ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:5","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"JS 在每个函数里加了 this ⚡️⚡️ JS 没有像 Python 那样加一个参数，而是发明了一个关键字 —— this 在任何一个函数里，可用 this 获取到那个你现在还不知道名字的对象 let person = { name: 'frank', sayHi(隐藏的this){ console.log(`你好，我叫` + this.name) } } person.sayHi() ---------------------------------------------------- class Person{ constructor(name){ this.name = name } sayHi(p){ console.log(`你好，我叫` + p.name) } } let person = new Person('frank') person.sayHi() // 隐式的写了 this = p （JS引擎擅自执行的操作） // ↑↑ 相当于 ↓↓ // person.sayHi(person) // JS 和 Python 做了一样的处理：会自动把 person 传给 sayHi // 然后 person 被传给 this 了（person 是个地址） JS 做的第 1 件事：把 this关键字 赋予 sayHi。 JS 做的第 2 件事：把 person(地址) 传给 this。 综上，就是把 person 给了 sayHi 这样，每个函数都能用 this 获取一个未知对象（person）的引用了 ","date":"2020-09-14","objectID":"/javascript-function/:6:6","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"person.sayHi() 会隐式地把 person 作为 this 传给 sayHi （ 而不是像 Python 一样作为第 1 个参数 self ，传给 sayHi ） 方便 sayHi 获取 person 对应的对象 ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:7","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"总结 总结一下目前的知识 我们想让函数获取对象的引用 但是并不想通过变量名做到 Python 通过额外的 self 参数做到 JS 通过额外的 this 做到： person.sayHi() 会把 person 自动传给 sayHi，sayHi 可以通过 this 引用 person 其他 注意 person.sayHi 和 person.sayHi() 的区别 注意 person.sayHi() 的断句 (person.sayHi) ( ) ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:8","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"这就引出另一个问题 💡 到底哪个对 let person = { name: 'frank', sayHi(){ // 隐藏的this参数 console.log(`你好，我叫` + this.name) } } // 自动隐式的把 person 传给 sayHi person.sayHi() // 省略传参 ？ person.sayHi(person) // 完整传参 ？ 哪种写法是对的 省略形式反而对了，完整形式反而是错的 JS 怎么解决这种不和谐 [Python](#谁会用这种办法 —— Python) 至少有明确的约定：这种 person.sayHi() 写法就会把 person 传给 sayHi 的第 1 个显式参数 self 。 那 JS 要怎么解释 this 的存在呢 ？（函数并没有显式的形参，this 完全是一个不成文的、隐性的约定） JS 提供两种调用形式 ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:9","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"两种调用🧐 小白调用法 🚫 person.sayHi() 会自动把 person 传到函数里，作为 this 大师调用法 ✅ 使用 JS 新出的调用方法：call person.sayHi.call(person) 需要自己手动把 person 传到函数里，作为 this （更为清晰） let person = { name: 'frank', sayHi(){ console.log(`你好，我叫` + this.name) } } person.sayHi.call({name:1}) // call 里传什么 this 就是什么，非常清晰 应该学习哪种？ 学习大师调用法，因为小白调用法你早就会了 从这段笔记开始，默认用大师调用法 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:6:10","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"指定 this 😈 ","date":"2020-09-14","objectID":"/javascript-function/:7:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"call 指定 this call 是 JS 新出的调用方法。call 会使得所有东西变得明朗起来 let person = { name: 'frank', sayHi(){ console.log(`你好，我叫` + this.name) // call传什么this就是什么 } } person.sayHi.call({name:1}) // call 里传什么 this 就是什么，非常清晰 person.sayHi.call({name:'jack'}) ------------------------------------------------------------------------------- // 大多数情况，我们需要this就是当前对象 person.sayHi.call(person) person.sayHi() // 为什么不用这种写法？因为隐藏了太多细节，只适合小白 ","date":"2020-09-14","objectID":"/javascript-function/:7:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"所有函数调用，必须强迫自己使用「大师调用法」—— call / apply ​ 例1 有一个 add 函数，不需要用到 this，那如何使用 call 调用 ？ function add(x,y){ return x+y } 没有用到 this add.call(undefined, 1,2) // 3 // call的第1个参数是指定this的，后面所有参数作为实参传递给函数对应形参 为什么要多写一个 undefined 因为第一个参数要作为 this 但是代码里没有用 this 所以只能用 undefined 占位 其实用 null 也可以 ​ 例2 Array.prototype.forEach 这个函数就用到了 this Array.prototype.forEach2 = function(){ console.log(this) } let array = [1,2,3] array.forEach2() // 小白写法：脑子一懵，就不知道了this是什么了 array.forEach2.call(array) // [1,2,3] // 大师写法：规定了call里面的就是this，所以清晰明了的知道此时打印的this就是传进去的array数组本身 尝试写出完整的 forEach 函数 forEach 功能是遍历当前数组。当前数组在哪呢？ 就是 this，this 就可以作为未来数组的引用 Array.prototype.forEach2 = function(fn){ // 传一个方法fn for(let i=0; i\u003cthis.length; i++){ fn(this[i], i, this) // 对每一个元素，执行fn方法 } } Tips 我们在看一个函数的代码时，不要想 this 的值是什么 ， 因为 this 的值是不确定的，没人知道 只有在函数被调用时（用大师法传进 this），才清晰的知道 this 是什么 如何调用 Array.prototype.forEach2 = function(fn){ for(let i=0; i\u003cthis.length; i++){ fn(this[i], i, this) } } let array = [1,2,3] array.forEach2.call(array, item =\u003e console.log(item) ) // 大师：显式的指定了this array.forEach2(item =\u003e console.log(item) ) // 小白：隐式的把array作为this this 是什么 由于大家使用 forEach2 的时候总是习惯于用 arr.forEach2 所以 arr 就被自动传给 forEach2 了 ​ this 一定是数组吗 不一定，比如 Array.prototype.forEach2 = function(fn){ for(let i=0; i\u003cthis.length; i++){ fn(this[i], i, this) } } // 我们可以指定 this 为一个对象转化的伪数组 Array.prototype.forEach2.call({0:'a',1:'b',length:2}, item=\u003econsole.log(item) ) 所以 this 就是我们可以任意指定的参数而已。 使用小白写法，JS 就会猜你想要的 this 是什么，绝大部分情况都能猜对。 ​ ","date":"2020-09-14","objectID":"/javascript-function/:7:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"总结 this 的两种使用方法 不论什么方式调用函数，实际上都在传递 this 。 区别在于：你【知道】传的 this 什么 或【不知道】 隐式传递 fn(1,2) // 等价于 fn.call(undefined, 1, 2) obj.child.fn(1) // 等价于 obj.child.fn.call(obj.child, 1) // 一个对象的属性上的fn函数 显式传递 fn.call(undefined, 1,2) fn.apply(undefined, [1,2]) apply 区别 apply 要在后面其他参数的部分，加上中括号 [ ] apply 后面的参数要用数组的形式来表示 只是写法形式不同，其他都和 call 是一样的 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:7:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"绑定 this 如果不确定 this 是什么，可以使用 bind 强制绑定 使用 .bind 可以让 this 不被改变 function f1(p1, p2){ console.log(this, p1, p2) } let f2 = f1.bind({name:'frank'}) // 那么 f2 就是 f1 绑定了 this 之后的新函数 f2() // 等价于 f1.call({name:'frank'}) // 打印结果：{name: \"frank\"} undefined undefined // this是传进来的对象，p1/p2没传所以是undefined f2 是 f1 的 this 绑定之后的版本 调 f2 相当于调 f1，唯一的区别就是，f2 的 this 被绑定了，绑定成通过 bind 传递的参数 有什么用呢？ —— 后面学 vue / react 可能就天天遇到了 ​ .bind 还可以绑定其他参数 bind 除了可以绑定 this，其实可以用来绑定所有参数 function f1(p1, p2){ console.log(this, p1, p2) } let f3 = f1.bind({name:'frank'}, 'hi') f3() // 等价于 f1.call({name:'frank'}, hi) // 已经绑死了：this是这个对象，p1是'hi' f3(3) // 因为 this 和 p1 已经绑死了，所以这里传的 3 会作为 p2 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:7:4","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"箭头函数 「箭头函数」没有 arguments 和 this 。 上面讲 this 用了大量篇幅，因为 this 功能太复杂且隐晦。所以新版 JS 就放弃了 this ","date":"2020-09-14","objectID":"/javascript-function/:8:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"函数里面的 this 就是外面的 this 默认的 this 是 window console.log(this) // window console.log(this === window) // true let fn = () =\u003e console.log(this) // 这里的this无需确认，外面的this是什么，箭头函数里面的this就是什么 fn() // window 例 对于箭头函数来说，变量就是普通变量 let a = 1 let fn = () =\u003e console.log(a) fn() // 1 函数打印变量a 。就近原则，先找函数里有没有变量a，没有。就用函数外的变量a this 同理，箭头函数里面没有 this 变量，就找外层的 this 变量。所以箭头函数中的 this 就是外面的 this ​ ","date":"2020-09-14","objectID":"/javascript-function/:8:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"就算用 call 也无法指定 this 怎么证明箭头函数里面没有 this 呢？ 可以用 call 来尝试指定箭头函数的 this 。 结果，无法指定，this 仍然指向 window let fn = () =\u003e console.log(this) fn.call({name:'frank'}) // 仍是 window 不论是用 call 、 bind … 都无法改变箭头函数中 this 的指向，永远是和 函数外的this 保持一致。 除非外面的 this 改变了，否则 箭头函数的 this 不会变化 ","date":"2020-09-14","objectID":"/javascript-function/:8:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"箭头函数没有 arguments let fn = ()=\u003e console.log(arguments) // arguments是所有参数组成的伪数组 fn(1,2,3) // 报错：arguments is not defined 没有 this ，没有 arguments 的函数就是「箭头函数」 ","date":"2020-09-14","objectID":"/javascript-function/:8:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"总结 每个函数都有这些东西 调用时机：决定了变量的值 作用域：同时多个作用域，遵循「就近原则」 闭包：如果一个函数用到了外部的变量，那么这个函数加这个变量，就叫做闭包 形式参数：给参数取名字，相当于声明一个变量 返回值：return ，默认 return undefined 调用栈：进去每个函数前都要先压栈，出来函数前要弹栈 函数提升：函数跑到最前面 arguments（除了箭头函数）：包含所有参数的伪数组 this（除了箭头函数）：引用一个当前不存在的对象，是 call() 方法的第一个参数 ​ ​ ","date":"2020-09-14","objectID":"/javascript-function/:9:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"立即执行函数 只有 JS 有的变态玩意，现在用得少 ","date":"2020-09-14","objectID":"/javascript-function/:10:0","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"声明局部变量（ES6 之前） 在 ES6 之前，怎么获得一个局部变量 例 // 以前只有 var声明时 var a = 1 // a 是一个全局变量 // 如果想声明一个局部变量，必须写一个函数 function fn(){ var a = 2 // 在函数里，声明的 a 才是局部变量 console.log(a) } fn() // 2 console.log(a) // 1 用函数确能得到局部变量，但也同时增加了一个全局的函数（不也是全局变量），这与初衷相悖 思考 / 办法 思考：如果函数没有名字，那就不会生成一个全局函数，然后直接调用这个没名的函数不就行了 办法：声明一个匿名函数，然后直接调用执行 —— 没有暴露任何一个全局变量 或 全局函数 function fn(){ var a = 2 // 获得局部变量a，但副作用是又带来一个全局函数 console.log(a) } fn() // 2 ----------------------------------------- ↑↑ 改写成 ↓↓ --------------- // 去掉函数名 function(){ var a = 2 // 获得局部变量a，但副作用是又带来一个全局函数 console.log(a) } () // 把圆括号加到匿名函数的后面 // 上面就是声明一个匿名函数，然后直接调用执行 执行 / 报错 function(){ var a = 2 console.log(a) } () // Uncaught SyntaxError: Function statements require a function name 执行，报错（JS认为语法不对） 解决 JS 的程序员绞尽脑汁，找到一些解决办法 ↓↓ 匿名函数前加一个操作符 + function(){ var a = 2 console.log(a) } () // 2 // NaN（返回值并不影响需求，所以放着就好） 只要做一个运算，上面函数的写法都可以直接执行，不会再报错（与 undefined 运算，返回都是 NaN） + function(){...}() // NaN - function(){...}() // NaN 1* function(){...}() // NaN // 乘号必须左右都有值 取反也可以 ! 返回值为 undefined =\u003e ! undefined =\u003e true ! function(){...}() // true … 这样我们终于就得到 JS 中，只要一个局部变量的方法 总结：为得到一个局部变量，不得不去造一个函数，并执行这个函数 —— 这也是 JS（旧） 的问题 ","date":"2020-09-14","objectID":"/javascript-function/:10:1","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"总结原理 ES 5 时代，为了得到局部变量，必须引入一个函数 但是这个函数如果有名字，就得不偿失 于是这个函数必须是匿名函数 声明匿名函数，然后立即加个 () 执行它 但是 JS 标准认为这种语法不合法 所以 JS 程序员寻求各种办法 最终发现，只要在匿名函数前面加个运算符即可 !、~、()、+、- 都可以 但是这里面有些运算符会往上走 所以方方推荐永远用 ! 来解决 ​ ","date":"2020-09-14","objectID":"/javascript-function/:10:2","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"声明局部变量（ES6 之后） { let a = 2 console.log(a) } 2 undefined console.log(a) // 报错 a is not defined ","date":"2020-09-14","objectID":"/javascript-function/:10:3","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"注意事项 推荐永远用 ! 来解决 用 +、括号 … 可能有 bug console.log('hi') // 没有这句时，代码执行一切正常，返回值也是 undefined。一旦有这句话，代码执行就不同了 (function(){ var a = 2 console.log(a) } ()) JS 有个特点：它的回车是没有意义的 // 上面代码执行过程，如下 console.log('hi') =\u003e log函数返回值 undefined =\u003e undefined(function(){}()) 因为回车是没有意义的，等同于 undefined 后面跟着一对 ( )，所以把 undefined 当成函数执行，必然报错 总结 永远不要用 【圆括号】来写立即执行函数（圆括号会往上面代码凑，甚至可能连起来执行） 虽然可以用【分号】来强制结束/分隔两个语句 。但显然也没感叹号方便 这是 JS 中唯一需要加分号 ; 的地方，其他任何代码不需要分号 console.log('hi'); // 可以用 ; 分隔两个语句 // 如果别人用了圆括号，一定要在前面加 ; 分号 (function(){ var a = 2 console.log(a) } ()) 用【感叹号】最合适，因为感叹号不会往上面代码看，只会往后看 ","date":"2020-09-14","objectID":"/javascript-function/:10:4","tags":["JavaScript","函数","Function"],"title":"JS 函数的基本介绍","uri":"/javascript-function/"},{"categories":["JavaScript"],"content":"JS 数组的基本介绍","date":"2020-09-11","objectID":"/javascript-array/","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"「数组的基本方法」「伪数组」「数组的增删改查」「索引越界！」 ​ ","date":"2020-09-11","objectID":"/javascript-array/:0:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"数组对象 一种特殊的对象 ","date":"2020-09-11","objectID":"/javascript-array/:1:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"JS 其实没有真正的数组 只是用对象去模拟数组 其他语言、基于底层的语言，比如 C 语言，会告诉你【数组是连续的内存分配】 ","date":"2020-09-11","objectID":"/javascript-array/:2:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"JS 数组不是典型数组 ","date":"2020-09-11","objectID":"/javascript-array/:3:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"典型的数组 元素的数据类型相同 使用连续的内存存储 通过数字下标获取元素 ","date":"2020-09-11","objectID":"/javascript-array/:3:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"但 JS 的数组不这样 JS 的数组，实际上是用 key / value 模拟的，本质是对象 元素的数据类型可以不同 内存不一定是连续的（对象是随机存储的） 不支持数字下标，而是通过字符串下标 这意味着数组可以有任何 key 比如 let arr = [1,2,3] Object.keys(arr) // [\"0\", \"1\", \"2\"] arr['xxx'] = 'xxx' // 下标为'xxx'，值为'xxx' arr.yyy = 'yyy' ","date":"2020-09-11","objectID":"/javascript-array/:3:2","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"创建一个数组 💡 ","date":"2020-09-11","objectID":"/javascript-array/:4:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"新建 let arr = [1,2,3] // 简写 let arr = new Array(1,2,3) // 正规：方便理解原理 let arr = new Array(3) // [empty × 3] 数组为空，但 length为3 ","date":"2020-09-11","objectID":"/javascript-array/:4:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"转化（ Array.from 用字符串创建数组） let arr = '1,2,3'.split(',') // [\"1\", \"2\", \"3\"] let arr = '123'.split('') Array.from('123') // 最新的ES标准提供的api：会把不是数组的东西，尝试变成数组 例 Array.from(123) // [] Array.from(true) // [] Array.from({name: 'sam'}) // [] Array.from({0:'a', 1:'b', 2:'c'}) // [] Array.from({0:'a', 1:'b', 2:'c', length: 3}) // [\"a\", \"b\", \"c\"] 总结：Array.from() 只在符合以下条件的情况下，才能把对象转换成数组 条件1 ：这个对象需要有 0,1,2,3… 这种形式的属性，符合数组的下标 条件2： 这个对象需要有 length 属性 满足以上条件，Array.from(xxx) 就可以尝试把 一个对象 转化成 真正的数组 变态情况 前面提到：JS 的数组 不支持数字下标，而是通过字符串下标。 那这里要转化的对象{0:'a', 1:'b', 2:'c'}的 key 值 0,1,2 都是数字，为什么可以被识别？ 答：当 JS 发现 0,1,2 是数字格式，会先自动调用 (1).toString() 方法，把数字全部转化为 字符串 对象中的下标为 0,1,2 但 length 不为 3 的情况 答：会以 length 为主，有多余的就删，不足就补 undefined。总之，length 值不变 对象中的下标为乱序 答：不会依照下标的乱序来转换数组，而是自动调整为顺序排列内容 ","date":"2020-09-11","objectID":"/javascript-array/:4:2","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"伪数组 伪数组的原型链中并没有数组的原型 换言之，如果一个数组，不具有数组的共有属性（push、pop…等方法），那它就是一个伪数组 可以通过 Array.from() 变成真正的数组 下面的是【真数组】 arr = [1,2,3,4] // new Array(1,2,3,4) arr.__proto__ === Array.prototype // true arr.__proto__.__proto__ === Object.prototype // true arr.__proto__.__proto__ === Array.prototype.__proto__ // true 下面的是【伪数组】 \u003cdiv\u003e1\u003c/div\u003e \u003cdiv\u003e2\u003c/div\u003e \u003cdiv\u003e3\u003c/div\u003e \u003cscript\u003e let divList = document.querySelectorAll('div') // 获取文档中所有div元素，组成一个数组 console.log(divList) // 伪数组 divList.push(4) // 报错 TypeError: divList.push is not a function 伪数组不具有数组的共有属性 let divArray = Array.from(divList) // 把【伪数组】转换为【真数组】 console.log(divArray) \u003c/script\u003e divList【伪数组】 ↓↓ divArray 【真数组】 ↓↓ 总结：没有数组共有属性的「数组」，就是伪数组 不知道 JS 为什么要设计伪数组，没什么用。 如果拿到的是伪数组，尽量转换成真数组，再操作 ​ ","date":"2020-09-11","objectID":"/javascript-array/:4:3","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"合并两个数组，得到新数组 不改变原数组 let arr1 = [3,3,3], arr2 = [4,4,4] arr1.concat(arr2) // [3, 3, 3, 4, 4, 4] // 返回一个新数组，原数组不改变 ","date":"2020-09-11","objectID":"/javascript-array/:4:4","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"截取一个数组的一部分 不改变原数组 let arr1 = [1,2,3,4,5,6] arr1.slice(2) // 从第3个元素开始，获得新数组 [3,4,5,6] // 原数组 arr1 不改变 ","date":"2020-09-11","objectID":"/javascript-array/:4:5","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"截取数组全部 不改变原数组 相当于把原数组复制了一遍 slice(0) 经常用于复制数组。JS 并没有提供专门的复制数组的方法，所以要实现复制效果，就使用 slice(0) let arr1 = [1,2,3,4,5,6] let arr2 = arr1.slice(0) // 全部截取，赋给arr2 注意，所以 JS 原生提供的，都是【浅拷贝】，没有深拷贝 深拷贝在【押题】中讲解 ","date":"2020-09-11","objectID":"/javascript-array/:4:6","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"数组的增删改查 ❤️ ","date":"2020-09-11","objectID":"/javascript-array/:5:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"删元素 🙁 跟对象一样 let arr = ['a','b','c'] delete arr['0'] // arr[0] 可不加引号，此时js会自动加引号 arr // [empty, 'b', 'c'] // 变成【稀疏数组】 delete arr[1] delete arr[2] arr // [empty × 3] // 变成【稀疏数组】 神奇，即使把元素全部 delete ，数组的长度也没有变 ​ 稀疏数组 稀疏数组：只有长度 length，但没有对应的下标，这种数组就是稀疏数组 （感兴趣可以取了解一下，稀疏数组没什么好处，倒是有很多 bug） 例 1 let arr = [1,2,3] arr[3] = 4 // 数组原本3个元素，下标0,1,2 // 现在添加第4个元素、下标为3 arr // [1,2,3,4] // 仍是普通数组，没有异常 arr[100] = 101 // 数组原本4个元素，下标0,1,2,3，现在跳级直接添加下标为100的元素 arr // [1, 2, 3, 4, empty × 96, 101] // 如果跳级添加下标，会导致数组变成【稀疏数组】// length: 101 例 2 let arr = [1,2,3] delete arr[1] arr // [1,empty,3] length: 3 // 使用 delete 删除数组元素，也会导致【稀疏数组】 ​ 🙁 如果直接改 length 可以删元素吗 let arr = [1,2,3,4,5] arr.length = 1 arr // [1] 我X，居然可以？！ JS 真神奇 重要忠告：不要随便改 length 🈲 尽量不要使用 delete 和 改 length 的方式，删除数组元素 ​ 😍 推荐 3 种 API 一个对象提供的函数，就叫做 API 。书写形式： 对象.方法名() 删除头部的元素 arr.shift() // arr 被修改，并返回被删元素 删除尾部的元素 arr.pop() // arr 被修改，并返回被删元素 删除中间的元素（允许增加元素） arr.splice(index) // 从下标为 index 的位置开始删除后面所有元素 arr.splice(index, 3) // 从下标为 index 的位置开始删除 3 个元素 arr.splice(index, 1) // 从下标为 index 的位置开始删除 1 个元素 arr.splice(-index, 3) // 从倒数第 index 位开始删除 3 个元素（index为负时，不表示下标） arr.splice(index, 1, 'x') // 并在删除位置添加 'x' arr.splice(index, 1, 'x', 'y') // 并在删除位置添加 'x'，'y' splice MDN 功能非常强大 示例 let arr = [1,2,3] arr.shift() // 1 // arr.shift() 删除第一个元素，返回被删除元素 arr // [2,3] let arr = [1,2,3] arr.pop() // 3 // arr.pop() 删除最后一个元素，返回被删除元素 arr // [1,2] let arr = [1,2,3,4,5,6,7] arr.splice(2,1) // [3] // arr.slice(2,1) 在下标为2的位置删除1个元素，返回被删除元素组成的数组 arr // [1,2,4,5,6,7] let arr = [1,2,3,4,5,6,7] arr.splice(2,3) // [3,4,5] // 从下标2开始删除3个元素，返回被删除元素组成的数组 arr // [1,2,6,7] let arr = [1,2,3,4,5,6,7] arr.splice(2,3,0) // [3,4,5] // 从下标2开始删除3个元素，添加元素0。返回被删除元素组成的数组 arr // [1,2,0,6,7] arr.splice(2,1,3,4,5) // [0] // 从下标2开始删除1个元素，添加元素3,4,5。返回被删除元素组成的数组 arr // [1,2,3,4,5,6,7] arr.splice(-1,1,777) // [7] // 从倒数第1位删除1个元素，添加元素777。返回被删除元素组成的数组 ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:5:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"查看所有元素 遍历 🙁 查看所有属性名 let arr = [1,2,3,4,5] arr.x = 'xxx' Object.keys(arr) // 遍历属性名 Object.values(arr) // 遍历属性值 for(let key in arr){ console.log(`${key}: ${arr[key]}`) } // for-in 更适用于遍历对象 Object.keys 、 Object.values、for…in… 这 3 种方法，都更适用于遍历对象，不适合遍历数组 通常我们遍历数组，只希望查看对应正常顺序的下标的元素。 如果遍历数组，获取到一个下标为 ‘x’ 的元素，可能是很奇怪的😱（如下图） 所以上述三种方式，虽然可以用，但不是最适合/最常见的遍历数组的方式 ​ 😍 查看数字（字符串）属性名和值 for 循环 用 for 循环遍历（可以自己控制下标） 让下标 i 从 0 增长到 length-1 let arr = [1,2,3,4,5] arr.x = 'xxx' for(let i=0; i\u003carr.length; i++){ console.log(`${i}: ${arr[i]}`) } for 循环，是访问数组的比较常见的形式 for…in… 用来访问对象 forEach forEach 接收一个函数作为参数。这种函数，称为回调函数 forEach 的作用：就是遍历数组的每一项，访问到每一个元素都执行一遍回调函数。 该回调函数，默认参数 【第1个形参】表示元素本身，通常写作 item 【第2个形参】表示当前下标，通常写作 index 【第3个形参】表示数组本身，通常写作 array （大部分情况用不到） 形参的名称无所谓，顺序是关键 例 1 let arr = [1,2,3,4,5] arr.forEach(function(item, index){ // 回调函数的默认第1个形参item表示元素本身、第2个形参index表示当前下标 console.log(`${index}: ${item}`) }) 也可以用 forEach/map 等原型上的函数 手写 forEach 为了更好地理解上述代码（forEach）是怎么实现遍历数组的 下面手动封装一个 forEach 函数 function forEach(array, fn){ for(let i = 0; i\u003carray.length; i++){ // 访问传入的 array 的每一项，对每项执行什么操作呢？↓ fn(array[i], i, array) // 对每一项调用 fn，把数组的相关值作为参数传入到 fn 中 } } forEach 用 for 访问 array 的每一项 对每一项调用 fn(array[i], i, array)。数组有几项，fn 就执行几次 为什么要传入 array 呢？不为什么，规定如此。 例 2 let arr = ['a','b','c'] forEach(arr, function(x,y,z){ console.log(x,y,z) }) 注意：例 2 是 forEach(arr,function)的形式 ，例 1 是 arr.forEach(function) 的形式。 两种写法其实是等价的。因为 JS 会自动把顺序倒过来，按照 例2 的形式执行 面试问：区别是什么 两者区别，回答的关键点就是：前者能实现、而后者做不到的 实际上大多数情况，for 和 forEach 都是通用的 只有一种情况 for 循环里面有 break 和 continue，而 forEach 是不支持的 forEach 只是个普通函数，而 for 是个 关键字，关键字的功能可能会更强大一点 示例 let arr = [1,2,3,4,5,6,7,8] for(let i=0; i\u003carr.length; i++){ console.log(`${i}: ${arr[i]}`) if(i===3){break;} } ----------------------------------------------------- let arr = [1,2,3,4,5,6,7,8] arr.forEach(function(item, i){ console.log(item) if(i===3){return false} // 无效 }) ⭐️区别： for 循环中间，可以 break 或 continue。而 forEach 一旦开始就会一直走到尾，即使 return 也无法结束 for 是关键字，{ } 是块级作用域。而 forEach 是一个函数，{ } 是函数作用域 ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:5:2","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"查看单个属性 跟对象一样 let arr = [111,222,333] arr[0] 注意：不论给下标什么数字，一定都会变成字符串。JS 中没有「数字下标」这么一说 ​ 索引越界 ⭐️ 「索引越界」指给的数组索引（下标）不存在 下述两种情况，需要注意避免 arr[arr.length] === undefined arr[-1] === undefined 例 for(let i=0; i\u003c=arr.length; i++){ // i===length时，数组中并没有对应元素，值为 undefined console.1og(arr[i].toString()) } // 报错：Cannot read property 'toString' of undefined （ undefined不是对象，没有toString ） 访问任何不存在的下标时，得到的结果都是 undefined 当碰到报错 Cannot read property ‘xxx’ of undefined，很有可能是数组的索引越界了 解决办法：console.log 大法 ​ 查找某个元素是否在数组里 ❌ 方法一：遍历 降智写法 let arr = [11,22,33,44,55] for(let i=0; i\u003carr.length; i++){ if(arr[i]===22){ console.log('arr中存在22') }else{ console.log('不存在') } } 😍 方法二：API indexOf 返回只要不是 -1 ，就说明存在 arr.indexOf(item) // 存在返回下标，否则返回 -1 例 let arr = [11,22,33,44,55] arr.indexOf(22) // 1 arr.indexOf(11) // 0 arr.indexOf(66) // -1 ​ 查找满足条件的元素 ❌降智写法：遍历 let arr = [1,2,3,4] for(let i=0; i\u003carr.length; i++){ if(arr[i]%2===0){ console.log(`数组中的偶数：${arr[i]}`) } } // 数组中的偶数：2 // 数组中的偶数：4 😍更好的方法：使用 find arr.find(item =\u003e item%2 === 0) // 找第一个偶数 完整写法 find 用法：找到第一个符合条件（return true）的元素，就停止，并返回这个元素 let arr = [1,2,3,4] arr.find(function(x){ return x%2 === 0 }) // 2 ​ 查找满足条件的元素的索引 findIndex 用法：找到第一个符合条件（return true）的元素，就停止，并返回这个元素的下标 arr.findlndex(item =\u003e item%2 === 0) // 找第一个偶数的索引 例 let arr = [11,22,33,44] arr.findIndex(function(x){ return x%2 === 0 }) // 1 ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:5:3","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"增加数组中的元素 ❌ 不推荐 let arr = [1,2,3] arr[3] = 4 // 数组原本3个元素，下标0,1,2 // 现在添加第4个元素、下标为3 arr // [1,2,3,4] // 仍是普通数组，没有异常 arr[100] = 101 // 数组原本4个元素，下标0,1,2,3，现在跳级直接添加下标为100的元素 arr // [1, 2, 3, 4, empty × 96, 101] // 如果跳级添加下标，会导致数组变成【稀疏数组】// length: 101 arr[index] 的方式，可以增加数组元素 但如果跳级增加下标，会导致数组变成【稀疏数组】，所以不推荐这种方式 ​ ​ ✅ 在尾部加元素 arr.push(newItem) // 修改 arr，返回新长度 arr.push(item1, item2) // 修改 arr，返回新长度 例 let arr = [1,2,3] arr.push('a','b','c') // 6 // 修改原数组，并返回该数组的新长度 arr // [1, 2, 3, \"a\", \"b\", \"c\"] arr.push(666) arr // [1, 2, 3, \"a\", \"b\", \"c\", 666] ​ ✅ 在头部加元素 arr.unshift(newItem) // 修改 arr，返回新长度 arr.unshift(item1, item2) // 修改 arr，返回新长度 例 let arr = [1,2,3] arr.unshift('x','y','z') // [\"x\", \"y\", \"z\", 1, 2, 3] arr.unshift(777) // [777, \"x\", \"y\", \"z\", 1, 2, 3] ​ ✅ 在中间添加元素 splice MDN 功能强大 前面讲，可以用 splice 来[删除指定位置的元素](# 删除中间的元素（允许增加元素）)，这里用来往指定位置添加元素 arr.splice(index, 0, 'x') // 在 index 处插入'x'，原元素向后移一位 // 第2个参数写 0 表示不删除元素 arr.splice(index, 0, 'x', 'y') 例 let arr = [1,2,3] arr.splice(1,0,666) // [] // 返回被删除元素组成的数组，0表示不删除元素，所以返回空数组 arr // [1, 666, 2, 3] splice：可以删除元素、添加元素 （会用 splice 基本可以对数组进行任何操作） ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:5:4","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"修改数组中的元素 直接修改 例 let arr = [1,2,3] arr[1] = 0 arr // [1,0,3] 例 let arr = [1,2,3] arr.splice(1,1,0) // [2] // 把下标为1的元素删除，插入一个0 // 相当于修改元素 arr // [1,0,3] ​ 反转顺序 reverse arr.reverse() // 修改原数组 例 let arr = [1,2,3] arr.reverse() // [3,2,1] arr // [3,2,1] 著名面试题 翻转字符串 let s = 'abcde' s.split('') // [\"a\", \"b\", \"c\", \"d\", \"e\"] s.split('').reverse() // [\"e\", \"d\", \"c\", \"b\", \"a\"] s.split('').reverse().join('') // \"edcba\" ​ 自定义顺序 sort 把乱序，改为【从大到小】或【从小到大】的顺序 arr.sort((a,b) =\u003e a-b) // 会改变原数组 从小到大 let arr = [5,2,4,3,1] arr.sort() // [1,2,3,4,5] // sort 默认【从小到大】排序 从大到小怎么实现 ？ // sort 接收一个回调 let arr = [3,5,2,4,1] arr.sort(function(a,b){ // 两个形参，表示每次进行两两比较的两个数值 if(a\u003eb){ return 1 }else if(a===b){ return 0 }else{ return -1 } }) // [1, 2, 3, 4, 5] ---------------------------------------------------------------------------------- arr.sort(function(a,b){ if(a\u003eb){ return -1 }else if(a===b){ return 0 }else{ return 1 } }) // [5, 4, 3, 2, 1] 例 let arr = [ {name:'Kate', score: 99}, {name:'Jack', score: 85}, {name:'Ryan', score: 100} ] 需求：根据每一项的 score 进行排序 arr.sort() // 显然无效，因为 JS 看不出要怎么比较，我们需要指定给 JS：让它用每一项的 score 来进行比较 怎么指定？用回调函数 let arr = [ {name:'Kate', score: 99}, {name:'Jack', score: 85}, {name:'Ryan', score: 100} ] arr.sort(function(a,b){ // a/b代表两两比较的数组元素（也就是3个对象） if(a.score \u003e b.score){return 1} else if(a.score === b.score){return 0} else{return -1} }) 简化写法 let arr = [5,2,4,3,1] arr.sort(function(a,b){ return a-b // a\u003eb返回一个正数，a\u003cb返回负数，a===b返回0 }) // [1, 2, 3, 4, 5] ------------------------------------------------- let arr = [5,2,4,3,1] arr.sort(function(a,b){ return b-a // b\u003ea返回一个正数，b\u003ca返回负数，a===b返回0 }) // [5, 4, 3, 2, 1] ==\u003e 箭头函数，进一步简化 arr.sort((a,b)=\u003ea-b) // 从小到大 arr.sort((a,b)=\u003eb-a) // 从大到小 arr.sort((a,b) =\u003e a.score - b.score) // 从小到大 arr.sort((a,b) =\u003e b.score - a.score) // 从大到小 ​ ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:5:5","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"数组变换 ⚡️ 高级 API map([🐮, 🥔, 🐔, 🌽], cook) // n变n =\u003e [🍔, 🍟, 🍗, 🍿] filter([🍔, 🍟, 🍗, 🍿], isNotMeet) // n变少 =\u003e [🍟, 🍿] reduce([🍔, 🍟, 🍗, 🍿], eat) // n变1 =\u003e 💩 ​ ","date":"2020-09-11","objectID":"/javascript-array/:6:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"map n 变 n ES6 新方法 map map 会对数组进行遍历，可以对每一项都执行指定的操作（对数组元素每一项进行一一映射） map 方法的返回值为【数组每一项经过回调处理后的返回值 组成的新数组】 返回新的数组，不改变原数组 语法： Array.map(function(ele, index, arr){...}); 回调函数 参数1：遍历的元素 item 参数2：元素下标 index 参数3：原数组 array （通常用不到这个参数） 例 1 let arr = [1,2,3,4]; arr.map(function(ele,index,arr){ console.log(\"ele ==\u003e \", ele,\" index ==\u003e \", index ,\" arr ==\u003e \",arr) }) // [undefined,undefined,undefined,undefined] 因为回调里没有 return，所以会采用函数的默认返回值 undefined，作为每一项回调处理后的返回值，并将这4个返回值组成新的数组，作为最终返回值 所以最后结果就是 4 个 undefined 组成的新数组 总结： 对每一项元素进行处理的语句要写在 return 后面。 否则每一项处理后的返回值都是 undefined 例 2 需求：对 arr 进行操作（每个数乘2），返回新的数组[2,4,6,8] // 以前的方法: for循环 let arr = [1,2,3,4] let newArr = []; for(let i = 0; i \u003c arr.length; i++){ newArr.push(arr[i]*2); // 返回新数组 } console.log(newArr) // [2,4,6,8] -------------------------------------------------------------- // ES6: map let newArr = arr.map(function(ele){ return ele*2 }); // 用箭头函数进行重构：return 的语句可以直接写在箭头后，省略'return' let newArr = arr.map(ele =\u003e ele*2); console.log(arr, newArr) // [1,2,3,4] [2,4,6,8] 例 3 ：计算每一项的平方 需求：把 arr 的每一项都平方 （这个也可[用 reduce 实现](# 计算每一项的平方)） for 循环（旧） let arr = [1, 2, 3, 4, 5, 6] for(let i=0; i\u003carr.length; i++){ arr[i] = arr[i] * arr[i] // 在原数组上进行修改 } arr // [1, 4, 9, 16, 25, 36] 使用 map 简化过程（ES6 新增） let arr = [1, 2, 3, 4, 5, 6] arr.map(item =\u003e item * item) // [1, 4, 9, 16, 25, 36] 返回新数组，原数组不改变 ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:6:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"filter n 变少 用于筛选数组中符合条件的全部元素，返回的是这些元素组成的新数组 返回新的数组，不改变原数组 区别于 find 方法 find方法 查找符合条件的第一个元素，并返回这个元素；没有符合条件的元素，返回 undefined filter方法 查找符合条件的全部元素，并返回这些元素组成的新数组；没有符合条件的元素，返回空数组[ ] 例 1 需求：筛选出 arr 中的偶数（也可以用 reduce 实现） let arr = [1, 2, 3, 4, 5, 6] arr.filter(item =\u003e item%2 === 0 ) // [2, 4, 6] // 把符合条件、返回true的item，筛选出来组成新数组 例 2 需求：筛选出大于等于3的元素 let arr = [1, 2, 3, 4, 5, 6] let newArr = arr.filter((ele , index , arr) =\u003e{ return ele \u003e= 3 console.log(ele) // 不会执行这句，因为函数中遇到 return 就返回（结束）了 }) console.log(newArr); // [3,4] 需求：筛选出大于等于10的元素 let arr = [1, 2, 3, 4, 5, 6] arr.filter( ele =\u003e ele \u003e= 10 ) // [] 例 3 ：删除元素 需求：删除数组中值为 3 的元素 方法一：filter 会把符合条件的全部元素删除 let arr = [3,4,5,6,3,3,3,7] arr = arr.filter(ele =\u003e ele!==3 ) // 筛选出不等于3的元素，相当于从数组中删除值为3的元素 // filter会返回新的数组，再重新赋值给原数组，相当于从原数组中删除 值为3的元素 方法二：findIndex + splice 会把符合条件的第一个元素删除 let arr = [3,4,5,6,3,3,3,7] let index = arr.findIndex(ele =\u003e ele === 3) // 找到下标，通过splice方法从数组中删除对应下标的元素 arr.splice(index,1) // [3] arr // [4, 5, 6, 3, 3, 3, 7] ​ ​ ","date":"2020-09-11","objectID":"/javascript-array/:6:2","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"reduce n 变 1 reduce 是数组里面最难理解，也是功能最强大的 API（第二名是 splice） reduce 可以代替 map 和 filter，只不过对新人有一定难度 求数组元素之和 用 for 循环实现 let arr = [1,2,3,4,5] let sum = 0 // 作为结果的初始值为0 for(let i=0;i \u003carr.length;i++){ sum += arr[i] // sum = sum + arr[i] } console.log(sum) // 15 用 reduce 来实现 let arr = [1,2,3,4,5] // arr.reduce(()=\u003e{}, 0) // reduce中，0作为结果的初始值，写在第2个参数上 // 第1个参数是一个函数：规定每一次遍历要对上一次的结果进行什么操作 arr.reduce((total,current)=\u003etotal+current, 0) // 15 // reduce的回调函数，默认形参1是上一次的返回值（初始0），形参2是当前元素 // 求和，就是要把上一次的结果再加上当前元素，获得二者的和，所以回调执行的就是 total+current // total初始值为0（相当于上面for循环例子中的sum） 第1轮，遍历获取元素 1，执行回调，total为初始值0 + current是当前遍历到的元素1，回调返回0+1=\u003e 1 第2轮，遍历获取元素 2，执行回调，total为上一次的返回值 1 + current：2，回调返回 1+2 =\u003e 3 第3轮，遍历获取元素 3，执行回调，total为上一次的返回值 3 + current：3，回调返回 3+3 =\u003e 6 第4轮，遍历获取元素 4，执行回调，total为上一次的返回值 6 + current：4，回调返回 6+4 =\u003e 10 第5轮，遍历获取元素 5，执行回调，total为上一次的返回值 10 + current：5，回调返回 10+5 =\u003e 15 变形 计算数组中成员的总年龄 var arr = [ {name: \"张三\", age: 40}, {name: \"李四\", age: 50}, {name: \"王五\", age: 60} ] arr.reduce((total, current) =\u003e { console.log(total, current.age) // 0 40 // 40 50 // 90 60 return total + current.age }, 0) // 150 计算每一项的平方 用 map 实现 let arr = [1, 2, 3, 4, 5, 6] arr.map(item =\u003e item * item) // [1, 4, 9, 16, 25, 36] 返回新数组，原数组不改变 用 reduce 实现 let arr = [1, 2, 3, 4, 5, 6] // arr.reduce((total,current)=\u003e{ return total.push(current*current) }, []) // 报错 total.push is not a function 因为 push 的返回值并不是新的数组，而是length，所以不能用 push // 连接两个数组，用 concat arr.reduce((result, item)=\u003e{ return result.concat(item * item) }, []) // [1, 4, 9, 16, 25, 36] 补充：concat 用法：不修改原数组，返回新数组 let arr = [0,1] // [0, 1] arr = arr.concat(2) // [0, 1, 2] 所以必须重新赋值给arr，才能实现push效果 arr = arr.concat([3,4]) // [0, 1, 2, 3, 4] ​ 筛选出所有偶数 用 filter 实现 let arr = [1, 2, 3, 4, 5, 6] arr.filter(item =\u003e item%2 === 0 ) // [2, 4, 6] // 把符合条件、返回true的item，筛选出来组成新数组 用 reduce 实现 let arr = [1, 2, 3, 4, 5, 6] arr.reduce((result,item)=\u003e{ if(item%2===1){ // 如果是奇数，不做任何处理，直接返回 原result return result }else{ // 如果是偶数，就把偶数连到result中，再返回新数组，作为下一轮的result return result.concat(item) } },[]) 简写 let arr = [1, 2, 3, 4, 5, 6] arr.reduce((result,item)=\u003e item % 2 === 1 ? result : result.concat(item) , []) 再进一步探索（炫技） let arr = [1, 2, 3, 4, 5, 6] arr.reduce((result,item)=\u003e // item % 2 === 1 ? result : result.concat(item) // 原理：如果item是奇数就不concat到result中 // ==\u003e 换言之，若是奇数，可concat一个空 // item%2===1 ? result.concat() : result.concat(item) // ==\u003e 也就是，我总是需要concat一个东西 ==\u003e 那就可以转换为 result.concat(item % 2 === 1 ? [] : item) , []) // [2, 4, 6] 将多维数组，转为一维数组 // reduce的参数total和current也可以执行【数组合并】这样的操作 var arr = [1, 2, 3, [4], 6, [1, 2, 3, [4]]]; var fun = function(arr) { var newArr = arr.reduce((total, current) =\u003e { if (current instanceof Array) { //递归 var news = fun(current); // 返回一个数组 total = total.concat(news); return total // 将返回的数组拼接回total中 } else { total.push(current); return total } }, []) //[]：表示给total赋初始值，total是一个空数组 return newArr } console.log(fun(arr)); 多维数组转为一维数组，也可以用flat方法等【方法很多，可以查看es6入门2/zuoye目录中的大家的解法】 reduce 叫做累加器 对数组进行遍历，执行加减乘除操作等等 reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 常用来【求和】 语法：array.reduce(function(total, current, currentIndex, arr), initialValue) 参数 total ： 必需。上一次循环计算结束后的return返回值； 如果回调函数没有return，则第二次循环时total为undefined **参数 current **： 必需。当前的元素 参数 currentIndex：可选。当前元素下标 参数 arr：可选。原数组 参数 initialValue：可选。传递给函数的初始值 ","date":"2020-09-11","objectID":"/javascript-array/:6:3","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"题目 ","date":"2020-09-11","objectID":"/javascript-array/:7:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"第一题：把数字变成星期 let arr = [0,1,2,2,3,3,3,4,4,4,4,6] let arr2 = arr.map((item,index)=\u003e{ if(item===0){return '周日'} if(item===1){return '周一'} if(item===2){return '周二'} if(item===3){return '周三'} if(item===4){return '周四'} if(item===5){return '周五'} if(item===6){return '周六'} }) console.log(arr2) // ['周日', '周一', '周二', '周二', '周三', '周三', '周三', '周四', '周四', '周四', '周四','周六'] 参考答案 let arr = [0,1,2,2,3,3,3,4,4,4,4,6] let arr2 = arr.map((i)=\u003e{ const hash = {0:'周日',1:'周一',2:'周二',3:'周三',4:'周四',5:'周五',6:'周六'} return hash[i] }) console.log(arr2) ","date":"2020-09-11","objectID":"/javascript-array/:7:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"第二题：找出所有大于 60 分的成绩 let scores = [95,91,59,55,42,82,72,85,67,66,55,91] let scores2 = scores.filter(item=\u003eitem \u003e 60) console.log(scores2) // [95, 91, 82, 72, 85, 67, 66, 91] 参考答案 let scores = [95,91,59,55,42,82,72,85,67,66,55,91] let scores2 = scores.filter(n =\u003e n\u003e= 60) console.log(scores2) // [95,91,82,72,85,67,66, 91] ","date":"2020-09-11","objectID":"/javascript-array/:7:2","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"第三题：算出所有奇数之和 let arr = [95,91,59,55,42,82,72,85,67,66,55,91] let arr2 = arr.reduce((sum,n)=\u003e{ if(n%2===0){return sum} else{return sum+n} }) console.log(arr2) let scores = [95,91,59,55,42,82,72,85,67,66,55,91] let sum = scores.reduce((sum,n)=\u003e n%2===1 ? sum+n : sum, 0) console.log(sum) // 598 参考答案 let scores = [95,91,59,55,42,82,72,85,67,66,55,91] let sum = scores.reduce((sum, n)=\u003e{ return n%2===0?sum:sum+n },0) console.log(sum) // 奇数之和：598 ​ ","date":"2020-09-11","objectID":"/javascript-array/:7:3","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"面试题 ","date":"2020-09-11","objectID":"/javascript-array/:8:0","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["JavaScript"],"content":"数据变换 let arr = [ {名称: '动物', id: 1, parent: null}, {名称: '狗', id: 2, parent: 1}, {名称: '猫', id: 3, parent: 1} ] // 数组变成对象 { id: 1, 名称：'动物', children:[ {id: 2, 名称：'狗', children: null}, {id: 3, 名称：'猫', children: null} ] } 解 test-1，先想当然的试试 arr.reduce((result,item)=\u003e{ result[item.id] = item return result }, {}) test-2， 如果在parent为null时，才往 result 添加 id，值为 item.id；parent不为空，就把 item 添加到 result.children数组中 初始化 result 把 id 和 children 加进去（注意children是数组） arr.reduce((result,item)=\u003e{ if(item.parent === null){ result.id = item.id result['名称'] = item['名称'] }else{ delete item.parent item.children = null result.children.push(item) } return result }, {id: null, children: []}) 完。 ","date":"2020-09-11","objectID":"/javascript-array/:8:1","tags":["JavaScript","数组","Array"],"title":"JS 数组","uri":"/javascript-array/"},{"categories":["个人博客的创建之路"],"content":"Valine + LeanCloud","date":"2020-09-09","objectID":"/blog-comments-valine-leancloud/","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"hugo 博客添加评论系统 Valine Valine - 一款快速、简洁且高效的无后端评论系统。 Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho等博客程序在使用Valine。 所以，理论上它也是支持 Hugo 的， 实践证明，确实如此。其特性如下： 快速 安全 Emoji 😉 无后端实现 MarkDown 全语法支持 轻量易用(~15kb gzipped) 文章阅读量统计 v1.2.0-beta1+ 下面就讲一下如何一步步添加 Valine 支持的。 Tips: 整个过程，是以Loveit主题为例的，其它主题操作大同小异。 配置之前应该先阅读Valine快速开始 ​ ","date":"2020-09-09","objectID":"/blog-comments-valine-leancloud/:0:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"Leancloud相关配置 评论系统依赖于 leancloud，所以需要先在leancloud中进行相关的准备工作。 登录 或 注册 LeanCloud（国际版） 必须验证邮箱和手机号 成功后，进入后台点击左上角的创建应用： 创建好应用，进入应用，点击【组件】 左边栏找到【设置】，然后点击【应用Key】，此时记录出现的 App ID 和 App Key，后面配置文件中会用到： 因为评论和文章阅读数统计依赖于存储，所以还需要建立两个新的存储 Class 左边栏找到并点击【存储】，点击【创建Class】 创建两个存储Class，分别命名为: Counter 和 Comment； 仅修改 ACL 的 write 权限 还需要为应用添加安全域名，左边栏点击【设置】，找到【安全中心】，点击后会看到【安全域名】设置框，输入博客使用的域名，点击保存即可： ​ ","date":"2020-09-09","objectID":"/blog-comments-valine-leancloud/:1:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"config.toml 添加参数 添加 Valine 参数项： [params.page.comment.valine] enable = true appId = \"xxxxxxxxxxxxxxxxxxxxxx\" appKey = \"xxxxxxxxxxx\" placeholder = \"说点什么吧...（提醒：填写邮箱，若有人回复您，您将及时收到提醒邮件！）\" avatar = \"mp\" meta= \"\" pageSize = 10 lang = \"\" visitor = false recordIP = true highlight = true enableQQ = false serverURLs = \"\" # LoveIt 新增 | 0.2.6 emoji 数据文件名称, 默认是 \"google.yml\" # (\"apple.yml\", \"google.yml\", \"facebook.yml\", \"twitter.yml\") # 位于 \"themes/LoveIt/assets/data/emoji/\" 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \"assets/data/emoji/\" emoji = \"apple.yml\" 上面几项内容的含义，这里简单一说，具体还是要看 Valine官网中配置相关的内容： 参数 用途 enable 这是用于主题中配置的，不是官方Valine的参数，true时控制开启此评论系统 appId 这是在 leancloud 后台应用中获取的，也就是上面提到的 App ID appKey 这是在 leancloud 后台应用中获取的，也就是上面提到的 App Key notify 用于控制是否开启邮件通知功能，具体参考邮件提醒配置 verify 用于控制是否开启评论验证码功能 avatar 用于配置评论项中用户头像样式，有多种选择：mm, identicon, monsterid, wavatar, retro, hide。详细参考：头像配置 placehoder 评论框的提示符 visitor 控制是否开启文章阅读数的统计功能, 详情阅读文章阅读数统计 ","date":"2020-09-09","objectID":"/blog-comments-valine-leancloud/:2:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"完善评论通知 ⭐️⭐️ Valine 评论邮件提醒功能不太健全，通知邮件中没有文章直达链接，Valine 官网中提供了评论系统第三方功能扩展Valine链接，按照链接中的说明，非常详细的步骤，一步步很容易实现完备的评论系统后台管理以及邮件提醒功能，部分高级配置点我了解。这里简单列举步骤如下： ","date":"2020-09-09","objectID":"/blog-comments-valine-leancloud/:3:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"步骤 进入leancloud，【云引擎】【部署项目】【git】 填写仓库地址： https://github.com/zhaojun1998/Valine-Admin 填写分支： master 此外，你需要设置云引擎的环境变量以提供必要的信息，点击云引擎的设置页，设置如下信息： 必选参数 SITE_NAME : 网站名称。 SITE_URL : 网站地址, 最后不要加 / 。 SMTP_USER : SMTP 服务用户名，一般为邮箱地址。 SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式 SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、\"Yahoo\"、...... ，全部支持请参考 : Nodemailer Supported services。 — 如这里没有你使用的邮件提供商，请查看自定义邮件服务器 SENDER_NAME : 寄件人名称。 （图略） 设置完环境变量，必须重新部署，邮件提醒功能才会生效 云引擎 —— 设置 —— 云引擎域名（如：jackma），保存 然后进入 存储 —— _User 添加一个用户，只需 User，password，email 三个信息即可。（为了安全考虑，此 email 必须为配置中的 SMTP_USER 或 TO_EMAIL， 否则不允许登录） 此时可以使用定义的主机域名登录后台管理系统了，地址为：[云引擎域名jackma].avosapps.us，用户名为刚设置的邮箱。 LeanCloud 休眠策略 首先需要添加环境变量，ADMIN_URL : 云引擎域名，如：https://jackma.avosapps.us（重启生效） 然后点击【云引擎】【定时任务】【创建定时任务】，按照图片上填写：0 0/20 7-23 * * ? 添加后，要记得点击启用 启用成功后，每 20 分钟在【云引擎】的 - 应用【日志】中可以看到提示 登录上面主机域名进入后台瞅一瞅： 我自己沙发了一条评论 日志提示： 进入后台后可以看到： 同时，我也收到了通知邮件： 至此完成了 Valine 评论系统的添加和完善，喝杯咖啡☕️庆祝一下！ ​ ​ ","date":"2020-09-09","objectID":"/blog-comments-valine-leancloud/:3:1","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"解决：自动唤醒失败 免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行： 每天必须休眠 6 个小时 30 分钟内没有外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。 分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。 使用 cron-job 解决 Valine-admin 因流控原因自动唤醒失败的问题 免费的体验版，基本崩了。 评论提醒功能，可能必须经常手动部署。阅读量仍正常记录，不受牵连。 Valine-admin由于Leancloud流控原因，自动唤醒任务可能会失败 所以这里介绍一个使用第三方计划任务网站进行定时唤醒 Valine-admin 的方法。 ","date":"2020-09-09","objectID":"/blog-comments-valine-leancloud/:4:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"注册 cron-job 帐号 注册地址：https://cron-job.org/en/signup/ 注册时的时区请选择 Asia/Shanghai ","date":"2020-09-09","objectID":"/blog-comments-valine-leancloud/:4:1","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"添加一个计划任务 登陆之后依次点击 Members，cronjobs，Create cronjob Title, Address Title 可以随便填一个 Address 填写你的云引擎环境变量的 ADMIN_URL，也就是Leancloud的Web 主机域名。 Schedule 选择 User-defined 进行自定义设置（按住 Ctrl 可多选） Days of month: 全选 Days of week: 全选 Months: 全选 Hours: 你需要在哪个时间段唤醒就选择什么 （每天强制休眠 6 小时，推荐选 7-23-0 唤醒） Minutes: 选择 0 , 20 , 40 Notifications 可以不用修改，也可以根据自己的需要修改 Common 勾选Save responses, 保存唤醒日志 点击Create cronjob ​ ","date":"2020-09-09","objectID":"/blog-comments-valine-leancloud/:4:2","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"参考 Valine Valine-Admin leancloud-休眠策略 hugo博客添加评论系统Valine 将 Valine 切换至 leancloud 国际版 https://juejin.im/post/6844904175298428941 ","date":"2020-09-09","objectID":"/blog-comments-valine-leancloud/:5:0","tags":["Valine","Leancloud","评论","博客"],"title":"个人博客添加评论系统 Valine + LeanCloud","uri":"/blog-comments-valine-leancloud/"},{"categories":["个人博客的创建之路"],"content":"hugo 搜索功能 Algolia","date":"2020-09-08","objectID":"/blog-search-algolia/","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"hugo 搜索功能 Algolia ","date":"2020-09-08","objectID":"/blog-search-algolia/:0:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"前言 Hugo是由 Steve Francis 大神（http://spf13.com/）基于Go语言开发的静态网站构建工具。没错你现在看到的本博客就是基于Hugo的，使用 Hugo 创建一个网站是非常简单的，基本上没有什么门槛，官方还提供了大量的主题供你选择，你只需要专心写的文章就行。不过有个问题是搜索，我们知道搜索属于动态行为了，如何给静态网站增加搜索功能呢？当然我们可以使用Google的站内搜索功能，Hugo 官方也提供了一些开源的和商业的解决方案，今天我们要介绍的就是一个非常优秀的商业解决方案：Algolia。 ","date":"2020-09-08","objectID":"/blog-search-algolia/:1:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"注册 前往官方网站https://www.algolia.com/ 使用 GitHub 或 Google 帐号登录。 登录完成后根据提示信息填写一些基本的信息即可。 注册完成后前往 Dashboard，我们可以发现 Algolia 会默认给我们生成一个 app。 默认的 app 可以在 settings → Applications 中重命名 选择 Indices，添加一个新的索引，我这里命名为blog，创建成功后，我们可以看到提示中还没有任何记录。 Algolia 为我们提供了三种方式来增加记录：手动添加、上传 json 文件、API。 ","date":"2020-09-08","objectID":"/blog-search-algolia/:2:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"修改 config.toml 配置 以下内容，基于 Loveit 主题测试生效 [params.algolia] appId = \"你的Application ID\" indexName = \"你的索引名字\" searchOnlyKey = \"你的Search-Only API Key\" 执行 hugo，会自动生成 public/index.json 用于索引 ","date":"2020-09-08","objectID":"/blog-search-algolia/:3:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"上传索引文件 生成索引文件之后，我们需要上传到 Algolia 的服务器。 ","date":"2020-09-08","objectID":"/blog-search-algolia/:4:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"手动上传 这一步是可选的，不过还是建议跟着做一下。 点击侧栏 Indices ，点击 Upload record(s) 按钮上传上一步生成的 index.json 文件。 上传成功之后，我们就可以马上尝试搜索了： 可以看到搜索的关键词有相应的匹配结果，说明我们生成的索引文件是正确的。 ","date":"2020-09-08","objectID":"/blog-search-algolia/:4:1","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"自动上传 每次写完博文都手动上传索引文件无疑是痛苦的、无意义的重复劳动。 因此我们需要把上传索引文件的操作自动化，在自动部署的时候顺便完成即可。 这里我们采用npm包 atomic-algolia 来完成上传操作。 安装 atomic-algolia 包 npm install atomic-algolia --save 修改根目录下的 package.json 文件（没有就新建），在 scripts 下添加 \"algolia\": \"atomic-algolia\" { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } 注意 \"test\" 那一行末尾有个英文逗号，不要漏了。 根目录下新建 .env 文件，内容如下： ALGOLIA_APP_ID=你的Application ID ALGOLIA_INDEX_NAME=你的索引名字 ALGOLIA_INDEX_FILE=public/index.json ALGOLIA_ADMIN_KEY=你的Admin API Key 注意替换你自己 Algolia 索引的信息。 另外特别注意 ALGOLIA_ADMIN_KEY 可以用来管理你的索引，所以尽量不要提交到公共仓库。可以添加到 .gitignore 中 上传索引的命令 你可以本地执行 npm run algolia 查看运行效果： 可以看到我们成功添加了记录。 后续，可以把下面的命令加到你的部署脚本中： npm run algolia // 在hugo命令后面执行 ","date":"2020-09-08","objectID":"/blog-search-algolia/:4:2","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["个人博客的创建之路"],"content":"参考资料 Hugo添加Algolia搜索支持 atomic-algolia 插件 Hugo 集成 Algolia 搜索 ","date":"2020-09-08","objectID":"/blog-search-algolia/:5:0","tags":["博客","搜索","Algolia"],"title":"Hugo 集成 Algolia 搜索","uri":"/blog-search-algolia/"},{"categories":["JavaScript"],"content":"JS 对象分类——原型 \u0026 类","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"「构造函数」「原型」「new 操作符」「类 class」 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:0:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"对象需要分类吗？ 这是一个值得思考的问题 我们来做一个小程序 输出各种形状的面积和周长 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:1:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"一个正方形 Square 代码 let square = { width: 5, getArea(){ return this.width * this.width // 先简单的把this理解成当前对象，在「函数篇」会重新学习this }， getLength(){ return this.width * 4 } } 分析 声明一个「正方形」对象 「正方形」拥有三个属性：边长、面积、周长 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:2:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"一打正方形 💡 let square1 = { width: 5, getArea(){ return this.width * this.width }， getLength(){ return this.width * 4 } } let square2 = { width: 5, getArea(){ return this.width * this.width }， getLength(){ return this.width * 4 } } let square3 = { ... } ... let square12 = { ... } 写12遍。这样写代码的，要么是新人，要么是傻子。 这么写非常累，如果修改，需要逐个修改，非常非常麻烦 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"用 for 循环实现（浪费内存） let squareList = [] for(let i=0; i\u003c12; i++){ // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c squareList[i] = { // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c width: 5, getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 } } } 如果 width 不全是 5，怎么实现 let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c for(let i=0; i\u003c12; i++){ squareList[i] = { width: widthList[i], // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 } } } 分析 虽然实现了需求，但上面写法仍属于「垃圾代码」，浪费了太多内存，自己画 内存图 就知道了 squareList[0].getArea === squareList[1].getArea // false \u003cimg src=\"https://i.loli.net/2020/09/03/kQiTnhXL92HNabF.jpg\" alt=\"内存图-循环过程\" /\u003e 会画内存图的人， 比其他人理解的更好 内存中，一共创建了 24 个函数，其中 22 个都是多余重复的 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"借助原型 √ 将12个正方形对象的共有属性放到原型里 代码 let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] let squarePrototype = { getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 } } for(let i=0; i\u003c12; i++){ squareList[i] = Object.create(squarePrototype) // 每一个正方形都以squarePrototype为原型，共享方法 squareList[i].width = widthList[i] } squareList[0].getArea === squareList[1].getArea // true 分析 有人指出创建一个正方形的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来 还是垃圾代码！创建square的代码太分散了！ 在上面基础上，应该再把代码抽离到一个函数里，实现调用函数 就可以创建正方形 —— 封装函数 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"抽离到函数（封装）⭐️ 将创建正方形的代码，整合到一个 function 中 直接调用 function 即可创建出对应个数的正方形对象 这种过程就叫做「封装」 把细节写到一个函数里，调用函数、传参，就搞定了 let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] function createSquare(width){ // 此函数叫做「构造函数」详见一下版块 let obj = Object.create(squarePrototype) // 以 squarePrototype 为原型创建空对象 obj.width = width return obj } let squarePrototype = { getArea(){ return this.width * this.width } getLength(){ return this.width * 4 } } for(let i=0; i\u003c12; i++){ squareList[i] = createSquare(widthList[i]) // 这下创建 square 很简单了吧！ } ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:3:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"构造函数 ⭐️ 就是可以构造出对象的函数 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:4:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"函数和原型结合（进一步封装）⭐️ 进一步封装 squarePrototype 原型 和 creatSquare 函数，还是分散的 能不能组合在一起？ let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] function createSquare(width){ // 构造函数：用于创建 square 对象 let obj = Object.create(createSquare.squarePrototype) // 先使用后定义？NO，这里并未执行，执行时已经定义完了 obj.width = width return obj } createSquare.squarePrototype = { // 把原型放到构造函数上，结合够紧密了吗？ getArea(){ return this.width * this.width }, getLength(){ return this.width * 4 }, constructor: createSquare // 再把构造函数放到原型上，方便通过原型找到构造函数 // 原型和构造函数互相引用，非常紧密 // 可以通过createSquare函数，找到原型squarePrototype。也可以拿到原型，方便的找到createSquare函数 } for(let i=0; i\u003c12; i++){ squareList[i] = createSquare(widthList[i]) console.log(squareList[i].constructor) // ƒ createSquare(width){...} // 打印 constructor 可以知道谁构造了 squareList[0→11] 对象：你妈是谁？ } 函数上面也可以用「点 . 」？ 因为函数属于对象 此时，代码已经没有进一步优化的空间了 这段代码几乎完美 为什么不固定下来，让每个JS开发者直接用呢? 这时 JS 就有了 new 操作符 来帮我们实现 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:4:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"new 操作符 ⭐️ 让我们感受JS之父的爱 JS 之父创建了 new 关键字，可以让我们可以再少写几行代码 JS 的 new 到底是干什么的？⚡️⚡️⚡️⚡️（必读！！！） 函数和原型结合（重写）⭐️⭐️ let squareList = [] let widthList = [5,6,5,6,5,6,5,6,5,6,5,6] function Square(width){ // 构造函数 this.width = width } Square.prototype.getArea = function(){ return this.width * this.width } Square.prototype.getLength = function(){ return this.width * 4 } for(let i=0; i\u003c12; i++){ squareList[i] = new Square(widthList[i]) console.log(squareList[i].constructor) } // 多美，几乎没有一句多余的废话 每个函数创建时，都自带有prototype属性，这是JS之父故意的 每个prototype都自带有constructor属性，也是故意的 function f1(){} console.dir(f1) f1.prototype.constructor === f1 // true // 函数原型上的constructor等于函数本身 ​ 对比 上面的代码被简化为下面的代码 唯一的区别是要用 new 来调用 细节 creatSquare =\u003e Square 函数名变了 之前需要创建对象，让对象的原型指向拥有 getArea 和 getLength 的那个对象 。 现在这句话不用写了，new 会帮我们实现 用 this 代表新的对象（this 会指向临时对象） return obj 也不用写了，new 会帮我们实现（函数原本三行，压缩成一行，其他 new 会帮我们实现） 现在，把 getArea 和 getLength 通过「点方法」挨个添加到 prototype 上，不能直接给 prototype 赋新值，会导致丢失原本的 constructor（可以用 Object.assign 批量添加） 最后，声明新对象时，用 new Square(width) ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:4:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"总结 ⚡️⚡️⚡️ JS 的 new 到底是干什么的？⚡️⚡️⚡️⚡️（必读！！！） ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"new X() 自动做了四件事情 自动创建空对象 自动为空对象关联原型，原型地址指定为 X.prototype 自动将空对象作为 this 关键字运行构造函数 this 就是我们new构造函数创建的对象 自动 return this ——这就是 JS 之父的爱 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"构造函数 X X 函数本身负责给对象本身添加属性 X.prototype 对象负责保存对象的共用属性 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"原型与共有属性的关系 因为 JS 引擎按照「堆栈」来分配内存、存储数据 根据「堆栈」的规则，简单类型在「栈区 Stack」存储，复杂类型在「堆区 Heap」存储 X.prototype 的值是，原型的地址 因为原型是一个对象，对象是以「堆」的形式存储，所以严格来说，X.prototype的值是：原型的地址 这个地址，对应到计算机中的那一坨内存，才是原型本身 而原型中，有很多属性/方法：toString、valueOf … 它们就是「共有属性」（原创的词） 共有属性的集合就是原型 如果会画内存图，会理解的更清楚 ↓↓↓ ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:5:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"示例 function Dog(name){ this.name = name this.color = 'white' this.kind = '萨摩耶' // this 就是我们new构造函数创建的对象 } Dog.prototype.say = function(){ console.log('汪汪') } // 共用函数 Dog.prototype.run = function(){ console.log('狗在跑') } let dog1 = new Dog('小白') Dog.prototype.x = '狗' // 共用的不一定都是函数, 也可以共用属性。 let dog2 = new Dog('小黑') dog1.x // '狗' dog2.x // '狗' ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:6:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"题外话：代码规范 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:7:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"大小写 所有构造函数（专门用于创建对象的函数）首字母大写 所有被构造出来的对象，首字母小写 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:7:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"词性 new 后面的函数（构造函数），使用名词形式。 如 new Person()、new Object() 普通函数，一般使用动词开头。如 createSquare(5)、createElement('div') 其他规则以后再说 ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:7:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"总结一个非常重要的公式 💋 也是 JS 里唯一的一个公式 很多前端对于原型的理解是通过画图，实际上是可以通过公式来表示的 只有方方的课才能看到，若愚的课也没有 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"如何确定一个对象的原型 为什么 let obj = new Object()的原型是 Object.prototype let arr = new Array()的原型是 Array.prototype let square = new Square()的原型是 Square.prototype let fn = new Function()的原型是 Function.prototype 可以总结出，一个对象通过 new XXX 创建出来，那么 XXX.prototype 就是这个对象的原型 因为 new 操作故意这么做的 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"结论 你是谁构造的 你的原型就是谁的 prototype 属性 对应的对象 很多前端会说 prototype 就是原型 实际上、严格来说，prototype 只是存了个地址，不是对象。 prototype 地址对应的那块内存、内存中所有共有属性的集合，才是原型对象本身 ⚡️⚡️⚡️⚡️ 原型公式 ⚡️⚡️⚡️ 对象.__proto__ === 其构造函数.prototype ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"例 💋 function X(width){ this.width = width } X.prototype.getArea = function(){ return this.width * this.width } X.prototype.getLength = function(){ return this.width * 4 } let a = new X(5) let b = new X(6) 构造函数的原型：X.prototype 是 #309 构造出的对象 a 和 b 的原型 ： a.__proto__ 和 b.__proto__ 也是 #309 补充：#109 结构 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"参考资料 JS 中 __proto__ 和 prototype 存在的意义是什么？ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:4","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"做几个题 来理解公式：对象.__proto__ === 其构造函数.prototype 难度1 let x = {} 请问： x的原型是什么？ Object.prototype x.__proto__的值是什么？ Object.prototype 上面两个问题是等价的吗？ 请用内存图画出x的所有属性 答： Object.prototype // x的原型 Object.prototype // x.__proto__ x.__proto__ === Object.prototype // true 二者是等价的 x.__proto__ === window.Object.prototype // true 「window.」可省略 ​ 难度2 function Square(width){ this.width = width } let square = new Square(5) ⚡️⚡️⚡️ 请问： square的原型是什么？ square.__proto__的值是什么？ 请用内存图画出 square 的所有属性 答： Square.prototype // square的原型 Square.prototype // square.__proto__ // 1/2两个问题是等价的（带入公式理解） ​ 难度3 请问： Object.prototype 是哪个函数构造出来的？ Object.prototype 的原型是什么？ Object.prototype.__proto__ 值是什么? 请用内存图画出上述内容 答： 未知，Object.prototype 是默认就存在的，没有谁把它构造出来 没有原型 Object.prototype.__proto__ === null // true ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:8:5","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"构造函数、prototype、new 通过 Square 的例子，已经可以基本理解了 构造函数 用来创建对象的函数，就是构造函数（特点：首字母大写） ​ prototype 不论构造函数、还是普通函数，每一个函数（对象）都有一个 prototype，用来存放共有属性 每个对象都有原型，但除了「根对象 Object.prototype」比较特殊，Object.prototype 这个对象的原型为空 null function add(x,y){return x+y} add.prototype // 不仅是构造函数，普通函数也有 prototype delete add.prototype // false 而且删不掉，仍然存在 ​ new：会帮我们做四件事情（省略了很多代码） 创建一个临时对象 把这个对象指向一个原型 把这个对象作为 this 来运行这个构造函数 return this ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:9:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"Square 最终版（存疑） function Square(width){ this.width = width } Square.prototype.getArea = function(){ return this.width * this.width } Square.prototype.getLength = function(){ return this.width * 4 } let square = new Square(5) square.width // 5 square.getArea() // 25 square.getLength() // 20 为什么说存疑：因为还有一个更简化的版本，后面再讲 ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:10:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"圆形 Circle function Circle(radius){ this.radius = radius } Circle.prototype.getLength = function(){ return this.radius * Math.PI } Circle.prototype.getArea = function(){ return Math.pow(this.radius, 2) * Math.PI } let c1 = new Circle(10) c1.radius // 10 c1.getLength() // 31.41592653589793 c1.getArea() // 314.1592653589793 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:11:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"长方形 Rectangle 两个参数：宽、高 function Rect(width, height){ this.width = width this.height = height } Rect.prototype.getArea = function(){ return this.width * this.height } Rect.prototype.getLength = function(){ return (this.width + this.height) * 2 } let r1 = new Rect(4,5) r1.width r1.height r1.getLength() r1.getArea() ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:12:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"对象需要分类吗？🧐 回到最初的问题 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"答案是 需要分类 因为不同的对象有不同的功能，某些对象具有相同功能，某些对象具有不同功能 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"理由一 有很多对象拥有一样的属性和行为 需要把它们分为同一类 如 square1 和 square2 如 圆1、圆2、圆3，都是圆 如 长方形1、长方形2，都是长方形 … 这样创建类似对象的时候就很方便 直接 new 一个 Square、new Circle、new Rect … 然后传参，就能创建出相应图形的对象 就不需要【 let square1 = {…}; let square2 = {…} 然后把所有属性写一遍】，这样会很麻烦 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"理由二 但是还有很多对象拥有其他的属性和行为 所以就需要不同的分类 比如 Square / Circle / Rect 就是不同的分类 Array / Function 也是不同的分类 而 Object 创建出来的对象，是最没有特点的对象（没有什么额外更多的功能，相对比较普通） let x = {} // 等价于 let x = new Object() ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:13:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"类型 vs. 类 「 类型 \u0026 类 」有什么区别 ？ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:14:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"类型 类型是 JS 数据的分类，有 7 种 四基两空一对象 string number boolean symbol null undefined object ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:14:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"类 类是针对于对象的分类，有无数种 Object 创建出来的对象，是最没有特点的对象 只要觉得需要再创建一个分类，就再写一个 构造函数，new 出来新的分类对象 常见的有 Array、Function、Date(日期)、RegExp(正则) 等 ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:14:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"有特色的类 ⭐️ 上面提到 Object 创建的的对象，是最没有特色的类 那什么是有特色的的类？举两个例子：数组对象、函数对象 （在其他语言中，数组、函数可能都不是对象，但在 JS 中，数组/函数 都属于对象） ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:15:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"数组对象 定义一个数组 let arr = [1,2,3] // 简写 let arr = new Array(1,2,3) // 元素为 1,2,3 // arr [1,2,3] let arr = new Array(3) // 长度为 3 // arr [empty×3] ​ 数组对象的自身属性 let arr = [1,2,3] // arr的自身属性有 4 个： '0'/'1'/'2'/'length' 注意，属性名没有数字，只有字符串 属性名：‘0’/‘1’/‘2’ ，都是字符串 灰色属性，是不能被遍历到的：如 length、__proto__ 数组对象的共用属性 共有属性非常多，都存储在数组对象的 __proto__ 中 'push'/'pop'/'shift'/'unshift'/'join' ...... ​ 数组对象 比 普通对象，多一层 原型 let obj = {} let arr = [1,2,3] obj.__proto__ === Object.prototype // true obj.__proto__ === arr.__proto__.__proto__ // true arr.__proto__.__proto__ === Object.prototype // true ​ 调用共有属性时，采用就近原则 在 arr 自身的原型上找到这个属性时，就不会再去 对象原型 上找 arr.toString == arr.__proto__.__proto__.toString // false arr.toString == arr.__proto__.toString // true ​ 各个【共有属性】，用法都在 MDN，基本与其英文原意相关 后面会有单独课程 教这些 API。所谓的 API 就是【数组有哪些函数、对象有哪些函数】 推 push() 方法，将一个或多个元素添加到数的末尾，并返回该数组的新长度。 弹 pop()方法，从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 提档 shift() 方法，从数组中删除第一个元素，并返回该元素的值。 降档 unshift() 方法，将一个或多个元素添加到数组的开头，并返回该数组的新长度。（修改原数组） 联结 join() 方法，将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。 联结 concat() 方法，用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 … let arr = [1,2,3] arr.push(0) // 4 返回数组的新长度 arr // [1,2,3,0] arr.pop() // 0 返回被删除的元素的值 arr // [1,2,3] arr.shift() // 1 返回被删除的元素的值 arr // [2,3] arr.unshift(0) // 3 返回数组的新长度 arr // [0,2,3] arr.join('哈') // \"0哈2哈3\" 直接返回字符串 let arr1 = [1,1], arr2 = [2,2], arr3 = [3,3] arr1.concat(arr2) // [1, 1, 2, 2] arr1.concat(arr2, arr3) // [1, 1, 2, 2, 3, 3] ... ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:15:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"函数对象 定义一个函数 function fn(x,y){return x+y} // 声明函数 fn let fn2 = function fn(x,y){return x+y} // 声明函数 fn，并赋给变量fn2 let fn3 = (x,y) =\u003e x+y let fn4 = new Function('x','y', 'return x+y') // 声明的是匿名函数，并将它赋给 fn4 function fn1(x,y){return 'fn1'} // 声明函数 fn let fn2 = function fn(x,y){return 'fn2'} // 声明函数 fn，并赋给变量fn2 let fn3 = (x,y) =\u003e 'fn3' // 声明函数 fn3 let fn4 = new Function('x','y', 'return `fn4`') // 声明的是匿名函数，并将它赋给 fn4 函数对象自身属性 'name' / 'length' ​ 函数对象共用属性 共有属性非常多，都存储在函数对象的 __proto__ 中 'call' / 'apply' / 'bind' 这三个属性是重点 后面会有单独课程介绍函数 ​ ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:15:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"JS 终极一问：谁构造了ta ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"window 是谁构造的 Window 可以通过 constructor 属性看出构造者 window.constructor === Window // true window.__proto__ === Window.prototype // true ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"window.Object 是谁构造的 window.Function ==因为所有函数都是 window.Function 构造的== window.Object.constructor === window.Function // true window.Object.__proto__ === window.Function.prototype // true ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"window.Function 是谁构造的 window.Function 因为所有函数都是 window.Function 构造的 window.Function.constructor === window.Function // true 自己构造的自己？并不是这样，这是「上帝(浏览器)」的安排 浏览器构造了 Function，然后指定它的构造者是自己 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:16:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"ES6 ：class 语法 💋 JS 构造对象目前有两种方式，一种是用【构造函数+prototype】，一种是用【class】 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"prototype 是过时的 ？ 非常遗憾，下面代码（构造函数）被某些前端认为是过时的 function Square(width){ this.width = width } Square.prototype.getArea = function(){ return this.width * this.width } Square.prototype.getLength = function(){ return this.width * 4 } 学习资料：你可以不会 class，但是一定要学会 prototype ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:1","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"ES6 ：class 语法 class 是用来声明一个类，类是用来创建对象的，不讲究什么内存共用 class Square{ constructor(width){ // constructor中写对象里的属性 this.width = width } getArea(){ // 对象里的函数 return this.width * this.width } getLength(){ // 对象里的函数 return this.width * 4 } } 注意：方法不能写成 getLength: function(){ ... } 这种形式 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:2","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"class 语法引入了更多概念 class Square{ static x = 1 // static表示x属于Square，调用需采用 Square.x 的写法 \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c width = 0 // 初始化 width 的值 // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c constructor(width){ this.width = width } getArea(){ return this.width * this.width } getLength(){ return this.width * 4 } get area2(){ // 只读属性：调用时直接Square.area2就会执行，无需括号 \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c return this.width * this.width } } class 引入更多的语法，这些语法多来自 Java世界 或 c#世界（跟 JS 以前的世界是格格不入的） ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:3","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"用 class 重写 Circle class Circle{ constructor(radius){ this.radius = radius } getArea(){ return Math.pow(this.radius, 2) * Math.PI } getLength(){ return this.radius * 2 * Math.PI } } let circle = new Circle(10) circle.radius circle.getArea() circle.getLength() ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:4","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"用 class 重写 Rectangle class Rectangle{ constructor(width, height){ this.width = width this.height = height } getArea(){ return this.width * this.height } getLength(){ return (this.width + this.height) * 2 } } let rect = neww Rectangle(4,5) rect.width rect.height rect.getArea() rect.getLenght() ​ ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:5","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"易混淆语法 语法1： class Person{ sayHi(name){} } // 等价于 function Person(){} Person.prototype.sayHi = function(name){} 语法2： 注意冒号变成了等于号 class Person{ sayHi = (name)=\u003e{} // 注意，一般我们不在这个语法里使用普通函数，多用箭头函数 } // 等价于 function Person(){ this.sayHi = (name)=\u003e{} } ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:6","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"不要强求完全转换成 ES5 大部分 class 语法都可以转为 ES5 语法，但并不是 100% 能转，有些 class 语法你意思理解就行，不需要强行转换为 ES5。 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:17:7","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"原型好，还是类好？ 都是用来给对象分类的 目前，先推荐用 class 但是 class 的语法知识比较复杂，还需要再多花点时间学习 （关于类和对象的新语法有 页面1，页面2 和 页面3） 原型的知识，上面👆已经全部讲过了 ","date":"2020-09-07","objectID":"/javascript-constructor-prototype-vs-class/:18:0","tags":["JS","原型","class","类"],"title":"JS 对象分类——原型 \u0026 类","uri":"/javascript-constructor-prototype-vs-class/"},{"categories":["JavaScript"],"content":"JS 对象的基本用法","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"「增」「删」「改」「查」「原型」 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:0:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"回顾 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:1:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"七种数据类型 number、string、booleansymbol undefined、null object 四基(本类型)两空一对象 (bigInt) ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:1:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"五个 falsy 值 null、undefined 0、NaN '' （空字符串） ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:1:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"JS 对象 是学习 JS 的三座大山之一 对象（原型） this AJAX ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:2:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"对象 object 对象的基础知识 object ，是第七种数据类型，唯一 一种「复杂类型」 其他六种（numbe、string、boolean、symbol、null、undefined），叫做「简单类型」。因为这六种不包含其他任何东西，而 object 对象包含其他内容 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"定义 无序的数据集合 键值对的集合 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"写法 let 对象名 = { key: value // 属性名/键名 : 属性值 } 对象的写法，与 block（代码块）类似，只是碰巧都有 { } 。 要注意区分 { } 是对象，还是代码块 例 let obj = { 'name': 'sam', 'age': 18 } // 不论'name'/'age'(属性名)是否有引号，它都只能是字符串 let obj = new Object({'name': 'sam'}) // 正规写法 console.log({ 'name': 'sam', 'age': 18 }) // 创建匿名对象 JS 既然可以通过字面量方式创建对象，为什么还要有第二种 new Object() 的方式创建 ? 实际上第二种 new Object() 才是正规创建对象的写法，第一种属于简化版 因为简化了代码，所以通常都是用第一种写法 ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"细节 ==键名是字符串==，不是标识符，可以包含任意字符 只要是字符串就行：空串、空格串、emoji 、数字字符串 … （任何一个 Unicode 能表达的串都 ok ） 标识符 规则：（变量）不能以数字开头 属性名的引号可省略，省略之后需按照标识符的规则命名，特例：允许纯数字的键名 就算引号省略了，键名也还是字符串（重要） 例 var obj1 = { '': 1 } var obj2 = { 2: 123, name:'fff', 'age':12 } var obj3 = { ' ': 2 } var obj4 = { '👍': 'zan' } // Object.keys(对象名) 获取对象中的 key名 组成的数组 Object.keys(obj1) // [\"\"] // 空串也是字符串，合法 Object.keys(obj2) // [\"2\", \"name\", \"age\"] Object.keys(obj3) // [\" \"] Object.keys(obj4) // [\"👍\"] // 所以不论怎么写，key 都是字符串 属性名 每个 key 都是对象的属性名（property） 属性值 每个 value 都是对象的属性值 ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:3","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"奇怪的属性名 所有属性名会自动变成字符串 let obj = { 1: 'a', // \"1\" 3.2: 'b', // \"3.2\" 1e2: true, // \"100\" 1e-2: true, // \"0.01\" .234: true, // \"0.234\" 0xFF: true // \"255\" }; Object.keys(obj) // [\"1\", \"100\", \"255\", \"3.2\", \"0.01\", \"0.234\"] JS 可能会自动换算「属性名」，所以如果不想被自动换算，给属性名加上「引号」即可解决 细节 Object.keys(obj) 可以得到 obj 的所有 key 组成的数组 这个 API 需要会使用 「变量」作属性名 如何用变量做属性名 之前都是用常量做属性名（所有不是变量的都是常量） let p1 = 'name' let obj = { p1 : 'sam'} 这样写，属性名为 'p1' let obj = { [p1] : 'sam' } 这样写，属性名为 'name' （ ES 6 ） let aa = 'xxx' // 想用变量a作为属性名 var obj = { aa: 1111 } // {aa: 1111} var obj = { 'aa': 1111 } // {aa: 1111} var obj = { [aa]: 1111 } // {xxx: 1111} // ES6之后 ES6之前，实现变量作属性名 ↓↓ ，需两行代码实现。ES6之后一行 ↑↑ 即可 let aa = 'xxx' var obj = {} obj[aa] = 1111 console.log(obj) // {xxx: 1111} 对比 不加 的属性名会自动变成字符串 加了 则会当做变量求值 值如果不是字符串，则会自动变成字符串 var obj = { [1+2+3+4]: '十' } console.log(obj) // { 10: \"十\" } Object.keys(obj) // [ \"10\" ] ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:4","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"对象的隐藏属性（原型 💡） 隐藏属性 JS 中，每一个对象 都有一个 隐藏属性 __proto__ 这个隐藏属性，储存着其 共有属性组成的对象的地址 这个共有属性组成的对象，叫做原型 也就是说，隐藏属性 储存着 原型的地址 __proto__ 存储了一个地址，这个地址所代表的内存空间中的对象，叫做原型 / 共有属性 代码示例 var obj = {} obj.toString() // 居然不报错 因为 obj 的隐藏属性对应的对象（原型 / 共有属性）上有 toString() ​ 举个栗子：什么叫共有属性 将共有的属性，提取出来单独存储成一个对象。最大的好处，就是省内存 每次声明一个 chinese 时，无需重复写入：国籍、肤色、发色 … 等 chinese 公共的属性，直接用一个特定属性（–proto–），存储共有属性所在的内存地址即可 var chinese1 = { name: '小兰' } var chinese2 = { name: '小红' } ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:5","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"超纲知识 前面提到，对象中所有的 key 都是字符串 实际上，ES 6 中稍微做了调整：除了字符串，symbol 也能做属性名 let a = Symbol() let obj = { [a]: 'Hello' } 这有什么用呢？ 目前，屁用都没用，很久很久以后可能会有用（方方从没用过） 在学习「迭代」时会用到（但前端不流行迭代，所以根本没机会用） ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:3:6","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"增删改查 「增删改查」对象的属性 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"删除属性 delete 操作符：用于删除对象的某个属性 delete obj.xxx delete obj['xxx'] 作用：删除 obj 的 xxx 属性 请区分「属性值为 undefined」和「不含属性名」 不含属性名 直接删除属性名 var obj = {name: 'sam', age: 18} delete obj.name // 或 delete obj['name'] console.log(obj) // {age: 18} // console.log(obj.name) // undefined 判断是否删除成功 'xxx' in obj === false // 返回 true 说明该属性名已被删除 （不能省略引号） 含有属性名，但是值为 undefined 仅删除属性值，保留属性名 'xxx' in obj \u0026\u0026 obj.xxx === undefined var obj = {name: 'sam', age: 18} obj.name = undefined console.log(obj) // {name: undefined, age: 18} // console.log(obj.name) // undefined 注意 obj.xxx === undefined obj.xxx === undefined 不能断定 ‘xxx’ 是否为 obj 的属性 let obj = {} let obj2 = {x:undefined} obj.x === undefined // true obj.x === undefined // true 所以说 这句话无法判断出 x 到底是不是 obj 的属性 用 in 和 hasOwnProperty 可以判断 let obj = {} let obj2 = {x:undefined} 'x' in obj // false 'x' in obj2 // true obj.hasOwnProperty('x') // false obj2.hasOwnProperty('x') // true 类比 你有没有卫生纸？ A: 没有 // 不含属性名 B: 有，但是没带 // 含有属性名，但是值为 undefined 程序员就是这么严谨 「没有」和「undefined」是两个概念 没有就是没有，undefined 就是 undefined 绝不含糊 需要细心，发现细微的区别 ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"查看所有属性（读属性） 例 var obj = {name: 'sam', age: 18} 查看自身所有属性 无法打印【共有属性 __proto__】 Object.keys(obj) // [\"name\", \"age\"] Object.values(obj) // [\"sam\", 18] Object.entries(obj) // [Array(2), Array(2)] =\u003e 0:[\"name\", \"sam\"] 1:[\"age\", 18] 查看自身+共有属性 dir 指以目录的形式，可以查看到【共有属性 __proto__】 console.dir(obj) // 查看 obj内容 及 共有属性 【推荐】 obj.__proto__ // 也可以直接打印共有属性（但不推荐此法，因为隐藏属性的命名是不固定的，不同浏览器可能规定不同） 或者自己依次用 Object.keys 打印出 obj.__proto__ 判断一个属性是自身的还是共有的 判断一个属性是否是某个对象的属性，可以用 in ，但是 in 无法区分是自身的还是共有的 \"name\" in obj // true \"toString\" in obj // true obj.hasOwnProperty('toString') // false obj.hasOwnProperty('name') // true obj.hasOwnProperty('age') // true ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"原型 原型，就是隐藏属性 所指向的对象 每个对象都有原型 原型里存着对象的共有属性 比如 obj 的原型就是一个对象 obj.__proto__ 存着这个原型对象的地址 这个原型对象里有 toString / constructor / valueOf 等属性 对象的原型也是对象 既然每个对象都有原型，且原型也是对象，那么可以推出：原型上也有原型 所以对象的原型上也有原型 obj = { } 空对象的原型即为所有对象的原型 这个原型包含所有对象的共有属性，是对象的根 这个原型也有原型，是 null 【/nʌl/】 原型为 null 的对象，就是对象的根 console.log(obj.__proto__) // 原型对象（根对象） console.log(obj.__proto__.__proto__) // null 原型上的原型 ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:3","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"查看属性 两种方法查看属性 **中括号语法：obj[‘key’] ** 点语法：obj.key 坑新人语法：obj[key] // 中括号里是变量，【变量 key】 值一般不等于【字符串 ‘key’】 var obj = {name: 'sam', age: 18} obj['name'] // 'sam' obj.name // 'sam' obj[name] // undefined console.log(name) // \"\" window.name = 'age' obj[name] // 18 // 等同于 obj['age'] 变态 obj['na'+'me'] // 'sam' obj[console.log('name')] // name // 先执行log命令，打印内容 // undefined // log 函数的返回值为 undefined，相当于执行 obj[undefined] =\u003e undefined ​ 请优先使用中括号语法 【点语法】会误导你，让你以为 key 不是字符串 等你确定不会弄混两种语法，再改用点语法 obj.name 等价于 obj[‘name’] obj.name 不等价于 obj[name] 简单来说，obj.name 这里的 name 是字符串，而不是变量 let name = ‘sam’ 此时 obj[name] 等价于 obj[‘sam’] ，而不是 obj[‘name’] 和 obj.name ​ 考题 区分变量 name 和 常量字符串 'name' 代码 let list = ['name', 'age', 'gender'] let person = {name:'sam', age:18, gender:'man'} for(let i = 0; i \u003c list.length; i++){ let name = list[i] console.log(person???) } // 使得 person 的所有属性被打印出来 选项 console.log(person.name) ✘ // sam sam sam console.log(person[name]) ✔ // sam 18 man 区分 name 和 ‘name’ 为什么这么重要 因为如果你现在不搞清楚，那么你在学 Vue 的时候，会更加迷惑 ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:4","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"修改或增加属性（写属性） 直接赋值 直接赋值，name 属性已存在，就相当于修改属性值；name 属性不存在，就会新增这个属性，值为 sam let obj = {name: 'sam'} // name 是字符串 obj.name = 'sam' // name 是字符串 ✔ obj['name'] = 'sam' // ✔ obj[name] = 'sam' // 错，因name为变量，值不一定等于'name' obj['na'+'me'] = 'sam' // ✔ let key = 'name'; obj[key] = 'sam' let key = 'name'; obj.key = 'sam' // 错，因为obj.key等价于obj['key']，相当于给obj增加了key属性 值为sam ​ 批量赋值 let obj = {name: 'sam'} Object.assign(obj, {name:'123', age: 18, gender: 'man'}) // name 属性已存在，就相当于修改属性值；name 属性不存在，就会新增这个属性，值为'123' console.log(obj) // {name:'123', age: 18, gender: 'man'} assign ：赋值的意思 Object.assign() ：是 ES6 新出的 API ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:5","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"修改或增加共有属性 JS 特性： 读取时，可以读取到（原型上的）共有属性。 写入时，只写在自己身上，不会影响（原型）共有属性 无法通过自身修改或增加共有属性 原型上的属性，无法通过自身直接修改 let obj = {}, obj2 = {} // 共有 toString 方法 obj.toString = 'xxx' // 只会在改 obj 自身属性，不会覆盖共用的 toString 方法 obj.toString // 'xxx' obj.toString() // 报错 obj.toString is not a function obj2.toString // ƒ toString() { [native code] } 还是在原型上的方法 obj2.toString() // \"[object Object]\" 偏要修改或增加原型上的属性 obj.__proto__.toString = 'xxx' // 不推荐用 __proto__ Object.prototype.toString = 'xxx' console.dir(obj.toString) // obj.__proto__ 存的地址，等价于 window.Object.prototype 存的地址 obj.__proto__ === window.Object.prototype // true 这是 JS 非常危险的特型，一旦修改，会使得原型上的属性非常不可信 —— JS 的脆弱性 一般来说，不要修改原型，会引起很多问题：代码崩溃/异常… ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:6","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"修改隐藏属性 不推荐使用 __proto__ 修改原型 例1 let obj = {name:'sam'} console.log(obj) // {name:\"sam\", __proto__: Object} obj.__proto__ = null console.log(obj) // {name:\"sam\"} 没有proto原型了，变成非常纯净的对象，不能调用任何功能 例2 let person = {name:'sam'} let person2 = {name: 'jack'} let common = {kind: 'human', '国籍': '中国'， hairColor: 'black'} person.__proto__ = common person2.__proto__ = common 上述，使用 __proto__ 直接修改原型，不推荐，性能非常低 ​ 推荐使用 Object.create 修改对象的原型 规范的修改对象的原型，使用 Object.create 【功能：用于指定原型】 var obj = Object.create({name:'sam'}) console.log(obj) // { __proto__:{name:'sam'} } 用法 ↓ let common = {kind: 'human', '国籍': '中国'， hairColor: 'black'} let obj = Object.create(common) // 以common为原型对象，创建obj obj.name = 'sam' // 点方法，挨个添加属性，或 批量修改/添加属性 Object.assign(obj,{ ... }) ... Object.create() 第二个参数，写法比较麻烦 let person = Object.create(common, { name: { value: 'sam' } }) console.log(person) // {name:'sam', __proto__: Object} =\u003e 规范的写法：大概是，要改就一开始就改；别后来再改，如person.__proto__ = common 影响性能 ​ ​ ​ ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:4:7","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"总结 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:0","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"删 delete obj['name'] 'name' in obj // false // in 用于判断某个对象中是否含这个属性，缺点：无法区分是自身的，还是原型上共有的 obj.hasOwnProperty('name') // false // 只有对象自身含有这个属性，才会返回 true ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:1","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"查 Object.keys(obj) console.dir(obj) // 目录形式，详细 obj['name'] obj.name // 记住这里的 name 是字符串 obj[name] // 记住这里的 name 是变量 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:2","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"改 改自身 obj['name'] = 'jack' 批量改自身 Object.assign(obj, {age:18, ...}) 改某个共有属性 obj.__proto__['toString'] = 'xxx' // 强烈不推荐 改某个共有属性 Object.prototype['toString'] = 'xxx' 换原型 obj.__proto__ = common // 强烈不推荐 换原型 let obj = Object.create(common) // 注：所有 proto 代码都是强烈不推荐写的。学习时可以用用，但是工作中不要用 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:3","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"增 基本同上，已有属性则改；没有属性则增。 查：属于读，可以读到原型链 改 和 增：属于写，只能改自身，不能改到原型 ","date":"2020-09-02","objectID":"/javascript-crud-of-object-prototype/:5:4","tags":["JS","增删改查","对象","原型"],"title":"JS 对象的基本用法","uri":"/javascript-crud-of-object-prototype/"},{"categories":["JavaScript"],"content":"JS 的数据类型","date":"2020-08-27","objectID":"/javascript-something-about-data-type/","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"「如何存数字\u0026字符」「JS 的数据类型」「64位浮点数 」「变量声明 var / let / const」「类型转换」 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:0:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数据为什么需要类型 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:1:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数字与字符串 都是一，为什么要分 1 和 '1' 功能不同 数字是数字，字符串是字符串，要严谨 数字能加减乘除，字符串不行 字符串能表示电话号码，数字不行 存储形式不同 JS中，数字 number 是用64位浮点数的形式存储的 JS中，字符串是用类似 UTF8 形式存储的（UCS-2) ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:1:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"如何存数字 进制转二进制即可 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:2:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"二进制 10转2 31变成二进制： 经过一番尝试： 所以31（十进制）= 01111（二进制） 不是套公式吗？程序员从来不套公式 🙃 2转10 100011变成十进制 每一位乘以2的N次方，然后加起来即可 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:2:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"用十六进制表示二进制 为什么用十六进制，因为二进制写起来太慢了：011110001011010 记住 8 4 2 1 对应 X X X X 从右往左每四位改写成一位：011110001011010 得到 3，12，5，10； 16进制中，把大于9的数字改为ABCDEF 0123456789 A B C D E F 10 11 12 13 14 15 于是得到 3C5A，你也可以用计算器的程序员模式 HEX表示16进制，BIN表示2进制 OCT表示8进制，DEC表示10进制 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:2:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"如何存字符 转成数字即可（但字符有几万个，数字只有0-9），解决办法就是把所有字符都编号 注意，\"1\" 不能用 1 来表示 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"用 0 ~ 127 表示所有符号 （2^7^ = 128） 0 表示结束字符 10 表示换行 13 表示回车 32 表示空格 33 到 47 表示标点 48 到 57 表示数字符号（存 0 用 48 表示） 65 到 90 表示大写字母（存 A 用 65 表示） 97 到 122 表示小写字母（存 a 用 97 表示） 127 表示删除键 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"中文怎么表示？ 1990-1995年左右，中国开始有人买得起电脑了 简单，还是编号 中国国家标准局来编，名称为「国标23121」 ​ 用 0000 ~ FFFF 表示汉字 用两个字节，表示一个汉字（一个字节是8个0/1位） 一个 16 进制数是4个0/1位 FFFF 就是 4x4=16 位，也就是两个字节 最多收录 2^16=65536 个字符 但只收录了6000多常用汉字、西文字母和日文假名（没有收录生僻字、繁体字、韩文…） 「你」的 GB2312 编号为 C4E3 「牛」的 GB2312 编号为 C5A3 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"生僻字 随着计算机的普及，政府、学习开始采用计算机管理录入信息 中国人的名字里有生僻字！ 例 李瓛 =\u003e 李* 陶喆 =\u003e 陶吉吉 怎么表示生僻字、繁体字、韩文呢，之前的忘了编进去 微软出手了，推出了一个国标扩展，简称 GBK ​ GBK 国标扩 含 21886 个汉字和图形符号 收录了中日韩使用的几乎所有汉字 完全兼容 GB2312 依然使用 16 位（两字节） 后来国标局推出 GB18030 想取代 GBK 但 GB18030 不兼容 GB2312，导致没人使用 GB18030，而是一直使用国标扩 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"泰文、藏文 继续编号，这回一次性解决全世界需求 —— 推出 万国码 Unicode 字符集 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"万国码 Unicode 优点 已收录13万字符（大于16位），全世界通用 以后还会继续扩充，不会停止 最新版(2019)只添加了一个字 —— 令和的合体字 （日本的新元号） 日文有很多合体字。如，「株式会社」被合成一个字；元号也都被合成一个字 缺点 两个字节不够用，每个字符要用三个及以上字节 这样所有文件都扩大50%，不划算 那怎么办？ 虽然用Unicode，但存的时候偷懒，这样行不行 UTF-8 就被发明出来了，还真行 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"UTF-8 Unicode 是字符集，UTF-8是编码形式 鸡贼的存法 英文用 1 个字节存，中文用 3 个字节存 存储「a」 a 对应的 Unicode 编号为 97，十六进制为61 Unicode 直接存：000000000000000001100001 UTF-8 偷懒存法：01100001 UTF-8 使得所有字母，从三字节变一字节，比 GBK 还省 存储「你」 你 对应的 Unicode 编号为 4F60（16位） Unicode 直接存：000000000100111101100000 UTF-8 偷懒存法：111001001011110110100000 还是三字节，没有省，但是字母都能省一点 UTF-8 中的 8 的意思是 最少可用 8 位，存一个字符。（可能用 8/16/24 位存一个字符） UTF-8 的规则 这一块看不懂就跳过，反正不考。记住去餐馆排队的比喻即可 以「你a」为例 11100100 10111101 10100000 01100001 如何知道上述内容表示什么字符？ 读 8 位信息 11100100 发现开头有3个1，就认为这个字符有3个八位 于是再往后读两个 8 位信息 10111101 10100000 10 表示当前这8位是跟着前面一起的 前面的 10 不要，其他合起来，得 0100 111101 100000 前面补8个0，这就还原为 Unicode 的「你」了： 000000000100111101100000 再读 8 位信息 01100001 发现开头是 0，就认为这个字符只占 8 位 前面补16个0，这就还原为 Unicode 的「a」 了： 000000000000000001100001 上面 4 个字节，存了两个字符。UTF-8 平均每个字符需要 2 个字节 Unicode 每个字符至少占 3 个字节，UTF-8 的存储方法更节省空间 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:6","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"终于搞清如何存字符了 全世界的字符，都是先把字符进行编号，然后存下编号（10进制变2进制） ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:3:7","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数字1 和 字符1 的区别 功能不同：数字1 可以进行运算，加减乘除… （ 字符只能相加 =\u003e 拼接字符 ） 存储形式不同：数字是转为二进制直接存储，字符需要经过编码变成数字再存储 数字1 ，最终存的是 1 字符1 ，最终存的是 49 ​ 既然字符也是存的数字，那么计算机怎么知道存的是字符还是数字呢？ 答：计算机并不知道这段0/1是字符还是数字。 但计算机可以通过看文件格式判断，如果是 .txt 那就全都是字符串，如果在 Excel 中存一个1 ，就是数字1 计算机并不知道用户存的0/1到底什么意思，但可以通过其他辅助信息得知（如后缀）或者其他方式约定（比如在文件开头约定：0表示数字，1表示字符串，2表示布尔值…这种方式）。 http 只支持字符串，在 html 中写一个1，就是字符串1 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:4:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"JS 中的数据类型 💡 7 种（大小写无所谓） 数字 number 字符串 string 布尔 bool 符号 symbol（JS 从 ruby 抄的，基本没人用） 空 undefined 空 null 对象 object 总结：四基两空一对象 bigint（新增第8种） 以下不是数据类型 数组、函数、日期、正则… 它们都是特殊的对象 object，所以它们都属于object ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"数字 number number 是由64位(0/1)浮点数组成的 JS 的 number 全都是以小数（浮点数）的形式存储的，没有单独的整数 写法 整数写法 1 小数写法 0.1 科学计数法 1.23e4 （1.23×10^4^ ） 八进制写法（用得少） 0 或 00 或 0o 开头，就是 8进制 0123 或 00123 或 0o123 十六进制写法 0x3F 或 0X3F （用得少） 0x 或 0X 开头 二进制写法 0b11 或 0B11（用得少） 0b 或 0B 开头 特殊值 正0和负0 0分三种：0、+0、-0 都是 0，基本没什么区别 只在一种情况有区别（要严谨） 1/0 或 1/+0 =\u003e Infinity 1/-0 =\u003e -Infinity 无穷大 Infinity、+Infinity、-Infinity 无法表示的数字 NaN (Not a Number) 0/0 =\u003e NaN 但 NaN 仍是一个数字 NaN 永远不会和另一个 NaN 相等 NaN == NaN // false 64位浮点数 网道教程 JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 1 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的“位运算”部分。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 0.1 + 0.2 === 0.3 // false 0.3 / 0.1 // 2.9999999999999996 (0.3 - 0.2) === (0.2 - 0.1) // false 根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 … 为什么说【 number 是由 64位(0/1)浮点数组成的】 ？ （看↓图）一共（1+11+52）64 位，就可以表示 js 中的所有数字，包括小数、NaN … JS数字的存储形式 浮点就是浮动的点，意思就是小数点会乱动 123.456 可以表示为 1.23456 × 10^2^ ，也可以表示为 12345.6 × 10^-2^（0.01） 如果小数点可以浮动，那就是浮点数 也有定点数，就是指 有效数位、指数数位 都是固定的（少用） ​ ​ 64位存储一个 number 符号占1位 浮点数的第一位，0表示正号，1表示负号。「+0」的第一位是 0，「-0」的第一位是 1 指数占11位 指的是 10 的 n 次方，把这个 n 存到这11位里（11位可以存2048，因为有正负所以范围是 -1023~1024） 有效数字占52位（开头的 1. 省略） 10进制的小数，第一位永远可以为 1.xxx ，如 0.123 =\u003e 1.23 × 10^-1^ ​ 例：存 0.5 先将0.5转为二进制（看0.5是多少个二分之一，凑）=\u003e 1.0 × 2^-1^ 0.5是1个二分之一，所以 0.5 的二进制是 0.1 0.1存成64位形式 =\u003e 1.0 × 2^-1^ 正：0，负：1 指数部分（有正负） 有效数字（省掉第一个1.） 0 -1 0 ​ 例：存 0.625 看0.625有多少个二分之一（转为二进制，凑一下） 0.625 = 0.5 + 0.125 = 1/2 + 1/8 = 1×2^-1^ + 1×2^-3^ 所以 0.625 表示成 二进制就是 0.101 0.101 ↑ ↑ -1 -3 0.101存成 64位形式 =\u003e 1.01 × 2^-1^ 正：0，负：1 指数部分（有正负） 有效数字（省掉第一个1.） 0 -1 01 ​ 范围和精度 范围（忽略符号位） 指数拉满、有效数字拉满，得到最大二进制数字 Number.MAX_VALUE: 1.7976931348623157e+308 指数负方向拉满、有效数字最小 1，得到最小值 Number.MIN_VALUE: 5e-324 精度（有效数字） 最多只能到 52 + 1 个二进制位表示有效数字 2^53^ 对应的十进制是 9 后面 15 个零 所以 15 位有效数字都能精确表示 16 位有效数字如果小于 90 开头，也能精确表示 9110000000000001 就存不下来 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"字符串 string 字符串 string 在 JS 中，每个字符占两个字节（定长）。是阉割版的 UTF8。 因为 1995 年发布 JS ，当时 Unicode 并未流行，甚至还没有推出第一个可用版本。 写法 - 单引号 '你好' - 双引号 \"你好\" - 反引号 `你好` (ES6) 注意 引号不属于字符串的一部分，就像书名号不属于书名的一部分一样 如果要在单引号里面包含单引号怎么办? 错误写法 'it's ok' JS 引擎会认为 'it' 就结束了，后面的看不懂，可能就会报错 Chrome 中这种写法如果不报错，那就是 Chrome 的误导💩🤬 正确写法 'it\\'s ok' // 这就是转义 \"it's ok\" `it's ok` ​ 转义 用另一种写法表示你想要的东西 \\' 表示 ' \\\" 表示 \" \\n 表示 换行 \\r 表示 回车 \\t 表示 tab制表符 \\\\ 表示 \\ \\uFFFF 表示对应的 Unicode 字符 \\xFF 表示前256个 Unicode 字符（16进制） 例 '\\u4f60' =\u003e \"你\" '\\x31' =\u003e \"1\" （10进制的49转16进制为 31） '\\x32' =\u003e \"2\" '\\x33' =\u003e \"3\" ​ 多行字符串 如果你想要在字符串里回车 let s=`这样是 可以的 用【反引号】很容易做到` 以前没有反引号的时候 写起来很麻烦，是比较古老的知识，想了解可以看阮一峰的网道教程 ​ 字符串的属性 “ 等等，对象才有属性，为什么字符串也有属性 ” 记住一点：只有对象才有属性，字符串、数字、布尔是没有属性这么一说的 那为什么这里讲「字符串的属性」？（源于对象，学完对象才能解答） 字符串的长度 string.length '123'.length // 3 '\\n\\t\\r'.length // 3 （1个换行、1个tab、1个回车） '\\\\\\\\\\\\'.length // 3 （2个反斜杠表示1个\\） ''.length // 0 （空字符串） ' '.length // 1 （1个空格字符串） ' '.length // 2 （2个空格字符串） 字符串的下标 通过下标读取字符 string[index] let s='hello' s[0] // \"h\" 注意 index 从0开始 s[0]是第一个字符 注意 index 不到 length 一个字符串的最大 index 为 length - 1 let s='hello' s[5] // undefined 居然不报错 s[4] // 'o' ​ base64 转码 window.btoa 正常字符串转为Base64编码的字符串 window.atob Base64 编码的字符串转为原来的字符串 一般用来隐藏招聘启事里的简历 邮箱：YWJjZGVmZ0BnbWFpbC5jb20= 编码 window.btoa('abcdefg@gmail.com') // YWJjZGVmZ0BnbWFpbC5jb20= 解码 window.atob('YWJjZGVmZ0BnbWFpbC5jb20=') // abcdefg@gmail.com 有时候也用来自欺欺人 所谓的「加密」，也就能骗过一部分外行 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"布尔 boolean 真或假 只有两个值：true / false （全都小写） 下列运算符会得到 bool 值 否定运算 !value 相等运算 1==2、1!=2、3===4、3!==4 比较运算 1\u003e2、1\u003e=2、3\u003c4、3\u003c=4 if 配 bool if 语句常常需要判断真假 if(value){...} else {...} 问题来了 如果 value 是 bool 值还好说 如果 value 不是 bool 值咋办，谁真谁假 1 是真还是假，0 是真还是假 '1' 是真还是假，'0' 是真还是假 五个 falsy 值 falsy 就是相当于 false，但又不是 false 的值 分别是 undefined null 0 NaN '' // ''和' '不是一个玩意再次声明，请保持严谨 整个 JavaScript 中，除了上述 5 个 falsy 值 和 false 本身（6个假值）之外 其他任何值都是【真值】，包括数组、函数、对象… ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"undefined 和 null 两种空类型，空空如也 为什么有两个空 这就是 JS 的原创（💩）之处 其他任何一种语言，都只有一个空类型 区别 没有本质区别 细节一 如果一个变量声明了，但没有赋值，那么默认值就是 undefined，而不是 null 细节二 如果一个函数，没有写 return，那么默认 return undefined，而不是 null 细节三 前端程序员习惯上，把非对象的空值写为 undefined，把对象的空值写为 null 但仅仅是习惯上而已 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"symbol 符号 不怎么常用的数据类型（大概率完全不会用到） 直接看文章吧 更详细更权威的知识参考下面的自学链接。 自学链接： MDN： Symbol - JavaScript 阮一峰：ECMAScript 6入门 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"bigint （2020.6 新增） 2020 年 6 月 JS 新增了一种类型：bigint 关于 bigint 的详细介绍，请看 MDN。 目前 bigint 用得很少。面试也基本不考，工作中也较少用到。因为太新了。 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:5:6","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"变量声明 var / let / const ⭐️ 强烈推荐阅读：《我用了两个月的时间才理解 let》 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"三种声明方式 var a=1 let a=1 const a=1 a=1 区别 var 是过时的、不好用的方式 let 是新的，更合理的方式 const 是声明时必须赋值，且不能再改的方式 最后这种方式是错误的，不准这样声明 var 变量提升 押题时再讲，有兴趣可以提前看网道教程 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"var 声明 直接跳过 我们写代码不用 var 面试押题前单独讲解 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"let 声明 规则（特点） 遵循块作用域，即：使用范围不能超出 { } 不能重复申明 可以赋值，也可以不赋值 必须先声明，再使用。否则报错 全局声明的 let 变量，不会变成 window 的属性 for 循环配合 let 有奇效 例 1 // 遵循块作用域，使用范围不能超出{} { let b=1 // let声明的b只能作用在声明的这个{}里面 console.log(b) // 1 } console.log(b) // Uncaught ReferenceError: b is not defined // 报错：b未被定义 例 2 let a=1 let a=2 // Uncaught SyntaxError: Identifier 'a' has already been declared // 报错：标识符a已被声明 不能重复声明：在同一个作用域，只能有一个 a let a=1 { let a=2 // 这样是可以的。因为a是在{}中的，与{}块外面的a不算重复声明 } 例 3 let a // 声明时可以赋值，也可以不赋值 console.log(a) // undefined let b = true console.log(b) // true 例 4 // 必须先声明，再使用，否则报错 { console.log(b) // Uncaught ReferenceError: Cannot access 'b' before initialization let b=1 } // 报错：不能访问 b 在初始化之前 例 5 // 全局声明的 let 变量，不会变成 window 的属性 let abc='abc' console.log(window.abc) // undefined var abc = 'abc' console.log(window.abc) // 'abc' // 这其实是 var 的 bug 。为什么声明变量会变成 window 上的属性？这是var强加的 // let就改掉这个bug了，let就是单纯声明变量，不做多余操作 例 6 for(var i=0;i\u003c5;i++){ setTimeout(()=\u003e console.log(i),0) // 5 5 5 5 5 } for(let i=0;i\u003c5;i++){ setTimeout(()=\u003e console.log(i),0) // 0 1 2 3 4 } ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"const 声明 规则 跟 let 相同的点 遵循 { } 块作用域 不能重复声明 先声明后使用 不会变成 window 属性 跟 let 只有一条不同：声明时就要赋值，赋值后不能改 const 声明的是一个 只读变量，也叫做「常量」 例 // const声明变量，声明时不赋值，就会报错 const i // Uncaught SyntaxError: Missing initializer in const declaration // 报错：const声明中缺少初始化 // 声明后，又重新赋值，会报错 const i=100 i=101 // Uncaught TypeError: Assignment to constant variable // 报错：赋值给常量 // for循环中，修改变量值，会报错 for(const i=2;i\u003c5;i++){ // Uncaught TypeError: Assignment to constant variable // 报错：赋值给常量 setTimeout(()=\u003e console.log(i),0) // 2 } ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"指定值，同时也指定了类型 变量声明 指定了值，同时也指定了类型 但是值和类型都可以随意变化 var a=1 // number类型 a=2 a='字符串' ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:6:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"name 和 ‘name’ 的区别 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:7:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"name 是变量 变量，意味着「值」「类型」可变，可能是 ‘name’，也可能是 ‘hello’ 变量，存在内存的「不知道什么区」 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:7:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"‘name’ 是字符串、常量 「常量」就是不变量 ‘name’ 只能是 ‘name’ ，不能是其他值 字符串，存在「Stack 区」 ​ ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:7:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"类型转换 ⚡️ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:0","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"number =\u003e string String(n) // 前端通常不会用这种写法，太麻烦了 n + '' // 前端都是用这种 例 var n=1 console.log(String(n)) // 1 [黑色字符串] console.log(n+'') // 1 [黑色字符串] console.log(''+n) // 1 [黑色字符串] console.log(n) // 1 [蓝色数字] JS bug String(1000000) // \"1000000\" String(1000000000000) // \"1000000000000\" String(1000000000000000000000000) // \"1e+24\" （0变多，就变成科学计数法的字符串了） // 后来JS补救了：即使0变多，也不会转成科学计数法 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:1","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"string =\u003e number Number(s) parseInt(s) / parseFloat(s) s-0 / +s // 前端都是用这种最省事的写法 例 var s='123' console.log(Number(s)) // 123 [蓝色数字] console.log(parseInt(s)) // 123 [蓝色数字] 虽然显示的是整数，实际上是小数，number只有一种64位浮点数 console.log(parseFloat(s)) // 123 [蓝色数字] console.log(s-0) // 123 [蓝色数字] console.log(+s) // 123 [蓝色数字] console.log(s) // 123 [黑色字符串] JS bug // ES6之前，parseInt()自动识别：看到0开头就认为是8进制 parseInt('0123') // 83 (8进制的0123转为10进制 =\u003e 83) // 1*8^2+2*8^1+3*8^0=83 // ES6之后，parseInt()默认就是10进制 parseInt('0123') // 123 ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:2","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"x =\u003e bool Boolean(x) !!x 例 // 把1/0变成布尔类型 Boolean(1) // true Boolean(0) // false // 上述方法，前端从来不用，太麻烦 // 前端直接用 !! （两次取反） 这种方法因为比较装B，所以在前端界比较流行 !!1 // true !!'aaa' // true （ !!aaa 不加引号就是变量，这里变量需要先声明才能使用） var obj={}; !!obj // true function foo(){}; !!foo // true !!0 // false !!NaN // false !!'' // false !!null // false !!undefined // false !!abc // abc is not defined var abc !!abc // false var abc=123 !!abc // true ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:3","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"x =\u003e string String(x) x.toString() 例 true.toString() // \"true\" false.toString() // \"false\" JS bug 1.toString() // 报错，js读到「1.」认为这是个小数，后面应该跟着数字，结果读到「t」，就直接报错 // 解决办法 (1).toString() // \"1\" 1 .toString() // \"1\" 1..toString() // \"1\" // 合法。js读到「1.」认为是 1.0 1.0.toString() // \"1\" ​ ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:4","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"补充：JS 秘密花园 Google 搜索 「JS 秘密花园」，里面就讲了 JS 的各种奇葩事情 ","date":"2020-08-27","objectID":"/javascript-something-about-data-type/:8:5","tags":["存储","进制","数据类型","声明","转换"],"title":"JS 的数据类型🧐","uri":"/javascript-something-about-data-type/"},{"categories":["JavaScript"],"content":"JS 的基本语法","date":"2020-08-24","objectID":"/javascript-basic-syntax/","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"内容包括「什么是表达式和语句」「标识符的规则」「 if else 语句」「 while for 语句」「 label 」 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:0:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"推荐书籍 适合入门《网道 JavaScript 教程》 适合进阶《你不知道的 JavaScript（上卷）》 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:1:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"JS 语法 ⭐️ 开始学习 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"表达式与语句 表达式 1+2 表达式的值为 3 add(1,2) 表达式的值为函数的返回值 console.log 表达式的值为函数本身（因为没加括号） console.log(3) 表达式的值为多少？（面试) 表达式的值就是函数的返回值 ，log函数的返回值为 undefined 所以 console.log(3) 表达式的值为 undefined 语句 var a=1 是一个语句 二者的区别 表达式一般都有值，语句可能有也可能没有 语句一般会改变环境（声明、赋值） 上面两句话并不是绝对的 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"大小写敏感 不要写错 var a 和 var A 是不同的 object 和 Object 是不同的 function 和 Function 是不同的 具体含义后面说 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"空格 大部分空格没有实际意义 var a = 1 和 var a=1 没有区别 加回车，大部分时候也不影响 只有一个地方不能加回车，那就是 return 后面 return 后面不加东西，js 会自动补充成 return undefined function fn(){ return 3 } function fn(){ return [undefined] // return 和 3 之间加了一个回车，js会自动补充为 return undefined 3 } 唯独 return 后面不能加回车，其他多离谱的回车都没问题 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:3","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"标识符 规则 第一个字符，可以是 Unicode 字母 / $ / _ / 中文 后面的字符，除了上面所说，还可以有数字 注意，首位不能是数字 var 9$ Uncaught SyntaxError: Invalid or unexpected token // SyntaxError意为语法错误，token理解成字符串 变量名是标识符 以下都是合法的标识符用法 var _ = 1 var $ = 2 var ______= 6 var 你好 = 'hi' 其他标识符用到再说 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:4","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"注释 谣言：“ 写代码要多写注释。” 注释，分为：好的注释、不好的注释 不好的注释 不好的注释：告诉别人我写了什么 把代码翻译成中文 可能埋没了重要的注释。有用的信息和噪音的比例（信噪比）要低 过时的注释 发泄不满的注释 好的注释 好的注释：告诉别人为什么我要这么写 踩坑注解 为什么代码会写得这么奇怪，遇到什么 bug 遇到某个 bug，代码非得这么奇怪的写，才能避开这个 bug（这种也需要注释出来） ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:5","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"区块 block 把代码包在一起 { let a=1 let b=2 } 常常与 if / for / while 合用 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:2:6","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"if 语句 如果 … 那么 … ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 if(表达式){语句1}else{语句2} { } 在语句只有一句的时候可以省略，不建议这样做 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"变态情况 (表达式) 里可以非常变态，如 a=1 const a=2 if(a=1){ console.log('a是1') // 最终打印这句，因为 = 是赋值，=== 才是判断是否相等 }else{ console.1og('a不是1') } 语句1 里可以非常变态，如嵌套的 if else 语句2 里可以非常变态，如嵌套的 if else 缩进也可以很变态，如面试题常常下套 const a=1 if(a===2) console.log('a') console.log('a等于2') 上述代码执行结果为：因为不写 { } 时，只默认第一个语句是跟随 if 条件的，有一个**无形的 { } **括住了第一句，相当于下面效果 const a=1 if(a===2) { console.log('a') } console.log('a等于2') 注：js 中是没有【行】的概念，即使两句写在一行，结果不变，仍是只括住第一个语句 const a=1 if(a===2) { console.log('a'); } console.log('a等于2') 如果用 逗号分隔呢？ const a=1 if(a===2) { console.log('a'), console.log('a等于2') } console.log('a???') 逗号，表示这句话没结束。所以默认两个 console 就变成一个语句了（效果如上） 分号；表示这句话结束了。 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"使用最没有歧义的写法 最推荐使用的写法 永远不要省略花括号 { }，即使只有一个语句。这是最不会产生歧义的写法 if(表达式){ 语句 }else if(表达式){ 语句 }else{ 语句 } 次推荐使用的写法 该写法，只在函数里有用 基于函数 return 的特点：执行 return ，函数就结束了，不再往下执行 function fn(){ if(表达式){ return 表达式 } if(表达式){ return 表达式 } return 表达式 } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:3:3","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"switch 语句 if…else…升级版 JS 的 switch 语句设计的不算精致，但确实在某些情况时，比 if…else… 好用 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:4:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 switch(fruit){ case \"banana\"： //... break； case \"apple\": //... break； default: //... } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:4:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"break **大部分时候，省略 break 你就完蛋了 ** 当条件符合 banana 时，执行某些语句 … ，遇到 break 跳出 switch 如果没有 break，就会向下跳过case 'apple'，直接执行 apple 的语句 … 看起来很鸡肋 少部分时候，可以利用 break 最早为什么这么设计 break 呢？ 是为了方便「 满足多个条件（case）时 」的判断 如下，case 1 可以默认贯穿到 case 3 （初衷是好的） ​ Swift 的 switch case 语句设计，完爆 JS 的 switch case （apple 出的语言） 执行完一个 case，默认跳出，无需 break 多条件判断：可以直接在一个 case 下写多个条件句 ，无需去掉 break 来表示贯穿 综上，JS 出现的太早了，没有抄到一个好的 switch case switch some value to consider { case value 1: respond to value 1 case value 2, value 3: respond to value 2 or 3 default: otherwise, do something else } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:4:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"问号冒号（三元）表达式 表达式1 ? 表达式2 : 表达式3 表达式 最简单的 if…else… 的写法，能用问号冒号就不用 if…else… // 求两个数的最大值 function max(a,b){ if(a\u003eb) return a; else return b; } function max(a,b){ return a\u003eb ? a: b } // 求绝对值 function abs(n){ return n\u003e0 ? n: -n } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:5:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"\u0026\u0026 短路逻辑 与运算 A \u0026\u0026 B \u0026\u0026 C \u0026\u0026 D 取第一个假值，后面就不看了 如果ABC都为真，就取 D。 一般整句表达式的值，不会出现取 true / false，而是取 ABCD 中的一个 只要整个表达式中，有一个是假，整个式子就是假 a\u0026\u0026b if(a){ // 理解：a\u0026\u0026b 等价于，如果a是真，就执行b，否则就什么都不执行 b }else{ } 例 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e5 \u0026\u0026 5 false 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e2 \u0026\u0026 5 5 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e2 \u0026\u0026 console.log('前面全对了') 前面全对了 3\u003e2 \u0026\u0026 2\u003e1 \u0026\u0026 4\u003e2 \u0026\u0026 5\u003c0 false 例 if(window.f1){ console.log('f1存在') } // 上下效果等价：如果 window.f1为 true ，就会执行 conosole.log('f1存在') window.f1 \u0026\u0026 conosole.log('f1存在') 前端中，如果能写成 \u0026\u0026 的语句，就不写 if…else… 语句 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:6:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"最常见的用法 fn \u0026\u0026 fn() // 如果 fn 存在就执行 fn 例 console \u0026\u0026 console.log \u0026\u0026 console.log('hi') // 如果console存在，就判断console.log是否存在，也存在，就执行打印 hi /* 这么写有什么意义？ 因为 IE 没有 console，如果用 IE 就不执行 console，不然 IE 会报错 */ ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:6:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"|| 短路逻辑 或运算 A || B || C || D 取第一个真值，后面就都不看了。 如果ABC都为假，就取 D 一般整句表达式的值，不会出现取 true / false，而是取 ABCD 中的一个 只要整个表达式中，有一个是真，整个式子就是 真 a||b if(!a){ // 理解：a||b 等价于，如果a不是真，就执行b，否则就什么都不执行 b }else{ } 如果能写成 || 的语句，就不写 if…else… ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:7:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"最常见的用法 例：前端中经常有一个种写法 a = a || 100 // 理解：如果a存在就什么都不做，否则 a=100 if(a){ a = a // 自己赋给自己，相当于什么都不做 }else{ a = 100 // 保底值 } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:7:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"总结：条件语句 if … else… if…else…的逻辑是最常用的，但是很多情况并不使用它。代码简短时，会用更简便的代码替代这种写法 switch case 不能少了 break A ? B : C 相当常用（A若为真，执行B，A若为假，执行C） A \u0026\u0026 B 相当常用，举例：fn \u0026\u0026 fn() （ fn 存在就执行 fn ） A || B 相当常用，举例： A = A || B （A 存在时就什么都不执行，A 不存在时 B 就是 A 的保底值） ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:8:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"while 循环 用的不多 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 while (表达式) { 语句 } 判断表达式的真假 当表达式为真，执行语句，执行完再判断表达式的真假 直到遇到表达式为假，跳出循环，执行后面的语句 var a = 1 // 初始化 while(a !== 10){ // 判断条件 console.log(a) // 循环体 a = a+1 // 增长(为最终能跳出循环) } 共需要四部分： 1. 初始化 2. 判断条件 3. 循环体 4. 增长 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"其他 do … while 用得不多，自行了解 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"while 变态情况：死循环 while(a!==1){ console.log(a) a = a + 0.1 } 原因：浮点数不精确，导致死循环 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:9:3","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"for 循环 for循环 是 while循环 的语法糖 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法糖 for 是 while 循环的方便写法 写 while 时需要四部分： 1. 初始化 2. 判断条件 3. 循环体 4. 增长 for 将 while 的写法升级、整合，如下 语句1 是用来初始化的 表达式2 是判断条件 语句3 是自增 循环体 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 for(语句1;表达式2;语句3){ 循环体 } 先执行语句1 然后判断表达式2 如果为真，执行循环体，然后再执行语句3 如果为假，直接退出循环，执行后面的语句 例 for(var i=0;i\u003c5;i++){ console.log(i) // 0 1 2 3 4 } // i 5 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"变态 for(var i=0;i\u003c5;i++){ setTimeout(()=\u003e{ console.log(i) // 5 5 5 5 5 // console.log(i + '随机数' + Math.random()) },0) } // i 5 9 是 Chrome 的 bug。 5个5是正解。 每轮循环触发 setTimeout 相当于设置一个闹钟命令：过一会再执行 setTimeout 中的语句。而过一会之后，for循环已经走完，i 变为 5。然后闹钟到点，依次执行每轮触发的 setTimeout 中的语句，也就是执行 5轮 console.log( i ) ，就会打印 5 个 5 解决 把 var 替换成 let for(let i=0;i\u003c5;i++){ setTimeout(()=\u003e{ console.log(i) // 0 1 2 3 4 },0) } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:3","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法变形 for(语句1;表达式2;语句3){ 循环体 } 省略 语句 1 ，可在 for 循环外面定义变量 let i = 0 for(; i\u003c5 ; i++){ console.log(i) // 0 1 2 3 4 } 省略 表达式 2 ，会进入死循环 let i = 0 for(; ; i++){ console.log(i) // 0 1 2 3 4 5 6... } 省略 语句 2 \u0026 3 ，会进入死循环 let i = 0 for(; ; ){ console.log(i) // 0 0 0 0 0 0 0... } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:4","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"break 和 continue break 退出所有循环 continue 退出当前一次循环 for(var i=0;i\u003c10;i++){ if(i%2===1){ // 遇到奇数轮次，退出整个for循环 break } } console.log(i) // 1 for(var i=0;i\u003c10;i++){ if(i%2===1){ // 遇到奇数轮次，跳过当次循环 continue }else{ console.log(i) // 0 2 4 6 8 } } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:10:5","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"label 语法 用的很少，面试会考（概率5%） 这个知识点，除了用来做面试题之外，毫无用处 ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:11:0","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"语法 label 语法：在任何情况下，写一个[标识符](# 标识符)，后面写一个代码块 { }（通常包含多句代码），或一句代码 代码块 foo: { console.log(1); break foo; // 跳出foo这个代码块 console.log('本行不会输出') } console.log(2); 一句代码 foo: console.log(2) ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:11:1","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"面试 1 { foo: 1 } 2 foo: 1 // 表示代码块只有一行，叫做 1 console.log(2); 3 { foo: 1 // 一个代码块，第一行是一个标签，标签内容是 1，没有什么实际意义 console.log(2); } 问上面是什么 答： 是一个代码块（属于 label 语法），里面有一个标签 foo，语句就是一个 1 为什么不是一个对象？ 答：如果写成下面形式，a 就是对象了 var a = { foo: 1 } 如果单纯写一个代码块（如下），那就是一个 label，语句为 1 { foo: 1 } ","date":"2020-08-24","objectID":"/javascript-basic-syntax/:11:2","tags":["JavaScript","语法"],"title":"JS 的基本语法🤓","uri":"/javascript-basic-syntax/"},{"categories":["JavaScript"],"content":"JS 的历史","date":"2020-08-12","objectID":"/javascript-history/","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"简单了解「学 JS 的基本要求」，重点了解「JS 的诞生与历史」 ​ ","date":"2020-08-12","objectID":"/javascript-history/:0:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"一些链接 《Code Rush》纪录片，记录了 Firefox 开源的过程，里面有 JS 之父的采访 Chrome 的广告，让你了解 Chrome 有多快 淘宝天猫不再支持 IE 6/7 淘宝天猫不再支持 IE 8 百度指数 【JavaScript 诞生】相关文章： JavaScript 的历史 JavaScript 诞生记⭐ JavaScript 的10个设计缺陷 ​ ","date":"2020-08-12","objectID":"/javascript-history/:1:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"前端的门槛 从 JavaScript 开始，你需要绞尽脑汁了 ​ ","date":"2020-08-12","objectID":"/javascript-history/:2:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"学 JS 的基本要求 ","date":"2020-08-12","objectID":"/javascript-history/:3:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"软要求 对大脑的要求 一、逻辑能力 逻辑分很多种：抽象逻辑、符号逻辑、三段论逻辑（最常用）… 三段论逻辑 示例 JS的数据类型有 number / string / null / undefined / bool / symbol / object 【大前提】 JS的函数不是 number / string / null / undefined / bool / symbol 中的任意一种 所以，JS的函数是object 【根据前两句话，能推出第三句】 好处 写代码基本就是在编写逻辑 ​ 二、质疑自己的能力 程序员不要相信人类，包括你自己 质疑自己、推翻自己 出现 bug ，先质疑自己、再质疑机器 大脑中有6个知识点，通过这6个知识点，写出一个bug，可能某个知识点记错了，不要纠结，不要认死理，懂得质疑和推翻自己。直接把错误的知识点从大脑中擦掉，灌入正确的知识点，来更新你的知识 回想一下 你犯了多少错误 拼错单词 多写了空格、少写了空格 把 O 看成 0，把 0 写成 O 把 iOS 写成 IOS 或者 ios 这不是粗心大意，这是人类不可克服的问题，通过 double check 可以缓解 正着核对一遍，再反着核对一遍 ​ 三、抽象思维 高级程序员必备能力 什么是抽象能力 举例 你订了一份报纸 你关注了偶像明星蔡徐坤的微博 你用JS监听了一个按钮的点击事件 对程序员来说，这三件事是一件事，拥有共同的模式：发布订阅模式。 这就是抽象，把事物的特征进行快速总结。 多练，初级程序员至少锻炼1年，才能具备这种抽象思维。 具备看到一个事物，就能把它抽离成代码示例的能力。 好处 抽象思维，使你的代码能解决更多的问题 而不是兵来将挡、水来土掩，一个一个解决 新手程序员，遇到一个问题就写一段代码 高级程序员，将所有可能问题汇总，写一大坨代码解决全部问题 比如 Vue 和 React 的作者（一套框架解决问题） ​ ","date":"2020-08-12","objectID":"/javascript-history/:3:1","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"硬要求 客观上的要求 一、足够的代码量 达到 1000 行 - 新手 达到 10000 行 - 熟手（至少做过1个比较复杂的项目，常规项目都能做） 达到 50000 行 - 专业选手（至少做过2-3个比较复杂的项目，可能3-5年，看996时间积累） 只能靠时间积累 如何统计自己的代码行数 安装 yarn global add cloc cloc --vcs=git . 可以用来统计一个仓库里的有效代码 注意 如果仓库里有 node_modules 目录等不相关内容 需要把 /node_modules/ 写入 .gitignore 文件 ​ 二、了解足够多的概念 不仅要会写，还要会扯说（面试） 概览 常用常考 闭包、原型类、继承、MVC、Flux、高阶函数、前端工程化 只会用，不会说，面试就完了 如何积累 在课程中提炼 就是记笔记 面试如果能完整说出来，就是满分。新手能说出一般也达到要求了，面试新手就看思路对不对，不需要百分百实现 在大脑中思考 JS需要思考清楚，这些代码到底是在做什么。为什么这样设计、为什么这样用 学JS，必须把疑问直接搞定，不能一直留着，不然会有越来越多的 bug 在博客上总结 思考清楚了，一定要总结、记下来 用于面试 在代码中实践 ​ 三、有足够的踩坑经验 你以为是工作经验吗？ 踩坑经验 何谓专家 **“ 该领域内所有的错误都犯完的人，就是专家 ” ** 如何踩坑 做项目，而且是个人项目 个人项目的意思是所有代码都是你一个人写的 团队合作的大项目，基本上只有两个人做，其他人都是打酱油的 这样你才能全方位踩坑 ​ ","date":"2020-08-12","objectID":"/javascript-history/:3:2","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"总结 软要求 逻辑能力 质疑自己的能力 抽象能力 硬要求 足够多的代码（至少5000行，大项目1000-2000行，小项目200行左右） 足够多的概念 足够多的踩坑经验（记下来自己遇到过什么坑） ​ ​ ","date":"2020-08-12","objectID":"/javascript-history/:3:3","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 的历史 历史和特点 ","date":"2020-08-12","objectID":"/javascript-history/:4:0","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"发明人 李爵士发明 HTML 赖先生发明 CSS 布兰登发明 JS ​ 布兰登的生平 生平1961年生于美国 物理学转数学与计算机学位 工作七年，负责操作系统与网络开发 又工作三年，负责微内核与电子信号处理相关工作 1995年进入网景公司，为其浏览器开发了 JS 功能 1998年协助成立 Mozilla.org，担任首席架构师 网景死亡（被收购）后，他成立了 Mozilla 基金会，Firefox 就是这个基金会维护的，有纪录片记录了这一过程 2014年晋升为 Mozilla 的 CEO，十天后，被赶下台 原因是他曾捐助过反同性恋的法案（只有异性可结婚） 2015年成立 Brave 公司，开发保护用户隐私的浏览器 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:1","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"总结 牛逼的程序员 从来不会只学一门编程语言 不怕被辞退，总能找到事做 很容易创业，比外行人靠谱得多 可以干到 50 岁以上（基本上都是创办公司或很有钱了） JavaScript 诞生之初，只是一个不起眼的小功能 同时 JS 有很多 bug，我们学习的时候要注意辨别 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:2","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 的诞生 布莱登临危受命 公司要求给浏览器添加一个脚本功能 公司要求这个脚本必须蹭 Java 的流量 布莱登花十天设计了 JS 的最初版本（不是实现） JS的命名 Mocha 摩卡 =\u003e LiveScript =\u003e JavaScript Java 既是编程语言，也是一种咖啡 浏览器一开始同时就支持 Java 和 JavaScript 后来，JS 胜了（在浏览器上），Java就逐渐退出了浏览器平台 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:3","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"浏览器大战 背景：1995年，网景推出 JS 功能，用户纷纷叫好，因为可以在页面上节省流量。 当时的网速非常慢 2~3k/s，用户填写一个表单，点击提交按钮，等待一分钟才刷新页面，反馈结果。 有了 JS 功能之后，点击按钮，马上反馈用户表单信息是否正确，所以用户非常喜欢。 注意：此时的 JavaScript 只是网景提供的一个功能，并不是语言 微软的跟进 1996年8月 IE 3 发布，支持 JScript（微软实现的JS） 浏览器大战开始，每家浏览器的脚本不太一样 网景的反击 1996年11月，网景向 ECMA 提交语言标准，由于版权问题，JS 语言标准不叫 JavaScript，叫 ECMAScript ECMA 发音：ai ke ma ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:4","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"网景之死 被收购 微软的 IE 浏览器由于捆绑进了 Windows，很快超越 1998年，网景浏览器节节败退，公司陷入内忧外患 同年，公司打算搏一搏，将浏览器开源（Firefox） 最终，市场并没有因为开源而重新青睐网景 年底，[美国在线 AOL] 宣布开始收购网景 收购后，网景团队里的程序员纷纷被解雇 布莱登在之后一直协助维护 Firefox 的运营 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:5","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"IE 6 如日中天 你想象不到 IE 6 多么火 2001年，IE 6 随着 Windows XP 一起发布 2004年，IE 6 全球市场占用率 80% 以上 然而，这款浏览器却不兼容 W3C 标准（主要是 CSS) IE 6 也不断爆出安全漏洞 Firefox 打算涅槃重生，重新打败 IE 2005年，IE 7 发布，但打不过 IE 6 2006年，主流浏览器为 IE 6 和 Firefox 2010年，中国的大部分浏览器还是 IE 6 由于盗版 Windows XP 在中国的风行，在很多年里，IE 6 始终占据中国浏览器市场，是前端开发者的恶魔 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:6","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"IE 6 神奇的 bug 下面代码会让 IE 6 直接崩溃，当场死机 \u003cstyle\u003e * { position: relative } \u003c/style\u003e \u003ctable\u003e \u003cinput\u003e \u003c/table\u003e 补充： 「*{ } 星号性能低下」的谣言，就是从 IE6 这个 bug ，开始传出来的 实际上星号没有这个问题，这是 IE6 自己有问题 如果现在还有人说「星号性能低下」，不要反驳他，八九年前的事情现在还在说 星号套星号…可能有问题，但是一个星号，是绝对不会有问题的 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:7","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"Chrome 横空出世 微软的懈怠 由于 IE6 的巨大成功，微软觉得再花费精力不值得，而且没有竞争对手，所以直接解散了 IE6 开发团队 Firefox 的出现让微软重新组建 IE 团队，但不是同一队人，造成 IE7、8 一直问题不断 谷歌抓住机会 2004年，谷歌雇用了一些 Firefox 和 IE 的开发者 2008年，Chrome 终于发布，迅速拿下 1% 份额 2011年，Chrome 份额超过 Firefox 2016年，Chrome 全球份额 62% 欣赏一支 Chrome 的广告 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:8","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"移动市场兴起 智能手机崛起 2010年，iPhone 4 发布 2011年，微软 和 Nokia 联合起来，打算搞一波事情 后来的事情大家都知道，Nokia 手机业务完了 也就是说，手机上基本没有 IE 了 前端程序员表示欣喜若狂，IE 终于快要死了 2016年，淘宝天猫宣布不再支持 IE6、IE7 同年年底，宣布不再支持 IE 8 移动市场的兴起，让中国前端摆脱 IE 十年的恐怖支配 从此，前端快速，不对，是极速发展 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:9","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"ECMAScript 标准的制定 时间 1997年6月，第一版 ECMAScript 发布 1999年12月，第三版发布，这个版本使用最广（IE6支持） 第四版，流产。 2009年12月，第五版发布，增加了一些功能 2015年6月，第六版发布，新浏览器都支持这一版 之后每年发布一版，版本号以年份命名 JS 与 ECMAScript 的关系 ECMAScript 是纸上的标准，JS 是浏览器的实现 纸上标准往往落后于浏览器，先实现，再写进标准 ECMA 只总结，不预演，这样就不会再导致标准流产（写进标准但没浏览器使用的情况） ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:10","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 兴起 杀手级应用 Gmail 2004年愚人节，谷歌发布 Gmail 在线网页 当时的人们认为网页只能用来看新闻和图片 Gmail 的发布让用户和开发者（后端、客户端）眼前一亮 2005年，Jesse 将谷歌用到的技术命名为 AJAX 从此，前端技术正式出现 在此之前的网页开发，都是由 后端 和 设计师 完成 2006年，jQuery 发布，是目前最长寿的 JS 库 后来的十年，jQuery 大发异彩，直到 IE 不行了，jQuery 才稍微没有那么火 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:11","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"中国前端的发展 正式出现时间 2010年左右，中国才有专门的前端岗位 百度搜索指数 前端的来源 一部分来自自学的后端程序员，他们把 Java 的思想代入 JavaScript，面向对象成了JS的主流思想 一部分来自设计师，他们开始学习 CSS，并独创了「重构工程师」岗位（现已没落） 比如张鑫旭，专门研究CSS 上面这两种来源，一种赶鸭子上架，一种不够专业，导致前端特别缺人 缺人 最应该产出前端人才的大学，迟迟没有相关课程 由于早期前端工资比不上后端，所以大部分人选后者 就如同现在很多高材生选择机器学习一样 一些不小心进入前端领域的科班生成长非常迅速 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:12","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"JavaScript 爆发 V8 快如闪电 Chrome 的 JS 引擎叫做 V8（V1到V7是啥) 2009年，Ryan 基于 V8 创建了 Node.js 2010年，Isaac 基于 Node.js 写出了 npm 前端工程师可以在浏览器之外执行 JS 了，Node.js 快速风靡 例：node demo.js 同年，TJ 受 Sinatra 启发，发布了 Express.js 从此，前端工程师可以愉快地写后端应用了！ 爆发 这期间出来的技术太多，以后慢慢介绍：gulp、grunt、yeoman、requirejs、webpack、Angular、React、Vue等 这些技术很多也已经过时了 ​ ","date":"2020-08-12","objectID":"/javascript-history/:4:13","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["JavaScript"],"content":"总结 JS 是历史的选择 一开始浏览器支持很多东西：Java、Flash、VBScript 只有 JS 活到最后 JS 的低开高走 一开始 JS 就是一个玩具语言 但是 JS 每次都走对了风口 JS 推出标准 Gmail 的出现（当时的网站只能看新闻，用户第一次体验到输入网址就能打开一个工具） 移动端 node.js 学习 JS 时需要注意 JS 最初也很混乱，旧的、过时的东西了解就好，考前记忆一些 跟 IE 相关的知识一律忽略 前端是进入互联网行业的捷径 ","date":"2020-08-12","objectID":"/javascript-history/:4:14","tags":["JavaScript","历史"],"title":"JavaScript 的发展历史","uri":"/javascript-history/"},{"categories":["HTTP"],"content":"🤞🏻 Nobody knows HTTP better than me !! 🤗🤥","date":"2020-08-10","objectID":"/http-2/","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"🤞🏻 “Nobody knows HTTP better than me !! ” 🤥 ​ ","date":"2020-08-10","objectID":"/http-2/:0:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"先导 安装 Node.js 8+ 理解 IP 和 端口 理解 URL 路径和查询参数 ​ ","date":"2020-08-10","objectID":"/http-2/:1:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"演示 Node.js Server ⭐ ","date":"2020-08-10","objectID":"/http-2/:2:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"请求与响应模型 服务器，就是没有显示器的电脑 ​ ","date":"2020-08-10","objectID":"/http-2/:2:1","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"如何发请求 方法 用 Chrome 地址栏 用 curl 命令 概念 帮你发请求的工具叫做「用户代理」 如果使用 Chrome 地址栏发送请求，那么 Chrome 就是我们的「用户代理」 如果使用 curl 命令发送请求，那么 curl 就是我们的「用户代理」 「用户代理」 英文名 User Agent ​ ","date":"2020-08-10","objectID":"/http-2/:2:2","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"如何做出一个响应 ⭐ 用 Chrome 地址栏 或 用 curl 命令 ，可以发出一个请求 那么如何做出一个响应呢？（演示自己发请求-自己响应的过程） 需要用到编程 Node.js 有一个 http 模块可以做到 新建项目目录 node-demo / server.js，将下面代码粘入 ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ 代码细节先不管，直接复制使用。（注意这块目的不是学 nodejs，而是搞清楚 http 的请求和响应） var http = require('http') var fs = require('fs') var url = require('url') var port = process.argv[2] if (!port) { console.log('请指定端口号好不啦？\\nnode server.js 8888 这样不会吗？') process.exit(1) } var server = http.createServer(function (request, response) { var parsedUrl = url.parse(request.url, true) var pathWithQuery = request.url var queryString = '' if (pathWithQuery.indexOf('?') \u003e= 0) { queryString = pathWithQuery.substring(pathWithQuery.indexOf('?')) } var path = parsedUrl.pathname var query = parsedUrl.query var method = request.method /******** 从这里开始看，上面不要看 ************/ console.log('有个傻子发请求过来啦！路径（带查询参数）为：' + pathWithQuery) if (path === '/') { response.statusCode = 200 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(`二哈`) response.end() } else if (path === '/x') { response.statusCode = 200 response.setHeader('Content-Type', 'text/css;charset=utf-8') response.write(`body{color: red;}`) response.end() } else { response.statusCode = 404 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(`你输入的路径不存在对应的内容`) response.end() } /******** 代码结束，下面不要看 ************/ }) server.listen(port) console.log('监听 ' + port + ' 成功\\n请在空中转体720度然后用电饭煲打开 http://localhost:' + port) 注意事项 这些代码就是服务器代码，一般放在服务器上 path 是不带查询参数的路径 /x query 是查询参数的对象形式 {a:1} queryString 是查询参数的字符串形式 ?a=1 pathWithQuery 是带查询参数的路径，一般不用 request 是请求对象 response 是响应对象 \\n 表示回车 ​ 运行机制⭐ 在终端中启动应用： 运行 node server.js 未指定端口号，会有提示 按照提示执行即可 node server.js 8888 或者 node server 8888 这句话就意味着我们的电脑会开一个端口 8888，这个端口被 server.js 监听着 这时候只要有人请求了8888 端口，就会走入 server.js 的代码中，我们注释的那段代码就会运行一遍。每接收到一次请求，就运行一遍 用 curl 发出请求 curl http://127.0.0.1:8080/xxxx。server.js 接收到请求，会做出响应。 如果响应内容乱码，可能是 windows 系统的关系 添加路由 编辑 server.js 文件，添加 if else（限定条件，访问某个路径，响应对应内容） 重新运行 node server.js 8888（修改服务代码，需要重启） if (path === '/') { console.log('有人访问/了') response.end('这就是访问/，响应的内容\\n') // 回车\\n } 下面是，server.js 监听到 curl 命令 请求根路径时 执行的 console.log(…) 后台启动应用： touch log 创建一个 log 文件 node server.js 8888 \u003elog log 2\u003e\u00261 \u0026 返回的数字1144就是这个进程的 ID（目前这个进程已经在后台运行了） 运行后，服务器在后台启动，不占用当前终端 怎么关闭这个后台进程呢？ 执行 kill -9 xxxx xxxx为后台进程的 id数字 kill -9 是最厉害的杀进程的方法 ​ 代码逻辑 语法 `这种字符串` 里面可以回车 '这种字符串' 里面要回车，只能用 \\n 表示 逻辑 每次收到请求都会把中间的代码执行一遍 用 if else 判断路径，并返回响应 如果是已知路径，一律返回 200 如果是未知路径，一律返回 404 Content-Type 表示内容的「类型/语法」（省略后缀，程序员从来不看后缀😎，后缀只是用来告诉计算机要用什么软件打开文件） `text/html`、`text/css` path 不写 /x.css 而写 /x，因为 content-type 中已经声明了类型/语法，所以可省略后缀 .css response.write() 可以填写返回的内容（写入响应内容） 调用 response.end() 表示响应可以发给用户了（调用 response.end() ，就会将响应发送给浏览器） （ 以前不写 end 就会一直等待，现在可能优化了可以不写 end，严谨起见还是都写完整，明确告知可以响应给用户了 ） if (path === '/') { response.statusCode = 200 response.write(` \u003c!DOCTYPE html\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003clink rel=\"stylesheet\" href=\"/x\"\u003e // \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c 将 html 和 css 结合起来 \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e标题\u003c/h1\u003e \u003c/body\u003e `) response.end() } else if (path === '/x') { response.statusCode = 200 response.setHeader('Content-Type', 'text/css;charset=utf-8') response.write(`body{color: red;}`) response.end() } 如上图就是，通过 link 把 html 和 css 联系起来，成为一个网页，把这个网页通过 http 传送到浏览器上的整个过程：一个路径返回 html 字符串，一个路径响应 css 字符串。 这就是李爵士发明的 URL + HTTP + HTML ​ 注意符号 `` 反引号 `` 可以识别回车、语法 单引号 ‘’ 不能识别回车语法，仅作为字符串 ​ ​ ","date":"2020-08-10","objectID":"/http-2/:2:3","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"遥想当年李爵士 世界上第一个服务器程序 我们也写一个服务器程序 世界上第一个网页 我们在 / 路径返回一个 HTML 内容 然后在 /x 路径返回一个 CSS 内容 然后再 /y 路径返回一个 JS 内容 if (path === '/') { response.statusCode = 200 response.write(` \u003c!DOCTYPE html\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003clink rel=\"stylesheet\" href=\"/x\"\u003e ←←←←←←←←←←←←←← 引入 css \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e标题\u003c/h1\u003e \u003cscript src=\"/y\"\u003e\u003cscript\u003e ←←←←←←←←←←←←←←← 引入 js \u003c/body\u003e `) response.end() } else if (path === '/x') { response.statusCode = 200 response.setHeader('Content-Type', 'text/css;charset=utf-8') response.write(`body{color: red;}`) response.end() } else if(path === \"/y\"){ response.statusCode = 200; response.setHeader(\"Content-Type\", \"text/javascript;charset=utf-8\"); response.write(`console.log('这是JS内容')`; response.end(); } else { response.statusCode = 404; response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(`你输入的路径不存在对应的内容`) response.end() } 注意事项 关于后缀 即使写成 path === \"/y.css\" ，但如果在 Content-Type 中规定是 js 类型，就会按照 js 解析。所以，URL里的css 后缀卵用没有 Content-Type 才是决定文件类型的关键 ​ ","date":"2020-08-10","objectID":"/http-2/:2:4","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"体系化学习 HTTP 必须学会什么 基础概念（有哪些是必会的） 请求、响应 如何调试（用的是 Node.js，可以用 log / debugger ) 本质是学习 HTTP，所以不要在 Nodejs 花费太多时间，只需要搞懂 nodejs 怎么调试即可 在哪查资料（用的是 Node.js，所以看 Node.js 文档） 标准制定者是谁（ HTTP 规格文档：RFC2616（中文）等） 如何学 Copy-抄文档、抄老师 Run-放在自己的机器上运行成功 Modify-加入一点自己的想法，然后重新运行 ​ ","date":"2020-08-10","objectID":"/http-2/:3:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"HTTP 基础概念 必须点击 view source ，才能看到完整的请求、响应 ","date":"2020-08-10","objectID":"/http-2/:4:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"请求 请求动词 路径加查询参数 协议名/版本（所有请求都按照这个格式，简化版）例：GET /x?wd=hi HTTP/1.1 Host: 就是域名或 IP（包括端口号） Accept: text/html（表示浏览器想接收什么内容） 测：根据 accept 返回不同内容 var accept = request.headers['accept']; // 获取请求头中的 accept 的值，赋给变量 if(accept.indexOf('xml')){ response.write('我知道你想访问 XML 内容') }else{ response.write(`\u003c!DOCTYPE html\u003e\u003chtml\u003e...\u003c/html\u003e`) } 浏览器可接收的内容：accept。（大多来说浏览器就是接收 html） 默认先找 html，如果没有 html，可以接收 xhtml、xml、webp、png、igned-exchange（如下） Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0. Content-Type: 表示请求体的格式（例：text/javascript;charset=utf-8） 回车（划分请求头、请求体的界线） 请求体（也就是上传内容） 细节 请求有三部分，用回车隔开，分别是：（与 ↑↑ 对应颜色） 请求行（因为只有一行，所以叫请求行）GET /x?wd=hi HTTP/1.1 请求头 请求体（请求体的格式，是在 content-type 中指定的） 请求动词有 GET / POST / PUT / PATCH / DELETE 等 GET 用于获取内容 POST 用于上传内容 发送post请求：curl -v -X POST --data '上传内容' http://localhost:8888/ 请求体在 GET 请求中一般为空 因为get请求通常用于获取内容，而请求体表示要上传的内容，所以GET请求一般没有请求体 文档位于 RFC2616 第五章 大小写不敏感（随意），最好照着我的写 ​ ","date":"2020-08-10","objectID":"/http-2/:4:1","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"响应 协议名/版本 状态码 状态字符串 Content-Type: 响应体的格式 回车 响应体（也就是下载内容） 细节 响应有三部分，用回车隔开，分别是： 状态行（Status LIne） 响应头 响应体（响应体的格式，在Content-Type中指定） 常见的状态码是考点 200 成功 404 找不到 文档位于 RFC2616 第六章 ​ ","date":"2020-08-10","objectID":"/http-2/:4:2","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"用 curl 构造请求 ","date":"2020-08-10","objectID":"/http-2/:5:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"curl 用法 curl 可以用来改请求动词、查询参数，还可以改第二部分的请求头、第三部分的请求内容… 什么都可以改，请求的东西都可以由自己觉得 只不过需要按照 http 的标准来写 前提条件：server 要处于开启的状态：node server.js 8888 例：curl -v http://localhost:8888 设置请求动词 -X POST 例：curl -v -X POST http://localhost:8888 设置为post请求 注意大小写 设置路径和查询参数 直接在 url 后面加 例：curl -v -X POST http://localhost:8888/xxx?id=xxx 注：在 url 后添加 # 锚点是不会发送到服务器的 设置请求头 -H 'Name: Value' 或者 --header 'Name: Value' 例：curl -v -X POST -H 'Accept: text/html' http://localhost:8888 设置请求体 -d '内容' 或者 --data '内容' curl -v -X POST -H 'ABC: abc' -H 'Content-Type: text/plain;charset=utf-8' -d '请求体内容' http://localhost:8888 在请求体中设置一个 ABC: abc，没有实际意义但是成立的。 text/plain 表示上传的内容是纯文本，编码是 utf-8（中文），内容是’请求体内容’这5个字（每个字占2bytes） 总结：可以使用 curl 随心所欲的构造一个请求 ​ ","date":"2020-08-10","objectID":"/http-2/:5:1","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"用 Node.js 读取请求 读取请求动词 request.method console.log('method:', request.method) // method: GET ... 读取路径 request.url 路径，带查询参数 console.log('路径：', request.url) // 路径：/xxxx?wd=hihihi path 纯路径，不带查询参数 query 只有查询参数 读取请求头 **request.headers['Accept'] ** 读取请求头中的 Accept 值 console.log(\"请求头：\", request.headers) // 请求头：{ host:xxx, ???:???, ... } 读取请求体 比较复杂，先不讲 ​ ","date":"2020-08-10","objectID":"/http-2/:5:2","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"用 Node.js 设置响应 设置响应状态码 response.statusCode = 200 状态码可以任意设置，状态字符串会根据设置的状态码自动改变 但是状态码是有统一的使用规则的，如 200 规定就是表示请求成功时返回的状态码，所以不要随意改变 404 表示请求的网页不存在 。404 页面就是一个普通页面，是 Chrome 提供的，当访问页面不存在时提醒用户 设置响应头 response.setHeader(\"Content-Type\", \"text/html\"); 设置响应体 response.write(\"内容\"） 可追加内容 ​ ","date":"2020-08-10","objectID":"/http-2/:5:3","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"curl 的作用是什么 不单单是用来测试 http 的请求和响应。 curl 可以完成 Chrome 的大多基本功能，但 curl 通过命令行执行，所以不具有可视化能力 下载图片 curl 图片路径.jpg \u003e xxx.jpg （ 在命令行开启的目录中，下载图片并重命名为 xxx ） curl https://i.loli.net/2020/07/15/Q2dnHSgxCcbfhZW.jpg \u003e 3.jpg 测试 请求和响应 … curl 功能很强大，Chrome 的基本功能都可以实现，但不具有可视化 ​ ","date":"2020-08-10","objectID":"/http-2/:5:4","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"HTML / CSS / JS 的本质都是字符串 HTML / CSS / JS 的本质都是字符串，不是文件 本质上我们看到的网页，都是通过 html字符串 渲染的，html字符串 里面请求了 css字符串、js字符串 从演示的 server.js 中就能体现这一点 ​ ​ ","date":"2020-08-10","objectID":"/http-2/:6:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"console.log 调试大法 console.log（打印）这种调试方法，是在所有编程语言中都适用的 JS（console.log）、Java（print）、Python（print）、PHP（echo）… 语言/写法不一样，但原理相同 把可能有问题的代码，打印看看 debug 就是在不断质疑自己的过程 不要过分相信自己，而要相信 console.log() 可以告诉你对错 程序员每天都在问自己错在哪里 ","date":"2020-08-10","objectID":"/http-2/:7:0","tags":["HTTP","node","请求响应","curl"],"title":"前端也得懂点儿 HTTP (下) ","uri":"/http-2/"},{"categories":["HTTP"],"content":"URL 懂？！😵","date":"2020-08-04","objectID":"/http-1-url/","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"本文主要围绕 URL ，为学 HTTP 做个铺垫。 ​ ","date":"2020-08-04","objectID":"/http-1-url/:0:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"先导 ","date":"2020-08-04","objectID":"/http-1-url/:1:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"英语：protocol protocol /ˈproʊtəkɑːl/ 协议、礼节、约定 ","date":"2020-08-04","objectID":"/http-1-url/:1:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"李爵士发明的三样东西 WWW = URL + HTTP + HTML HTML 前面已经学了，html + css 本质就是网页 再认识了 URL 和 HTTP ，那么 WWW 我们就基本了解了（ URL 是为 HTTP 做铺垫） ​ ","date":"2020-08-04","objectID":"/http-1-url/:1:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"什么是 IP 要学习 URL 、HTTP，得先从 IP 讲起（⭐剧透：HTTP 的 P 和 IP 的 P 之间有重要联系） IP： Internet（因特网==互联网，整个人类组成的网络就叫互联网，比WWW更加底层）protocol（协议） 由此可见 IP 也是非常底层的，没有 IP 就不能上网 Internet Protocal 主要约定了两件事： 一、如何定位一台设备 二、如何封装数据报文，以跟其他设备交流 具体内容我们不关心 只要你在互联网中，你就有至少一个独特的IP ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"IP 分为内网和外网 内网和外网是不能直接相通的，只能通过路由器作为网关，来连通 路由器：是一个非常重要的设备，连通了内网和外网 例：比如你在玩 LOL，按了一下Q键（第一个技能），怎么让网线那头的对手被Q到？ Q 通过键盘传到路由器，路由器通过电信服务器传到 QQ 的游戏服务器， QQ 的游戏服务器接收到 Q 键后，就将 Q 键发送到对手那里，对手就被 Q 到了 整个过程是非常复杂的，但非常快，按下Q键立马响应，因为这个复杂的过程是以光速的形式来运行的，所以用户感受不到 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"如何获取外网 IP 必须有 外网IP 才能和小伙伴打 LOL、王者荣耀… 首先，你得从电信租用带宽，一年一千多。 （然后需要有个猫（调制解调器），猫是用来把信号转换成路由器能理解的信号。现在普遍是光猫，把光信号变成电信号，变成路由器能理解的网络信号） 你买了一个路由器，然后用电脑和手机分别连接路由器广播出来的无线 WIFl。 有线连接和无线WiFi在本质上没有不同，但在实际使用中，无线可能慢于有线连接 有线连接的下载速度可能超过 10M/s，但无线WIFI连接的设备的下载速度可能无法超过 10M/s 只要路由器连上电信的服务器，那么路由器就会有一个「外网 IP」 ，比如 [ 14.17.32.211 ] 就是一个外网 IP。这就是你在互联网中的地址。 访问 https://ip138.com/ 查看当前外网 IP（通常外网IP不要告诉别人，可以准确定位你的位置） 那么你的所有设备，就全都是这一个 外网 IP 那么如何区分是手机设备…还是笔记本呢？这就依靠「内网 IP」来区分了 但是如果你重启路由器，那么你很有「可能」被重新分配一个「外网 IP」，也就是说你的路由器没有「固定的外网 IP」 如果想固定外网IP ，需要花钱每个月五六千，可以得到一个固定的外网IP（在国内购买这些网络资源通常贵于国外） 但是有个问题，你的路由器的外网 IP 如果是 14.17.32.211，那么你的手机和电脑的 IP 又是什么呢？答案是「内网IP」 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"内网 IP 路由器会在你家里创建一个内网，内网中的设备使用内网IP，一般来说这个IP的格式都是192.168.xxx.xxx。 命令行：ipconfig ，查看当前设备的内网 IP ：192.168.101.10 默认网关中的 IP：192.168.101.1 是路由器的 IP 如果你家足够大，路由器可能功率不够，覆盖不了整个家，用户可能需要买电力猫或再买一个小路由器做中介器之类的手段，来扩大覆盖范围到整个家。 如果家里五六十平米，那路由器基本可以全覆盖。 一般路由会给自己分配一个好记的内网IP，如 192.168.1.1 小米路由器的 IP ，一般都是 192.168.31.1，为了让出一个位置给光猫的 IP 然后路由会给每一个内网中的设备分配一个不同的内网 IP，如电脑是 192.168.1.2，手机是 192.168.1.3，以此类推。 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"路由器的功能 把内网的请求，路由到外部，把外部的响应，路由到内部。具有双向路由的功能，所以也被称为网关 现在路由器有两个 IP，一个外网 IP（电信分配的）和一个内网 IP（自己分配给自己的） 内网中的设备可以互相访问，但是不能直接访问外网 内网设备想要访问外网，就必须经过路由器中转 外网中的设备可以互相访问，但是无法访问你的内网 外网设备想要把内容送到内网，也必须通过路由器 想从网上（外网）下载内容，会先把内容下载到路由器，路由器再把内容下载到用户的设备上 也就是说内网和外网就像两个隔绝的空间，无法互通，唯一的联通点就是路由器 所以路由器有时候也被叫做「网关] 一夫当关，万夫莫开。一旦把路由器拔了，那就与网络世界断联了 ​ 用 http-server 可以创建一个服务 命令行：http-server . -c-1 第一个地址 192.168.xxx.xxx:8080 ，是给手机访问的（需要手机端调试内容时，就可以使用） 第二个地址 127.0.0.1:8080 ，是给电脑访问的 ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:4","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"几个特殊的 IP 分别是 127.0.0.1 表示自己（规定死的） localhost 通过 hosts 指定为自己 0.0.0.0 不表示任何设备 ​ 问：hosts 文件在哪？ 答： 在 Windows 系统中，hosts 位于 C:\\Windows\\System32\\drivers\\etc\\hosts 。在 macOS / Linux系统中，hosts 位于 /etc/hosts hosts 文件，用于指定本机 IP （表示自己） 127.0.0.1 / localhost 是 hosts 中默认的 （表示自己） 也可以在 hosts 文件中添加自定义 任何字符串 来表示自己（文件中的#内容均为注释，可删） 写法如下，定义后，就可以使用这些字符串来访问本地服务 + 127.0.0.1 sam + 127.0.0.1 ryuuks 注意：需要通过 http-server 开启本地服务后，下述地址才可以使用 http://localhost:8080/index.html http://127.0.0.1:8080/index.html http://sam:8080/index.html http://ryuuks:8080/index.html 上述地址，均可以访问到 index.html ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:2:5","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"端口 IP 有了，还需要什么？ 端口 WWW（万维网）= URL + HTTP + HTML URL 就是用来定位服务器的，例如，定位百度的服务器 baidu.com 一台机器可以提供很多服务 每个服务一个号码，这个号码就叫端口号port ","date":"2020-08-04","objectID":"/http-1-url/:3:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"端口 port 一个比喻 麦当劳提供两个窗口，一号快餐，二号咖啡 你去快餐窗口点咖啡会被拒绝，让你去另一个窗口 你去咖啡窗口点快餐结果一样 在计算机世界也是这样，你要提供不同的服务，就需要有不同的窗口。这个窗口，就是端口 port 一台机器可以提供不同服务 要提供 HTTP 服务最好使用 80 端口 要提供 HTTPS 服务最好使用 443 端口 要提供 FTP 服务最好使用 21 端口 一共有 65535 个端口（基本够用） ​ ","date":"2020-08-04","objectID":"/http-1-url/:3:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"我怎么知道应该用什么端口 维基百科一个一个列出来了，需要的时候就对应查找：每个端口用来做什么 端口 描述 80/TCP,UDP 超文本传输协议（HTTP）或 快速UDP网络连接- 用于传输网页 例如：百度服务器要给用户传输一个网页，那就必须用80端口，用其他端口会有问题 443/TCP 超文本传输安全协议（HTTPS）或QUIC HTTPS 协议传输就必须用 443 端口，用其他端口也会有问题 21/TCP,UDP 文件传输协议（FTP） - 控制端口 80后和早期的90后应该在学校见过FTP协议，传文件都是通过 FTP。95后00后可能没见过FTP了 ​ ","date":"2020-08-04","objectID":"/http-1-url/:3:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"端口使用还有什么规则 0 到 1023（2的10次方减1）号端口是留给系统使用的 普通用户绝对不能使用 即使是管理员有使用权限，但也需要输入额外的密码才能使用这些端口，所以也不推荐管理员使用 通常使用 8080 端口做开发，真正部署服务器时，拥有服务器权限才能用 80 端口… 你只有拥有了管理员权限后，才能使用这 1024 个端口 其他端口可以给普通用户使用 比如 http-server 默认使用 8080 端口 一个端口如果被占用，你就只能换一个端口 在其他端口开启服务 在 1234 端口开启服务 命令行：hs -c-1 -p 1234（hs：http-server 简写） http://192.168.101.10:1234 http://127.0.0.1:1234 通过访问 http://localhost:1234/index.html 就可以浏览本地页面 可否强行使用 80 端口，开启服务呢？🉑 仅在 windows 上能直接使用这个端口号，在 Linus 和 Mac 中都必须输入密码才能使用，不推荐 命令行：hs -c-1 -p 80 （在 80 端口开启服务） http://192.168.101.10:80 http://127.0.0.1:80 通过访问 http://localhost/index.html 就可以浏览本地页面（80 是默认端口，可省略） 端口被占用的情况，会有如下报错，换个其他的端口号即可（六万多个端口） hs -c-1 -p 80 =\u003e Error: listen EADDRINUSE 0.0.0.0:80 // EADDRINUSE: error address in use 错误地址正在使用中 hs -c-1 -p 1234 =\u003e Error: listen EADDRINUSE 0.0.0.0:1234 // error address in use hs -c-1 -p 2233 =\u003e http://192.168.101.10:2233 =\u003e http://127.0.0.1:2233 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:3:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"IP 和端口缺一不可 总而言之：IP 和 端口 缺一不可 （记住这句话） IP 是用来定位一个设备。 端口是用来定位一个设备的服务。 有了 IP 和端口，就可以定位一个设备提供的服务了。 例如：百度设备提供的网页服务。腾讯设备提供的聊天服务。淘宝设备提供的支付服务 这些服务都可以通过 IP + 端口 ，实现唯一确定 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:4:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"域名是什么 域名就是对 IP 起一个友好的名字。 域名是以 .com .net .org … 结尾的字符串，仅此而已。需要花钱购买 如：qq.com 在前面搭建个人博客时，已经注册过域名。 我没有自己的服务器，而是将这个域名映射到（指向） github 的服务器上 github 给我 4 个 IP。用户访问时，会访问到这4台中的任何一台服务器。访问的内容都是一样的 ​ 补充： .com 域名，比较便宜，一年50-80 t.tt，曾经是锤子手机的域名，转手价50W。访问 t.tt 跳转至锤子手机官网：smartisan.com 蔡文胜，2000年抢注十多万个域名，倒手生意。 qiyi.com 是百度旗下爱奇艺的域名 为什么我们需要向国外的人购买域名？发域名的机构也很赚钱。这就是美国人欧洲人赚钱的思维，我发明一套东西，用户都需要使用的，那使用一次就要交一次钱。 比如苹果有很多手机专利。谷歌买了摩托罗拉，摩托罗拉也有很多手机专利。谷歌发明了安卓系统，手机厂商用到安卓系统里面的谷歌服务，也需要给谷歌钱。 中国的 5G 出来了，如果以后世界的 5G 应用是由中国主导，关键技术是中国的，那么中国就可以躺着赚钱。如果中国的 5G 搞起来了，那就不单是 5G，周边的所有产业都会全面超过其他国家（所以川普联合各国抵制） 在互联网，每一个新东西出来，都蕴藏着巨大的商机。 如5G ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"域名就是对 IP 的别称 baidu.com 对应什么 IP 命令行：ping baidu.com 220.181.38.148 // 也有 39.156.69.79 qq.com 对应什么 IP 命令行：ping qq.com 125.39.52.26 知识点 先总结：IP 和 域名 之间，没有什么必然的一对一关系 一个域名可以对应不同 IP（这个叫 负载均衡） 这个叫做均衡负载，防止一台机器扛不住 一个 IP 可以对应不同域名（这个叫 共享主机） 比如6个人合买一台主机，这台主机服务6个域名 就叫做共享主机，穷开发者会这么做 或者一个公司提供不同的网站，但不想买两台服务器，就把两个网站（两个域名）放在同一台主机上 ​ 通常 ping 同一个域名，不一定会得到同一个 IP。这里涉及 负载均衡 的问题。 假如，一万人同时访问百度，如果只有一个服务器，就要同时接纳一万人。 如果有100万人同时访问，，即使每人只分配1k内存，也需要 100万 k，那么这台服务器肯定容纳不了 解决方法，把这个域名绑定到4个不同的 IP 上，4个 IP 分别位于 华中、华南、华东、华北。 电信有全国服务器，告诉电信，如果用户来自华中，就访问华中服务器…（1/4分流） 如此实现负载均衡。分散负担，不至于让某个服务器因承受不了而宕机。（网站优化策略） ​ 补充： ping 的作者写的一篇文章：The Story of the PING Program 皮卡丘站起来，是皮卡兵。皮卡丘跑起来是什么？答案 😂 ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"域名和 IP 是怎么对应起来的 通过 DNS Domain Name System （域名系统、域名服务） 当你输入 baidu.com 过程 你的 Chrome 浏览器会向电信/联通提供的 DNS 服务器询问 baidu.com 对应什么IP 电信/联通会回答一个 IP（具体过程很复杂，不研究） 这个过程可以用 nslookup 模拟（ns域名，lookup寻找）命令行：nslookup baidu.com 然后 Chrome 才会向对应 IP 的 80 / 443 端口发送请求 请求内容是查看 baidu.com 的首页 baidu 收到请求，就会把你请求的页面的 index.html 发送给你，index.html 中又会请求 css 、js，加载完css、js，就可以看到 baidu.com 的完整页面 ​ 在 network 中可以查看全部请求 Request URL: https://www.baidu.com/（末尾的 / 表示请求的是baidu的根目录） Response：[得到一个\u003chtml\u003e…\u003c/html\u003e]，浏览器就会把这一串 html 渲染出来（中间遇到 link 会请求对应的图片、css、js等文件） ​ 为什么是 80 或 443 端口？ 因为这是规定。 我们在地址栏输入 baidu.com 时，为什么不用写端口号？如 baidu.com:443 （ IP 和端口不是缺一不可吗！） 服务器默认用 80 提供 http 服务 服务器默认用 443 提供 https 服务 你可以在开发者工具里看到具体的端口 61.135.168.125:443 （ 前面就是服务器 IP ，后面就是网页服务的端口） 访问 http 就是 80，访问 https 就是 443 ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"题外话 前端需要懂点域名知识 www www.baidu.com 和 baidu.com 是同一个域名吗？不是 他们是什么关系 www.baidu.com 和 baidu.com com 是顶级域名（com 全写 company 公司，org 非营利性组织） baidu.com 是二级域名（俗称一级域名）父域名 www.baidu.com 是三级域名（俗称二级）子域名 他们是父子关系 github.io 把子域名 xxx.github.io 免费给你使用 所以 github.io（github公司）和 xxx.github.io（个人网站） 可能不是同一家公司，之间没什么关系 所以你应该知道 www.baidu.com 和 baidu.com 可以不是同一家公司，也可以是 www 是多余的吗？是的，非常多余。 早期人们为了表明自己是 www 而加的，实际上没有必要加，因为所有域名本身就存在与 万维网www中，写上www前缀反倒多此一举 ​ ","date":"2020-08-04","objectID":"/http-1-url/:5:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"如何请求不同的页面 访问不同的路径，就请求到不同的页面，如下（注意：路径后面不加后缀） https://developer.mozilla.org/zh-CN/docs/Web/HTML https://developer.mozilla.org/zh-CN/docs/Web/CSS 工具 使用 Chrome 开发者工具 Network 面板看看区别 只有 Request URL 不同 ​ ","date":"2020-08-04","objectID":"/http-1-url/:6:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"同一个页面，不同内容 不同的查询参数，返回不同的内容 www.baidu.com/s?wd=hi www.baidu.com/s?wd=hello ​ ","date":"2020-08-04","objectID":"/http-1-url/:7:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"同一个内容，不同位置 锚点可以做到 https://developer.mozilla.org/zh-CN/docs/Web/CSS#参考书 https://developer.mozilla.org/zh-CN/docs/Web/CSS#教程 注意 锚点看起来有中文，实际不支持中文 #参考书 会变成 #%E5%8F%82%E8%80%83%E4%B9%A6 重新编码 锚点是无法在 Network 面板看到的，因为锚点不会传给服务器。 # 井号后面的内容会被浏览器直接吃掉，并不会传到服务器中 锚点仍在当前页面中，只是位置不同而已，并不需要重新请求数据 注意：一定不要把用户传参拼接到 # 后面，会被浏览器当做锚点内容直接吃掉，服务器就无法获取到参数 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:8:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"一个 URL 的完整内容 协议 + 域名 或 IP + 端口号 + 路径 + 查询字符串 + 锚点 协议：分 HTTP 和 HTTPS 域名：用来表示IP对应的名称的字符串 IP ：用来定位一个设备的字符串（分为4段，最大值255） 端口号：提供一个服务，就要有对用端口号（有六万多个） 路径：就是一个字符串，用来判断用户访问什么网页 查询参数：就是这个网页中，用户要具体看什么内容，可能有分页 锚点：内容已经获取到了，通过锚点定位到用户想要具体查看的内容的位置（实现文档内部的定位） 把上述全部加起来，就是 李爵士发明的 URL （统一资源定位符） URL U：Uniform 统一。国际化标准的 R：Resouce 资源。图片、网页…都是资源 L：Locator 定位符。 例： 就算没写，你也应该知道端口 HTTPS 默认端口 443、HTTP 默认端口 80 ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:9:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"HTTP（协议） 前面讲了 IP 协议：是用于表示每个设备的地址 而 HTTP 协议：是用来表示如何传输网页的 HTTP协议，是基于 TCP 和 IP 两个协议 先有 TCP、IP，李爵士基于前人发明的这两个协议，发明了新的 HTTP 协议 ​ ","date":"2020-08-04","objectID":"/http-1-url/:10:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"curl 命令 curl /kɜːrl/ 使…卷曲 如何用 curl 命令，发出 HTTP 的请求？ ","date":"2020-08-04","objectID":"/http-1-url/:11:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"用 curl 可以发 HTTP 请求 示例1： curl https://www.baidu.com 执行命令，获取到整个文档。（中文默认 utf-8 编码，而控制台默认 GBK 所以中文会乱码） 我们在 Chrome 的地址栏中输入上述网址，Chrome 也是做了同样的事情，获取到这个html文档并解析 ​ 示例2： curl -v http://baidu.com 只有域名没有路径 -v ： verbose /vɜːrˈboʊs/ 啰嗦（效果：会显示更多内容） 请求的内容 我们发出的 HTTP 请求中，只有域名没有路径，则默认请求根路径，会自动补全根路径的斜杠 / 开启代理，使用了一些代理的功能（非必须） 问了DNS：获取到 baidu.com 的 IP 获取到 IP 后，就开始启动 TCP 开始连接到 baidu.com（ 220.181.38.148 这个 IP） 的 80 端口 连接成功，往 baidu.com 发送了这5行内容 GET请求，请求/根路径，使用 HTTP 协议 1.1 版本 因为一个IP（220.181.38.148）可能对应多个域名，说明需要访问的是这个IP上的 baidu.com 这个域名 说明我是用什么来访问的：用 curl 的 7.61.1 版本来访问的 期待返回什么内容：*/* 表示所有内容我都接收 空行（发送一个回车） 表示请求头部分结束 返回的内容 响应头：先忽略 😂 \u003chtml\u003e \u003cmeta …\u003e \u003c/html\u003e meta 中内容，意为请重新访问 http://www.baidu.com 说明 http://baidu.com 这个 URL 被弃用了，只使用这个最早就有的 URL www.baidu.com 通常直接使用 baidu.com 访问百度的人，基本都是程序员，将程序员的流量导到 www 上 上面请求失败，发起第二次请求 curl -v http://www.baidu.com ​ 示例3： curl -s -v -- https://www.baidu.com 会比上面显示的内容更详细 ​ ","date":"2020-08-04","objectID":"/http-1-url/:11:1","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"需要理解以下流程 url 会被 curl 工具重写，先请求 DNS 获得 IP 先进行 TCP 连接，TCP 连接成功后，开始发送 HTTP 请求 请求内容看一眼 响应内容看一眼 响应结束后，关闭TCP连接（curl 中没有直接写出来） 真正结束（只有TCP结束才是真正的结束） ​ ","date":"2020-08-04","objectID":"/http-1-url/:11:2","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"HTTP HTTP 到底做了什么 规定请求的格式是什么，响应的格式是什么 HTTP 规定了请求怎么写： 如何写第6步中的5行请求 HTTP 规定了响应怎么写： 如何写下面响应的内容 ​ 那么 HTTP 到底是怎么规定请求格式和响应格式的？ 下回分解 ✋ ​ ​ ","date":"2020-08-04","objectID":"/http-1-url/:11:3","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["HTTP"],"content":"习题 关于 www.baidu.com 和 baidu.com，正确的有（多选）答案 是同一个域名 是不同的域名 它们还有相同的一级域名 baidu.com 关于 hosts 文件，正确的有（多选） 答案 hosts 文件中以 # 开头的表示注释 hosts 中可以添加一行 127.0.0.1 sam，让 sam 成为 127.0.0.1 的别称 hosts 中可以添加一行 sam 127.0.0.1，让 sam 成为 127.0.0.1 的别称 hosts 一般需要用管理员权限才能编辑 HTTP 的英文全称是 ____（注意大小写不要错了） HyperText Transfer Protocol DNS 的英文全称是 ____（注意大小写不要错了） Domain Name System URL 包含哪些部分？（多选）答案 协议 域名或IP 端口 路径 查询参数 锚点 get 或 post ","date":"2020-08-04","objectID":"/http-1-url/:12:0","tags":["URL","HTTP","笔记"],"title":"前端也得懂点儿 HTTP (上) ：浅析 URL","uri":"/http-1-url/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-08-02","objectID":"/css-animation/","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"浏览器的渲染流程、transform、transition、animation ​ ","date":"2020-08-02","objectID":"/css-animation/:0:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"动画的原理 人脑的 bug ","date":"2020-08-02","objectID":"/css-animation/:1:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"动画 定义 由许多静止的画面（帧）， 以一定的速度（如每秒30张）连续播放时， 肉眼因视觉残象产生错觉， 而误以为是活动的画面。 概念 帧：每个静止的画面都叫做帧 播放速度：每秒24帧（影视）或者每秒30帧（游戏） ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:1:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"一个最简单的例子 ","date":"2020-08-02","objectID":"/css-animation/:2:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"将div从左往右移动 http://js.jirengu.com/bagow/1/edit?html,css,js,output JSBin 示例1 通过循环定时器 + 定位 + left 实现动画。控制每隔一小段时间增加 left 值，实现位移 JSBin 示例2 通过延时器 + 添加类名 + transition / transform 实现动画。控制添加类名 原理 每过一段时间（用setlnterval做到）， 将div移动一小段距离， 直到移动到目标地点。 注意性能 需要先搞懂：浏览器的渲染步骤，以及 每个属性会触发什么流程 绿色表示重新绘制（repaint）了 CSS渲染过程依次包含布局、绘制、合成 其中布局和绘制有可能被省略 ​ ","date":"2020-08-02","objectID":"/css-animation/:2:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"前端高手不用 left 做动画 用 transform（变形） JSBin 演示 原理 transform: translateX(0=\u003e300px) 直接修改会被合成，需要等一会修改 transition 过渡属性可以自动脑补中间帧 注意性能 需要先搞懂：浏览器的渲染步骤，以及 每个属性会触发什么流程 transform 优势在于，并没有 relayout（重新布局） 和 repaint（重新绘制）过程 transform 比 left 性能好很多（ 因为 left 会依次经过 relayout、 repaint、composite 3个过程） ​ ","date":"2020-08-02","objectID":"/css-animation/:2:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"如何查看性能 上述 JSBin 示例1/2两种方式，在性能上有什么区别 ？ 查看性能的方式 开启浏览器的【渲染 Rendering 】\u003e 【画图闪烁 Paint flashing】：突出显示需要重新绘制的页面区域（绿色） 如果元素发生的重新渲染（绿）的次数多，则更耗性能 示例1：使用 setInterval ，控制 left 实现动画 （位移全程 demo元素 都呈绿色：说明全程都在进行demo元素的重新渲染绘制） 示例2：添加类名，通过 transition + transform 实现动画 （刷新后，初次渲染呈绿色，移动过程没有发生重新渲染，移动结束的位置重新渲染一次） 总结：显然 ，示例1 更耗性能，全程都需要重新渲染 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:2:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"浏览器的渲染原理 既然讲到这里，提到了性能、渲染，那就深入了解一下 了解浏览器的渲染流程后，再回头看前面2个示例，可能会更好理解它们的不同 ","date":"2020-08-02","objectID":"/css-animation/:3:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"参考文章 Google 团队写的文章（右上角中文） 渲染树构建、布局及绘制 渲染性能 使用 transform 来实现动画 查看CSS各属性触发什么 CSSTriggers.com ​ ","date":"2020-08-02","objectID":"/css-animation/:3:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"浏览器渲染过程 浏览器在获取到 html 和 css 后做了什么？ 步骤 根据 HTML 构建 HTML 树（DOM） 根据 CSS 构建 CSS 树（CSSOM） 将两棵树合并成一颗渲染树（render tree） 根据渲染树，进行 Layout 布局（文档流、盒模型、计算大小和位置） 先定位：某个标签是否在文档流中…（文档流的概念非常重要！！） 定位后，要知道这个标签多高多宽、样式如何… Paint 绘制（填色：把边框颜色、文字颜色、阴影等画出来） Composite 合成（根据层叠关系展示画面） 三棵树 render tree 就是最终用户看到的树 ​ ","date":"2020-08-02","objectID":"/css-animation/:3:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"如何更新样式 ","date":"2020-08-02","objectID":"/css-animation/:4:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"一般我们用 JS 来更新样式 比如 div.style.background='red' 让内联背景变红色 比如 div.style.display='none' 让div消失 比如 div.classList.add('red') （小白才直接加样式，高手从来只加类名） 比如 div.remove()直接删掉节点 ","date":"2020-08-02","objectID":"/css-animation/:4:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"那么这些方法有什么不同吗 有三种不同的渲染方式 详细看下面 ↓↓ ","date":"2020-08-02","objectID":"/css-animation/:4:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"三种更新方式 使用 JS 来更新样式，要经过哪些步骤 ？ 下面有3种代码示例，配合开启浏览器渲染功能，清晰看到执行重新绘制（Paint）的元素 注意 JSBin 中最好全屏查看效果，在 iframe 里看可能有问题 第一种，流程全走一遍 div.remove() 会触发当前消失，其他元素 relayout 重新布局 第二种，跳过 layout 说明没有改变元素的位置和大小，不需要变动布局 比如说：只改变背景颜色，直接 repaint + composite 第三种，跳过 layout 和 paint 没有改变位置、大小，也没有改颜色，只需要合成 例如：只改变 transform，则只需 composite 合成 注意必须全屏查看效果，在 iframe 里看有问题 ​ ","date":"2020-08-02","objectID":"/css-animation/:4:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"每个属性触发什么流程 CSS变态之处来了：挨个尝试吧 还好，程序员喜欢分享 https://csstriggers.com/ 这个网站已经把所有属性全试过了 Blink：谷歌 Chrome 浏览器的内核（一般只看 Chrome 性能渲染） Gecko：火狐浏览器 Firefox WebKit：苹果 Safari 浏览器 EdgeHTML：微软 Edge 浏览器 现在可以解释 为什么 前端高手不用 left 做动画，而用 transform 做动画了 因为执行 left 会触发3个流程：先布局、再绘制、最后合成 而执行 transform 只会触发 1个流程：只合成 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:4:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"CSS动画优化 可以自己总结一篇博客。面试背不出来，可以让面试官去看博客 CSS 性能优化，除了把 left 变成 transform ，还有什么？ 面试可能考察，但这个问题没什么技术含量，就是背 ","date":"2020-08-02","objectID":"/css-animation/:5:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"没什么技术含量 答案都在 Google写的文章 里，谁看完谁牛 X 优化 JS 的执行 （JavaScript） 缩小样式计算的范围并降低其复杂性 （优化 Style 过程） 避免大型、复杂的布局和布局抖动（优化 Layout 布局过程） 简化绘制的复杂度、减小绘制区域（优化 Paint 绘制过程） 坚持仅合成器的属性和管理层计数（优化 Composite 合成过程） 上述每篇文章中的优化方法，都总结在【TL;DR（too long don’t read 太长不看）】部分 每条优化点之间，都没什么规律，就依靠死记硬背（面试问到，可能这些点，如果能答出1个，就得满分） ","date":"2020-08-02","objectID":"/css-animation/:5:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"JS优化 使用 requestAnimationFrame 代替 setTimeout 或 setInterval ","date":"2020-08-02","objectID":"/css-animation/:5:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"CSS优化 使用 will-change 或 translate（transform） ","date":"2020-08-02","objectID":"/css-animation/:5:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"没错 没错，完全就是死记硬背！ 如果面试官问，“ CSS 怎么优化 ”？（通常就是问动画怎么优化，性能上更低耗） 动画尽量使用 will-change 或 translate（transform），不直接使用 left JS 控制的动画中，尽量不使用 setTimeout 和 setInterval，而使用 requestAnimationFrame ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:5:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform 全解 MDN 上讲的非常详细 ","date":"2020-08-02","objectID":"/css-animation/:6:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform 四个常用功能 位移 translate（常用） 缩放 scale（常用） 旋转 rotate（做加载动画可能用到） 倾斜 skew（不常用） 经验 一般都需要配合 transition 过渡 inline 元素不支持 transform，需要先变成 block ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之translate 常用写法 可以写长度length和百分号percentage， ?表示可省略值 translateX(\u003clength-percentage\u003e) （横向） translateY（\u003clength-percentage\u003e) （纵向） translate(\u003clength-percentage\u003e,\u003clength-percentage\u003e?) 可省略第二个值，只写第一个值，默认x轴 translateZ(\u003clength\u003e) （垂直于屏幕的方向） 在三维世界中，才能看出 Z 的变化。 需要配合 perspective 属性，告知浏览器视点的位置 来形成三维。 例：perspective: 1000px 指视点在（位于画面中心）距离屏幕 1000 像素的位置上。 注意：是给父容器设置 perspective \u003cdiv class=\"wrapper\"\u003e \u003cdiv id=\"demo\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e #demo{ width: 100px; height: 200px; border: 1px solid red; margin: 50px; } #demo:hover{ transform: translateZ(50px); /* 元素在z轴（默认垂直屏幕方向）上的位置 */ } .wrapper{ perspective: 1000px; /* 形成三维构图，标注视点位置 */ border: 1px solid black; } \u003c/style\u003e translate3d(x,y,z) translate3d(50px,50px,200px); 同时设定3个轴上的位置 JSBin 演示 经验 要学会看懂 MDN 的语法格式 translate(-50%，-50%) 可做绝对定位元素的居中 #demo{ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) } ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之scale 常用写法 scaleX(\u003cnumber\u003e) scaleY(\u003cnumber\u003e) scale(\u003cnumber\u003e,\u003cnumber\u003e?) JSBin 演示 经验 用得较少，因为缩放容易出现模糊 border 也会跟随缩放 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之rotate 常用写法 rotate 默认以 Z轴为中心轴，进行转动 rotate（[\u003cangle\u003e|\u003czero\u003e]) 以Z轴为中心旋转 rotateZ([\u003cangle\u003e|\u003czero\u003e]) 以Z轴为中心旋转 rotateX([\u003cangle\u003e|\u003czero\u003e]) 以X轴为中心旋转 rotateY（[\u003cangle\u003e|\u003czero\u003e]) 以Y轴为中心旋转 rotate3d 太复杂，无法用语言表述 JSBin 演示 经验 一般用于360度旋转制作 loading 用到时再搜索 rotate MDN 看文档 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform之skew 常用写法 skewX([\u003cangle\u003e|\u003czero\u003e]) skewY（[\u003cangle\u003e|\u003czero\u003e]) skew([\u003cangle\u003eI\u003czero\u003e],[\u003cangle\u003e|\u003czero\u003e]?) JSBin 演示 经验 用得较少 用到时再搜 skew MDN 文档 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:5","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transform 多重效果 组合使用 transform: scale(0.5) translate(-100%, -100%); transform: none; 取消所有 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:6:6","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"实践：用 transform 做红心 ","date":"2020-08-02","objectID":"/css-animation/:7:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"跳动的心 JSBin ","date":"2020-08-02","objectID":"/css-animation/:7:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"心得 CSS需要你有想象力，而不是逻辑 CSS给出的属性都很简单，但是可以组合得很复杂 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003ebeating heart\u003c/title\u003e \u003cstyle\u003e *{ margin: 0; padding: 0; box-sizing: border-box; } #heart{ margin: 100px; position: relative; /*border: 1px solid black;*/ display: inline-block; transition: all .5s ease; } #heart:hover{ transform: scale(1.5); } #heart\u003e.bottom{ width: 50px; height: 50px; background-color: red; /*border: 1px solid red;*/ transform: rotate(45deg); } #heart\u003e.left{ width: 50px; height: 50px; background-color: red; /*border: 1px solid red;*/ border-radius: 50% 0 0 50%; transform: rotate(45deg) translateX(31px); position: absolute; bottom:100%; right: 100%; } #heart \u003e .right { width: 50px; height: 50px; background-color: red; /*border: 1px solid red;*/ border-radius: 50% 50% 0 0; transform: rotate(45deg) translate(0,30px); position: absolute; bottom: 100%; left: 100%; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"heart\"\u003e \u003cdiv class=\"left\"\u003e\u003c/div\u003e \u003cdiv class=\"right\"\u003e\u003c/div\u003e \u003cdiv class=\"bottom\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:7:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"transition 过渡 学习资料：MDN ","date":"2020-08-02","objectID":"/css-animation/:8:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"作用 补充中间帧 已知开头位置，结尾位置，中间运动轨迹自动补齐 ","date":"2020-08-02","objectID":"/css-animation/:8:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"语法 transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性。 JSBin 示例 transition: 属性名 时长 过渡方式 延迟 transition: left 200ms linear 属性名是指要给哪个属性添加过渡效果 可以用 all 代表所有属性：width | height | left | right | margin-right …… transition: all 200ms 可以用逗号分隔两个不同属性 transition: left 200ms, top 400ms 时长 ：支持 秒 s 和 毫秒 ms 单位。0.5s 可以写成 .5s 过渡方式有：linear（线性匀速） | ease（默认值：缓动） | ease-in | ease-out | ease- in-out | cubic-bezier | step-start | step-end | steps 具体含义要靠数学知识 https://cubic-bezier.com/ 测试运动曲线 ","date":"2020-08-02","objectID":"/css-animation/:8:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"注意 不学常态，学变态 并不是所有属性都能过渡 一个元素，切换可见状态 使用 display: none \u003c=\u003e display: block 没法过渡，会闪现、闪隐【元素消失，不占位置】 使用 opacity: 0 \u003c=\u003e opacity: 1 透明度控制可见状态【可实现过渡效果，缺点是元素消失仍占位置】 推荐使用 visibility: hidden \u003c=\u003e visibility: visible （不要问为什么）【缺点没法过渡、元素消失仍占位置】 button.onclick = () =\u003e { demo.classList.add('end'); /* 解决隐藏后仍占位问题：延迟1s后，将元素删除 */ /* 方法一：使用延时器 */ setTimeout(() =\u003e { demo.remove(); } ,1000) /* 方法二: on事件可能有bug，推荐使用事件监听器 */ demo.ontransitionend = () =\u003e { demo.remove(); } /* on事件 */ demo.addEventLisener('transitionend', () =\u003e { demo.remove(); }) /* 事件监听器 */ } display 和 visibility 的区别 https://www.cnblogs.com/zrenj/p/9785835.html background 颜色可以过渡吗？可以 。 查看示例 opacity 透明度可以过渡吗？ 可以 。 查看示例 不推荐用透明度控制显示隐藏，推荐 visibility opacity: 0 \u003c=\u003e opacity: 1 可实现过渡效果，缺点是元素消失仍占位置，可通过 js 控制 remove() 该元素 ​ ","date":"2020-08-02","objectID":"/css-animation/:8:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"过渡必须要有起始 起始：指一个属性的开始是一个值，该属性的结尾也有一个值。这样才能实现某属性的属性值的变化过渡，中间过渡的效果浏览器会自动补充 一般只有一次动画，或者两次 一次：指只有进入动画 两次：①进入动画、②离开动画 比如 hover 和 非 hover 状态的过渡，就是两次动画 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:8:4","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"如果除了起始，还有中间点，怎么办 例如：从红色，先变黄色，最后再变绿色，怎么实现 有如下两种办法 ","date":"2020-08-02","objectID":"/css-animation/:9:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"方法① 使用两次 transform 流程： .a === transform ===\u003e .b 然后 .b === transform ===\u003e .c 如何知道到了中间点呢？ 用 setTimeout 或者监听 transitionend 事件。 给元素添加新的类名：执行第二段 transform 效果。 注意：第二段 transform 中必须包含第一段动画效果，不然执行第二段动画可能还原初始位置，有 bug，可自行测试。 JSBin 示例 ","date":"2020-08-02","objectID":"/css-animation/:9:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"方法② 使用 animation 声明关键帧 添加动画 JSBin 示例 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:9:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"animation 动画 ","date":"2020-08-02","objectID":"/css-animation/:10:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"提问 如何让动画停在最后一帧？ 搜索 css animation stop at end 网友给出的答案是：加个 forwards animation: xxx 1.5s forwards; JSBin 演示 ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:10:1","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"@keyframes 完整语法 标准写法 搜索 keyframes MDN 讲得很清楚 一种写法是 from to ：只支持两种状态 另一种写法是百分数：支持添加 n 个帧状态 ​ ","date":"2020-08-02","objectID":"/css-animation/:10:2","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"animation 缩写语法 animation MDN animation 属性是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写属性形式。 Jirengu 视频讲解 JSBin 演示 animation: 时长 | 过渡方式 | 延迟 | 次数 | 方向 | 填充模式 | 是否暂停 | 动画名 ; /* 位置任意 */ 时长：1s 或者 1000ms 过渡方式：跟 transition 取值一样，如 linear 。默认是 ease 先快后慢 延迟时间：1s 或 1000ms 次数：3 或者 2.4 或者 infinite（无限次） 方向：reverse | alternate（交替，非常适合做加载动画） | alternate-reverse 填充模式：none | forwards（保持在动画终点位置） | backwards | both 是否暂停：paused | running pauseBtn.onclick = () =\u003e { demo.style.animationPlayState = 'paused' } /* 点击按钮，暂停demo元素的动画 */ 更多属性值的效果，需要自己尝试。JSBin 演示 以上所有属性都有对应的单独属性 **animation** 只是这些单独属性的**缩写**，上述效果可以通过单独的属性设置\r ​ ​ ","date":"2020-08-02","objectID":"/css-animation/:10:3","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"实践：用 animation 做红心 JSBin 示例 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003ebeating heart-animation\u003c/title\u003e \u003cstyle\u003e * { margin: 0; padding: 0; box-sizing: border-box; } @keyframes beating { 0% {transform: scale(1)} /*25% {transform: scale(1.25)}*/ /*50% {transform: scale(1.5)}*/ /*75% {transform: scale(1.25)}*/ 100% {transform: scale(1.5)} } #heart { /*border: 1px solid black;*/ display: inline-block; position: relative; margin: 100px; } #heart:hover { animation: beating .5s ease infinite alternate; } #heart \u003e .left { position: absolute; bottom: 50px; left: -50px; width: 50px; height: 50px; /*border: 1px solid red;*/ background: red; border-radius: 50%; transform: rotate(45deg) translateX(43px); } #heart \u003e .right { position: absolute; bottom: 50px; right: -50px; width: 50px; height: 50px; /*border: 1px solid red;*/ background: red; border-radius: 50%; transform: rotate(45deg) translateY(45px); } #heart \u003e .bottom { width: 50px; height: 50px; /*border: 1px solid red;*/ background: red; transform: rotate(45deg); } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"heart\"\u003e \u003cdiv class=\"left\"\u003e\u003c/div\u003e \u003cdiv class=\"right\"\u003e\u003c/div\u003e \u003cdiv class=\"bottom\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-08-02","objectID":"/css-animation/:11:0","tags":["CSS","笔记","动画"],"title":"CSS 学习笔记——动画","uri":"/css-animation/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-29","objectID":"/css-position/","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"复习盒模型、div 的分层、新属性 position 详解、层叠上下文 ​ ","date":"2020-07-29","objectID":"/css-position/:0:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"布局和定位的区别 区别大了 布局是屏幕平面上的 定位是垂直于屏幕的 ​ ","date":"2020-07-29","objectID":"/css-position/:1:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"CSS 定位 还得从文档流和盒模型说起（两个非常重要的概念） ​ ","date":"2020-07-29","objectID":"/css-position/:2:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"复习盒模型 margin 外边距、border 边框、padding 内边距、content 内容 background 背景 ","date":"2020-07-29","objectID":"/css-position/:3:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"问两个问题 背景的范围是从哪到哪？ 【A】border 内边沿围成的区域 ？【B】border 外边沿围成的区域 ？ 如何验证自己的猜想？ border 半透明试试，答案是【B】 注意：在浏览器的元素样式中，可通过 【alt + 上下方向键】，对半透明数值进行 0.1 的 ± 调整 从左边看一个 div，是什么样子？ 元素是有层叠关系的，脑内模拟一个三维立体结构，从左边看一个 div，是什么样子？ background 在文字后面然后呢？ 如何验证自己的猜想？用代码证明即可。 \u003cdiv class=\"demo\"\u003e \u003cspan class=text\u003e你好\u003c/span\u003e \u003c/div\u003e \u003cstyle\u003e .demo{ box-sizing: border-box; border: 5px solid red; width: 100px; height: 100px; background: blue; } .text{ font-size: 100px; /* 让字足够大，测试字能否覆盖住border */ color: green; } \u003c/style\u003e 结论： 文字在最上层，中间是 border，最底层是 background 背景 ​ ​ ","date":"2020-07-29","objectID":"/css-position/:3:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"代码验证：一个 div 的分层 三维立体模型 （SketchUp） 先给出结论（三维图），再在下面进行代码验证 ​ ","date":"2020-07-29","objectID":"/css-position/:4:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"块级子元素与内联子元素的分层位置 让块级元素与内联元素，出现重叠，就可以判断哪个层级更高 \u003cstyle\u003e .demo{ background: rgb(120,184,211); width: 200px; height: 200px; border: 15px solid red; padding: 10px; } .childDiv{ background: white; height: 50px; margin-top: -10px; /* 测试块级元素与文字的分层位置，将div向上移动，与文字重叠，看是否会遮挡文字 */ } \u003c/style\u003e \u003cdiv class=\"demo\"\u003e 文字内容 \u003cdiv class=\"childDiv\"\u003e\u003c/div\u003e \u003c/div\u003e 如上，“文字内容” 和 div.childDiv 属于同级关系 结论： 块级元素位于文字下层 ​ ","date":"2020-07-29","objectID":"/css-position/:4:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"浮动子元素与内联子元素的分层位置 \u003cstyle\u003e .demo{ ... } .float{ float: left; background: white; height: 50px; width: 50px; margin-right: -10px; /* 测试浮动元素与文字的分层位置，将浮动元素向右移动，与文字重叠，看是否会遮挡文字 */ } \u003c/style\u003e \u003cdiv class=\"demo\"\u003e 文字内容 \u003cdiv class=\"float\"\u003e\u003c/div\u003e \u003c/div\u003e 结论： 浮动元素位于文字下层 ​ ","date":"2020-07-29","objectID":"/css-position/:4:2","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"浮动子元素与块级子元素的分层位置 \u003cstyle\u003e .demo{...} .float{...} .childDiv{ height: 50px; background: orange; margin-top: -10px; } \u003c/style\u003e \u003cdiv class=\"demo\"\u003e 文字内容 \u003cdiv class=\"float\"\u003e\u003c/div\u003e \u003cdiv class=\"childDiv\"\u003e\u003c/div\u003e \u003c/div\u003e 结论： 浮动内容（脱离文档流），高于 childDiv（普通文档流元素），低于文字 所以，==脱离文档流==，实际上就是从普通文档流中跳出，比文档流的层级稍微高一点 ​ ","date":"2020-07-29","objectID":"/css-position/:4:3","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"结论 文字内容层级最高，代码写在下面的文字内容，会覆盖上面的 只有浮动元素会脱离文档流（从普通文档流中跳出），比普通文档流的层级稍高 ​ ​ ","date":"2020-07-29","objectID":"/css-position/:4:4","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"新属性 position ","date":"2020-07-29","objectID":"/css-position/:5:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position 取值 static 默认值，当前元素待在文档流里 relative 相对定位，升起来，但不脱离文档流 absolute 绝对定位，定位基准是相对于祖先里的非 static 祖先进行定位 fixed 固定定位，定位基准是 viewport 视口 有诈：后来 css 出的 transform 属性，使 fixed 无法相对 viewport 视口定位，这就是 CSS 的不正交 sticky 粘滞定位，不好描述直接举例 ↓↓ 特别适合做导航：正常状态会存在于文档流中，当向下滚动到 sticky 元素且 sticky 元素即将移出视口时，sticky 元素会始终保持在视口顶部，不会随文档流继续滚动。 兼容性特别差，可以在 caniuse 中查询。 （黄色是需要加前缀or部分支持） ","date":"2020-07-29","objectID":"/css-position/:5:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"经验 如果你写了 absolute，一般都得补一个 relative 如果你写了 absolute 或 fixed，一定要补 top 和 left sticky 兼容性很差，主要用于面试装逼 ​ ","date":"2020-07-29","objectID":"/css-position/:5:2","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position: relative 使用场景 用于做位移（很少用），将两个元素对齐 用于给 absolute 元素做爸爸 配合 z-index z-index: auto 默认值，不创建新层叠上下文 z-index: 0/1/2 z-index: -1/-2 经验 写 z-index: 9999 的都是 菜B 要学会管理 z-index ​ ​ ","date":"2020-07-29","objectID":"/css-position/:5:3","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position: absolute 使用场景 脱离原来的位置，另起一层，比如对话框的关闭按钮，通常是通过绝对定位实现的 鼠标提示 \u003cdiv style=\"height:100px;\"\u003e\u003c/div\u003e \u003cbutton\u003e 点击 \u003cspan class=\"tips\"\u003e提示内容\u003c/span\u003e \u003c/button\u003e \u003cstyle\u003e button{ position: relative; } button span{ position: absolute; border: 1px solid red; white-space: nowrap; bottom: calc(100% + 10px); left: 50%; transform: translateX(-50%); } button span{ display: none; } button:hover span{ display: inline-block; } /* 鼠标悬浮时，显示span */ \u003c/style\u003e 配合 z-index 经验 很多 菜B 都以为 absolute 是相对于 relative 定位的 absolute 是相对于 祖先元素中最近的一个定位元素 只要 position 属性值不是 static 的元素，就是定位元素 某些浏览器上，如果写了 absolute，不写 top / left / bottom / right 会位置错乱 （4个至少写2个） .demo{ position: absolute; top: 0; left: 0; } 善用 left: 100% （效果通常是该元素会出现在定位元素的最右边） 善用 left: 50%; + 加负 margin （负宽度的一半）：实现居中 也可以用 left: 50%; + transform: translateX(-50%); 实现，优点是不需要自己计算宽度的一半 ​ ​ ","date":"2020-07-29","objectID":"/css-position/:5:4","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"position: fixed fixed 是相对于【视口】定位的 视口，就是浏览器中普通用户能看到的部分（不包括滚动条） 使用场景 烦人的广告 回到顶部按钮 配合 z-index 经验 如果 fixed 元素所在的容器，具有某些属性，可能会导致 fixed 元素不再相对于视口定位。 .container{ position: relative; } .container \u003e .fixed{ position: fixed; left: 10px; bottom: 10px; } .container{ transform: scale(0.9); } /* 此时fixed元素就不再相对于视口定位 */ 总结：不要把 fixed 元素放到 具有 transform 属性的容器中，可能会产生奇怪的bug（不正交：调这个元素却影响了另一个元素） 手机上尽量不要用这个属性，坑很多，无穷无尽的bug。不信你搜索一下「 移动端 fixed 」 用了，可能就开始996了。一个bug可能引出10个bug ​ ​ ","date":"2020-07-29","objectID":"/css-position/:5:5","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"层叠上下文 ","date":"2020-07-29","objectID":"/css-position/:6:0","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"div分层 与 position 任意一个元素的 position 取值非 static 时，就成为了定位元素。定位元素的层级，立马超越内联文字，成为最上层元素（跑到所有元素最上层） z-index，默认是 auto 所有定位元素，会以内联文字层为底层，随着 z-index 递增，层级也会递增 如果 z-index 为负值，则层级比 background 还低 （可以无限向下，但是不能低于层叠上下文，也就是不能低于 html ，低于html还有什么意义） ","date":"2020-07-29","objectID":"/css-position/:6:1","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"什么是层叠上下文 也叫堆叠上下文 层叠上下文，会把所有元素包起来。 默认的层叠上下文，是 html 元素，html 就是会把所有元素包起来 其他元素，也会因为拥有某些属性而变成层叠上下文（导致 z-index 需要重新计算） ​ 比喻 层叠上下文对 z-index 的影响 每个层叠上下文就是一个新的小世界（作用域） 这个小世界里面的 z-index 跟外界无关 处在同一个小世界的 z-index 才能比较 JSBin 示例 a 和 b2 处于同一个层叠小世界，由 container 创造的，如果 container 没有设定 z-index，那么 a 和 b2 就同处于 html 的作用域里面，是具有可比性的。 ​ 哪些不正交的属性可以创建层叠上下文 最简单的就是定位元素设置 z-index = 0 ，就会创建一个层叠上下文 MDN文档有写 文档根元素 html 自成一个层叠上下文 z-index 不为 auto 的定位元素，会开启一个小世界（作用域） 元素的 opacity 小于1，就会创建一个层叠上下文（因为 opacity 会影响内部所有元素） position: fixed; 一定会创建层叠上下文 … 需要记忆的有： z-index=0时会创建层叠上下文 flex元素内部会形成层叠上下文 opacity 不为1 ，就会创建层叠上下文 具有 transform 的元素，会形成一个 层叠上下文 知道这些知识的面试官也不太多，不用花时间背 忘了就搜「 层叠上下文 MDN 」 你说 CSS 为什么不单独创建一个属性做这个事 例如： xxxdisabled: true; /* true就创建层叠上下文，false就不创建；css并没有这种直接功能开关*/ 这就是css的难学之处，互相交叉影响，错综复杂（不正交） ​ ​ ","date":"2020-07-29","objectID":"/css-position/:6:2","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"负 z-index 与层叠上下文的关系 JSBin 示例 .demo 的 z-index = -1，会使 demo 出现在文档流的 bg 的后面 z-index 是默认 auto 时，不具有层叠上下文 记住 ：负 z-index 逃不出 层叠上下文的小世界 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"demo\"\u003e\u003c/div\u003e \u003c/div\u003e .container{ background: rgba(0,255,255,0.5); height: 200px; position: relative; /* z-index 是默认 auto 时，不具有层叠上下文，所以添加z-index=0，创建层叠上下文 */ z-index: 0; /* 注释这行看看 */ } .container \u003e .demo{ width: 50px; height: 50px; background: red; position: absolute; z-index: -1; /* 因为上面z-index:0创建了层叠上下文，所以demo无法逃出这个小世界，不可能比container低 */ } 图一：当 container 不是层叠上下文（也就是没有 z-index: 0; ）时，demo 是 z-index = -1 存在于容器bg之下 图二：当 container 创建层叠上下文，demo 就无法跳出容器之外 ​ 总结： z-index = -1 不一定存在于容器的背景之下。当这个容器是一个层叠上下文时，就不可能存在于容器之外 ","date":"2020-07-29","objectID":"/css-position/:6:3","tags":["CSS","盒模型","文档流","position","层叠上下文"],"title":"CSS 学习笔记——定位","uri":"/css-position/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-26","objectID":"/css-layout-2/","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"CSS 布局篇（下）：Grid 布局。 ​ ","date":"2020-07-26","objectID":"/css-layout-2/:0:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"如何在两套布局中切换 一个css中，写两种布局，使用 @media 媒体查询来切换 ​ ","date":"2020-07-26","objectID":"/css-layout-2/:1:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"Grid 布局 Grid 布局兼容性并不好，在一两年内都可能不会非常广泛的使用（现在可以不用学的那么仔细） 但功能确实非常强大 flex 更擅长 一维布局，要么横着布局，要么竖着布局 一维布局用 Flex ​ ","date":"2020-07-26","objectID":"/css-layout-2/:2:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"二维布局用 Grid 以下内容主要来自 CSS Tricks 的一篇文章 A Complete Guide to Grid 查看本地代码 ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"Grid 也分 container 和 items 分别记忆 ","date":"2020-07-26","objectID":"/css-layout-2/:3:1","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"成为 container .container{ display: grid | inline-grid; } ","date":"2020-07-26","objectID":"/css-layout-2/:3:2","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"行和列 类似 table 表格（grid 被称为新时代的表格） .container{ display: grid; grid-tamplate-columns: 40px 50px auto 50px 40px; /* 每列宽度（有n个值对应生成n列） */ /* 第1列 第2列 第3列 第4列 第5列 */ grid-tamplate-rows: 25% 100px auto; /* 每行高度（有n个值对应生成n行） */ /* 第1行 第2行 第3行 */ } [1] [2] [3] … [6] 指的是线的序号。用于划分 items 的范围（具体使用见 items 部分 ） ​ 缩写 grid-template grid-template是grid-template-rows（行高）和grid-template-columns（列宽）的缩写形式。 比如说，grid-template: 50% 50% / 200px;将创建一个具有两行的网格，每一行占据50%，以及一个200像素宽的列。 /* 需要包括你的花园上部的60%，以及左侧的200像素。 */ #garden { display: grid; grid-template: 60% 40% / 200px calc(100% - 200px) ; /* 行高↑↑ 列宽↑↑ */ } #water { grid-column: 1; grid-row: 1; } /* 你的花园看起来很棒。现在，你在花园的底部留下了50像素的小路，其他的空间用来种植胡萝卜。 不幸的是，胡萝卜地的20%已经杂草丛生了，最后一次用CSS网格布局来规划你的花园吧！ */ #garden { display: grid; grid-template: calc(100% - 50px) 50px/20% 80% } ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:3","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"指定 items 布局 第一步 搭出大框架：几行几列 有几个区域，就建立几个 items \u003cstyle\u003e * { margin: 0; padding: 0; box-sizing: border-box; } .container { display: grid; grid-template-columns: 40px 50px auto 50px 40px; /* 5列（auto会撑满该行余下空间） */ grid-template-rows: 100px 300px 100px; /* 3行（每行高度累加，成为container的总高度） */ border: 3px solid red; } .a, .b, .c, .d, .e { border: 3px solid black; } \u003c/style\u003e \u003cdiv class=\"container\"\u003e \u003c!-- emmet快捷键: 键入.a+.b+.c+.d ——\u003e tab 创建出5个div，class分别为abcde --\u003e \u003cdiv class=\"a\"\u003e\u003c/div\u003e \u003c!--第1行, 第1列--\u003e \u003cdiv class=\"b\"\u003e\u003c/div\u003e \u003c!--第1行, 第2列--\u003e \u003cdiv class=\"c\"\u003e\u003c/div\u003e \u003c!--第1行, 第3列--\u003e \u003cdiv class=\"d\"\u003e\u003c/div\u003e \u003c!--第1行, 第4列--\u003e \u003cdiv class=\"e\"\u003e\u003c/div\u003e \u003c!--第1行, 第5列--\u003e \u003c/div\u003e container 中的子元素，与列数一一对应。且默认只占据第一行。所以添加 border 后 效果如下图所示 第二步 给每个 item 指定区域、设置范围 grid-xxx-start / grid-xxx-end grid-row-start、grid-row-end grid-column-start、grid-column-end .a{ grid-row-start: 1; /* a从哪条线开始 */ grid-row-end: 3; /* a到哪条线结束 */ /* 指定的两条【线】的中间区域，就是a所占的【行】 */ grid-column-start: 1; grid-column-end: 2; /* 指定的两条【线】的中间区域，就是a所占的【列】 */ } grid-row / grid-column grid-row：grid-row-start / grid-row-end; grid-column: grid-column-start / grid-column-end; /* 上面写法，可以缩写成 ↓ */ .a{ grid-row: 1/3 ; grid-column: 1/2 ; } grid-area grid-area属性接受4个由’/‘分开的值：grid-row-start, grid-column-start, grid-row-end, 最后是 grid-column-end。 ​ 起始行 ↑↑ 起始列 ↑↑ 终止行 ↑↑ 终止列 ↑↑ /* 再进一步缩写 */ .a{ grid-area: 1/1/3/2 ; } 最终效果 ​ 可以给线起名字 但没必要，代码太麻烦。就按照序号就很好 取名结果：如图↘ item可以设置范围，直接用线的名称 .item-a{ grid-column-start: 2; grid-column-end: five; grid-row-start: rowl-start; grid-row-end: 3; } ​ ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:4","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"fr ：单位【份】 容器属性 全称 free space 自由空间 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"a\"\u003ea\u003c/div\u003e \u003cdiv class=\"b\"\u003eb\u003c/div\u003e \u003cdiv class=\"c\"\u003ec\u003c/div\u003e \u003cdiv class=\"d\"\u003ed\u003c/div\u003e \u003cdiv class=\"e\"\u003ee\u003c/div\u003e \u003c!-- \u003cdiv class=\"f\"\u003ef\u003c/div\u003e --\u003e \u003c/div\u003e \u003cstyle\u003e * {margin: 0;padding: 0;box-sizing: border-box;} .container { display: grid; grid-template-columns: 1fr 1fr 1fr; /* fr=份，与flex的份类似：共3列每列占1份，也就是均分 */ grid-template-rows: 1fr 1fr; /* 共2行，每行占1份，均分 */ border: 3px solid red; min-height: 500px; } .a, .b, .c, .d, .e { border: 3px solid black; } .e{ grid-column-start: 2; /* 再单独定义e版块占两列空间 */ grid-column-end: 4; background-color: #ccc; } \u003c/style\u003e ​ 变形 .container { display: grid; grid-template-rows: 1fr 3fr; /* 2行：第2行占3份 */ grid-template-columns: 1fr 2fr 1fr; /* 3列：第2列占2份 */ ... } ​ 平均布局 grid-gap fr 主要用于实现平均布局 容器属性：grid-gap 用于控制间距 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c!-- 应用下面grid布局样式，可实现任意添加.image，都可以实现一排4个、间距12px的布局 --\u003e \u003c/div\u003e \u003cstyle\u003e *{ margin: 0; padding: 0; box-sizing: border-box; } .container{ margin-right: auto; margin-left: auto; margin-top: 30px; outline: 5px solid red; width: 800px; /* 开启grid布局 */ display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; /* 格子布局：1排4个 */ grid-template-rows: 1fr 1fr; grid-gap: 12px; /* 计算每项边距，自动计算位置，四边上的会紧贴 */ } .container\u003ediv{ border: 2px solid black; background-color: #ccc; height: 191px; /* 宽800px，1排4个产品，计算得出：每个产品可占宽191px，则间距为12px */ width: 191px; } \u003c/style\u003e ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:5","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"分区 grid template-areas 名字很长，但非常好用 \u003cdiv class=\"container\"\u003e \u003cheader\u003eheader\u003c/header\u003e \u003caside\u003easide\u003c/aside\u003e \u003cmain\u003emain\u003c/main\u003e \u003cdiv class=\"ad\"\u003ead\u003c/div\u003e \u003cfooter\u003efooter\u003c/footer\u003e \u003c/div\u003e \u003cstyle\u003e .container { min-height: 100vh; /* 最小高度为占满整个屏幕 */ display: grid; grid-template-rows: 60px auto 60px; /* 行高 */ grid-template-columns: 190px auto 100px; /* 列宽 */ /* 布局：以版块名称直接写出布局、位置 */ grid-template-areas: \"header header header\" \"aside main ad\" \". footer .\"; /* 空格通常会写一个不存在的名称，如【.】点 */ grid-gap: 10px; /* 设置空隙 */ } .container \u003e * { border: 2px solid red } .container \u003e header {grid-area: header;} /* 版块命名 */ .container \u003e aside {grid-area: aside;} .container \u003e aside {grid-area: aside;} .container \u003e main {grid-area: main;} .container \u003e .ad {grid-area: ad;} .container \u003e footer {grid-area: footer;} \u003c/style\u003e grid-gap 设置间距 grid-gap：通用间距 grid-row-gap : 行间距 grid-column-gap： 列间距 .container{ ... grid-gap: 10px; } .container{ ... grid-row-gap: 20px; /* 行间距 */ grid-column-gap: 10px; /* 列间距 */ } ​ ​ ","date":"2020-07-26","objectID":"/css-layout-2/:3:6","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"实践 ","date":"2020-07-26","objectID":"/css-layout-2/:4:0","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"布局 Grid 尤其适合不规则布局 ","date":"2020-07-26","objectID":"/css-layout-2/:4:1","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"经验 等到 Grid 普及了，前端对CSS的要求会进一步降低 目前你简单尝试一下 Grid 就可以了 ","date":"2020-07-26","objectID":"/css-layout-2/:4:2","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"示例 第一步：根据设计图，划分行列需求，给每块区域命名 第二步：书写【容器】样式 \u003cdiv class=\"container\"\u003e \u003cheader\u003eheader\u003c/header\u003e \u003cdiv class=\"image bigImage\"\u003ebig\u003c/div\u003e \u003cdiv class=\"image smallImage\"\u003esmall\u003c/div\u003e \u003cdiv class=\"image smallImage\"\u003esmall\u003c/div\u003e \u003cdiv class=\"image smallImage\"\u003esmall\u003c/div\u003e \u003cdiv class=\"image middleImage\"\u003emiddle\u003c/div\u003e \u003cdiv class=\"image middleImage\"\u003emiddle\u003c/div\u003e \u003cdiv class=\"image middleImage\"\u003emiddle\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e * { margin: 0; padding: 0; box-sizing: border-box; } .container { display: grid; grid-template-rows: 50px 200px repeat(4, 100px); /* 重复4个120px，可以使用repeat()缩写语法 */ grid-template-columns: 240px 240px; grid-template-areas: \"header header\" \"big mid1\" \"big mid2\" \"sm1 mid2\" \"sm2 mid3\" \"sm3 mid3\"; } \u003c/style\u003e 第三步：指定每项的名称（所属） .container \u003e * { border: 2px solid black; } .container \u003e header {grid-area: header;} .container \u003e .image:nth-child(2) {grid-area: big;} .container \u003e .image:nth-child(3) {grid-area: sm2;} .container \u003e .image:nth-child(4) {grid-area: sm3;} .container \u003e .image:nth-child(5) {grid-area: mid1;} .container \u003e .image:nth-child(6) {grid-area: mid2;} .container \u003e .image:nth-child(7) {grid-area: mid3;} ​ ​ ","date":"2020-07-26","objectID":"/css-layout-2/:4:3","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"游戏 https://cssgridgarden.com/#zh-cn 忘记用法时，可以通过游戏来快速回忆 ​ grid-area grid-area属性接受4个由’/‘分开的值：grid-row-start, grid-column-start, grid-row-end, 最后是 grid-column-end。 ​ 起始行 ↑↑ 起始列 ↑↑ 终止行 ↑↑ 终止列 ↑↑ #garden { display: grid; grid-template-columns: 20% 20% 20% 20% 20%; grid-template-rows: 20% 20% 20% 20% 20%; } #water-1 { grid-area: 1 / 4 / 6 / 5; } #water-2 { grid-area: 2 / 3 / 5 / 6; } ​ order 如果网格项不是以grid-area、grid-column、grid-row 等显示的，它们会自动按照它们在源程序中出现的位置摆放。同样我们也可以使用order属性来重写它的顺序，这也是网格布局优于表格布局的好处之一。 默认情况下，所有的网格项的order都是0，但是顺序也可以被任意设置为正数或者负数，就像z-index一样。 ​ fr 与 px 结合 #garden { display: grid; grid-template-columns: 50px 1fr 1fr 1fr 50px; grid-template-rows: 20% 20% 20% 20% 20%; } #water { grid-area: 1 / 1 / 6 / 2; } #poison { grid-area: 1 / 5 / 6 / 6; } #garden { display: grid; grid-template-columns: 20% 20% 20% 20% 20%; grid-template-rows: 1fr 1fr 1fr 1fr calc(100% - 50px); } #water { grid-column: 1 / 6; grid-row: 5 / 6; } ","date":"2020-07-26","objectID":"/css-layout-2/:4:4","tags":["CSS","Grid"],"title":"CSS 学习笔记——布局（下）","uri":"/css-layout-2/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-25","objectID":"/css-layout-1/","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"CSS 布局篇（上）： Float 布局、Flex 布局 。 ​ ​ Float 示例代码 https://jsbin.com/vobenim/edit?html,css,output Flex 示例代码 https://jsbin.com/biluwan/edit?html,css,output Flex 青蛙游戏 https://flexboxfroggy.com/#zh-cn ​ ","date":"2020-07-25","objectID":"/css-layout-1/:0:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局是什么 把页面分成一块一块，按左中右、上中下等排列 ","date":"2020-07-25","objectID":"/css-layout-1/:1:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局分类 两种 固定宽度布局，一般宽度为960/1000/1024px （淘宝pc） 不固定宽度布局，主要靠文档流的原理来布局（常用在移动端、响应式，会跟随设备宽度变化） 还记得吗 文档流本来就是自适应的，不需要加额外的样式 第三种布局 响应式布局 意思就是PC上固定宽度，手机上不固定宽度 也就是一种混合布局 ​ ","date":"2020-07-25","objectID":"/css-layout-1/:1:1","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局的两种思路 从大到小 先定下大局 然后完善每个部分的小布局 从小到大 先完成小布局 然后组合成大布局 两种均可 新人推荐用第二种，因为小的简单 老手一般用第一种，因为熟练有大局观 ​ ","date":"2020-07-25","objectID":"/css-layout-1/:1:2","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"布局需要用到哪些属性 不多哔哔，直接给你所有套路 以前经常说 DIV+CSS 布局，但是现在已经无意于用 DIV 了，就说用 CSS 布局 main、header、footer、nav、aside … 这些标签的出现，已经可以代替 div 了 需要兼容 IE9 吗 不用，只做手机页面（闲鱼），阿里巴巴在顺应手机时代 很老的手机产品要兼容吗？兼容最新浏览器吗？ ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:1:3","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"Float 布局 float 主要是针对 IE 的，而现在公司基本不需要兼容 IE6789。 ","date":"2020-07-25","objectID":"/css-layout-1/:2:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"步骤 子元素上加 float: left 和 width 在父元素上加 .clearfix（清除浮动的影响） \u003c!-- header中没有文档流元素，子元素都浮动了(脱离文档流) ，所以header的高度为0 --\u003e \u003c!-- 添加 clearfix 后，可以清除浮动的影响 --\u003e \u003cheader class=\"clearfix\"\u003e \u003cdiv class=\"logo\"\u003eXDML\u003c/div\u003e \u003cnav\u003e导航\u003c/nav\u003e \u003c/header\u003e \u003cstyle\u003e .logo{float: left;...} /* 脱离文档流 */ nav{float: left;...} \u003c/style\u003e .clearfix:after{ content: ''; display: block; clear: both; } /* 请背过 clearfix 的写法 */ ","date":"2020-07-25","objectID":"/css-layout-1/:2:1","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"经验 有经验者会留一些空间或者最后一个不设 width （或者可以给个 max-width: xxxpx;） 不需要做响应式，因为手机上没有IE，而这个布局是专门为 IE 准备的 IE6/7 存在双倍 margin bug（给浮动元素设置 margin: 10px 在 IE6/7 中实际距离会变成 margin: 20px 的效果） 解决办法有两个 一是将错就错，针对 IE6/7 把 margin 减半 .logo{ float: left; margin-top: 10px; /* 其他浏览器 只能识别这句，无法识别下面属性 */ _margin-top: 5px; /* IE6/7在属性前加 下划线 或 星号 都能识别 */ } 二是神来一笔，再加一个 display: inline-block .logo{ float: left; margin-top: 10px; display: inline-block; /* 微软说：IE6/7遇到margin乘2的bug，就添加这句 */ } 为什么可以这样？你问我，我问谁… ​ ","date":"2020-07-25","objectID":"/css-layout-1/:2:2","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"实践 不同布局 用 float 做两栏布局（如顶部条） 用 float 做三栏布局（如内容区） 用 float 做四栏布局（如导航） 用 float 做平均布局（如产品列表展示区）—— 负margin 曾经淘宝的前端发明了双飞翼布局，不要学，已过时代码 经验 加上头尾，即可满足所有PC页面需求 手机页面傻子才用float float要程序员自己计算宽度，不灵活 float用来应付IE足以 技术总结 JSbin 演示，总结如下 outline 现象描述：计算宽度时，内部3个元素的宽度和=300，外层容器=300，但是还会把最后一个元素挤下去，说明子元素的宽度超出容器的宽度。 原因可能是，虽然设定容器宽度为 300，但是容器添加了边框 border : 1像素，所以容器的内容区域的宽度实际只有 298 px。(仅限 border-box 情况) 解决： 把容器的边框删了 改用 outline: 1px solid red; outline 是在外侧的，不占内部区域，但是outline 样式上会有点奇怪 改用 背景颜色 标识区域 居中 /* margin: 0 auto; 下面两句的写法更好，这句还覆盖了margin上下的距离，css原则是不要写多余的 */ margin-left: auto; margin-right: auto; 只有==块级元素==，才能使用 margin … auto，实现居中。 float实现平均布局 添加一个 父元素 x ，进行 ==负margin== 操作（这个词基本都是高手才懂） 注意：添加 父元素后，clearfix 的位置也需要相应移动到，浮动元素的直属父级上 \u003cdiv class=\"imageList\"\u003e \u003cdiv class=\"x clearfix\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c!--\u003cdiv class=\"image\"\u003e\u003c/div\u003e--\u003e \u003c!--\u003cdiv class=\"image\"\u003e\u003c/div\u003e--\u003e \u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .imageList { outline: 1px solid green; width: 800px; margin-left: auto; margin-right: auto; margin-top: 10px; } .imageList \u003e .x \u003e .image { width: 191px; height: 191px; background-color: #555; border: 1px solid red; float: left; margin-bottom: 10px; margin-right: 12px; } .imageList \u003e .x { margin-right: -12px; } \u003c/style\u003e ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:2:3","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"缩写 html、css （√） navigator —\u003e nav （√） 不能缩写未经约定、达成统一的单词 content —\u003e cnt （x） container 也可以缩写成 cnt 容易误会，所以不要用 ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:3:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"Flex 布局 教程（来自 CSS Tricks) 把教程过一遍，然后忘掉 完成 Flex青蛙游戏 开始用flex！ ","date":"2020-07-25","objectID":"/css-layout-1/:4:0","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"容器 container 有哪些属性 container ：表示容器，一般用于做父元素 items ：表示容器里面的、直接的子元素，就称为 items（项） 以下都是 container 的样式 ​ 让一个元素变成 flex 容器 只有下面两种写法： .container{ display: flex; /* 或 display: inline-flex; */ } ​ 改变 items 流动方向（主轴） 默认，所有项都会挤在主轴，主轴占满会平均压缩每项宽度，以保证在主轴存放下所有项 .container{ display: flex; border: 1px solid red; flex-direction: row; /* 【默认值】横向（从左到右） */ flex-direction: column; /* 纵向（从上到下） */ flex-direction: row-reverse; /* 横向反向（从右到左） */ flex-direction: column-reverse; /* 纵向反向（从上到下） */ } ​ 改变折行 .container{ display: flex; border: 1px solid red; flex-direction: row; /* 默认横向 */ flex-wrap: wrap-reverse; /* 反向折行, 效果如下图，基本没用 */ } flex-direction和flex-wrap两个属性经常会一起使用，所以有缩写属性flex-flow。这个缩写属性接受两个属性的值，两个值中间以空格隔开。 举个例子，你可以用flex-flow: row wrap去设置行并自动换行。 ​ ​ 主轴对齐方式 默认主轴是 横轴 除非你改变了 flex-direction 方向 .container { justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly; } space-around： 每项左右两边的空间一样 space-evenly：每项间距一样 space-between：把空间放到中间，元素分布两边 ​ 次轴对齐 默认次轴是 纵轴 .container{ align-items: stretch [默认值] | flex-start | flex-end | center | baseline（不需要） } stretch【默认值】 默认所有 items 的高度 与 高度最高的 item 保持一致 如下图，3个 item 都与 2 号 item 一样高 flex-start flex-end center ​ 多行分布 很少用到 默认平均分 ： align-content: stretch (如图) .container{ display: flex; border: 1px solid red; flex-wrap: wrap; height：400px； align-content: flex-start; /* 全部集中到顶部 */ align-content: flex-end; /* 全部集中到底部 */ align-content: center; /* 全部集中到中间 */ align-content: space-between; align-content: space-around; } ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:4:1","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"flex item 有哪些属性 以下都是 item 的属性 item 上加 order 默认 order 为 0 指定 order 后，item 会按照 order 顺序从小到大排列（可以指定为负数） \u003cdiv class=\"container\"\u003e \u003cdiv class=\"item\"\u003e1\u003c/div\u003e \u003cdiv class=\"item\"\u003e2\u003c/div\u003e \u003cdiv class=\"item\"\u003e3\u003c/div\u003e \u003cdiv class=\"item\"\u003e4\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .container{ display: flex; border: 1px solid red; } .item{ width:50px; height:50px; border: 1px solid green; } .item:first-child{ order: 100; } /* 最后 */ .item:nth-child(2){ order: 2; } .item:nth-child(3){ order: 3; } .item:last-child{ order: 1; } /* 最前 */ \u003c/style\u003e ​ item 上加 flex-grow 用于分配多余的空间（控制变胖） flex-grow： 默认为 0. 就是 item 宽度由内容撑开，没内容的话宽度就是0，不会占用多余的空间 给 item 设置 flex-grow 值为 n （\u003e0），就是将分配多余空间给当前 item 占 n 份。 如果一共有3个item，那就平均分配多余空间，每个 item 占 n/3. 当我们不给 item 设置宽度时，item 的宽度是能有多窄有多窄（宽度由内容撑开） 实现宽度能有多宽有多宽，就给 item 添加 flex-grow .item{ flex-grow: 1; /* 每一个 item 平均分配宽度，来占满多余的空间（不是占满整行空间） */ } 需求：从多余的空间中，给2,3 的宽度占 2 份; 给 1,4 占 1 份 空间 .container{ display: flex; border: 1px solid red; } .item{ height:50px; border: 1px solid green; } .item:first-child{ flex-grow: 1; } .item:nth-child(2){ flex-grow: 2; } .item:nth-child(3){ flex-grow: 2; } .item:last-child{ flex-grow: 1; } 经验 当 3 栏布局，如下 只给【导航】设置 flex-grow: 1（实现导航宽度的响应式），logo、头像固定宽度 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"item\"\u003elogo\u003c/div\u003e \u003cdiv class=\"item\"\u003e导航\u003c/div\u003e \u003cdiv class=\"item\"\u003e头像\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .container{ display: flex; border: 1px solid red; } .item{ height:50px; border: 1px solid green; } .item:nth-child(2){ flex-grow: 1; } \u003c/style\u003e ​ flex-shrink 控制如何变瘦 当界面不断变窄，无法存放每项的给定宽度时，每项都需要变窄，flex-shrink 就控制谁瘦的多，谁瘦的少 默认是1（所有item平均收缩，要缩一起缩） 一般写 flex-shrink: 0; 防止变瘦（被设置为 0 的这一项，就算空间不够时，也不会收缩。要缩别找我） .item{ width: 150px; /* 合计宽度最小450px */ height:50px; border: 1px solid green; flex-grow: 1; /* 每项会均分多余空间 */ } .item:first-child{ flex-shrink: 1; } .item:nth-child(2){ flex-shrink: 50; /* 2 的收缩比例较大 */ } .item:last-child{ flex-shrink: 1; } 当宽度缩小达到450px以内，每项宽度不足，此时每项会开始收缩， flex-shrink 值越大，则收缩的越大，flex-shrink 值越小，越不会受到收缩的影响 如下图，宽度收缩450px以内，【导航】最先开始发生了较大的收缩，因为设定了较大的 flex-shrink 值 【logo】和【头像】版块，基本不收缩 ​ flex-basis 控制基准宽度 用法： 默认是 auto（与 item 的 width 值保持一致） 指定宽度：flex-basis: 100px; 相当于指定了 width 值 这个属性比较迷：不是很重要的属性 可以直接用 width 来代替这个属性 ​ 缩写成 flex flex 相当于 flex-grow flex-shrink flex-basis 习惯上我一般不写缩写，容易记错位置 flex 只有以下 4 种形式的写法 .item:first-child{ flex: 1 1 100px; /* grow-1，shrink-1，宽100px */ } .item:nth-child(2){ flex: 1 100 100px; /* grow-1，shrink-100，宽100px */ } .item:last-child{ flex: 1 1 100px; /* grow-1，shrink-1，宽100px */ } 上述，3个item，宽度为100px grow撑开时每个item平均占满所有多余空间 宽度不足时，2 号主要进行收缩 ​ align-self 定制 align-items 用的很少 默认在垂直方向上，都是顶端对齐的 align-self 可以让某一个 item，在垂直方向上，特例独行的展示（指定一个特别的对齐方式） 实现：单独设置，最后一个 item 底部对齐 ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:4:2","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"重点 记住这些代码 display: flex 开启flex布局 flex-direction: row / column 主轴是横向还是纵向 flex-wrap: wrap 空间不足时是否换行 just-content: center / space-between 主轴方向上的对齐方式：居中/分开 align-items: center 次轴方向上的对齐方式：居中，顶，底 工作中基本只用这些 ​ ​ ","date":"2020-07-25","objectID":"/css-layout-1/:4:3","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"实践 不同布局 用 flex 做两栏布局 用 flex 做三栏布局 用 flex 做四栏布局 用 flex 做平均布局 —— 负 margin 用 flex 组合使用，做更复杂的布局 JSBin 代码 经验 永远不要把 width 和 height 写死，除非特殊说明 PC端通常可以写死。移动端不能写死，需要适配各种尺寸：平板/手机… 用 min-width / max-width / min-height / max-height flex 可以基本满足所有需求 flex 和 margin-xxx : auto 配合有意外的效果——例：左右布局 ​ 什么叫写死 写死 width:100px 不写死 width: 50% max-width: 100px width: 30vw （屏幕宽度的百分之30） min-width: 80% 特点：不使用 px，或者加 min max 前缀 css 最忌讳把宽高写死 ​ 技术总结 左右布局 表示两栏布局-贴左、贴右：可通过以下两句中的任意一句来实现 margin-xxx: auto 更灵活 \u003cstyle\u003e .header { display: flex; border:1px solid black; /*justify-content: space-between; ---------------二者任选其一----------------------*/ } ul { /* margin-left: auto; -------------------------二者任选其一【推荐】------------------*/ display: flex; border: 1px solid green; } ul \u003e li { border: 1px solid red; } \u003c/style\u003e \u003cheader class=\"header\"\u003e \u003cdiv class=\"logo\"\u003e \u003cimg alt=\"\" src=\"./logo.png\"\u003e \u003c/div\u003e \u003cul\u003e \u003cli\u003e首页\u003c/li\u003e \u003cli\u003e课程\u003c/li\u003e \u003cli\u003e优惠\u003c/li\u003e \u003cli\u003e关于\u003c/li\u003e \u003c/ul\u003e \u003c/header\u003e 产品展示格子布局 失败方案 \u003cdiv class=\"imageList\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c/div\u003e .imageList{ border: 1px solid red; width: 800px; margin-right: auto; margin-left: auto; margin-top: 10px; display: flex; flex-wrap: wrap; justify-content: space-between; /* 会导致产品不足数的行 --\u003e 错位 */ } .image{ width: 191px; height: 191px; background-color: #ccc; margin-bottom: 10px; border: 1px solid green; } ​ 负margin方案 \u003cdiv class=\"imageList\"\u003e \u003c!-- 可以命名为 inner 或者 wrapper --\u003e \u003cdiv class=\"x\"\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003cdiv class=\"image\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e .imageList { outline: 1px solid red; /* 注意：边框去掉或者放在外面，否则占据宽度 */ width: 800px; margin-right: auto; margin-left: auto; margin-top: 10px; } .imageList \u003e .x { display: flex; flex-wrap: wrap; margin-right: -12px; /* 负margin */ } .image { width: 191px; height: 191px; background-color: #ccc; margin-bottom: 10px; border: 1px solid green; margin-right: 12px; /* 每个的间距 */ } ","date":"2020-07-25","objectID":"/css-layout-1/:4:4","tags":["CSS","float","flex"],"title":"CSS 学习笔记——布局（上）","uri":"/css-layout-1/"},{"categories":["CSS 入门"],"content":"CSS is A*s***e!! 🥴 🤢 🤮","date":"2020-07-25","objectID":"/css-basic/","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"熬夜总结 – CSS 基础篇 。 ","date":"2020-07-25","objectID":"/css-basic/:0:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 的历史 ","date":"2020-07-25","objectID":"/css-basic/:1:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 是谁发明的 李爵士的挪威同事赖先生，首先提出 CSS Håkon Wium Lie （挪威语） ","date":"2020-07-25","objectID":"/css-basic/:1:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"赖先生的生平 生平 1991年获得MIT媒体实验室视觉研究理学硕士学位 1994年提出CSS概念而闻名 1999年任Opera的CTO（首席技术官，不分前端后端、只要是技术就负责） 2005年他写公开信给比尔盖茨问为什么IE不支持Web标准，盖茨说IE 7马上发布，他写了 Acid2 用来验证 2006年通过了博士论文答辩 2006年他倡议 Web 网页应使用通用字体格式 2007年他倡议浏览器可以支持video标签 观点 微软的IE常常成为他的批评对象 他也是Web打印概念的倡导者，用HTML和CSS写书 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 的牛 X 之处在哪？ CSS（Cascading Style Sheets）：==层叠==样式表 样式层叠 可以多次对同一选择器进行样式声明 选择器层叠 可以用不同选择器对同一个元素进行样式声明 文件层叠 可以用多个文件进行层叠 这些特性使得 CSS 极度灵活 这也为 CSS 后来被吐槽留下了隐患 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:3","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 的版本 ⭐目前使用最广泛的css版本：css 2.1 版本 2004-2011年间不断更新，没有具体发布时间 版本 时间 重点 CSS 1 1996年 不用管 CSS 2 1998年 添加定位、z-index、media，不用管 **CSS 2.1 ** 2004~2011年 使用最广泛的版本（IE支持） CSS 3 1999年开始起草 现代版本，分模块（IE 8 部分支持） CSS 4* 分模块升级 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:4","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"浏览器对CSS的支持（兼容性） 怎么知道，哪些浏览器，支持哪些特性？ 方法一：几十种浏览器全部跑一遍 方法二：使用 caniuse.com 红色：不支持flex 黄色：部分支持 绿色：完全支持 caniuse.com 使用方法 请收藏此网站 输入你关心的样式，比如 border-radius 或 filter 查看大部分浏览器的支持情况 如果想看更多，点击 Show All 下方会详细说明兼容 bug 有哪些（翻译成中文） 这个网站是怎么运作的 网站主一开始自己测试了一部分浏览器 社区的前端工程师帮助测试各种各样的浏览器 UC 浏览器和 QQ 浏览器当然主要是中国开发者测试 大家把测试结果提交到 GitHub 上 这就是开发者社区的力量、 什么是社区？ 社区不是一个准确存在的概念，大家你帮我我帮你，互相学习，互相分享，就形成了社区。 是一种弱联系。 社区通过汇集的力量将事情给解决好 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:1:5","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"CSS 是艺术 就像画画、折纸 你需要用感性思维来理解 CSS ","date":"2020-07-25","objectID":"/css-basic/:2:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"不要用理性思维 即不要问「为什么会这样」，而是说「原来是这样」 浏览器说是怎么样，就是怎么样 当然有极少情况是浏览器出错了 ","date":"2020-07-25","objectID":"/css-basic/:2:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"为什么 color: red 能让字变红 不要问「为什么」 要说「原来是这样」 所见即所学 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:2:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"体系化学习 有生之年都不太可能把css所有知识学完，因为它太、多、了。只文档可能就有几百页，目录全看一遍都很累：css标准文档（google 搜 css spec） 不是把所有知识都学完，而是在一个新知识点到来的时候，马上学会它。这才是学习CSS体系化最重要的手段 体系化学习 CSS 和 HTML 的过程完全一致 ","date":"2020-07-25","objectID":"/css-basic/:3:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"学一门语言必须学会什么 语法（怎么写代码） css 语法非常简单 [如何调试](#如何调试 CSS)（怎么知道自己代码写错了） node-w3c-validator -i index.html // 查错 在哪查资料（其实就是为了抄代码） MDN 标准制定者是谁 尝试所有方法仍不能解决问题的话，就必须看标准文档了 ","date":"2020-07-25","objectID":"/css-basic/:3:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"如何学 Copy - 抄文档、抄老师 Run - 放在自己的机器上运行成功 Modify - 加入一点自己的想法，然后重新运行 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"语法 超级简单 语法一：样式语法 选择器 { 属性名: 属性值; /*注释*/ } 注意事项 不学常态，学变态 所有符号都是英文符号，如果写错了，浏览器会警告（样式会被划掉） 区分大小写，a 和 A 是不同的东西（特别是大小写很相似的字母，很容易错） 没有 // 注释，只有 /* 注释 */ 这种形式 最后一个分号可以省略，但建议不要省略 任何地方写错了，都不会报错，浏览器会直接忽略 那我怎么知道自己写没写错呢？一会说 语法二：at 语法 @charset \"UTF-8\"; /* 声明字符编码，必须放在第一行 */ @import url(2.css); /* 导入一个额外的css文件 */ @media (min-width: 100px) and (max-width: 200px) { /* 媒体查询 */ 语法一 } 注意事项 @charset 必须放在第一行 前两个 at 语法必须以分号 ; 结尾 @charset \"UTF-8\"; @import url(2.css); @media 语法会单独教学 charset 是字符集的意思，但 UTF-8 是字符编码 encoding（并不是字符集），这是历史遗留问题 最早只有 ASCII 这一种字符集（英文），这个字符集的编码形式就是它自己 后来中国人发现 ASCII 不能表示中文，所以就发明了 GB2312，由中国国家标准局（国标局）发行，GB 就是国家标准的缩写。 GB2312 是一个支持中文简体汉字的字符集。它对应的编码形式，是它自己 后来日本、韩国的文字，我们的 GB2312 也表示不了。国标局还没开始动作，微软先一步发明 GBK，k表示扩展。GBK 可以同时表示 中文、日文、韩文（CJK） 后来中国发现还需要和更多国家建立联系，国标库根本就搞不定，就有一个叫 Unicode 的组织，给全球制作了一个字符集，叫做 Unicode（万国码）。这个码包含非常多国家，特别长，所以必须采用不同的编码形式。 编码形式包含：UTF8/UTF16/UTF32 （选择任意一个即可） 从 Unicode开始字符集和编码形式就不统一了，之前都是统一的 html 1993年左右发明，css 发明于1996年左右，Unicode在1996年之后发明。 charset 原本后面写一个【字符集的名字】，写 GBK/GB2312 ….这种，对应编码形式也是同名的。但是Unicode发明后，字符集名称和编码形式不统一了，所以我们为了表明自己使用的是 Unicode 的那种编码形式，就只能将Unicode的编码形式，写在表示字符集的 charset 的位置。 ==【这就是这个历史问题的发展经过】== 字符集 编码形式 ASCII ASCII GB2312 GB2312 GBK GBK Unicode UTF8/UTF16/UTF32 问： @charset “UTF-8” 指的是什么？ 回答 ：字符集（charset） 是错误的 “UTF-8”指定的不是字符集 charset，而是指定的【 文件编码 】 虽然charset本身是字符集的意思，但后面的 utf-8 指的是 Unicode字符集的**【编码形式】**的一种。这是一个历史遗留问题 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:3","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"如何调试 CSS 方法 使用 W3C 验证器（在线 / 命令行工具）不用试了 node-w3c-validator -i index.html // 可能需要先安装java环境，才能运行 node-w3c-validator Java环境安装、配置 使用 VSCode 看颜色 使用 WebStorm 看颜色 使用开发者工具看警告 浏览器预览页面，右键检查，查看Element中，一般会给出问题警告。有问题的css会被划删除线 如何使用开发者工具 找到你脑中的标签 看它是否有选择器 看它的样式是否被划掉 看它的样式是否有警告 Border 调试法 步骤 怀疑某个元素有问题 就给这个元素加 border border 展示效果没出现？说明选择器错了或者语法错了 通常是 border 上面的代码有问题（因为上面代码执行遇到问题，就会影响下面样式的输出） border 出现了？看看边界是否符合预期 说明选择器没有错、border以上的代码没有错 可以继续往下测试、查找错误 bug 解决了才可以把 border 删掉 记住 CSS 的 border 调试法 就相当于 JS 的 log 调试法 我会再每节课重复这个调试法 ​ 新人常见错误 低级错误 选择器拼写错误 属性名拼写错误 属性值拼写错误 大小写错误 没写分号 中文冒号 没写反花括号 没加单位 非低级错误 没有非低级错误 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:4","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"在哪查资料 网站推荐 Google 搜索关键词时加 MDN CSS tricks（英文），专门收集 css 小技巧的网站 使用方式：在google 搜 [技术名词] css tricks https://css-tricks.com/snippets/css/a-guide-to-flexbox/ 张鑫旭的博客：可能是中国花时间最多来学css的人 使用方式：搜 [技术名词] 张鑫旭 书籍推荐 不推荐买任何书 CSS 和 HTML 一样，以练为主 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:5","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"在哪搜练习素材 PSD Freepik 搜索 PSD web 英文（下载免费的 psd） 如果下载慢，就把域名加入翻墙插件 中文免费 PSD 网站较少，需要多搜一下 365PSD 里的 UI 套件还行 效果图（不提供下载） dribbble.com 顶级设计师社区 可以用肉眼模仿它 商业网站 直接模仿你常去的网站 ​ ","date":"2020-07-25","objectID":"/css-basic/:3:6","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"不要沉迷临摹 每个类型的临摹一两个即可 PC 网站、手机网站、UI 套件 再多无益 ​ ","date":"2020-07-25","objectID":"/css-basic/:3:7","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"遇到查不到的问题，怎么办 遇到查不到的问题，应该去哪里查文档？ ——找标准制定者 李爵士、赖先生 W3C 搜索 CSS spec 可以找到 CSS 最新标准 没人能看完它 你可以看看 CSS 2.1 标准的中文版 正确学 css ，应该是遇到问题，再查资料 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:3:8","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"基本概念 ","date":"2020-07-25","objectID":"/css-basic/:4:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"要理解几个重要的概念 文档流 Normal Flow 块、内联、内联块 margin 合并 两种盒模型（border-box 更符合人类思维） ​ ","date":"2020-07-25","objectID":"/css-basic/:4:1","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"文档流 文档流的英文名称叫做 Normal Flow 文档流方向：默认，内联元素从左到右，块级元素从上到下 emmet: span{第$个span元素}*6 + tab ​ ","date":"2020-07-25","objectID":"/css-basic/:4:2","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"块、内联、内联块 将元素分为：内联元素、块级元素。是一种已经过时的分法。 在新的 HTML5 标准中，元素不分内联、块级。所有元素都可以是内联元素，所有元素都可以是块级元素。 看样式：如果 display:inline， 就是内联元素。如果 display: block 就是块级元素。 内联块：不会出现如【内联元素首尾可以在不同行】的情况，内联块会同行展示，但是又保有 block 的一个特点：不会跨两行（这就是inline和inline-block在流动方向上相似又稍微不同的点） 流动方向 inline 元素从左到右，到达最右边才会换行 block 元素从上到下，每一个都另起一行 inline-block 也是从左到右 宽度 inline 元素 宽度为 内部 inline 元素的和。 不接受用 width 指定宽度。加了也不变化 不要在 inline元素内部，再写 block 元素。它的计算可能乱套的，出现后果自负 block 元素 默认自动计算宽度，可用 width 指定 width: 200px; （200像素）、width: 20em; （20个字宽） 不指定宽度，宽度默认是 width: auto。不是 width: 100%，是能有多宽就占多宽，最大可以占 100% 如下图，每个div元素都有边框，【div默认宽度】=100%-边框宽度。如果【设置div宽度为100%】，那么相当于，整行宽度= div宽度100%+边框宽度，所以会多出边框宽度的一小块位置 ==经验之谈==：给任何元素都尽量，不要设置 width: 100% 的样式。大部分情况写了就等于 bug。 inline-block 元素 结合前两者特点，可用 width 默认情况，与 inline 一致 但是又可以用 width 指定宽度，这一点又与 block 一致 高度 inline 高度 由 line-height（行高） 间接确定，跟 height 无关 （设置height无效） 如下图，为什么外层的 绿div 没有包住 红span、被撑高呢？ 因为 span 的高度，不是【内容高+padding】决定的。padding 改变的不是 span 的实际高度，只是改变了可视的高度。div 框的高度才是 span 的实际高度。 span 的实际高度，由 行高 间接确定。如下图，虽然span的红框仍然没变，但是 div高度变化了。而div包裹的高度才是 span 的实际高度（只需关注外层div高度即可，红框的高度并不是span实际高度） “间接” 怎么理解？ 即使设置行高100px，span的高度也有可能不是100px高 设置不同的字体，会改变 span 的实际高度。经测试：↓↓ 默认，微软雅黑字体、行高是100px的话，实际高度就是100px。 改成宋体、行高是100px，span 的实际高度变成 101px。 改成 monospace(等宽字体)、行高是100px。 实际高度变成 102px 具体知识点叫做：行盒 （可以看文章，能看懂就看，面试官可能都看不懂，前期可以不用研究这么深） block 高度 默认高度，由内部所有 文档流元素 的高度总和 决定的。（由默认行高间接决定） 内层div是脱离文档流的元素，外层div就无法计算上它的高度 后面会介绍：如何脱离文档流、脱离后去哪里了 同时也可以自定义设置 height 高度。这种情况，就忽略内部元素高度。 如果div中没有任何内容，高度为0。区别于span，span中没有内容，也有高度，由 默认的 line-height 决定。 inline-block 高度 默认高度的计算，跟 block 一样。 也可以自定义设置 height。 ","date":"2020-07-25","objectID":"/css-basic/:4:3","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"overflow 溢出 当内容大于容器 当内容的宽度或高度大于容器的，会溢出 可用 overflow 来设置是否显示滚动条 auto 是灵活设置 scroll 是永远显示（基本不用） hidden 是直接隐藏溢出部分 visible 是直接显示溢出部分（默认值） overflow 可以分为 overflow-x 和 overflow-y，通常只用overflow。x和y可能最终效果会与实际需求有差 示例 \u003cdiv style=\"width: 10em; height: 200px;\"\u003e内容......\u003c/div\u003e overflow: visible; /* 默认 */ overflow: hidden; /* 超出部分隐藏 */ overflow: scroll; /* 超出部分可滚动预览，很少有人用。因为内容没溢出时，仍显示滚动条，非常丑 */ overflow: auto; /* 超出时显示滚动条，不超出不显示 */ 横向滚动条 \u003cdiv style=\"width: 10em; height: 200px;\"\u003e 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 \u003cdiv style=\"width:1000px;\"\u003e 内容 \u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e div{ border: 1px solid green; overflow: auto; } span{ border: 1px solid red; } \u003c/style\u003e 内部文档流元素宽度超出外层父元素，就会出现横向滚动条 同时原本的内容，不会因为宽度被内部元素撑开而平铺显示，仍会只显示在第一屏中 ​ ","date":"2020-07-25","objectID":"/css-basic/:4:4","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"脱离文档流 回忆一下 block 高度由内部文档流元素决定，可以设 height 这句话的意思是不是说，有些元素可以不在文档流中 哪些元素脱离文档流 脱离文档流的元素，那么它所在的容器，就不会把它计算进高度中 脱离文档流，就是从普通文档流中跳出，比普通文档流的层级稍高 float position: absolute / fixed 怎么让元素不脱离文档流 不要用上面属性不就不脱离了 ​ ","date":"2020-07-25","objectID":"/css-basic/:4:5","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"盒模型 content box \u0026 border box css 盒模型分为两种：一种是 content-box ，一种是 border-box 二者的区别是： content-box 的宽度，只包含 content 部分 border-box 的宽度，包含 border、padding 和 content 分别是 content-box 内容盒 - 内容，就是盒子的边界 border-box 边框盒 - 边框，才是盒子的边界 公式 content-box width = 内容宽度 border-box width = 内容宽度 + padding + border 哪个好用 border-box 好用 同时指定 padding、width、border 就知道为什么了 ​ ","date":"2020-07-25","objectID":"/css-basic/:4:6","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"margin合并 哪些情况会合并 兄弟 margin 合并 上方元素的 margin-bottom，会和下方元素的 margin-top 重合 父子 margin 合并 给子元素添加 margin-top，效果会作用在父元素上（bf：嵌套崩塌） 第一个子元素的 margin-top，会和 最后一个子元素的 margin-bottom，效果会作用在父元素的 margin-top/bottom 或 和父元素的 margin-top/bottom 重合 记住：只有上下会重叠，左右从来不重叠 如何阻止合并 不要问为什么，CSS 很多效果是试出来了，无法解释清楚 父子合并用 padding / border 挡住 可以用很小的 padding/border 来挡住，让父子的margin无法穿透并重叠 父子合并用 overflow: hidden 挡住 父子合并用 display: flex，不知道为什么，试出来的 兄弟合并是符合预期的 兄弟合并可以用 display: inline-block 消除 总之要一条一条死记。 而且 CSS 的属性逐年增多，每年都可能有新的 为什么css 难学？ 不正交 因为很多没有道理，需要死记硬背的点。 为什么 display: inline-block 可以消除 margin 合并。 并没有 enable-margin-callapse: false 这种选项，翻译一下就知道它是用来单独控制margin合并的。 无法知道 现在写的这句 css，到底会影响哪些属性 什么叫正交？ 当我们调节显示器的亮度时，显示器的对比度不会改变。 而 css 是不正交的，因为我们在写某一个属性时，可能就会改变其他属性的状态、效果 ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:4:7","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"基本单位 长度单位 px 像素 em 相对于自身 font-size 的倍数 百分数 整数 rem：等你把 em 滚瓜烂熟了再问 rem vw 和 vh 其他长度单位都用得很少，不用了解 颜色 十六进制 #FF6600 或者 #F60 #000 也支持最后添加 alpha。 #FF660000 全透明、 #FF6600FF 不透、 #FF660088 半透。但兼容性不确定 RGBA 颜色 rgb(0,0,0) 或者 rgba(0,0,0,1) hsl 颜色 hsl(360,100%,100%)：色相、饱和度、明度 hsla(360,100%,100%, 0.5) ​ ​ ","date":"2020-07-25","objectID":"/css-basic/:4:8","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["CSS 入门"],"content":"实践：做一个彩虹 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eJS Bin\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"rainbow\"\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003cdiv\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e * { box-sizing: border-box; margin: 0; padding: 0; } body{ background: white; } .rainbow { height: 200px; overflow: hidden; } .rainbow div { overflow: hidden; } .rainbow \u003e div { width: 400px; height: 400px; background: red; border-radius: 50%; } .rainbow \u003e div\u003e div { background: hsl(60, 80%, 50%); height: 380px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div { background: hsl(120, 80%, 50%); height: 360px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div { background: hsl(180, 80%, 50%); height: 340px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv { background: hsl(240, 80%, 50%); height: 320px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv \u003e div { background: hsl(300, 80%, 50%); height: 300px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv \u003e div \u003e div { background: hsl(330, 80%, 50%); height: 280px; margin: 10px; border-radius: 50%; } .rainbow \u003e div\u003e div \u003e div \u003e div \u003ediv \u003e div \u003e div \u003e div { background: hsl(330, 80%, 100%); height: 260px; margin: 10px; border-radius: 50%; } ","date":"2020-07-25","objectID":"/css-basic/:5:0","tags":["CSS","历史","基本概念","彩虹"],"title":"CSS 学习笔记——基础篇","uri":"/css-basic/"},{"categories":["HTML 入门"],"content":"❤️ 🧡 💛 💚 💙 💜","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"记录几个标签的简单用法，然后忘掉 🤪 ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:0:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"a 标签 特别常用，但很多人不会用 😳😳 属性 href target download rel=noopener 面试可能会问 作用 跳转外部页面 跳转内部锚点 跳转到邮箱或电话等 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:1:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"href href 是 Hypertext REFerence 超链接 发音 ：应该读 H-Ref /ˈeit∫.rɛf/ href 的取值 网址 https://google.com http://google.com //google.com 【推荐写这种形式】 network 会先请求 http://google.com → http://www.google.com → https://www.google.com 结束 路径 使用 hs 开启服务的目录，就是 /a/b/c 的根目录 双击打开文件，访问的路径是硬盘的根目录 file /a/b/c 以及 a/b/c index.html 以及 ./index.html \u003ca href=\"/a/b/c.html\"\u003ec.html\u003c/a\u003e \u003ca href=\"./index.html\"\u003eindex.html\u003c/a\u003e 伪协议 javascript:代码; \u003ca href=\"javascript:alert(1);\"\u003e\u003c/a\u003e \u003c!--执行js操作：弹出1--\u003e \u003ca href=\"javascript:;\"\u003e\u003c/a\u003e \u003c!--只有这种是什么都不做--\u003e \u003ca href=\"\"\u003ehref为空，页面会刷新\u003c/a\u003e \u003c!--如果有input会被清空--\u003e \u003ca href=\"#\"\u003e#不刷新，但页面会滚动到顶部\u003c/a\u003e 补充：编译器中 p{$}*30 + tab ，会生成 30 个 p 标签，内容 1-30 mailto:邮箱 移动端，通常会直接呼出发邮件的界面，并自动填写收件人邮箱 \u003ca href=\"mailto:ryuukousen@gmail.com\"\u003e给他发邮件\u003c/a\u003e tel:手机号 移动端，直接呼出拨号盘，并自动填写号码 \u003ca href=\"tel:13912345678\"\u003e\u003c/a\u003e id 锚点 跳转到指定标签 href=#xxx \u003ca href=\"#xxx\"\u003e查看aaa\u003c/a\u003e ... \u003cp id='xxx'\u003eaaa\u003c/p\u003e ... ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:1:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"target 在哪个页面打开窗口 内置名字 _blank ：新窗口 _top ：顶级窗口（结合 iframe） _parent ：父级窗口（结合 iframe） _self ：当前窗口（默认值） 程序员命名 window 的 name \u003ca href=\"//google.com\" target=\"asdf\"\u003egoogle\u003c/a\u003e \u003ca href=\"//baidu.com\" target=\"asdf\"\u003ebaidu\u003c/a\u003e target=asdf，表示如果有这个asdf窗口就在这个窗口打开google，如果没有就创建一个新的窗口命名为asdf 控制台输出 window.name 可知当前窗口的名称 iframe 的 name 可以写一个搜索引擎的集合或切换，goodbai 谷歌已经禁用了在 iframe 中引入 \u003ca href=\"//google.com\" target=\"asd\"\u003egoogle\u003c/a\u003e \u003ca href=\"//baidu.com\" target=\"qwe\"\u003ebaidu\u003c/a\u003e \u003ciframe src=\"\" name=asd\u003e\u003c/iframe\u003e \u003ciframe src=\"\" name=qwe\u003e\u003c/iframe\u003e ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:1:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"download 绝大多数浏览器不支持，chrome 不支持 \u003ca href=\"//google.com\" download\u003e下载页面\u003c/a\u003e 作用 不是打开页面，而是下载页面 问题 不是所有浏览器都支持，尤其是手机浏览器可能不支持 ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:1:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"iframe 内嵌窗口 已经很少使用了，还有些老系统再用。新的方式是通过 ajax 实现 \u003ciframe name=\"a\" src=\"a-target-iframe.html\" frameborder=\"0\"\u003e\u003c/iframe\u003e ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:2:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"table ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:3:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"相关标签 thead、tbody、tfoot，即使开发时换了顺序，浏览器识别时仍会按照 head body foot 的顺序解析渲染 table thead tbody tfoot tr td th 一个表头的表格 \u003ctable\u003e \u003cthead\u003e \u003c!-- tr: table row 行--\u003e \u003ctr\u003e \u003c!-- th: table head 表头--\u003e \u003cth\u003e英语\u003c/th\u003e \u003cth\u003e翻译\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003c!-- td: table data 数据 --\u003e \u003ctd\u003ehyper\u003c/td\u003e \u003ctd\u003e超级\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003etarget\u003c/td\u003e \u003ctd\u003e目标\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003ereference\u003c/td\u003e \u003ctd\u003e引用、链接\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003ctfoot\u003e \u003ctr\u003e \u003ctd\u003e空\u003c/td\u003e \u003ctd\u003e空\u003c/td\u003e \u003c/tr\u003e \u003c/tfoot\u003e \u003c/table\u003e 两个表头的表格 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003e小红\u003c/th\u003e \u003cth\u003e小明\u003c/th\u003e \u003cth\u003e小颖\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003cth\u003e数学\u003c/th\u003e \u003ctd\u003e61\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e92\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e语文\u003c/th\u003e \u003ctd\u003e61\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e92\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e英语\u003c/th\u003e \u003ctd\u003e61\u003c/td\u003e \u003ctd\u003e85\u003c/td\u003e \u003ctd\u003e92\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003ctfoot\u003e \u003ctr\u003e \u003cth\u003e总分\u003c/th\u003e \u003ctd\u003e200\u003c/td\u003e \u003ctd\u003e200\u003c/td\u003e \u003ctd\u003e200\u003c/td\u003e \u003c/tr\u003e \u003c/tfoot\u003e \u003c/table\u003e ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:3:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"相关样式 table-layout auto【默认】：根据单元格中的内容数量，计算单元格宽度 fixed：单元格宽度尽量平均 inherit initial unset border-spacing 设定每个单元格的间隙 \u003cstyle\u003e table{ width: 600px; table-layout: auto; border-spaceing: 10px; } td,th{ border: 1px solid blue; } \u003c/style\u003e border-collapse 通常用于 去掉单元格间隙 \u003cstyle\u003e table{ width: 600px; table-layout: auto; border-collapse: collapse; /* 去掉单元格间隙 */ border-spaceing: 0; /* 去掉单元格间隙 */ } td,th{ border: 1px solid blue; } \u003c/style\u003e 下面这两句常被写进 reset.css 中 border-collapse: collapse; /* 去掉单元格间隙 */ border-spaceing: 0; /* 去掉单元格间隙 */ ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:3:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"img 标签 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"作用 发出 get 请求，展示一张图片 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"属性 alt：全称是可替换的，当图片加载失败，会显示 alt 的值 height：只设置 height ，宽度自适应 width：只设置 width ，高度自适应 同时设定，height 和 width，图片可能变形 永远不要让图片变形 src：全称 source ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"事件 onload/onerror \u003cimg id=\"xxx\" width=\"400\" src=\"dog.jpg\" alt=\"一只狗子\"\u003e \u003cscript\u003e xxx.onload = function(){ console.log(\"图片加载成功\"); } xxx.onerror=function(){ console.log(\"图片加载失败\"); xxx.src = \"/404.jpg\"; // 挽救：图片加载失败，展示404图，放在项目中 } \u003c/script\u003e ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"响应式 max-width:100% \u003cstyle\u003e *{ margin:0; padding:0; box-sizing: border-box; } img{ max-width: 100%; /* 图片是响应式的，尺寸永远满足各种窗口大小 */ } \u003c/style\u003e ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:4","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"可替换元素 https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element 考试可能会问，被问概率30% ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:4:5","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"form 标签 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:5:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"作用 发 get 或 post 请求，然后刷新页面 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:5:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"属性 \u003cform action=\"/xxx\" method=\"POST\"\u003e \u003cinput type=text /\u003e \u003cinput type=submit /\u003e \u003c/form\u003e action 默认需要给一个 action ，就是发送请求的目标地址（HTTP相关）、请求某一个页面的页面地址 需要有后台给我们提供这个地址 method method 属性控制用 GET 还是 POST 来发送请求 autocomplete 自动填写 autocomplete: on / off target 提交到哪个页面：新开页面、当前页面、iframe 与 a 标签写法一致 _blank top ：顶级窗口（结合 iframe） _parent ：父级窗口（结合 iframe） _self ：当前窗口（默认值） window.name \u003ciframe name=xxx\u003e\u003c/iframe\u003e \u003cform action=\"/xxx\" method=\"POST\" autocomplete=\"off\" target=\"a\"\u003e \u003cinput type=text /\u003e \u003cinput type=submit /\u003e \u003c/form\u003e \u003ciframe name=\"a\" src=\"a-target-iframe.html\" frameborder=\"0\"\u003e\u003c/iframe\u003e ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:5:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"事件 onsubmit：用户点击提交会触发这个事件 ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:5:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"type=submit form 中的 button 如果没有指定 type 类型，默认是 type=submit 的，点击 button 就会提交 form 表单。如果指定了其他类型，例如 type=button，按钮就不能提交表单。 一个 form 表单中，必须要有一个 type=submit 的 input 或 button ，才能提交表单。 ​ 修改submit按钮文字 \u003cinput type=\"submit\" /\u003e \u003cinput type=\"submit\" value=\"搞起\" /\u003e ​ submit 按钮的 input 和 button 的区别 \u003cinput type=\"submit\" value=\"搞起\" /\u003e \u003cbutton type=\"submit\"\u003e搞起\u003cbutton\u003e 区别是： input按钮中，不能再添加内容 button按钮中还可以再添加标签内容 \u003cbutton\u003e \u003cstrong\u003e搞起\u003c/strong\u003e \u003cimg src=\"dog.jpg\" alt=\"狗子\"\u003e \u003c/button\u003e ​ ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:5:4","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"input 标签 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:6:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"作用 让用户输入内容 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:6:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"属性 类型 type: button/checkbox/email/file/hidden/ number/password/radio/ search/submit/tel/text \u003cinput type=\"text\" /\u003e \u003cinput type=\"color\" /\u003e \u003cinput type=\"password\" /\u003e \u003cinput type=\"radio\" name=\"gender\" /\u003e男 \u003c!--同一组，取相同的name--\u003e \u003cinput type=\"radio\" name=\"gender\" /\u003e女 \u003cinput type=\"checkbox\" name=\"hobby\" /\u003e唱 \u003c!--同一组，取相同的name--\u003e \u003cinput type=\"checkbox\" name=\"hobby\" /\u003e跳 \u003cinput type=\"checkbox\" name=\"hobby\" /\u003erap \u003cinput type=\"checkbox\" name=\"hobby\" /\u003e篮球 \u003cinput type=\"file\" multiple/\u003e 看不见我吧：\u003cinput type=\"hidden\"\u003e \u003c!-- 通常用于js自动获取并填入 --\u003e \u003ctextarea style=\"resize: none;width:50%;height:50px\"\u003e\u003c/textarea\u003e \u003c!--禁止改变大小--\u003e \u003cselect name=\"\" id=\"\"\u003e \u003coption value=\"\"\u003e-请选择-\u003c/option\u003e \u003coption value=\"1\"\u003e星期一\u003c/option\u003e \u003coption value=\"2\"\u003e星期二\u003c/option\u003e \u003c/select\u003e 其他 （js内容） name/autofocus/checked/disabled/ maxlength/pattern/value/placeholder ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:6:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"事件 （js内容） onchange ：用户改变内容触发 onfocus：用户聚焦时触发 onblur ：用户失焦时触发 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:6:3","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"验证器 （js内容） HTML5新增功能：自带验证 例： \u003cinput type=\"text\" require/\u003e \u003cinput type=\"password\" require/\u003e ​ ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:6:4","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"其他输入标签 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:7:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"标签 （js内容） select + option textarea label ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:7:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"注意事项 一般不监听 input 的 click 事件 form 里面的 input 都要有 name form 里要放一个 type=submit 才能触发 submit 事件 ​ ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:7:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"补充工具：开启 http 服务 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:8:0","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"http-server 安装 yarn global add http-server 使用 http-server . -c-1 http-server -c-1 hs -c-1 -c 缓存，-c-1 不要缓存 . 可以省略 http-server 可缩写成 hs 按住ctrl + 点击打开任意链接。地址栏追加 html 文件名，即可浏览 ctrl + C 中断服务器 ​ ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:8:1","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["HTML 入门"],"content":"parcel 操作更简便 好像有bug ：ctrl + c 无法中断 yarn global add parcel // 安装 parcel a-href.html // 使用 ","date":"2020-07-16","objectID":"/html-a-simple-record-of-html-tags/:8:2","tags":["HTML","标签","笔记"],"title":"HTML 标签の简单记录","uri":"/html-a-simple-record-of-html-tags/"},{"categories":["工具"],"content":"最近 Typora 有了更新，终于支持图床功能了 🎉！新增了原生对 PicGo-Core 的调用，可以自动上传 markdown 内的图片，尝鲜一波！","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"​ Typora 是一款简单、高效而且优雅的 Markdown 编辑器，它提供了一种所见即所得的全新的 Markdown 写作体验。它把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时生成预览效果。Typora 的一切都围绕纯粹的生产效率而设计。 Typora一直是我最喜欢的 markdown 编辑器，写博客、记笔记的首选软件。相信大部分朋友也在使用 Typora 这款软件。 但是 Typora 之前是不支持图床功能的，只能通过第三方插件实现图片自动上传的功能。不过最近 Typora 有了更新，终于支持图床功能了，新增了原生对 PicGo-Core 的调用，可以自动上传 markdown 内的图片，赶紧尝鲜一波。 ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:0:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"1. 安装 PicGo-Core 因为Typora已经原生支持PicGo-Core, 所以只需要在软件内下载一下就可以了(PS: 下面这张图就是用的自动上传, 很方便) 首先点击上面红色1的位置，选择 PicGo-Core，再点3（不要问我2去哪儿了….就当他不存在），并等待下载完成。 ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:1:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"2. 安装 smms 插件 直接点击红色5的位置，根据文本内容找到 PicGo-Core 的程序目录 注意，上图中我们只需关心红框中的路径下的 picgo.exe 文件，其他信息都不管 找到目录后，我们在picgo的目录下启动命令行，执行如下命令，并等待安装成功 .\\picgo.exe install smms-user ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:2:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"3. 配置 PicGo-Core 安装完成之后点击红色4的位置（红标顺序不代表点击顺序），打开 PicGo-Core 的配置文件，按照下面的格式无脑全选替换就行 { \"picBed\": { \"current\": \"smms-user\", \"uploader\": \"smms-user\", \"smms-user\": { \"Authorization\": \"这里替换成你自己的\" }, \"transformer\": \"path\" }, \"picgoPlugins\": { \"picgo-plugin-smms-user\": true } } 没有 Authorization 的自己去这里申请一个： https://sm.ms/home/apitoken 申请前需要注册一个账号，这个没啥难度，就不细说了。 ​ ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:3:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["工具"],"content":"4. 体验效果 保存配置之后，我们直接在 Typora 内粘贴一张图片，就会自动提示上传中 或者在已有的本地图片上面按右键，也可以弹出上传图片的按钮，整个操作非常便捷。 ","date":"2020-07-16","objectID":"/tools-upload-images-in-typora/:4:0","tags":["Typora","图片","“SM.MS”"],"title":"Typora 如何上传图片？（图床）","uri":"/tools-upload-images-in-typora/"},{"categories":["HTML 入门"],"content":"😎💋","date":"2020-07-16","objectID":"/html-introduction/","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"HTML (HyperText Markup Language) 不是一门编程语言，而是一种用来告知浏览器如何组织页面的标记语言。😎💋 HTML 可复杂、可简单，一切取决于开发者。 它由一系列的元素（elements）组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 一对标签（ tags）可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。 ​ ","date":"2020-07-16","objectID":"/html-introduction/:0:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"HTML 是谁发明的 HTML 之父 ","date":"2020-07-16","objectID":"/html-introduction/:1:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"1990年左右诞生 Tim Berners-Lee，称之为李爵士 2004年，英女皇他颁发大英帝国爵级司令勋章 2017年，被颁发图灵奖 ","date":"2020-07-16","objectID":"/html-introduction/:1:1","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"李爵士做了啥？ 自己写了第一个浏览器 自己写了第一个服务器 用自己写的浏览器访问了自己写的服务器 发明了WWW，同时发明了HTML、HTTP和URL ​ ","date":"2020-07-16","objectID":"/html-introduction/:1:2","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"HTML 起手式怎么写 快捷键：感叹号 ! + tab \u003c!DOCTYPE html\u003e ← 文档类型 \u003chtml lang=\"en\"\u003e ← 页面根标签 \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e ← 文件的字符编码 \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e ← 防止页面缩放 \u003cmeta http-equiv\"X-UA-Compatible\" content=\"ie=edge\"\u003e ← 如果在IE打开，告诉IE使用最新内核（IE11） \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e DOCTYPE：文档类型 浏览器支持很多种文档类型（HTML、XHTML…）。 \u003c!DOCTYPE html\u003e 表示告诉浏览器开始写HTML了。 html 标签是根标签 必须要写（如果没写也会自动加上） 可以把 lang 的属性值改为 zh-CN head 和 body 标签，虽然是 html 的子元素，但一般格式上不缩进 head 标签里面存放看不见的元素 viewport 视口、视窗 ​ ","date":"2020-07-16","objectID":"/html-introduction/:2:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"章节标签 章节标签，通常用于表示文章、书的层级（就是内容框架） 标题 h1~h6 章节 section 文章 article 段落 p 头部 header 脚部 footer 主要内容 main 旁支内容 aside 划分 div \u003cbody\u003e \u003cheader\u003e顶部广告\u003c/header\u003e \u003cdiv\u003e \u003cmain\u003e \u003ch1\u003e文章标题\u003c/h1\u003e \u003csection\u003e \u003ch2\u003e第一章\u003c/h2\u003e \u003cp\u003e 一段话一段话一段话一段话一段话一段话一段话一段话一段话一段话一段话 \u003c/p\u003e \u003csection\u003e \u003ch3\u003e1.1 节\u003c/h3\u003e \u003cp\u003e一段话\u003c/p\u003e \u003c/section\u003e \u003csection\u003e \u003ch3\u003e1.2 节\u003c/h3\u003e \u003cp\u003e一段话\u003c/p\u003e \u003c/section\u003e \u003c/section\u003e \u003c/main\u003e \u003caside\u003e 参考资料 1 2 3 \u003c/aside\u003e \u003c/div\u003e \u003cfooter\u003e\u0026copy; xxx版权所有\u003c/footer\u003e \u003c/body\u003e ​ ​ ","date":"2020-07-16","objectID":"/html-introduction/:3:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"全局属性 任何标签都可以有的属性 ​ ","date":"2020-07-16","objectID":"/html-introduction/:4:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"class ： 类名 \u003cstyle\u003e ← style标签也有contenteditable 属性，可以被编辑 [class=middle]{ /* 早期写法--缺点：当一个标签存在多个类名，就无法通过匹配单个类名来找到这个标签 */ background: black; color: white; } .middle{ /* 简写 */ background: black; color: white; } \u003c/style\u003e ​ ","date":"2020-07-16","objectID":"/html-introduction/:4:1","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"contenteditable ：让标签可以被编辑 style标签，也有 contenteditable 属性，可以被编辑 可以将 style 标签放到 body里面，然后添加 style { display : block; } ，style 标签中的样式内容就会显示在浏览器中，然后给style标签添加contenteditable 属性，就可以在浏览器总直接修改样式，并实时刷新 \u003cbody\u003e \u003cstyle contenteditable\u003e style{ display: block; } .xxx{ border: 10px solid orange; } \u003c/style\u003e \u003cp class=\"xxx\" contenteditable\u003e这段话可以直接在浏览器中编辑修改内容\u003c/p\u003e \u003c/body\u003e contenteditable\" contenteditable ​ ","date":"2020-07-16","objectID":"/html-introduction/:4:2","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"hidden ：让标签隐藏 \u003ch1 class=\"title\" hidden\u003e\u003c/h1\u003e .title{ display: block /* 直接添加属性hidden而隐藏的元素，可以通过设置样式 display: block，再显示回来 */ } ​ ","date":"2020-07-16","objectID":"/html-introduction/:4:3","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"id ：全局唯一 id 用来表示【全局唯一的标签】 id 的全局唯一性没有保障，就算有两个重复的 id，HTML 也不会提示我写错了 class足够了，不到万不得已不要用 id ，因为 id 重复使用也不会报错，可能误导开发者 \u003cheader id=\"xxx\"\u003e\u003c/header\u003e \u003cdiv id=\"xxx\"\u003e\u003c/div\u003e #xxx{ /* 此时设置的样式会同时对两个id=xxx元素生效，id被重复使用不会报错，那id的唯一性就毫无意义了 */ } id 中有很多不能使用的词：parent、self、top … 控制台输入 window. 弹出属性列表中所有的词都不能用，因为这些词是 window 已经有的全局属性 \u003cheader id=\"top\"\u003e\u003c/header\u003e \u003cscript\u003e top.style.border=\"10px solid red\" // 直接调用不能获取到top元素，与window对象中的全局属性重名 var ele = document.getElementById(\"top\") // 通过这种方式可以获取到 top 元素，但单词略复杂 \u003c/script\u003e ​ ","date":"2020-07-16","objectID":"/html-introduction/:4:4","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"style ：行内样式 \u003cdiv style=\"border: 10px solid red\" id=\"a\"\u003e\u003c/div\u003e js 中写 a.style.border = \"100px solid green\" 会覆盖 div元素中的行内样式 ​ ","date":"2020-07-16","objectID":"/html-introduction/:4:5","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"tabindex ：顺序 在浏览页面时，网页中按钮都只通过键盘 tab 控制切换选中。而这里的 tabindex 属性就是控制，切换的顺序 被选中的会有一圈不明显的蓝色边框 \u003ca tabindex=1\u003e首页\u003c/a\u003e \u003cp tabindex=3\u003e一段话\u003c/p\u003e \u003cfooter tabindex=2\u003e\u0026copy;版权所有\u003c/footer\u003e tabindex 可以是正数，不必是连续的 tabindex 可以是 0，表示最后才被 tab 访问 tabindex 可以是 -1，表示不可被 tab 访问 ​ ","date":"2020-07-16","objectID":"/html-introduction/:4:6","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"title ：鼠标指向时显示的内容 单行文字溢出，使用省略号 将鼠标移动到这段文字上时，应该能展示出全部文字内容，包括溢出隐藏的部分 \u003cp class=\"xxx\" title=\"显示一段超长的话\"\u003e一段超长的话\u003c/p\u003e \u003cstyle\u003e .xxx { text-overflow: ellipsis; /* 超出部分用省略号 */ overflow: hidden; /* 超出隐藏 */ white-space: nowrap; /* 不换行 */ } \u003c/style\u003e ​ ​ ","date":"2020-07-16","objectID":"/html-introduction/:4:7","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"内容标签 ","date":"2020-07-16","objectID":"/html-introduction/:5:0","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"ol+li ordered list + list item ol ：有序列表 ol 不能含有 li 之外的任何元素、字符 ","date":"2020-07-16","objectID":"/html-introduction/:5:1","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"ul+li unordered list + list item ul ：无序列表 ","date":"2020-07-16","objectID":"/html-introduction/:5:2","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"dl+dt+dd description list + term + data dl ：description list —— 描述列表 dt ：description term —— 描述项 dd ：猜测是 description data —— 描述信息 ","date":"2020-07-16","objectID":"/html-introduction/:5:3","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"pre preview 的缩写 用的较少 html 特点：HTML 代码里的多处空格、回车、tab 等内容，默认会被转化为一个空格 pre 的作用是，可以保留开发者键入的空白位置（pre 有默认样式，很丑，如下） pre\" pre ","date":"2020-07-16","objectID":"/html-introduction/:5:4","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"code 等宽字体 用 code 标签包裹的内容，字符是等宽的。但默认内容在同行展示，无法换行 使用 pre 可以让 code 的内容换行 code \u0026 pre+code\" code \u0026 pre+code ","date":"2020-07-16","objectID":"/html-introduction/:5:5","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"hr 水平分割线 horizontal ","date":"2020-07-16","objectID":"/html-introduction/:5:6","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"br break 的缩写 换行 ​ ","date":"2020-07-16","objectID":"/html-introduction/:5:7","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"a anchor 的缩写 超链接 href target 国内开发习惯使用 _blank 在新标签打开链接。 国外开发通常不写 target，他们觉得会让浏览器网页越开越多（他们习惯：通过鼠标中间点击打开新标签页，默认左键点击同屏跳转） ","date":"2020-07-16","objectID":"/html-introduction/:5:8","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"em emphasis 的缩写 emphasis 意为强调，效果字体斜体 ​ ","date":"2020-07-16","objectID":"/html-introduction/:5:9","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"strong 字体加粗 表示重要 ​ ","date":"2020-07-16","objectID":"/html-introduction/:5:10","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"q quote 的缩写 quote 意为引用 quote标签：内联，行内，不换行 ​ ","date":"2020-07-16","objectID":"/html-introduction/:5:11","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["HTML 入门"],"content":"blockquote 引用 块级，换行 quote \u0026 blockquote\" quote \u0026 blockquote ","date":"2020-07-16","objectID":"/html-introduction/:5:12","tags":["HTML","起手式","标签","属性"],"title":"HTML 入门笔记","uri":"/html-introduction/"},{"categories":["工具"],"content":"这里是文章描述，本文用于测试一些 Markdown 语法和样式展现","date":"2020-07-15","objectID":"/tools-test-markdown/","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"本文用于测试一些 Markdown 语法和样式展现 ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:0:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"文章摘要 \u003c!--more--\u003e [more注释]之前的内容，会作为文章摘要显示在主页。尽量不要包含代码块、图片、表格等模块。如果 [more注释] 之前的内容为空，则将自动添加 description 内容为文章摘要，显示在主页中。 ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:1:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"文章置顶 weight: 1 // Front-matter ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:2:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"常用语法 主题文档链接 ​ 反引号 ==高亮== ​ 加粗 ​ 斜体 下划线 这是一个链接哦。 ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:3:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"markdown 支持 emoji 在 config.toml 中开启/关闭 emoji 支持 表情包大全：https://hugoloveit.com/zh-cn/emoji-support/ 冒号joy冒号 冒号jack_o_lantern冒号 冒号heart冒号 😂 🎃 ❤️ ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:4:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"有序列表 有序列表1 无序列表 无序列表 有序列表2 有序列表3 ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:5:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"无序列表 无序列表 无序列表 无序列表 无序列表 在这里添加一个脚注 1 无序列表 无序列表 ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:6:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"复选框 - [x] Write the press release - [x] Update the website - [ ] Contact the media Write the press release Update the website Contact the media ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:7:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"代码块 console.log(\"test\") \u003cdiv class=\"box\" style=\"color:red;\"\u003e\u003c/div\u003e body{ font-size: 20px; } ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:8:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"内置 Shortcodes 语法支持 ","date":"2020-07-15","objectID":"/tools-test-markdown/:9:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"横幅 This is a tip 一个 danger 横幅 This is a tip 一个 note 横幅 This is a tip 一个 tip 横幅 ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:9:1","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"图片 Iceland (figure) ​ 点击图片放大，点击空白缩小↘ Iceland (image)\" Iceland (image) ​ ","date":"2020-07-15","objectID":"/tools-test-markdown/:9:2","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"二级标题 ","date":"2020-07-15","objectID":"/tools-test-markdown/:10:0","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["工具"],"content":"三级标题 四级标题 五级标题 六级标题 ​ 这是一段脚注 https://xxx 这是一段脚注 ↩︎ ","date":"2020-07-15","objectID":"/tools-test-markdown/:10:1","tags":["测试","markdown","语法"],"title":"测试 Markdown 语法","uri":"/tools-test-markdown/"},{"categories":["个人博客的创建之路"],"content":"如何用 hugo 搭建个人博客","date":"2020-07-14","objectID":"/blog-start-a-hugo/","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"第一篇正式博文，我想给大家分享下我的博客的创建过程吧！🥇 ​ Hugo 是由 Go 语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 ​ ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:0:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"安装 Hugo 官方教程 英文 Mac 安装方式 brew install hugo hugo version Windows 安装方式 去 Hugo releases 页面 下载 hugo_xxx_Windows- 64bit.zip 解压，把 hugo.exe 放到 D:\\Software\\hugo\\hugo.exe 把 D:\\Software\\hugo\\ 加到 PATH 重启终端，运行 hugo version 查看版本 ​ ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:1:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"快速搭建博客 官方文档教程，必看！ ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:2:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"准备、提交 新建 blog 目录，运行 hugo new site xxx.github.io-generator ， xxx 为 github 用户名 。会在当前目录中创建 xxx.github.io-generator 文件夹（博客生成器） 进入博客生成器目录，git init 选择并下载主题 ，放到 themes 目录下 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 遇到报错 ↘ fatal: unable to access 'https://github.com/dillonzq/LoveIt.git/': error setting certificate verify locations: CAfile: D:/Software/Git/mingw64/ssl/certs/ca-bundle.crt CApath: none 解决办法：使用 git clone 出现 fatal: unable to access 'https://github.com/...' ，执行代码 ​↓ git config --system http.sslverify false // 把证书校验禁用 然后，将主题添加到站点配置中：echo 'theme = \"LoveIt\"' \u003e\u003e config.toml // 主题目录的名称 创建新文章：hugo new posts/first_post.md D:\\blog\\xxx.github.io-generator\\content\\posts\\first_post.md created 编辑文章后，修改 draft: false。draft : true 表示处于草稿状态，此时Hugo不会真正发布它 初次创建博客或修改主题，需将主题文档中给出的配置，粘贴到 config.toml 文件中。 baseURL 配置成 http://[用户名].github.io/ hugo server -D 建立本地访问 https://localhost:1313 预览博客 hugo 创建一个新的目录 public/，这就是需要提交到 github，最终生成线上博客的目录 根目录下，新建 .gitignore 文件，添加 /public/。使得 /public 可以自成一个仓库 进入public cd public，git init git add . git commit ​ ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:2:1","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"第一次部署 登录 github，创建博客专用仓库，仓库名必须为 ： [用户名].github.io 。 进入 public 目录，git remote add origin xxx git push -u origin master 进入 github 博客仓库的 Settings，找到 GitHub Pages ，选择 master ，保存 通过 http://[用户名].github.io 就能访问博客 ​ ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:2:2","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"以后的部署 在 xxx.github.io-creator 目录（注意确保自己不在 public 目录）里运行 hugo new posts/第二篇博客.md 运行 code posts/第二篇博客.md 对文件进行编辑，注意不要把文件原本的内容 front matter 给删了，直接在后面另起一行写新内容。 hugo server -D 建立本地访问 https://localhost:1313 预览博客 运行 hugo -D，得到新的 public 目录（-D 是显示草稿文章） 进入 public 目录 cd public，执行一下操作 git add . 注意有一个点 git commit -m update git push -f 其中 -f 是强制上传的意思 等待几分钟后，你的博客就会出现第二篇文章了！ 通过 http://[用户名].github.io 访问博客 ​ ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:2:3","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"备份博客生成器 generator 程序员永远都会留备份 新建仓库 xxx.github.io-generator 将本地 xxx.github.io-generator 目录，git init，git add . ，git commit -m backup，git remote add origin xxx，git push -u origin master 即可 如果在执行 add 时，提示我们需要执行 rm 操作，可能是因为主题目录下已经存在 .git 文件，主题目录本身就是一个本地仓库了，那和 generator 目录会形成一个嵌套子目录的关系，that’s not good . 我们需要把主题目录下的 .git 文件删除 如果嵌套了，可以创建 .gitignore 文件。把【嵌套的子目录】添加到【.gitignore】中，忽略不上传 ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:3:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"网站基础配置 ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:4:0","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"网站 ico 图标配置 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在根目录下的 /static 目录中。利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件。 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color 。 ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:4:1","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"域名配置 博客根目录下的 /static 目录中，新建文件 CNAME 无后缀，填入域名 touch CNAME echo \"[你的域名]\" \u003e\u003e CNAME 执行 hugo ，会在 public 目录下生成 CNAME 文件。 push 到 github 后，会自动识别 CNAME 文件中的域名，填入 Github pages 的 custom domain 中，就无需手动配置域名啦！👍 ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:4:2","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"头像配置 博客根目录下的 /assets/images 目录中，存放名为 avatar.png 的图片。 执行 hugo，会在 public/images 目录下生成 avatar.png。push 到 github 后，网站会自动识别 avatar.png 作为网站头像 ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:4:3","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["个人博客的创建之路"],"content":"文章 Front-matter 配置 title: \"主标题\" subtitle: \"这里是副标题\" draft: false #是否为草稿 weight: 1 #表示置顶。数字越小，文章越靠前 toc: auto: false # true自动收放，false全部展开不能收缩 author: \"Sam\" authorLink: \"https://liubingxuan.xyz/\" #设置作者名的链接 description: \"这里是文章描述。可在鼠标悬停文章封面图时显示此处内容\" license: \"转载请注明出处\" images: [] # 页面图片, 用于 Open Graph 和 Twitter Cards. tags: [\"标签1\",\"标签2\"] categories: [\"文章所处的大分类\"] #featuredImagePreview: \"https://i.loli.net/2020/07/15/QY8Ac1ojVqtl9XB.png\" 指定封面图网络地址 #featuredImage: \"https://i.loli.net/2020/07/15/QY8Ac1ojVqtl9XB.png\" resources: - name: \"featured-image\" # 指定文章内顶部封面图 src: \"featured-image.jpg\" - name: \"featured-image-preview\" # 指定文章在首页显示的封面图。可省略并默认使用featured-image src: \"featured-image-preview.jpg\" hiddenFromHomePage: false # 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: false # 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: false #如果设为 true, 这篇文章会使用 twemoji. lightgallery: true # 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: true # 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: true # 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: true # 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: true #如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: false #如果设为 true, 在 RSS 中将会显示全文内容. # ...... 更多配置，详见 Hugo 文档、Front Matter ","date":"2020-07-14","objectID":"/blog-start-a-hugo/:4:4","tags":["搭建","Hugo","博客"],"title":"使用 Hugo 搭建个人博客","uri":"/blog-start-a-hugo/"},{"categories":["JS编程接口"],"content":"区分 DOM 和 jQuery 的 API","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"对比 DOM 和 jQuery ​ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:0:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"JavaScript 的组成 ECMAScript：JavaScript 的语法标准。包括变量、表达式、运算符、函数、if 语句、for 语句等。 DOM：文档对象模型，操作网页上的元素的 API。比如让盒子移动、变色、轮播图等。 BOM：浏览器对象模型，操作浏览器部分功能的 API。比如让浏览器自动滚动。 ​ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:1:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"事件的三要素 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:2:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"事件源、事件、事件驱动程序 比如，我用手去按开关，灯亮了。这件事情里，事件源是：开关。事件是：按开关。事件驱动程序是：灯的开和关。 再比如，网页上弹出一个广告，我点击右上角的X，广告就关闭了。这件事情里，事件源是：X。事件是：onclick。事件驱动程序是：广告关闭了。 于是我们可以总结出：谁引发的后续事件，谁就是事件源。 ​ 总结如下： 事件源：引发后续事件的 html 标签。 触发事件的对象 在 js 中就是 dom 对象 在 jQuery 中 是包装过的 dom 对象 事件：js 已经定义好了（常见事件 见下图）。 js 中 指的是 onclick , onmouseenter/onmouseleave , onmouseup/onmousedown，…… jQuery 中 就是 click , mouseenter/mouseleave , mouseup/mousedown，…… 事件驱动程序：对样式和 html 的操作。也就是 DOM。 常见的事件如下： JavaScript 事件 jQuery 事件 当一下情况发生时,出现此事件 onabort 图像加载被中断 onblur blur( ) 元素失去焦点 onchange change( ) 用户改变域的内容 onclick click( ) 鼠标点击某个对象 ondblclick dblclick( ) 鼠标双击某个对象 onerror 当加载文档或图像时发生某个错误 onfocus focus( ) 元素获得焦点 onkeydown keydown( ) 某个键盘的键被按下 onkeypress keypress( ) 某个键盘的键被按下或按住 onkeyup keyup( ) 某个键盘的键被松开 onload load( ) 某个页面或图像被完成加载 onmouseenter mouseenter( ) 鼠标指针进入（穿过）元素 onmouseleave mouseleave( ) 鼠标指针离开元素 onmousedown mousedown( ) 某个鼠标按键被按下 onmousemove mousemove( ) 鼠标被移动 onmouseout mouseout( ) 鼠标从某元素移开 onmouseover mouseover( ) 鼠标被移到某元素之上 onmouseup mouseup( ) 某个鼠标按键被松开 onreset 重置按钮被点击 onresize resize( ) 窗口或框架被调整尺寸 onselect select( ) 文本被选定 onsubmit submit( ) 提交按钮被点击 onunload unload( ) 用户退出页面 ​ ​ ​ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:2:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"什么是 DOM DOM：Document Object Model，文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让 js 操作 html 元素而制定的一个规范。 DOM 就是由节点组成的。 ​ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:3:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"解析过程 HTML 加载完毕，渲染引擎会在内存中把 HTML 文档，生成一个 DOM 树，getElementById 是获取内中 DOM 上的元素节点。然后操作的时候修改的是该元素的属性。 ​ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:3:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"DOM 树（一切都是节点） DOM 的数据结构如下： 上图可知，在 HTML 当中，一切都是节点：（非常重要） 元素节点：HMTL 标签。 文本节点：标签中的文字（比如标签之间的空格、换行） 属性节点：：标签的属性。 整个 html 文档就是一个文档节点。所有的节点都是 Object。 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:3:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"DOM 可以做什么 找对象（元素节点） 设置元素的属性值 设置元素的样式 动态创建和删除元素 事件的触发响应：事件源、事件、事件的驱动程序 ​ ​ ​ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:3:3","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"什么是 jQuery ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:4:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"为什么要学 jQuery 究其原因是因为原生 js 在进行 dom 操作时代码量多而且容错性差，不够简练。那么 jQuery 就是为了解决这些问题而出现的。 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:4:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQuery 是什么 jQuery 是一个快速、简洁的 JavaScript 框架，是继 Prototype 之后又一个优秀的 JavaScript 代码库（或 JavaScript 框架）。 jQuery 设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 jQuery 的作用：**它封装 JavaScript 常用的功能代码，提供一种简便的 JavaScript 设计模式，优化 HTML 文档操作、事件处理、动画设计和 Ajax 交互。 ** 目前这个阶段，主要介绍如何来使用 jQuery 操作 DOM，其实就是学习 jQuery 封装好的那些功能方法，这些方法叫做 API（Application Programming Interface 应用程序编程接口）。 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:4:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"对 JavaScript 进行封装 jQuery 对 JavaScript 的哪些方面进行了封装 ？ 比如说 ： 获取事件源 类名操作 样式操作 内容操作 通过关系查找元素，也进行了封装 对 简单的动画 进行封装 …… 那我们需要学习它的使用方法(语法/规则) ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:4:3","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"DOM 和 jQuery 的基本使用区别 这里是网上找的一个，别人总结出来的两者区别，可以阅读一下 jQuery与DOM的区别 jQuery对象和DOM对象的区别 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:5:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"事件处理的区别 事件源 触发事件的对象 在 js 中就是 dom 对象 在 jQuery 中 是包装过的 dom 对象 事件 js 中 指的是 onclick , onmouseenter/onmouseleave , onmouseup/onmousedown jQuery 中 就是 click , mouseenter/mouseleave , mouseup/mousedown **事件处理程序 ↓↓ ** // 1. js中 obj.onclick = function() { // 事件处理 }; // jQuery中 $(obj).click(function() { // 事件处理 }); // 区别 // obj.onclick dom对象调用属性 // obj.click() jQuery对象调用方法 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:5:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"完整代码书写步骤 DOM书写格式 （1）获取事件源：document.getElementById(“box”); （2）绑定事件： 事件源 box.事件 onclick = function(){ 事件驱动程序 }; （3）书写事件驱动程序：关于 DOM 的操作。 最简单的代码举例：（点击 box1，然后弹框） \u003cbody\u003e \u003cdiv id=\"box1\"\u003e\u003c/div\u003e \u003cscript\u003e // 1、获取事件源 var div = document.getElementById(\"box1\"); // 2、绑定事件 div.onclick = function() { // 3、书写事件驱动程序 alert(\"我是弹出的内容\"); }; \u003c/script\u003e \u003c/body\u003e jQuery书写格式 （0）先下载 jQuery 源文件，引入页面 （想使用 jQuery，必须先引入 jQuery 文件代码） \u003cscript src=\"js/jquery-3.3.1.min.js\"\u003e\u003c/script\u003e \u003c!-- 如果没有引入，浏览器会报错： Uncaught ReferenceError: $ is not defined --\u003e （1）获取事件源：$( ' .box ' ) ; （2）绑定事件： 事件源 box.事件 click ( function ( ) { 事件驱动程序 } ) ; （3）书写事件驱动程序：关于 jQuery 的操作。 最简单的代码举例：（点击 box1，然后弹框） \u003cbody\u003e \u003cdiv id=\"box1\"\u003e\u003c/div\u003e \u003c!-- 先下载jQuery源文件 --\u003e \u003c!-- 引入 --\u003e \u003c!-- 同时注意引用顺序，引入之后才能使用，否则会报错 $ is not defined --\u003e \u003cscript src=\"js/jquery-3.3.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e // 1、获取事件源 2、绑定事件 3、书写事件驱动程序 $('#box1').click(function() { alert(\"我是弹出的内容\"); }) \u003c/script\u003e \u003c/body\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:5:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"DOM对象 和 jQuery对象 DOM对象，即是我们用传统的方法（javascript）获得的对象 jQuery对象，即是用 jQuery类库 的选择器获得的对象 jQuery对象就是通过jQuery包装DOM对象后产生的对象，它是jQuery独有的。 如果一个对象是jQuery对象，那么就可以使用jQuery里的方法 \u003cscript\u003e var domObj = document.getElementById(\"id\"); // domObj 是一个 DOM对象 var $obj = $(\"#id\"); // $obj 是一个 jQuery对象; \u003c/script\u003e 对于一个dom对象，只需要用$( )把dom对象包装起来，就可以获得一个jquery对象了，方法为$(dom对象) \u003cscript\u003e var cr=document.getElementById(\"cr\"); //dom对象 var $cr = $(cr); //转换成jquery对象 //转换后可以任意使用jquery中的方法了. //建议:如果获取的对象是 jquery对象，那么在声明变量时，变量名前面加上$,这样方便容易识别出哪些是jquery对象 var $variable = jquery对象; var variable = dom对象; \u003c/script\u003e 如何理解这句话 ↓↓ ？ 在 jquery 当中，有两个变量 $ 和 jQuery ，他们是等价的 jquery获取事件源的方式 $('.box’) 等价于 jQuery ('.box’) 在jq中 用 $( ) == jQuery( ) 来获取数据源 dom获取事件源的方式 document.querySelector('.box’) 在dom中，用 document 来获取事件源 \u003cscript\u003e var boxEl = document.querySelector('.box'); //boxEL =\u003e dom对象 var box = $('.box'); //box =\u003e jquery对象 // box 和 boxEl 并不等价 // 因为 用jquery 获取事件源 拿到的 不是 dom 对象(拿到的是进行了二次封装的dom对象),把它叫做jq对象 boxEl.click(function () { console.log(1); //并不会打印,不会进行任何操作,因为压根没有click这个方法 }); // boxEl 是原生dom,并没有click 这个方法, jq对象 才有 // 所以进行dom操作时,搞清楚 操作的是 原生dom对象 还是 jq对象 \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:5:3","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"入口函数 入口函数的功能 入口函数的作用是 页面加载完成后，再执行 function（）{ 里面的代码 } ，有了入口函数，就可以实现将 js代码 写在页面基本结构的 标签 之前 如果没有入口函数，js 会被浏览器逐行解析，此时书写 js 必须注意存在顺序 此时若将 \u003cscript\u003e 代码写在最上面，则可能导致浏览器先执行了js的标签操作，却还没解析生成标签，就会报错 jQuery 中的入口函数 可以用来取代 原生 JS 中的 入口函数（写法见下） 原生 JS 中的入口函数的写法 **window.onload = function ( ) { … } ** *onload 事件比较特殊，这里单独讲一下。*当页面加载（文本和图片）完毕的时候，触发 onload 事件。 作用是 页面加载完成后，再执行 function（）{ 里面的代码 } ，有了这个函数，就可以将 js代码 写在页面基本结构的 标签 之前 jQuery 中的入口函数的写法 $ ( document ) . ready ( function ( ) { … } ) ; 当文档对象执行完的时候，就执行 function 这个函数 ready 这个事件 就等价于 onload 这个事件 jQuery中的很多功能，实现起来的效果与原生 JS 一样，其实是 jQuery 对原生 JS 进行了封装，换成一种直接调用的方式，使得原生 JS 中原本实现书写 很复杂、麻烦的语句，变得非常简单 jQuery 学起来和原生 JS 相比，就是换了一种写法 jQuery 能实现的东西，原生 JS 都能实现 原生 JS 能实现的，jQuery 不一定能实现，因为 jQuery 只是封装了原生 JS 中的常用功能代码，不是全部 jQuery 中的入口函数可以直接简写成 ==\u003e $ ( function ( ) { … } ) ; 这是一种常见写法 推荐 这种形式的写法 ↑↑ js 和 jQuery 入口函数的区别 执行时间 window.onload 必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是 DOM 结构绘制完毕后就执行，不必等到加载完毕。只加载了 dom 框架，对于大的图片需要时间，这个不等。 编写个数 window.onload 不能同时编写多个，如果有多个 window.onload 方法，只会执行一个。 $(document).ready()可以同时编写多个，并且都可以得到执行。 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:5:4","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"获取事件源 \u003cbody\u003e \u003cp id=\"p1\"\u003e下雨了\u003c/p\u003e \u003cdiv class=\"box\"\u003e不凡\u003c/div\u003e \u003cp\u003e你好\u003c/p\u003e \u003c/body\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:6:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"JS 获取事件源 (dom元素,dom对象) 1. 通过选择器获取 DOM 节点的获取 有三种方式： 方式（1）：通过 id 获取 单个标签：get Element By Id var pEl = document.getElementById('p1'); // 拿到的对象pEl是 dom元素，也叫dom对象 方式（2）：通过 类名 获得 标签数组，所以有s get Elements By Class Name 数组形式(类数组) 具备长度、下标属性，但是不具备数组的方法 var box = document.getElementsByClassName('box'); var boxEl = box[0]; // 通过下标 获取到具体的 dom 元素 var boxL= box.length; // box为数组形式的dom对象，可以通过.length属性，获取box数组长度 方式（3）：通过 标签名 获得 标签数组，所以有s get Elements By Tag Name var p = document.getElementsByTagName('p')[1]; // 拿到的是 p标签中的第2个\u003cp\u003e你好\u003c/p\u003e 既然方式（2）、方式（3）获取的是标签数组，那么习惯性是先遍历之后再使用。 **特殊情况：数组中的值只有 1 个。**即便如此，这一个值也是包在数组里的。这个值的获取方式如下： document.getElementsByTagName(\"div1\")[0]; //取数组中的第一个元素 document.getElementsByClassName(\"hehe\")[0]; //取数组中的第一个元素 2. querySelector 获取方式—H5新增 html5 新选择器：参数是 css 选择器参数 document.querySelector(\"selector\") 选择选中的第一个 document.querySelectorAll(\"selector\") 选择多个，拿的是数组（符合这个选择器的所有元素） ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:6:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQ 获取事件源 ( jQuery对象 ) 通过选择器获取 jQuery 的基本选择器 符号 说明 用法 $('#demo’) 选择 id 为 demo 的元素 $('#demo’).css(‘color’,‘red’) $('.demo’) 选择 class 为 demo 的所有元素 $('.demo’).css(‘color’,‘red’) $(‘div’) 选择所有 div 标签元素 $(‘div’).css(‘color’,‘red’) $('*') 选择所有标签元素 $('*').css(‘color’,‘red’) $('.arr.arr-left’) 选择同时具有 arr 和 arr-left 类名的元素 $('.arr.arr-left’).css(‘color’,‘red’) 看起来和 css 的选择器没什么两样! jQuery 的其他选择器 层级选择器 (书写css样式时，同样适用 ↓↓ ) 符号 说明 用法 空格 后代选择器 $(‘div span’).css(‘color’,‘red’) \u003e 子代选择器 $(‘div\u003espan’).css(‘color’,‘red’) + 紧邻选择器：下一个兄弟 $(‘div+p’).css(‘color’,‘red’) ~ 兄弟选择器：后边所有兄弟 $(‘div~p’).css(‘color’,‘red’) 属性选择器 ​ (书写css样式时，同样适用 ↓↓ ) 符号 说明 用法 $(‘a[href]') 具有 href 属性的 a 标签 $(‘a[href]').css(‘color’,‘red’) $(‘a[href='baidu’]') href 属性为’baidu’的 a 标签 $(‘a[href='baidu’]').css(‘color’,‘red’) $(‘a[href!='baidu’]') href 属性不为’baidu’的 a 标签,包括不具有 href 属性的 a 标签 $(‘a[href!='baidu’]').css(‘color’,‘red’) $(‘a[href^='www’]') href 属性以’www’开头的 a 标签 $(‘a[href^='www’]').css(‘color’,‘red’) $(‘a[href$='cn’]') href 属性以’cn’结尾的 a 标签 $(‘a[href$='cn’]').css(‘color’,‘red’) $(‘a[href*='i’]') href 属性包含’i’的 a 标签 $(‘a[href*='i’]').css(‘color’,‘red’) $(‘a[href][title='内容’]') 具有 href 属性且 title 属性为’内容’的 a 标签 $(‘a[href][title='内容’]').css(‘color’,‘red’) 基本筛选选择器 符号 说明(index 从 0 开始) 用法 说明 :eq(index) 匹配一个给定索引值的元素 $(‘li:eq(1)').css(‘color’,‘red’) 匹配 li 中 下标为1的元素 :gt(index) 匹配所有大于给定索引值的元素 $(‘li:gt(1)').css(‘color’,‘red’) 匹配 li 中 下标\u003e1的所有元素 :lt(index) 匹配所有小于给定索引值的元素 $(‘li:lt(2)').css(‘color’,‘red’) 匹配 li 中 下标\u003c2的所有元素 :odd 匹配所有索引值为奇数的元素 $(‘li:odd’).css(‘color’,‘red’) 匹配 li 中 下标为奇数的所有元素 :even 匹配所有索引值为偶数的元素 $(‘li:odd’).css(‘color’,‘red’) 匹配 li 中 下标为偶数的所有元素 :first 获取匹配的第一个元素 $(‘li:first’).css(‘color’,‘red’) 匹配 li 中 第一个元素 :last 获取匹配的最后一个元素 $(‘li:last’).css(‘color’,‘red’) 匹配 li 中 最后一个元素 其他选择器 符号 说明(index 从 0 开始) 用法 说明 :empty 匹配所有不包含子元素或者文本的空元素 $(‘li:empty’) 匹配 li 中 不包含子元素 或 文本 的所有空元素 :contains(text) 匹配包含给定文本的元素 $(‘li:contains(‘john’)') 匹配 li 中 包含文本john 的所有元素 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:6:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"通过关系获取节点 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:7:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"DOM：节点关系获取元素 DOM 的节点并不是孤立的，因此可以通过 DOM 节点之间的相对关系对它们进行访问。如下： 节点的访问关系，是以属性的方式存在的。 JS 中的父子兄访问关系： 这里我们要重点知道parentNode和children这两个属性的用法。下面分别介绍。 \u003cdiv class=\"box\"\u003e \u003cdiv class=\"inner-box\"\u003e 内部盒子 \u003c/div\u003e \u003c/div\u003e \u003cul\u003e \u003cli class=\"li-item\"\u003eli1\u003c/li\u003e \u003cli class=\"li-item\"\u003eli2\u003c/li\u003e \u003cli class=\"li-item\"\u003eli3\u003c/li\u003e \u003cli class=\"li-item\"\u003eli4\u003c/li\u003e \u003cli class=\"li-item li5\"\u003eli5\u003c/li\u003e \u003cli class=\"li-item\"\u003eli6\u003c/li\u003e \u003c/ul\u003e 获取父节点 .parentNode 调用者就是节点。一个节点只有一个父节点，调用方式就是 // 节点.parentNode; var inner = document.getElementsByClassName('inner-box')[0]; var wBox = inner.parentNode; // 拿到inner的父节点，赋值给wBox console.log(wBox); 获取兄弟节点 1、下一个节点 Sibling 的中文是兄弟。 （1）nextSibling： var li5 = document.getElementsByClassName('li5')[0]; var next = li5.nextSibling; 火狐、谷歌、IE9+版本：都指的是下一个节点（包括标签、空文档和换行节点）。 IE678 版本：指下一个元素节点（标签）。 （2）nextElementSibling： var nextEl = li5.nextElementSibling; 火狐、谷歌、IE9+版本：都指的是下一个元素节点（标签）。 总结：为了获取下一个元素节点，我们可以这样做：在 IE678 中用 nextSibling，在火狐谷歌 IE9+以后用 nextElementSibling，于是，综合这两个属性，兼容写法 ↓↓ // 下一个兄弟节点 = 当前节点.nextElementSibling || 当前节点.nextSibling; **2、前一个节点 ** previous 的中文是：前一个。 （1）previousSibling： var next = li5.previousSibling; 火狐、谷歌、IE9+版本：都指的是前一个节点（包括标签、空文档和换行节点）。 IE678 版本：指前一个元素节点（标签）。 （2）previousElementSibling： var next = li5.previousElementSibling; 火狐、谷歌、IE9+版本：都指的是前一个元素节点（标签）。 总结：为了获取前一个元素节点，我们可以这样做：在 IE678 中用 previousSibling，在火狐谷歌 IE9+以后用 previousElementSibling，于是，综合这两个属性，兼容写法 ↓↓ // 前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling; 获取单个子节点 **1、第一个子节点 ** （1）firstChild： var ulEl = document.getElementsByTagName('ul')[0]; var first = ulEl.firstChild; 火狐、谷歌、IE9+版本：都指的是第一个子节点（包括标签、空文档和换行节点）。 IE678 版本：指第一个子元素节点（标签）。 （2）firstElementChild： var first = ulEl.firstElementChild; 火狐、谷歌、IE9+版本：都指的是第一个子元素节点（标签）。 总结：为了获取第一个子元素节点，我们可以这样做：在 IE678 中用 firstChild，在火狐谷歌 IE9+以后用 firstElementChild，于是，综合这两个属性，兼容写法 ↓↓ // 第一个子元素节点 = 节点.firstElementChild || 节点.firstChild; 2、最后一个子节点 （1）lastChild： var last = ulEl.lastChild; 火狐、谷歌、IE9+版本：都指的是最后一个子节点（包括标签、空文档和换行节点）。 IE678 版本：指最后一个子元素节点（标签）。 （2）lastElementChild： var last = ulEl.lastElementChild; 火狐、谷歌、IE9+版本：都指的是最后一个子元素节点（标签）。 总结：为了获取最后一个子元素节点，我们可以这样做：在 IE678 中用 lastChild，在火狐谷歌 IE9+以后用 lastElementChild，于是，综合这两个属性，兼容写法 ↓↓ // 最后一个子元素节点 = 当前节点.lastElementChild || 当前节点.lastChild; 获取所有的子节点 （1）childNodes：标准属性。返回的是指定元素的子节点的集合（包括元素节点、所有属性、文本节点）。是 W3C 的亲儿子。 火狐 谷歌等高版本，会把 换行、空格、… 都看做 是子节点。 用法： // 子节点数组 = 父节点.childNodes; // 获取所有节点。 var childN = ulEl.childNodes; // 所有子节点,包括换行符 （2）children：非标准属性。返回的是指定元素的子元素节点的集合。 ==【重要】== 它只返回 HTML 节点，甚至不返回文本节点。 在 IE6/7/8 中包含注释节点（在 IE678 中，注释节点不要写在里面）。 用法：（用的最多） // 子节点数组 = 父节点.children; // 获取所有子节点。用的最多。 var children = ulEl.children; // 所有标签节点 ; 组成伪数组 兼容问题： // 自己封装方法 实现 获取元素的 素有子元素节点 function myChildren(el) { var children = el.children; var myChildrenArr = []; console.log(children); for (var i = 0; i \u003c children.length; i++) { // 如何 判断 他是 注释节点 还是 元素几点 // nodeType = 8 注释节点 // nodeType = 1 元素节点 // nodeType = 3 是文本节点 if (children[i].nodeType === 1) { myChildrenArr.push(children[i]); } } return myChildrenArr; } var ulElChildren = myChildren(ulEl); nodeType 属性 这里讲一下 nodeType 属性。 ↑↑ 案例见上 nodeType == 1 表示的是元素节点（标签） 。记住：元素就是标签。 nodeType == 2 表示是属性节点。 nodeType == 3 是文本节点。 nodeType == 8 注释节点 获取除自己以外的所有兄弟节点 function getSiblings(el) { var siblings = []; var pNode = el.parentNode; var children = pNode.children; for (var i = 0; i \u003c children.length; i++) { // 兼容ie8 if (children[i].nodeType === 1) { // 不是el再push if (children[i] !== el) { siblings.push(children[i]); } } } return siblings; // siblings是一个数组，是由除了el元素以外的所有兄弟元素组成的数组 } 这个函数实现过程，在 jQuery 中被封装成现成的方法 在 JQ 中，可以直接调用 . siblings( ) 方法 ，实现获取除自己以外的所有兄弟节点 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:7:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQuery：通过关系获取 JQ 对象 \u003cul class=\"nav\"\u003e \u003cli class=\"nav-item\"\u003eli-1\u003c/li\u003e \u003cli class=\"nav-item active\"\u003eli-2\u003c/li\u003e \u003cli class=\"nav-item\"\u003eli-3\u003c/li\u003e \u003cli class=\"nav-item\"\u003eli-4\u003c/li\u003e \u003cli class=\"nav-item\"\u003eli-5\u003c/li\u003e \u003cli class=\"nav-item li6\"\u003eli-6\u003c/li\u003e \u003cli class=\"nav-item\"\u003e\u003cp\u003eli-7\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e \u003cscript src=\"js/jquery-3.4.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e var currentLi = $('.nav-item.active'); // li-2 //... \u003c/script\u003e 获取父元素 currentLi.parent(); // 父节点 // [0]ul.nav currentLi.parents(); // 所有父节点 // [0]: ul.nav [1]: body [2]: html currentLi.parentsUntil('html') // '\u003chtml\u003e'之前的所有父节点 // [0]: ul.nav [1]: body 注：所有输出结果是 在控制台打印后 才可见 console.log ( ) ; 获取兄弟元素 1. 后边的兄弟 currentLi.next(); // 下一个兄弟节点 // li-3 length=1 currentLi.nextAll(); // 后面的所有兄弟节点 // li-3~7 length=5 currentLi.nextUntil('.li6'); // 后面的兄弟节点,直到('...') // li-3~5 length=3 2. 前边的兄弟 currentLi.prev(); // 上一个兄弟节点 currentLi.prevAll(); // 前面的所有兄弟节点 currentLi.prevUntil('.li6'); // 前面的兄弟节点,直到('...') 获取除自己以外的所有兄弟节点 currentLi.siblings(); 获取子节点 . children ( ) $('.nav').children(); // .nav里的所有子节点 // li-1~7 var children = $('.nav').children(); children.eq(4); // 拿到所有子节点中 下标为4 的那个 // li-5 $('.item:eq(4)'); // 写在括号里的 :eq(index) 是作为筛选选择器 children.eq(4); // children调用的 .eq(index) 是方法 获取符合条件的后代节点 \u003cul class=\"nav\"\u003e \u003cli class=\"nav-item\"\u003eli-1\u003c/li\u003e \u003cli class=\"nav-item active\"\u003eli-2\u003c/li\u003e \u003cli class=\"nav-item\"\u003eli-3\u003c/li\u003e \u003cli class=\"nav-item\"\u003eli-4\u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003cp\u003eli-5\u003c/p\u003e \u003c/li\u003e \u003cli class=\"nav-item li6\"\u003eli-6\u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003cp\u003eli-7\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003cscript\u003e $('.nav').find('p'); // 获取.nav后代节点中的 所有p标签节点 // [0]:p li-5 , [1]:p li-7 \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:7:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"==总览== jQuery 方法 jQuery 方法 说明 $( ) . eq ( index ) 拿到对应下标的节点 $( ) . find ( ) 符合条件的后代节点 $( ) . siblings ( ) 除自己外的所有兄弟节点 $( ) . children ( ) 所有孩子节点 $( ) . next ( ) 下一个兄弟节点 $( ) . nextAll ( ) 后面的所有兄弟节点 $( ) . nextUntil ( ) 后面的兄弟节点，直到… $( ) . prev ( ) 上一个兄弟节点 $( ) . prevAll ( ) 前面的所有兄弟节点 $( ) . prevUntil ( ) 前面的兄弟节点，直到… $( ) . parent ( ) 父节点 $( ) . parents ( ) 所有父节点 $( ) . parentsUntil ( ) 所有父节点，直到… DOM 属性 DOM 属性 说明 dom . parentNode 父节点 dom . nextElementSibling 下一个兄弟节点（IE8以下不兼容） dom . nextSibling 下一个兄弟节点（包括标签、空文档和换行节点） dom . previousElementSibling 上一个兄弟节点（IE8以下不兼容） dom . previousSibling 上一个兄弟节点（包括标签、空文档和换行节点） dom . firstElementChild 第一个子节点 （IE8以下不兼容） dom . firstChild 第一个子节点（包括元素节点、所有属性、文本节点） dom . children 所有子节点 dom . childNodes 所有子节点（包括元素节点、所有属性、文本节点） dom . nodeType == 1/2/3/8 判断节点类型 == 元素节点（ 标签）/ 属性节点 / 文本节点 / 注释节点 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:7:3","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"事件绑定方式 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:8:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"js绑定事件的三种方式 1. 行内绑定 基本语法： \u003c标签 属性列表 事件=”事件的处理程序” /\u003e 例：\u003cinput type='button’ onclick='display()’ /\u003e 示例代码： 以上代码就是最典型的行内绑定，虽然可以完成我们需要的功能，但是其把结构+样式+行为都绑定在同一个标签中，不利于后期维护。 2. 动态绑定 基本语法： dom对象.事件 = 事件的处理程序（通常是一个匿名函数） 通过动态绑定这种思想改进上题，效果如下图所示： 3. 事件监听器 addeventlistener 绑定事件的第三种方式，可以更精细的控制事件 允许绑定多个 ① 采用一般事件获取方式，直接绑定函数时，只能绑定一次 var box = document.querySelector('.box'); box.onclick = function () { console.log(1); // 不会打印，因为已经被后面的绑定事件操作覆盖 } // 会覆盖,不能绑定多个 box.onclick = function () { console.log(2); // 打印 2 } ② 采用一般事件获取方式后，借助 **“ 事件监听器 ” ** 绑定函数：可多次绑定 **target . addEventListener ( type , listener , useCapture ) ; ** target : 给谁绑定 type : 事件类型 不加 on listener : 要执行的函数 ( 处理程序 ) useCapture : 使用捕获还是 冒泡 ( true 代表 捕获 ) ( false 代表冒泡 ) 不写默认 false box.addEventListener('click', function () { console.log(1); // 会打印 1 }) box.addEventListener('click', function () { console.log(2); // 同时也会打印 2 }) // 点击一次 box，会打印两行，分别打印 1 和 2 触发机制 由 useCapture 拓展 “ 触发机制 ” 触发机制：先捕获后冒泡 每个事件绑定时，可以指定绑在哪个阶段 ( 捕获阶段 和 冒泡阶段 ) 捕获：就是 从外往里 触发 冒泡：从里到外 触发 d1.addEventListener('click',function(){ alert('d1); },true) d2.addEventListener('click',foo,false) function foo(){ alert('d2'); } 实例 ↓↓ //当点击w3时，弹出顺序是 w1 w3 w2 w1.addEventListener('click', function () { alert('w1'); }, true)//true,则事件在从外向里的捕获阶段,就会触发 w2.addEventListener('click', function () { alert('w2'); }, false)//false,则事件在从外向里的捕获阶段,不会触发;捕获阶段走完,开始走冒泡阶段时,才会触发 w3.addEventListener('click', foo, true) //true,则事件在从外向里的捕获阶段,就会触发 function foo() { alert('w3'); } //所以当点击了w3时,事件开始从捕获阶段进入,先依次触发了w1,w3,进入冒泡阶段后,触发了w2 removeEventListener 移除绑定 如果同一个监听事件分别为“事件捕获”和“事件冒泡”注册了一次，一共两次，这两次事件需要分别移除。两者不会互相干扰。 移除的事件必须为外部事件（外部封装的函数）。 总结来讲，就是移除时，必须和绑定时一一对应。 d2.addEventListener(\"click\", foo, false); d2.removeEventListener(\"click\", foo, false); function foo() { alert(\"d2\"); } IE8 以下兼容问题 target.attachEvent(type, listener); target.detachEvent(type,listener); /** * 兼容IE8和标准浏览器 * el 绑定元素 * type 事件类型,IE8要加on * func 执行方法 **/ function myAddEventListener(el, type, func) { // attachEvent 是IE 专有的方法 if (el.attachEvent) { el.attachEvent(\"on\" + type, func); } else { el.addEventListener(type, func); } } ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:8:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"判断元素节点类型 节点类型 说明 值 元素节点 每一个HTML标签都是一个元素节点，如 、 、等 1 属性节点 元素节点（HTML标签）的属性，如 id 、class 、name 等。 2 文本节点 元素节点或属性节点中的文本内容。 3 注释节点 表示文档注释，形式为。 8 文档节点 表示整个文档（DOM 树的根节点，即 document ） 9 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:9:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"1. target.nodeName \u003c!--使用javascript判断节点名称--\u003e \u003cdiv id=\"oneDiv\"\u003e一段文本\u003c/div\u003e\u003c!--注释文本--\u003e \u003cscript type=\"text/javascript\"\u003e var div = document.getElementById(\"oneDiv\"); console.log(div.nodeName); //输出DIV，元素节点为标签大写 var divText = div.firstChild; console.log(divText.nodeName) //输出#text，文本节点使用nodeName时永远为#text var divAttr = div.getAttributeNode(\"id\"); console.log(divAttr.nodeName) //输出id，属性节点为属性名 var comment = div.nextSibling; console.log(comment.nodeName) //输出#comment，注释节点使用nodeName时永远为#comment \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:9:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"2. target.tagName 要访问元素的标签名，可以使用tagName或nodeName属性；这两个属性返回的值相同 假设HTML如下： \u003cdiv id=\"a\"\u003e\u003c/div\u003e 获取标签名： var ele = document.getElementById('a'); console.log(a.tagName) //DIV console.log(a.nodeName) //DIV console.log(a.nodeName == a.tagName) //true 在HTML中，标签名会以全部大写表示;而在XML中（部分XHTML）中，标签名则始终保持与源代码一致。 基于上面的特性，在判断标签名的时候，需要做些兼容处理： var ele = document.getElementById('a'); if( ele.tagName.toLocaleLowerCase() == 'div' ){ console.log( 'div success' ); } 有关它们的区别，这位老师总结的很详细，https://blog.csdn.net/borishuai/article/details/571922 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:9:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"3. target.nodeType \u003c!--使用javascript判断节点类型--\u003e \u003cdiv id=\"oneDiv\"\u003e一段文本\u003c/div\u003e\u003c!--注释文本--\u003e \u003cscript type=\"text/javascript\"\u003e var div = document.getElementById(\"oneDiv\"); console.log(div.nodeType); //输出1，元素节点 var divText = div.firstChild; console.log(divText.nodeType) //输出3，文本节点 var divAttr = div.getAttributeNode(\"id\"); console.log(divAttr.nodeType) //输出2，属性节点 var comment = div.nextSibling; console.log(comment.nodeType) //输出8，注释节点 \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:9:3","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"4. target.nodeValue \u003c!--使用javascript判断节点值--\u003e \u003cdiv id=\"oneDiv\"\u003e一段文本\u003c/div\u003e\u003c!--注释文本--\u003e \u003cscript type=\"text/javascript\"\u003e var div = document.getElementById(\"oneDiv\"); console.log(div.nodeValue); //输出null，元素节点对于nodeValue不支持 var divText = div.firstChild; console.log(divText.nodeValue) //输出一段文本，文本节点输出文本值 var divAttr = div.getAttributeNode(\"id\"); console.log(divAttr.nodeValue) //输出oneDiv，属性节点输出属性值 var comment = div.nextSibling; console.log(comment.nodeValue) //输出注释文本，注释节点输出注释内容 \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:9:4","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"理解Node类型 理解Node类型——不应被忽视的 nodeType、nodeName、nodeValue 原地址 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:10:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"Node 类型 DOM1级定义了 Node 接口，该接口将由 DOM 中的所有节点类型实现。这个 Node 接口在 JavaScript 中是作为 Node 类型实现的；除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。 这篇讲讲 Node 类型常会被忽视的三个属性：nodeType、nodeName、nodeValue。 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:10:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"nodeType 属性 每个节点都有一个 nodeType 属性，用于表明节点的类型，节点类型由 Node 类型中定义12个常量表示： 注：红色加粗为常用的节点类型 来看下面这个例子，看如何去 Node 类型节点，以及它 NodeType 属性。 ps: 可以直接复制出去运行 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"box\"\u003ehello nodeType~\u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e var element = document.getElementById(\"box\"); var attr = document.getElementById(\"box\").getAttributeNode(\"id\"); var text = document.getElementById(\"box\").firstChild; console.log(element.nodeType); //1 console.log(attr.nodeType); //2 console.log(text.nodeType); //3 \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:10:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"nodeName 属性与 nodeValue 属性 要了解节点的具体信息，可以使用 nodeName 和 nodeValue 这两个属性。这两个属性的值完全取决于节点的类型。 一般来说： 元素节点的 nodeName 是标签名称（大写） 属性节点的 nodeName 是属性名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document 这里可以改下上面的例子，打印这样的： console.log(document.nodeName) //#document console.log(element.nodeName); //DIV console.log(attr.nodeName); //id console.log(text.nodeName); //#text 对于文本节点，nodeValue 属性包含文本。 对于属性节点，nodeValue 属性包含属性值。 文档节点和元素节点，nodeValue 属性的值始终为 null。 console.log(document.nodeValue) //null console.log(element.nodeValue); //null console.log(attr.nodeValue); //box console.log(text.nodeValue); //hello nodeType~ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:10:3","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"节点的增删改查==（重要）== ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:11:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"DOM 节点的增删改查 上一段的内容：节点的访问关系都是属性。 本段的内容：节点的操作都是函数（方法）。 创建节点 格式如下： 新的标签(元素节点) = document.createElement(\"标签名\"); 比如，如果我们想创建一个 li 标签，或者是创建一个不存在的 adbc 标签，可以这样做： \u003cscript type=\"text/javascript\"\u003e var a1 = document.createElement(\"li\"); //创建一个li标签 var a2 = document.createElement(\"adbc\"); //创建一个不存在的标签 console.log(a1); // \u003cli\u003e\u003c/li\u003e console.log(a2); // \u003cadbc\u003e\u003c/adbc\u003e console.log(typeof a1); // object console.log(typeof a2); // object \u003c/script\u003e 插入节点 往页面中添加节点，依赖于父节点 插入节点有两种方式，它们的含义是不同的。 多次插入同一个节点的时候 ,相当于剪切效果 注意：如果是往 body 里插入，直接 var body = document.body 即可获取到 body 节点，不需要 getElements 将同一个元素，前后设置插入到不同的地方，并不会出现在两个地方，而是后次设置对前次设置进行了剪切 举例 ↓↓ \u003cdiv class=\"box\"\u003e \u003cdiv class=\"innerbox\"\u003e \u003cp class=\"txt\"\u003e天气很好\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e 方式 1： 父节点.appendChild(新的子节点); 解释：父节点的最后插入一个新的子节点。 // 创建节点 var el = document.createElement('p'); // \u003cp\u003e\u003c/p\u003e // 插入节点 // 将el这个节点 作为innerbox的子节点 插入进去, 从后添加 var innerbox = document.getElementsByClassName('innerbox')[0]; innerbox.appendChild(el); \u003cdiv class=\"box\"\u003e \u003cdiv class=\"innerbox\"\u003e \u003cp class=\"txt\"\u003e天气很好\u003c/p\u003e \u003cp\u003e\u003c/p\u003e \u003c!-- 执行结果是: 这里插入了一个p标签 --\u003e \u003c/div\u003e \u003c/div\u003e 方式 2： 父节点.insertBefore(新的子节点, 作为参考的子节点); 解释： 在参考节点前插入一个新的节点。 如果参考节点为 null，那么他将在父节点里面的最后插入一个子节点。 // 创建一个div节点 var el1 = document.createElement('div'); // \u003cdiv\u003e\u003c/div\u003e // 获取类名为txt的节点 var pEl = document.getElementsByClassName('txt')[0]; // 插入节点 // box.appendChild(el1); //方式1: el1作为子节点插入到box内部的最后面 box.insertBefore(el1, pEl); //方式2: el1作为子节点插入到box内部的pEl节点之前 // 如果参考节点为null，那么他将在节点最后插入一个节点。 box.insertBefore(pEl, imgEl); \u003cdiv class=\"box\"\u003e \u003cdiv class=\"innerbox\"\u003e \u003cdiv\u003e\u003c/div\u003e \u003c!-- 执行结果是: 这里插入了一个div标签 --\u003e \u003cp class=\"txt\"\u003e天气很好\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e 删除节点 格式如下： 父节点.removeChild(子节点); 解释：用父节点删除子节点。必须要指定是删除哪个子节点。 box.removeChild(pEl); // 删除 box节点中 的子节点 pEL //如果想删除自己这个节点：自己(先调用属性获取到父节点)删除自己 pEl.parentNode.removeChild(pEl); // pEl调用parentNode属性拿到父节点，然后从父节点中删除pEl // 本质上，删除节点操作 仍然是依赖父节点的 复制节点（克隆节点） 格式如下： 要复制的节点.cloneNode(); // 括号里不带参数和带参数false，效果是一样的：只复制节点本身 要复制的节点.cloneNode(true); // 括号里带参数true，是深复制：复制节点本身及其所有子节点 括号里带不带参数，效果是不同的。解释如下： 不带参数/带参数 false：只复制节点本身，不复制子节点。 带参数 true：既复制节点本身，也复制其所有的子节点。——深复制 var temp = box.cloneNode(true); var tempF = box.cloneNode(false); console.log(temp); console.log(tempF); \u003c!-- 控制台输出结果 --\u003e \u003c!-- temp 深复制 --\u003e \u003cdiv class=\"box\"\u003e \u003cdiv class=\"innerbox\"\u003e \u003cp class=\"txt\"\u003e天气很好\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- tempF --\u003e \u003cdiv class=\"box\"\u003e \u003c/div\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:11:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQuery 节点的增删改查 \u003cdiv class=\"box\"\u003e\u003c/div\u003e \u003cul\u003e \u003cli\u003e1\u003c/li\u003e \u003cli\u003e2\u003c/li\u003e \u003cli class=\"active\"\u003e3\u003c/li\u003e \u003cli\u003e4\u003c/li\u003e \u003c/ul\u003e 创建节点 格式如下： var 变量名 = $('闭合标签'); // 注意是写在'引号'里面，字符串形式 创建过程，会自动把 “ 字符串 ” 里的 标签，包装成一个节点 注意是 “ 字符串 ”，且是一个闭合标签 创建时，除了写标签外，也可以选择书写内容和属性；也可以后面用 attr ( ) 设置属性 var jqNode1 = $('\u003cimg src=\"img/m1.jpg\" alt=\"\"\u003e'); var jqNode2 = $('\u003cp\u003e不凡\u003c/p\u003e'); console.log(jqNode1); // 打印出 img标签 的节点 console.log(jqNode2); // 打印出 p标签 的节点 如图打印结果，就是将 $('\u003cimg src=\"img/m1.jpg\" alt=\"\"\u003e'); 包装成一个 img 节点（jQuery对象） 打印结果为 k.fn.init [ ] 就说明是 jQuery 对象 插入节点 \u003cdiv class=\"box\"\u003e\u003c/div\u003e \u003cdiv class=\"box1\"\u003e\u003c/div\u003e \u003cdiv class=\"box2\"\u003e\u003c/div\u003e append() 参数 jq对象 或 标签字符串 或 DOM对象 ，也就是可以传 jq对象，标签字符串，原生dom 作用：在被选元素内部从前面追加内容或节点。 如果是页面中存在的元素，那么调用 append ( ) 后，会把这个元素放到相应的目标元素里面去；但是，原来的这个元素，就不存在了。(剪切) **对一个元素多次进行追加到其他位置的操作，就是剪切 ** $('.box').append($p); //参数是jq对象 $('.box1').append('\u003cp\u003e不凡\u003c/p\u003e');//参数是标签字符串 var pEl = createElement('p');//原生js方法，创建了一个p标签 =\u003e pEl是一个dom对象 $('.box2').append(pEl);// 参数是原生dom 如果是给多个目标追加元素，那么方法的内部会复制多份这个元素，然后追加到多个目标里面去。 \u003cul\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ul\u003e \u003cscript\u003e $('li').append(pEl); // $('li')对象，代表了多个元素，此时会往每个li里都插入pEl， //而pEl原来的位置是被创建插入到.box2中，经过此次append后，.box2中已经没有pEl了，但每个li中都会有pEl \u003c/script\u003e appendTo ( ) 作用：把$(selector)追加到node中去 append ( ) 作用是：在被选元素内部，从前面追加内容或节点。 二者是，把字句 和 被字句 的关系 $(selector).appendTo(node); $('.box2').append(pEl); // 在box2里追加 pel $(pEl).appendTo($('.box2')); // 把pel追加到box2里 //这两句代码是等价的 //通常使用 append（）即可 prepend() 参数 jq对象 或 标签字符串 或 DOM对象 作用：在被选元素内部从前面追加内容或节点。 注意问题与 append ( ) 基本一致 after() 作用：在被选元素之后，作为兄弟元素插入内容或节点 $(selector).after(node); before() 作用：在被选元素之前，作为兄弟元素插入内容或节点 $(selector).before(node); 对于这些添加方法，node 可以是jq对象 或 标签字符串 或 DOM对象。 清空元素 共有3个方式： 不需要再借助父节点 $(selector).empty(); // 清空selector里面的内容，selector依然存在 $(selector).html('...'); // 清空selector里面的内容，但是会把“引号”里的内容追加进去 $(selector).remove(); //清空selector里面的内容，同时会把selector自己也删除 . html（ \" \" ）：这个原本是做内容操作，用来追加内容， 但是它本身机制，是讲被选元素里的内容，全部替换为 引号里的，如果引号不填内容，实际上就是变相的实现了 清空元素的作用； 引号里填了内容，就是实现完全替换的作用 .text（）：同理，也可以用来清空元素； 区别是text()不能识别标签，如果有替换元素，则仅以文本形式存在 复制元素 格式如下： $(selector).clone(); 参数，与dom相同：要复制的节点 . cloneNode ( ) 不带参数/带参数 false：只复制节点本身，不复制子节点。 带参数 true：既复制节点本身，也复制其所有的子节点。——深复制 $('.box').clone(); var clone = $('.box').clone(); console.log(clone); ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:11:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"样式操作 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:12:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"DOM 的样式修改 dom对象 . style . 属性名 = ' 属性值 ' \u003cdiv class=\"box\" style=\"color:orange;\"\u003e不凡\u003c/div\u003e \u003cscript\u003e var box = document.getElementsByClassName('box')[0]; box.onclick = function () { box.style.color = 'blue'; box.style.width = '300px'; // font-size 写成 fontSize (‘-’拼接字符命名的属性名 改为 驼峰命名) box.style.fontSize = '24px'; // 这些属性，修改的都是 标签的行内样式 } \u003c/script\u003e date-* — H5新增 *自定义属性 data- ** 功能强大：可以修改样式，但这只是data-*的基础操作，有待深挖研究 \u003cul class=\"nav\"\u003e \u003cli class=\"nav-item active\" data-color=\"red\" data-info=\"你好\"\u003eli1\u003c/li\u003e \u003cli class=\"nav-item\" data-color=\"blue\"\u003eli2\u003c/li\u003e \u003cli class=\"nav-item\" data-color=\"orange\"\u003eli3\u003c/li\u003e \u003cli class=\"nav-item\" data-color=\"pink\"\u003eli4\u003c/li\u003e \u003cli class=\"nav-item\" data-color=\"green\"\u003eli5\u003c/li\u003e \u003cli class=\"nav-item\" data-color=\"gray\"\u003eli6\u003c/li\u003e \u003c/ul\u003e \u003cscript\u003e // 自定义属性 data-* // 如何获取自定义属性值 Node.dataset['color'] 我们便可以获取到自定义的属性值。 console.log(liArr[0].dataset); // {color: \"red\", info: \"你好\"} console.log(liArr[0].dataset['color']); // red for (var i = 0; i \u003c liArr.length; i++) { var temp = liArr[i].dataset['color']; //获取每一个li的data-color值，存在temp里 liArr[i].style.backgroundColor = temp; // 然后赋给 每个li的背景颜色样式中 } \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:12:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQuery 的样式修改 . css( ) $ ( ' 选择器 ' ) . css ( ' 属性名 ' , ' 属性值 ' ) \u003cdiv class=\"box\" style=\"color:orange;\"\u003e不凡\u003c/div\u003e \u003cscript\u003e $('.box').click(function () { // $('.box').style.color = 'red'; 错误 // 获取样式 var tempColor = $('.box').css('color'); console.log(tempColor); // 没有设置字体颜色时,默认是rgb(0, 0, 0) 黑色 // 修改样式 $('.box').css('color', 'red'); // 设置多个样式: css里写一个对象,对象中写入,多个样式信息 $('.box').css({ color: 'blue', width: '200px', height: '200px', backgroundColor: 'red' }) }) \u003c/script\u003e . css ( ) 写法 和 . attr ( ) 写法一致，书写方式一致：都可以设置修改 单个 或 多个 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:12:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"属性操作 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:13:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"DOM 的属性操作 \u003cdiv class=\"box\" title=\"你好\"\u003e不凡\u003c/div\u003e \u003cimg src=\"\" alt=\"\"\u003e \u003cscript\u003e var img = document.getElementsByTagName('img')[0]; var box = document.getElementsByClassName('box')[0]; //... \u003c/script\u003e 设置节点属性 方式（1）：dom对象 . 属性名 = \" 属性值 \" img.src = 'img/m1.jpg'; box.title = '天气'; box.className = 'd1'; 方式（2）： setAttribute ( 属性名 , 属性值 ) box.setAttribute('class', 'box1'); // 类名修改为box1 box.setAttribute('title', '你好吧'); // 设置title为“你好吧” img.setAttribute('src', 'img/m2.jpg'); // 设置\u003cimg\u003e的图片路径 获取节点属性 方式（1）：dom对象 . 属性名 方式（2）：getAttribute( 属性名 ) console.log(box.title); // 你好吧 console.log(box.getAttribute('title')); // 你好吧 删除属性 removeAttribute ( \" 属性名 \" ) box.removeAttribute('title'); ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:13:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQuery 的属性操作 . attr ( ) \u003cimg src=\"images/05.jpg\" alt=\"\"\u003e \u003cscript src=\"js/jquery-3.4.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e //... \u003c/script\u003e 设置节点属性 方式（1）：$ ( ' 选择器 ' ) . attr ( ' 属性名 ' , ' 属性值 ' ) 设置修改单个属性 $('img').attr('src', 'images/06.jpg'); // 设置图片路径 $ ( ' 选择器 ' ) . prop ( ) ：常用来 设置 修改 属性值为（ true / false ）的属性 浅谈 jQuery 中 prop( ) 和 attr( ) 方式（2）：$ ( ' 选择器 ' ) . attr ( { 属性名 : ' 属性值 ' ，属性名 : ' 属性值 ' } ) 设置修改多个属性 ( 对象 ) $('img').attr({ src: 'images/02.jpg', //注意：对象形式中，每个属性间隔用“,”逗号 alt: 'sorry' }) . attr ( ) 写法和 . css ( ) 写法一致：都可以设置修改 单个 或 多个 获取节点属性 var src = $('img').attr('src'); console.log(src); // images/05.jpg 删除属性 $ ( ' 选择器 ' ) . removeAttr ( \" 属性名 \" ) $('img').removeAttr('alt') ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:13:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"类名操作 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:14:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"DOM 的类名操作_—_H5新增 \u003cul\u003e \u003cli class=\"li-item\"\u003eli1\u003c/li\u003e \u003cli class=\"li-item\"\u003eli2\u003c/li\u003e \u003c/ul\u003e \u003cscript\u003e var lis = document.getElementsByClassName('li-item'); //... \u003c/script\u003e **追加类名：dom. classList . add ( ' 类名 ' ) ** lis[0].classList.add('danger'); // \u003cli class=\"li-item danger\"\u003eli1\u003c/li\u003e **删除类名：dom. classList . remove ( ' 类名 ' ) ** lis[0].classList.remove('danger'); // \u003cli class=\"li-item\"\u003eli1\u003c/li\u003e **有则删除，无则添加：dom. classList . toggle ( ' 类名 ' ) ** lis[0].classList.toggle('strong'); // 切换类名 \u003cli class=\"li-item danger\"\u003eli1\u003c/li\u003e **判断是否有该类名：dom. classList . contains ( ' 类名 ' ) ** console.log(lis[1].classList.contains('danger'));// 返回 true/false // false . contains 检测是否存在 class 非常好用，但是出现的太晚了 。。。T o T ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:14:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQuery 的类名操作 \u003cp class=\"txt\"\u003e不凡\u003c/p\u003e \u003cscript src=\"js/jquery-3.4.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e //... \u003c/script\u003e 追加类名：$ ( ' 选择器 ' ) . addClass ( ' 类名 ' ) $('p').addClass('danger'); // 向被选元素添加一个或多个类 // \u003cp class=\"txt danger\"\u003e不凡\u003c/p\u003e 删除类名：$ ( ' 选择器 ' ) . removeClass ( ' 类名 ' ) $('p').removeClass('danger'); // 从被选元素删除一个或多个类 // \u003cp\u003e不凡\u003c/p\u003e 有则删除，无则添加：$ ( ' 选择器 ' ) . toggleClass ( ' 类名 ' ) $('p').toggleClass('danger'); // 对被选元素进行添加/删除类的切换操作 // \u003cp class=\"danger\"\u003e不凡\u003c/p\u003e 判断是否有该类名：$ ( ' 选择器 ' ) . hasClass ( ' 类名 ' ) console.log($('p').hasClass('danger')); // 判断被选元素是否存在类，返回值true/false // true ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:14:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"内容操作 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:15:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"DOM 的内容操作：调用 . 属性 调用属性，直接等号赋值 （ dom . 属性名 = ’ ‘ ） DOM 对象的属性和 HTML 的标签属性几乎是一致的。例如：src、title、className、href 等。 innerHTML 和 innerText ↑↑ 这俩属性实现的是 对元素内部的内容的完全替换 即会先删除元素内部的所有内容，再将 等号= 后的值添加到元素中 也就是说如果等号=后为空，则实现了清空元素内部所有内容的效果 box.innerHTML = ''; // 将box元素里的内容替换为‘’,即清空box元素里的内容 **dom对象 . innerHTML = \" …. \" ; ** 双闭合标签里面的内容（识别标签）。可以用来动态的生成页面 \u003cdiv class=\"box\"\u003e不凡\u003c/div\u003e \u003cul class=\"box\"\u003e \u003c/ul\u003e \u003cscript\u003e var box = document.getElementsByClassName('box')[0]; var box1 = document.getElementsByClassName('box')[1]; //... \u003c/script\u003e box.innerHTML = '\u003ch1\u003e今天天气很好\u003c/h1\u003e'; // 识别标签 // \u003cdiv class=\"box\"\u003e\u003ch1\u003e今天天气很好\u003c/h1\u003e\u003c/div\u003e // **动态生成**的标准写法：采用for循环\u003e累加的思想 var str = ''; for (var i = 0; i \u003c= 100; i++) { str += '\u003cli\u003eli' + i + '\u003c/li\u003e'; } box1.innerHTML = str; **dom对象 . innerText = \" …. \" ; ** 双闭合标签里面的内容（不识别标签）。 ( 老版本火狐用 textContent ) box.innerText = '\u003ch1\u003e今天天气很好\u003c/h1\u003e'; //（不识别标签） // \u003cdiv class=\"box\"\u003e今天天气很好\u003c/div\u003e 表单的内容操作 \u003c!-- 输入框 --\u003e \u003cinput type=\"text\" value=\"请输入内容\"\u003e \u003c!-- 单选框 --\u003e 男:\u003cinput type=\"radio\" class=\"sex\" name=\"sex\"\u003e 女:\u003cinput type=\"radio\" class=\"sex\" name=\"sex\"\u003e \u003cbutton\u003e选择男生\u003c/button\u003e \u003c!-- 复选框 --\u003e 篮球：\u003cinput type=\"checkbox\" class=\"cb\" name=\"like\"\u003e 足球：\u003cinput type=\"checkbox\" class=\"cb\" name=\"like\"\u003e \u003c!-- 下拉框 --\u003e \u003cselect\u003e \u003coption value=\"1\" class=\"s1\" \u003e选项内容1\u003c/option\u003e \u003coption value=\"2\" class=\"s2\" \u003e选项内容2\u003c/option\u003e \u003c/select\u003e \u003cscript\u003e //... ↓↓ \u003c/script\u003e **dom对象 . value = \" … \" ** 直接调用 输入框 的 value 属性 .value = ’ ‘ var input = document.getElementsByTagName('input')[0]; input.onfocus = function () { // .onfocus ：获得焦点 input.value = ''; // 输入框value值，设为空 } **dom对象 . checked = \" true / false \" ** 单选框 和 复选框 的 checked 属性。 var btn = document.getElementsByTagName('button')[0]; var men = document.getElementsByClassName('sex')[0]; var cb1 = document.getElementsByClassName('like')[0]; btn.onclick = function () { //点击 按钮 men.checked = true; //men的input的checked属性，设为true，即-被选中 } cb1.checked = true; // 复选框 默认选中 篮球 **dom对象 . selected = \" true / false \" ** 下拉菜单 的 selected 属性。 var select2 = document.getElementsByTagName('s2')[0]; select2.selected = 'true'; // 下拉菜单 默认显示 .s2 的选项内容 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:15:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQuery 的内容操作：调用方法 ( ) html()、text()、value()、prop() 可以取值、设值 方法 说明 实例 html ( ) $ ( ' p ' ) . html ( ) $ ( \" p \" ) . html ( ' html 代码 ' ) text ( ) $ ( ' p ' ) . text ( ) $ ( ' p ' ) . text ( ' 内容 ' ) value ( ) $ ( ' input ' ) . value ( ) $ ( ' input ' ) . value ( ' 姓名 ' ) prop ( ) $ ( ' input ' ) . prop ( ' checked ' ) $ ( ' input ' ) . prop ( ' checked ' , false ) html()、text() 同时也具有清空的功能 因为它俩实现效果是：将调用元素内部的所有子元素都替换为html方法的（）中的内容，也就是说，如果（）里没有内容，则实现的是清空的功能 $('div').html(); // 将div内的所有子元素替换为()中的内容，也就是替换为空，即清空div子元素 $('div').html(); // 将div内的所有子元素替换为()中的内容，也就是替换为空，即清空div子元素 ​ 延伸：prop() 和 attr() 的区别 prop ( ) ：常用来设置、修改属性值为 true / false 的属性： checked属性、selected属性 …… attr ( ) ：可以用来设置修改所有属性的值 两者都可以修改属性，那有什么区别 ？？ 浅谈 jQuery 中 prop ( ) 和 attr ( ) DOM 补充 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:15:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"arguments 对象 arguments 对象：函数的实参对象，只能在函数内部使用 console.log(arguments) =\u003e 输出 类数组：保存了传进来的 实参信息（如图 ↓ ） \u003cscript\u003e // arguments 对象 : 函数的实参对象,只能在函数内部使用 function add(x, y, z) { // console.log(arguments) =\u003e 输出形式：类数组,保存了传进来的 实参信息 console.log(arguments); //[1, 3, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ] console.log(arguments[1]); //3 console.log(arguments.callee); // 打印出了 这个函数本身 //多数情况下没什么用,but递归 return x + y + z; } add(1, 3, 5); // 既然 arguments.callee 是函数本身，符合递归思想：可以实现自己调用自己 // 可以用来写递归函数 ↓↓ function foo(n) { if (n === 1) { return 1 } // return foo(n - 1) * n; return arguments.callee(n - 1) * n; } \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:16:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"定时器 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:17:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"延迟定时器 setTimeout ( ) setTimeout(function(){console.log('你好');}, 1000) // 触发后 延迟1秒，函数开始执行，执行1次 作用：可以让写在其内部的 function 函数，延迟执行 函数作为参数，称为回调函数 第一个参数：要执行的函数（时间到了就执行 ） 第二个参数：设置参数延迟时间（ 以毫秒为单位 ） 执行次数：只会执行一次 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:17:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"循环定时器 setInterval ( ) setInterval(function(){console.log('不凡')}, 1000) // function 每隔1秒，执行1次 作用：可以让写在其内部的 function 函数，每隔一段时间，就执行一次 函数作为参数，称为回调函数 第一个参数：要执行的函数（时间到了就执行 ） 第二个参数：设置参数延迟时间（ 以毫秒为单位 ） 执行次数：循环执行 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:17:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"清除定时器 clearTimeout ( ) var timer1 = setTimeout(function () {console.log('你好');} ,1000); var timer2 = setInterval(function () {console.log('不凡');} ,1000); clearTimeout(timer1); clearTimeout(timer2); 作用：顾名思义，可以用于清除以上两种定时器 需要给要清除的定时器起名字，才能使用 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:17:3","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"立即执行函数 现有匿名函数如下： function(a, b) { console.log(\"a = \" + a); console.log(\"b = \" + b); }; 立即执行函数如下： (function(a, b) { console.log(\"a = \" + a); console.log(\"b = \" + b); })(123, 456); 立即执行函数：函数定义完，立即被调用，这种函数叫做立即执行函数。 立即执行函数往往只会执行一次。为什么呢？因为没有变量保存它，执行完了之后，就找不到它了。 立即执行函数的应用 循环绑定事件时，解决如何获取当前点击元素的下标。 for (var i = 0; i \u003c lis.length; i++) { lis[i].onclick = (function(n) { return function() { console.log(n); }; })(i); } jQuery 补充 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:18:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"mouseover 和 mouseout 区别 \u003c!-- 红盒子 --\u003e \u003cdiv class=\"box\"\u003e \u003c!-- 绿盒子 --\u003e \u003cdiv class=\"inner-box\"\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript src=\"js/jquery-3.4.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e $('.box').mouseenter(function () { console.log('mouseenter') }) $('.box').mouseover(function () { console.log('mouseover') }) // 两者 都是 鼠标进入 // mouseover 会触发多次, 进入子类元素时，会再次触发，从子类元素回到父类时，又会触发；来回在子类和父类间移动，就会来回触发，不停在控制台打印 // mouseenter 进入父类盒子触发打印，顺势进入子类盒子，不会打印；也就是将整个父类盒子的范围作为主体，绑定的事件与子类无关 \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:19:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQuery 动画 \u003cdiv class=\"box\"\u003e\u003c/div\u003e \u003cbutton class=\"btn\"\u003e显示\u003c/button\u003e \u003cbutton class=\"btn\"\u003e隐藏\u003c/button\u003e \u003cbutton class=\"btn\"\u003eslideDown滑入\u003c/button\u003e \u003cbutton class=\"btn\"\u003eslideUp滑出\u003c/button\u003e \u003cbutton class=\"btn\"\u003efadeIn淡入\u003c/button\u003e \u003cbutton class=\"btn\"\u003efadeOut淡出\u003c/button\u003e \u003cbutton class=\"btn\"\u003efadeTo\u003c/button\u003e \u003cscript src=\"js/jquery-3.4.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e //... \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:20:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"隐藏(hide)/显示动画(show) $ ( selector ) . show ( speed , callback ) ; speed：显示动画的时长（毫秒单位） 参数1 也可以填关键字 slow ( 600 ) / normal ( 400 ) / fast ( 200 ) callback：回调函数：显示动画结束后，执行的函数 function ( ) { … } ; ​ 隐藏动画 hide ( ) ， 同 show ( ) $ ( selector ) . show ( 2000 ) ; $ ( selector ) . show ( slow ) ; slow ( 600 ) / normal ( 400 ) / fast ( 200 ) $ ( selector ) . show ( 2000 , function ( ) { … } ) ; $ ( selector ) . show ( ) ; $('.btn').eq(1).click(function () { $('.box').hide(2000) //用2秒时间来完成隐藏动作 }); $('.btn').eq(0).click(function () { $('.box').show(2000, function () { //2秒显示出来后，瞬间修改css样式宽变为100，颜色绿 $(this).css({ width: '100px', backgroundColor: 'green' }) }) }); ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:20:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"滑入滑出动画 修改的是 . box 的 height 值 $ ( selector ) . slideDown/Up/Toggle ( speed , callback ) ; speed：显示动画的时长（毫秒单位） 参数1 也可以填关键字 slow ( 600 ) / normal ( 400 ) / fast ( 200 ) callback：回调函数：显示动画结束后，执行的函数 function ( ) { … } ; $ ( selector ) . slideDown ( speed , callback ) ; $ ( selector ) . slideUp ( speed , callback ) ; $ ( selector ) . slideToggle ( speed , callback ) ; $('.btn').eq(2).click(function () { $('.box').slideDown(1000) }); $('.btn').eq(3).click(function () { $('.box').slideUp(1000) }); ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:20:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"淡入淡出动画 $ ( selector ) . slideDown/Up/Toggle ( speed , callback ) ; speed：显示动画的时长（毫秒单位） 参数1 也可以填关键字 slow ( 600 ) / normal ( 400 ) / fast ( 200 ) callback：回调函数：显示动画结束后，执行的函数 function ( ) { … } ; $ ( selector ) . fadeIn ( speed , callback ) ; $ ( selector ) . fadeOut ( speed , callback ) ; $ ( selector ) . fadeToggle ( speed , callback ) ; $ ( selector ) . fadeTo ( speed , opacity ) ; 调节透明度 $('.btn').eq(4).click(function () { $('.box').fadeIn(1000) // 淡入 }); $('.btn').eq(5).click(function () { $('.box').fadeOut(1000) // 淡出 }); $('.btn').eq(6).click(function () { $('.box').fadeTo(1000, 0.3); // 将被选元素.box的不透明度逐渐地改变为指定的值0.3 }); 注意：省略参数或者传入不合法的字符串，那么则使用默认值：400 毫秒 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:20:3","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"自定义动画 和 停止动画 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:21:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"自定义动画 $ ( selector ) . animate ( styles , speed , ease , callback ) 第一个参数表示：要执行动画的 CSS 属性（必选） 第二个参数表示：执行动画时长（可选） 第三个参数表示: 运动函数 ' swing ' 和 ' linear ' 第四个参数表示：动画执行完后立即执行的回调函数（可选） ​ ↓↓↓↓ \u003cbutton class=\"start\"\u003e开始\u003c/button\u003e \u003cbutton class=\"stop\"\u003e停止\u003c/button\u003e \u003cscript src=\"js/jquery-3.4.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e // animate() $('.start').click(function () { $('.box').animate({ width: '400px', left: '600px', top: '100px' // 颜色不能参与动画,但是可以借助一些 插件 实现 // backgroundColor: 'green' // marginLeft: '600px' }, 1000, 'linear', function () { $('.box').animate({ left: 200 }, 1000, 'linear') }) // 可以为他指定多个动画,但是动画会进入排队状态,上一个执行完,下一个才能开始 // 回调函数异步 ,必须等同步执行完,他才能执行 $('.box').animate({ left: '1000px' }, 1000, 'linear') }) // 如何停止动画 $('.stop').click(function () { // stop(stopAll,goToEnd) $('.box').stop(false, false) }) \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:21:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"停止动画 ↑↑↑↑ stop ( ) ; 停止当前动画 为什么要停止动画？如果多个动画同时作用于一个单位上面，那么多个动画会进入排队。后一个动画的执行必须等前面的执行完毕。 stop ( stopAll , goToEnd ) stopAll：是否全部停止动画（停止队列中所有动画），默认 false goToEnd： 是否将停止的动画,停在当前动画的最后一个状态 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:21:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"BOM 相关 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:22:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"宽高设置 （ 这两个方法( ) 并不常用，更多是通过css样式来设置或修改宽高） height ( ) height ( 200 ) width ( ) width ( 100 ) 取值类型为 num 可以直接参与运算 // width() / height() console.log($('.box').width()) // 获取元素 宽和高 num 数值 可以参与运算 $('.box').width(300); // 也可以用来设置宽高 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:22:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"坐标值操作：获取元素位置 offset() 作用：获取或设置元素相对于文档的位置 $(selector).offset(); $(selector).offset({left:100, top: 150}); console.log($('.box').offset()); // 用于获取 {top: 100, left: 100} console.log($('.box').offset().left); // 用于获取 100 $('.box').offset({ // 用于设置 top: 200, left: 150 }) position() 作用：获取相对于其最近的具有定位的父元素的位置。 $(selector).position(); 注意：只能获取，不能设置。 console.log($('.inner').position()); // {top: 0, left: 80} 回到顶部 scrollTop() 作用：获取或者设置元素垂直方向滚动的位置 $(selector).scrollTop(); $(selector).scrollTop(100); // 原生 js 获取 scrollTop var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; console.log(scrollTop) // jQuery 获取 scrollTop console.log($(document.documentElement).scrollTop()); // 实例应用：回到顶部 $('.top').click(function () { // $(document.documentElement).scrollTop(0); 回到顶部效果 $(document.documentElement).animate({ //回到顶部效果，上面和这个的最终呈现一样，但是animate实现了动画过渡，不会特别生硬 scrollTop: 0 }, 2000) }) ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:22:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"on方式绑定事件 html \u003cdiv class=\"box\"\u003e \u003cp\u003e不凡\u003c/p\u003e \u003ca href=\"javascript:;\"\u003enihao\u003c/a\u003e \u003c/div\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:23:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQuery 正常绑定事件的方式 $('.box').click(function () { // 这里是 jq 正常绑定事件的方式 console.log('click') }) ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:23:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"on ( ) 方法 绑定事件的方式 $('.box').on('mouseenter', function () { console.log('你好') //鼠标移入 \u003cp\u003e不凡\u003c/p\u003e 和 \u003ca\u003enihao\u003c/a\u003e 都会在控制台打印'你好' }) on ( ) 方法：一共有三个参数 第1个参数：是要绑定的事件名 第2个参数：用来过滤后代元素（!） 第3个参数：是执行程序 $('.box').on('click', 'p', function () { // (第2个参数写了p,就只绑定p标签,点击a标签不再触发box 的点击事件) // 其实就相当于，获取了.box的jq对象，对其内部的p标签，进行绑定点击事件 和 执行程序 console.log('点击') // 点击.box里的p标签才会打印;点击a标签不再触发 }) ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:23:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"如何解绑事件：off ( ) $('.box').off( ); // 不写参数: 全部解绑 $('.box').off('mouseenter'); // 解绑括号里的'鼠标进入mouseenter'事件 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:23:3","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"事件委托 使用 on 方式，将事件委托给父级元素代理。 \u003cul\u003e \u003cli\u003eli0\u003c/li\u003e \u003cli\u003eli1\u003c/li\u003e \u003cli\u003eli2\u003c/li\u003e \u003c/ul\u003e \u003cbutton\u003e新增\u003c/button\u003e 想要实现：动态生成多个 li ，并给 li 绑定事件和程序 \u003cscript\u003e var count = 2; $('button').click(function () { // 每次点击按钮，都生成一个 \u003cli\u003e li? \u003c/li\u003e count++; $('ul').append('\u003cli\u003eli' + count + '\u003c/li\u003e') }) // 给每个 li 绑定单机事件：打印 this.li 里的文本内容 $('li').click(function () { console.log($(this).text()); // 仅能打印出 li0 li1 li2 }) // 因为对于动态生成的元素，会出现无法绑定事件的情况 // 解决办法： // 利用on()方法绑定，可以解决这个问题 // 给父级盒子绑定on('click')，筛选出里面的li标签，添加处理程序function，此时的this就可以获取到当前点击的li身上，这种方法就叫——事件委托 // 事件委托 // 把li的点击事件 委托给了 ul $('ul').on('click', 'li', function () { // 不加过滤元素('li'), this 指向 ul // 加上'li' ,之后 this 指向 点击的 那个 li console.log(this); // 此时点击哪个li就打印\u003cli\u003eli?\u003c/li\u003e 出整个li内容 console.log($(this).text()); //此时点击哪个li就打印哪个li里的文本内容 =\u003e li? }) \u003c/script\u003e ​ ​ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:24:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"事件对象 event ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:25:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"**打印 事件对象event ** $('.box').click(function (event) { console.log(event); // 打印结果（见下图：信息非常之多） // console.log('你好'); console.log('current====\u003e', event.currentTarget); console.log('target===\u003e', event.target); console.log('this====\u003e', this) }) ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:25:1","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"常用事件属性、方法 event.data 传递给事件处理程序的额外数据 event.currentTarget 事件绑定的对象(事件源),和 this 相同 event.pageX 鼠标相对于文档左部边缘的位置 event.target 实际触发事件的对象，不一定===this event.stopPropagation()； 阻止事件冒泡 event.preventDefault(); 阻止默认行为 event.type 事件类型：click，mouseover… event.which 鼠标的按键类型：左 1 中 2 右 3 event.keyCode 键盘按键代码 …… 举例演示：↓↓ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:25:2","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"阻止事件冒泡、阻止默认事件 $('ul').click(function () { alert('ul') }) $('li').click(function (e) { e.stopPropagation(); // 阻止冒泡 //调用event方法,书写形式 //如果不写 ↑↑ 这个方法 , 当我点击li时,同时触发ul的事件 // 会先弹出li,再弹出ul的弹窗 //写了上面这个方法,就会阻止事件冒泡; 点击li,不再触发父级事件ul alert('li') }) $('a').click(function (abc) { abc.stopPropagation(); // 阻止冒泡 // 调用event方法,书写形式 abc.preventDefault(); // 阻止 a标签 默认的跳转行为 // 调用event方法,书写形式 console.log('a'); }) // 很多情况下,我们想要实现阻止事件往外冒泡,只触发自己的；就可以调用事件对象里的stopPropagation() - \u003cstyle\u003e div { width: 200px; height: 200px; background-color: brown; overflow: hidden; } ul { margin: 50px auto; width: 100px; height: 100px; background-color: pink; list-style: none; overflow: hidden; } li { margin: 25px auto; width: 50px; height: 50px; background-color: orange; text-align: center; line-height: 50px; } \u003c/style\u003e \u003c!-- 阻止事件冒泡 --\u003e \u003cdiv id=\"div\"\u003e \u003cul id=\"ul\"\u003e \u003cli id=\"li\"\u003e test \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c!-- 阻止默认事件 --\u003e \u003cform action=\"/account/login\" id=\"login-form\" method=\"post\"\u003e \u003cp\u003e账号: \u003cinput type=\"text\" name=\"username\" required /\u003e\u003c/p\u003e \u003cp\u003e密码: \u003cinput type=\"password\" name=\"pwd\" required /\u003e\u003c/p\u003e \u003cp\u003e\u003cinput id=\"submit\" type=\"submit\" value=\"登录\" /\u003e\u003c/p\u003e \u003c/form\u003e \u003ca id=\"a\" href=\"https://www.baidu.com\"\u003e跳转百度\u003c/a\u003e \u003cscript\u003e //阻止事件冒泡 li.onclick = () =\u003e { alert('li'); } ul.onclick = () =\u003e { alert('ul'); event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true; } div.onclick = () =\u003e { alert('div'); } //阻止默认事件 submit.onclick = () =\u003e { event.preventDefault ? event.preventDefault() : event.returnValue = false; } a.onclick = () =\u003e { event.preventDefault ? event.preventDefault() : event.returnValue = false; } \u003c/script\u003e ​ ​ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:25:3","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"**键盘按键代码 . keyCode ** 补充 keyup ( ) 方法：效果是 监听到每次键盘按键升起时，就执行该方法下的函数操作 本例想要实现的效果是： 按下enter键(13)的时，将当前input输入框里输入的内容，在p标签里显示 $('input').keyup(function (e) { var txt = $(this).val(); // 先设置，将当前input输入框内的内容，赋值给变量txt console.log(e.keyCode) //调用keyCode 可实现打印键盘按下的按键的数字代码，测出enter是13 $('p').text(txt); // 监听到每次键盘按键升起时,直接将输入框的text内容,添加到p标签里显示 //完成 // 也可以用if语句判断 当前按下的按键的keycode是否是13，是则将txt内容添加到p标签中 if (e.keyCode === 13) { //当按下回车时(回车键代码为13),将输入框的txt内容,添加到p标签里显示 $('p').text(txt); } }) ​ ​ ​ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:25:4","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"jQuery 链式编程 链式编程原理：return this；调用“任何”一个方法都是返回了对象本身 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 this。 end ( ) ：结束当前 this 并回到匹配元素之前的状态，让this重新指向了 最初的调用者 $(\".inner-box\").click(function() { $(this) .css(\"width\", \"80px\") // 设置当前点击的innerbox的宽为80，return $(\".inner-box\") .css(\"font-size\", \"40px\")// 因为返回的是对象本身，所以这里就相当于对象本身在调用css() .parent() // 这里相当于$(this).parent()，拿到this的父级对象 .css(\"width\", \"200px\") // this的父级对象调用css()，修改其宽度 .end() // 结束了this指向父级的操作,让this重新指向了$(.inner-box).$(this) .css(\"background-color\", \"black\"); // $(.inner-box).$(this) 调用css()方法 // 结束当前链最近的一次过滤操作，并且返回匹配元素之前的状态。 }); ​ ​ ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:26:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"隐式迭代 隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。 如果获取的是多元素的值，大部分情况下返回的是第一个元素的值。 文本比较特殊，如果要返回元素的文本内容，则会将全部元素的文本内容都返回，不会只返回第一个元素的文本内容 $(\".btn\").click(function() { console.log($(\".box\").text()); }); 实例 ↓↓ \u003cul\u003e \u003cli\u003eli-1\u003c/li\u003e \u003cli\u003eli-2\u003c/li\u003e \u003cli\u003eli-3\u003c/li\u003e \u003c/ul\u003e \u003cdiv class=\"btn\"\u003e点击\u003c/div\u003e \u003cscript src=\"js/jquery-3.4.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e $('li').click(function () { console.log($(this).text()); }) $('.btn').click(function () { console.log($('li').text()); // li-1 li-2 li-3 //文本比较特殊, 点击btn后【会返回所有的li里的文本内容】, 不会只返回第一个li的文本内容 console.log($('li').css('color')); // green // 但是,如果要打印文本以外的值，例如color值,此时只会返回 第一个li的颜色 绿色【不会返回所有li的color值】 }) \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:27:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"each 循环 大部分情况下是不需要使用 each 方法的，因为 jQuery 的隐式迭代特性 ↑↑ ：会为自动为匹配到的所有元素进行循环遍历 each 类似于 数组的 forEach 方法 var arr = ['小明', '张三', '李四']; arr.forEach(function (item, index) { console.log('item====\u003e ', item); console.log('index====\u003e', index); }) // 打印结果如下： // item====\u003e 小明 // index====\u003e 0 // item====\u003e 张三 // index====\u003e 1 // item====\u003e 李四 // index====\u003e 2 如果要对每个元素做不同的处理，这时候就用到了 each 方法 作用：遍历 jQuery 对象集合，为每个匹配的元素执行一个函数 $(selector).each(function(index,element){}); Element 是一个 js 对象，需要转换成 jquery 对象 var lis = $('li'); lis.each(function (index, item) { //index - 选择器的 下标 位置 // item 正在遍历的 dom元素 console.log(index, item); // 0 \u003cli\u003eli-1\u003c/li\u003e // 1 \u003cli\u003eli-2\u003c/li\u003e // 2 \u003cli\u003eli-3\u003c/li\u003e if (index % 2 === 0) { // 意为 下标为偶数 $(item).click(function () { $(this).css('color', 'red'); //点击 下标为偶数的li,就会让当前li变成 红色 }) } else { //反之,也就是下标为奇数的,执行下面的函数 $(item).click(function () { $(this).css('color', 'green'); //点击 下标为奇数的li,就会让当前li变成 绿色 }) } }) 在 **“ 01-DOM操作 ” **中 有一个案例：**for循环 实现 “ 隔行变色 ↓↓ ” **，那在 **jQuery **中就可以使用 **each ( ) 方法 ↑↑ **来实现 \u003cscript\u003e // 实现 奇数行 显示red ; 偶数行 显示green // 鼠标移入 this行 显示orange var liArr = document.getElementsByTagName('li'); console.log(liArr); var colorBefore; for (var i = 0; i \u003c liArr.length; i++) { // for循环遍历li if (i % 2 === 0) { // 奇数行 红色 liArr[i].style.backgroundColor = 'red'; } if (i % 2 !== 0) { // 偶数行 绿色 liArr[i].style.backgroundColor = 'green'; } // 鼠标移入：变橙色， // 鼠标离开：变回原来颜色 liArr[i].onmouseenter = function () { colorBefore = this.style.backgroundColor; this.style.backgroundColor = 'orange'; } liArr[i].onmouseleave = function () { this.style.backgroundColor = colorBefore; } } \u003c/script\u003e ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:28:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"多库共存 此处多库共存指的是：jQuery 占用了$ 和 jQuery 这两个变量。当在同一个页面中引用了 jQuery 这个 js 库，并且引用的其他库（或者其他版本的 jQuery 库）中也用到了$或者 jQuery 这两个变量，那么，要保证每个库都能正常使用，这时候就有了多库共存的问题。 $.noConflict(); 让 jQuery 释放对$的控制权，让其他库能够使用$符号，达到多库共存的目的。此后，只能使用 jQuery 来调用 jQuery 提供的方法 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:29:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["JS编程接口"],"content":"插件机制 jQuery 这个 js 库，虽然功能强大，但也不是面面俱到包含所有的功能。 jQuery 是通过插件的方式，来扩展它的功能： 当你需要某个插件的时候，你可以“安装”到 jQuery 上面，然后，使用。 当你不再需要这个插件，那你就可以从 jQuery 上“卸载”它。 ","date":"2020-05-26","objectID":"/dom-dom-vs-jquery/:30:0","tags":["DOM","jQuery","API"],"title":"DOM vs jQuery（API篇）","uri":"/dom-dom-vs-jquery/"},{"categories":["个人博客的创建之路"],"content":"个人博客绑定域名","date":"2020-03-15","objectID":"/blog-buy-setup-a-domain/","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"买个域名玩玩！ ","date":"2020-03-15","objectID":"/blog-buy-setup-a-domain/:0:0","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"个人博客绑定域名 ","date":"2020-03-15","objectID":"/blog-buy-setup-a-domain/:1:0","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"购买域名 namesilo （方便、无需填写个人真实信息）和阿里云（中文、可能需要实名填写详细信息） namesilo 进入官网，搜索并选中需求的域名（domain），进行注册 支付，使用支付宝，需设置支付宝邮箱 购买成功后，等待跳转。邮箱也会收到购买成功的邮件。 每年需要续费，不续费，会有一个保护期，保护期过了，域名就重新开放购买 点击 Manage my Domains 【管理我的域名】。 初次进入可能需要填写基本信息。点击 create my new account。只要保证当前账户邮箱是真实的即可 在域名管理页面，点击蓝色圆形按钮，可以进入 【Manage DNS】 管理DNS页面 ​ 阿里云 进入官网，注册一个账户，国内账户通常需要提供真实的手机号/姓名/身份证等。 在【域名与网站】选项卡中，选择【域名注册】；或者直接在搜索框进入【域名 控制台】选择【域名注册】 搜索域名，加入清单，结算 个人 or 企业 填写 [个人] 信息 支付 ​ ","date":"2020-03-15","objectID":"/blog-buy-setup-a-domain/:1:1","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"配置 GitHub Pages 添加域名 找到 github pages 中的 custom domain ，添加域名，SAVE 保存 仓库会多出一个 CNAME 文件，记录配置的域名 注意：不勾选 Enforce HTTPS。现在不用开启 HTTPS（不开启比较方便测试） 勾选后，所有与当前仓库相关的页面，可能都需要变成 https，可能还需要申请免费证书之类的，hin麻烦 ​ ","date":"2020-03-15","objectID":"/blog-buy-setup-a-domain/:1:2","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"配置 DNS 最终效果是，让 4个A记录出现在域名的DNS管理页面中，就搞定了 配置四条 A 记录 找到 github pages 中的 custom domain ，点击 Learn more ，找到【配置 apex 域】 找到 4 个IP，配置到域名中 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 namesilo 配置 A 记录 （点击蓝色圆形按钮）进入某个域名的管理页面，点击选择 A 会生成一个配置，然后依次将4个IP 多填入提交，生成4条配置。只保留这4条配置，将其他默认存在的配置删除即可，默认提供的配置都是没用的 阿里云 配置 A 记录 基本同 namesilo 在域名DNS解析中，添加 4 条 A 记录 IP 下拉框选择 @ ​ 测试DNS是否配置成功 打开命令行，运行nslookup liubingxuan.xyz 命令行能打印出4条A记录的IP，就说明配置的DNS生效了 刚配置完可能没法立即生效，需要等待（可能半小时、一天或更久，只能等，听天由命😢 ） Windows 用户：nslookup 域名 Mac 用户：dig + noall + answer 域名 A 记录可能要很久才会生效，等就好了 ​ ","date":"2020-03-15","objectID":"/blog-buy-setup-a-domain/:1:3","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":["个人博客的创建之路"],"content":"tip 如果要放弃域名方案 😭 把仓库中的 CNAME文件（自定义域名） 删掉。settings 中 custom domain 也删掉。 ","date":"2020-03-15","objectID":"/blog-buy-setup-a-domain/:1:4","tags":["博客","域名","部署"],"title":"个人博客：💰购买并配置域名","uri":"/blog-buy-setup-a-domain/"},{"categories":null,"content":"🎉","date":"2020-03-06","objectID":"/celebration/","tags":["开博纪念"],"title":"【置顶】开博纪念🥰","uri":"/celebration/"},{"categories":null,"content":"G！🎉🎉 💪 Life is simply about getting hit over and over :) Never put off till tomorrow what you can do today :) make IT :) ","date":"2020-03-06","objectID":"/celebration/:1:0","tags":["开博纪念"],"title":"【置顶】开博纪念🥰","uri":"/celebration/"}]